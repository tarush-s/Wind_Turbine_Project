
Application.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00019a88  00012000  00012000  00002000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     000003dc  20000000  0002ba88  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00005384  200003e0  0002be70  000203e0  2**4
                  ALLOC
  3 .stack        00002004  20005764  000311f4  000203e0  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  000203dc  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  00020404  2**0
                  CONTENTS, READONLY
  6 .debug_info   000e7221  00000000  00000000  0002045d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00013322  00000000  00000000  0010767e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0003a733  00000000  00000000  0011a9a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00003018  00000000  00000000  001550d3  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00004fa0  00000000  00000000  001580eb  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0003e6fc  00000000  00000000  0015d08b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   000578cd  00000000  00000000  0019b787  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000c16d4  00000000  00000000  001f3054  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  0000a730  00000000  00000000  002b4728  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00012000 <exception_table>:
   12000:	68 77 00 20 d9 ee 01 00 bd ee 01 00 bd ee 01 00     hw. ............
	...
   1202c:	65 6d 01 00 00 00 00 00 00 00 00 00 41 6e 01 00     em..........An..
   1203c:	85 6e 01 00 bd ee 01 00 bd ee 01 00 bd ee 01 00     .n..............
   1204c:	21 d3 01 00 85 cf 01 00 bd ee 01 00 55 22 01 00     !...........U"..
   1205c:	bd ee 01 00 f9 22 01 00 c5 d6 01 00 d5 d6 01 00     ....."..........
   1206c:	e5 d6 01 00 f5 d6 01 00 05 d7 01 00 15 d7 01 00     ................
   1207c:	8d ee 01 00 9d ee 01 00 ad ee 01 00 79 5a 01 00     ............yZ..
   1208c:	89 5a 01 00 99 5a 01 00 00 00 00 00 00 00 00 00     .Z...Z..........
   1209c:	bd ee 01 00 bd ee 01 00 bd ee 01 00 bd ee 01 00     ................
   120ac:	bd ee 01 00 00 00 00 00                             ........

000120b4 <__do_global_dtors_aux>:
   120b4:	b510      	push	{r4, lr}
   120b6:	4c06      	ldr	r4, [pc, #24]	; (120d0 <__do_global_dtors_aux+0x1c>)
   120b8:	7823      	ldrb	r3, [r4, #0]
   120ba:	2b00      	cmp	r3, #0
   120bc:	d107      	bne.n	120ce <__do_global_dtors_aux+0x1a>
   120be:	4b05      	ldr	r3, [pc, #20]	; (120d4 <__do_global_dtors_aux+0x20>)
   120c0:	2b00      	cmp	r3, #0
   120c2:	d002      	beq.n	120ca <__do_global_dtors_aux+0x16>
   120c4:	4804      	ldr	r0, [pc, #16]	; (120d8 <__do_global_dtors_aux+0x24>)
   120c6:	e000      	b.n	120ca <__do_global_dtors_aux+0x16>
   120c8:	bf00      	nop
   120ca:	2301      	movs	r3, #1
   120cc:	7023      	strb	r3, [r4, #0]
   120ce:	bd10      	pop	{r4, pc}
   120d0:	200003e0 	.word	0x200003e0
   120d4:	00000000 	.word	0x00000000
   120d8:	0002ba88 	.word	0x0002ba88

000120dc <frame_dummy>:
   120dc:	4b08      	ldr	r3, [pc, #32]	; (12100 <frame_dummy+0x24>)
   120de:	b510      	push	{r4, lr}
   120e0:	2b00      	cmp	r3, #0
   120e2:	d003      	beq.n	120ec <frame_dummy+0x10>
   120e4:	4907      	ldr	r1, [pc, #28]	; (12104 <frame_dummy+0x28>)
   120e6:	4808      	ldr	r0, [pc, #32]	; (12108 <frame_dummy+0x2c>)
   120e8:	e000      	b.n	120ec <frame_dummy+0x10>
   120ea:	bf00      	nop
   120ec:	4807      	ldr	r0, [pc, #28]	; (1210c <frame_dummy+0x30>)
   120ee:	6803      	ldr	r3, [r0, #0]
   120f0:	2b00      	cmp	r3, #0
   120f2:	d100      	bne.n	120f6 <frame_dummy+0x1a>
   120f4:	bd10      	pop	{r4, pc}
   120f6:	4b06      	ldr	r3, [pc, #24]	; (12110 <frame_dummy+0x34>)
   120f8:	2b00      	cmp	r3, #0
   120fa:	d0fb      	beq.n	120f4 <frame_dummy+0x18>
   120fc:	4798      	blx	r3
   120fe:	e7f9      	b.n	120f4 <frame_dummy+0x18>
   12100:	00000000 	.word	0x00000000
   12104:	200003e4 	.word	0x200003e4
   12108:	0002ba88 	.word	0x0002ba88
   1210c:	0002ba88 	.word	0x0002ba88
   12110:	00000000 	.word	0x00000000

00012114 <FS3000_isConnected>:
	
	int32_t error;
	airflow.lenIn = 0;
	airflow.msgIn = _buff;
	
	airflow.address = FS3000_DEVICE_ADDRESS;
   12114:	2028      	movs	r0, #40	; 0x28
	airflow.lenIn = 0;
   12116:	2200      	movs	r2, #0
   12118:	4b03      	ldr	r3, [pc, #12]	; (12128 <FS3000_isConnected+0x14>)
	airflow.msgIn = _buff;
   1211a:	4904      	ldr	r1, [pc, #16]	; (1212c <FS3000_isConnected+0x18>)
	airflow.address = FS3000_DEVICE_ADDRESS;
   1211c:	7018      	strb	r0, [r3, #0]
	airflow.lenIn = 0;
   1211e:	819a      	strh	r2, [r3, #12]
	airflow.msgIn = _buff;
   12120:	6099      	str	r1, [r3, #8]
	airflow.msgOut = _buff;
   12122:	6059      	str	r1, [r3, #4]
	airflow.lenOut = 0;
   12124:	81da      	strh	r2, [r3, #14]
	
	//return I2cReadDataWait(&airflow, 0, 100);
}
   12126:	4770      	bx	lr
   12128:	20004200 	.word	0x20004200
   1212c:	200003fc 	.word	0x200003fc

00012130 <FS3000_begin>:
{
   12130:	b510      	push	{r4, lr}
    return FS3000_isConnected();
   12132:	4b01      	ldr	r3, [pc, #4]	; (12138 <FS3000_begin+0x8>)
   12134:	4798      	blx	r3
}
   12136:	bd10      	pop	{r4, pc}
   12138:	00012115 	.word	0x00012115

0001213c <FS3000_readData>:
}

/*************************** READ DATA *************************/
/*                Read 5 bytes from sensor, put it at a pointer (given as argument)                  */
void FS3000_readData(uint8_t *buffer_in)
{
   1213c:	b507      	push	{r0, r1, r2, lr}
	
	//packet.data = buffer_in;
	//packet.data_length = 5;
	//packet.high_speed = true;
	//error = i2c_master_read_packet_job(module, &packet);
	uint8_t reg_add = 0;
   1213e:	2200      	movs	r2, #0
   12140:	466b      	mov	r3, sp
	
	airflow.address = FS3000_DEVICE_ADDRESS;
   12142:	4808      	ldr	r0, [pc, #32]	; (12164 <FS3000_readData+0x28>)
	uint8_t reg_add = 0;
   12144:	71da      	strb	r2, [r3, #7]
   12146:	3307      	adds	r3, #7
	airflow.lenIn = 5;
	airflow.msgIn = _buff;
	
	//airflow.address = FS3000_DEVICE_ADDRESS;
	airflow.msgOut = &reg_add;
   12148:	6043      	str	r3, [r0, #4]
	airflow.lenOut = 1;
	
	return I2cOnlyReadWait(&airflow, 1000); //I2cReadDataWait(&airflow, 0, 100);
   1214a:	21fa      	movs	r1, #250	; 0xfa
	airflow.lenOut = 1;
   1214c:	2301      	movs	r3, #1
	airflow.address = FS3000_DEVICE_ADDRESS;
   1214e:	3228      	adds	r2, #40	; 0x28
   12150:	7002      	strb	r2, [r0, #0]
	airflow.lenIn = 5;
   12152:	3a23      	subs	r2, #35	; 0x23
   12154:	8182      	strh	r2, [r0, #12]
	airflow.msgIn = _buff;
   12156:	4a04      	ldr	r2, [pc, #16]	; (12168 <FS3000_readData+0x2c>)
	airflow.lenOut = 1;
   12158:	81c3      	strh	r3, [r0, #14]
	return I2cOnlyReadWait(&airflow, 1000); //I2cReadDataWait(&airflow, 0, 100);
   1215a:	0089      	lsls	r1, r1, #2
   1215c:	4b03      	ldr	r3, [pc, #12]	; (1216c <FS3000_readData+0x30>)
	airflow.msgIn = _buff;
   1215e:	6082      	str	r2, [r0, #8]
	return I2cOnlyReadWait(&airflow, 1000); //I2cReadDataWait(&airflow, 0, 100);
   12160:	4798      	blx	r3
    //while (i2c_tools_available())
    //{
        //buffer_in[i] = i2c_tools_read(); // Receive Byte
        //i += 1;
    //}
}
   12162:	bd07      	pop	{r0, r1, r2, pc}
   12164:	20004200 	.word	0x20004200
   12168:	200003fc 	.word	0x200003fc
   1216c:	000140c1 	.word	0x000140c1

00012170 <FS3000_readRaw>:
{
   12170:	b510      	push	{r4, lr}
    FS3000_readData(_buff);
   12172:	4c05      	ldr	r4, [pc, #20]	; (12188 <FS3000_readRaw+0x18>)
   12174:	4b05      	ldr	r3, [pc, #20]	; (1218c <FS3000_readRaw+0x1c>)
   12176:	0020      	movs	r0, r4
   12178:	4798      	blx	r3
    airflowRaw |= (data_high_byte << 8);
   1217a:	230f      	movs	r3, #15
    uint8_t data_high_byte = _buff[1];
   1217c:	7860      	ldrb	r0, [r4, #1]
    airflowRaw |= (data_high_byte << 8);
   1217e:	4018      	ands	r0, r3
   12180:	78a3      	ldrb	r3, [r4, #2]
   12182:	0200      	lsls	r0, r0, #8
    return airflowRaw;
   12184:	4318      	orrs	r0, r3
}
   12186:	bd10      	pop	{r4, pc}
   12188:	200003fc 	.word	0x200003fc
   1218c:	0001213d 	.word	0x0001213d

00012190 <FS3000_readMetersPerSecond>:
{
   12190:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    int airflowRaw = FS3000_readRaw();
   12192:	4b24      	ldr	r3, [pc, #144]	; (12224 <FS3000_readMetersPerSecond+0x94>)
   12194:	4798      	blx	r3
    if (_range == AIRFLOW_RANGE_7_MPS)
   12196:	4b24      	ldr	r3, [pc, #144]	; (12228 <FS3000_readMetersPerSecond+0x98>)
    uint8_t dataPointsNum = 9; // Default to FS3000_1005 AIRFLOW_RANGE_7_MPS
   12198:	2409      	movs	r4, #9
    if (_range == AIRFLOW_RANGE_7_MPS)
   1219a:	7819      	ldrb	r1, [r3, #0]
    else if (_range == AIRFLOW_RANGE_15_MPS)
   1219c:	2901      	cmp	r1, #1
   1219e:	d100      	bne.n	121a2 <FS3000_readMetersPerSecond+0x12>
        dataPointsNum = 13;
   121a0:	3404      	adds	r4, #4
    for (int i = 0; i < dataPointsNum; i++) // cound be an array of datapoints 9 or 13 long...
   121a2:	2200      	movs	r2, #0
    int data_position = 0;
   121a4:	0013      	movs	r3, r2
        if (airflowRaw > _rawDataPoint[i])
   121a6:	4d21      	ldr	r5, [pc, #132]	; (1222c <FS3000_readMetersPerSecond+0x9c>)
    for (int i = 0; i < dataPointsNum; i++) // cound be an array of datapoints 9 or 13 long...
   121a8:	42a2      	cmp	r2, r4
   121aa:	db2e      	blt.n	1220a <FS3000_readMetersPerSecond+0x7a>
    if (airflowRaw <= 409)
   121ac:	229a      	movs	r2, #154	; 0x9a
   121ae:	32ff      	adds	r2, #255	; 0xff
   121b0:	4290      	cmp	r0, r2
   121b2:	dd31      	ble.n	12218 <FS3000_readMetersPerSecond+0x88>
    if (airflowRaw >= 3686)
   121b4:	4a1e      	ldr	r2, [pc, #120]	; (12230 <FS3000_readMetersPerSecond+0xa0>)
   121b6:	4290      	cmp	r0, r2
   121b8:	dd03      	ble.n	121c2 <FS3000_readMetersPerSecond+0x32>
        if (_range == AIRFLOW_RANGE_7_MPS)
   121ba:	2900      	cmp	r1, #0
   121bc:	d02e      	beq.n	1221c <FS3000_readMetersPerSecond+0x8c>
        if (_range == AIRFLOW_RANGE_15_MPS)
   121be:	2901      	cmp	r1, #1
   121c0:	d02e      	beq.n	12220 <FS3000_readMetersPerSecond+0x90>
    int window_size = (_rawDataPoint[data_position + 1] - _rawDataPoint[data_position]);
   121c2:	4e1a      	ldr	r6, [pc, #104]	; (1222c <FS3000_readMetersPerSecond+0x9c>)
   121c4:	1c5a      	adds	r2, r3, #1
   121c6:	009b      	lsls	r3, r3, #2
   121c8:	599d      	ldr	r5, [r3, r6]
    float window_size_mps = (_mpsDataPoint[data_position + 1] - _mpsDataPoint[data_position]);
   121ca:	4f1a      	ldr	r7, [pc, #104]	; (12234 <FS3000_readMetersPerSecond+0xa4>)
    int window_size = (_rawDataPoint[data_position + 1] - _rawDataPoint[data_position]);
   121cc:	9200      	str	r2, [sp, #0]
    float window_size_mps = (_mpsDataPoint[data_position + 1] - _mpsDataPoint[data_position]);
   121ce:	59dc      	ldr	r4, [r3, r7]
    int diff = (airflowRaw - _rawDataPoint[data_position]);
   121d0:	1b40      	subs	r0, r0, r5
    float percentage_of_window = ((float)diff / (float)window_size);
   121d2:	4b19      	ldr	r3, [pc, #100]	; (12238 <FS3000_readMetersPerSecond+0xa8>)
   121d4:	4798      	blx	r3
    int window_size = (_rawDataPoint[data_position + 1] - _rawDataPoint[data_position]);
   121d6:	9b00      	ldr	r3, [sp, #0]
    float percentage_of_window = ((float)diff / (float)window_size);
   121d8:	9001      	str	r0, [sp, #4]
    int window_size = (_rawDataPoint[data_position + 1] - _rawDataPoint[data_position]);
   121da:	009b      	lsls	r3, r3, #2
   121dc:	5998      	ldr	r0, [r3, r6]
   121de:	9300      	str	r3, [sp, #0]
   121e0:	1b40      	subs	r0, r0, r5
    float percentage_of_window = ((float)diff / (float)window_size);
   121e2:	4b15      	ldr	r3, [pc, #84]	; (12238 <FS3000_readMetersPerSecond+0xa8>)
   121e4:	4798      	blx	r3
   121e6:	4b15      	ldr	r3, [pc, #84]	; (1223c <FS3000_readMetersPerSecond+0xac>)
   121e8:	1c01      	adds	r1, r0, #0
   121ea:	9801      	ldr	r0, [sp, #4]
   121ec:	4798      	blx	r3
    float window_size_mps = (_mpsDataPoint[data_position + 1] - _mpsDataPoint[data_position]);
   121ee:	9b00      	ldr	r3, [sp, #0]
    float percentage_of_window = ((float)diff / (float)window_size);
   121f0:	1c05      	adds	r5, r0, #0
    float window_size_mps = (_mpsDataPoint[data_position + 1] - _mpsDataPoint[data_position]);
   121f2:	1c21      	adds	r1, r4, #0
   121f4:	59d8      	ldr	r0, [r3, r7]
   121f6:	4b12      	ldr	r3, [pc, #72]	; (12240 <FS3000_readMetersPerSecond+0xb0>)
   121f8:	4798      	blx	r3
    airflowMps = _mpsDataPoint[data_position] + (window_size_mps * percentage_of_window);
   121fa:	4b12      	ldr	r3, [pc, #72]	; (12244 <FS3000_readMetersPerSecond+0xb4>)
    float window_size_mps = (_mpsDataPoint[data_position + 1] - _mpsDataPoint[data_position]);
   121fc:	1c01      	adds	r1, r0, #0
    airflowMps = _mpsDataPoint[data_position] + (window_size_mps * percentage_of_window);
   121fe:	1c28      	adds	r0, r5, #0
   12200:	4798      	blx	r3
   12202:	1c21      	adds	r1, r4, #0
   12204:	4b10      	ldr	r3, [pc, #64]	; (12248 <FS3000_readMetersPerSecond+0xb8>)
   12206:	4798      	blx	r3
}
   12208:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        if (airflowRaw > _rawDataPoint[i])
   1220a:	0096      	lsls	r6, r2, #2
   1220c:	5976      	ldr	r6, [r6, r5]
   1220e:	42b0      	cmp	r0, r6
   12210:	dd00      	ble.n	12214 <FS3000_readMetersPerSecond+0x84>
   12212:	0013      	movs	r3, r2
    for (int i = 0; i < dataPointsNum; i++) // cound be an array of datapoints 9 or 13 long...
   12214:	3201      	adds	r2, #1
   12216:	e7c7      	b.n	121a8 <FS3000_readMetersPerSecond+0x18>
        return 0;
   12218:	2000      	movs	r0, #0
   1221a:	e7f5      	b.n	12208 <FS3000_readMetersPerSecond+0x78>
            return 7.23;
   1221c:	480b      	ldr	r0, [pc, #44]	; (1224c <FS3000_readMetersPerSecond+0xbc>)
   1221e:	e7f3      	b.n	12208 <FS3000_readMetersPerSecond+0x78>
            return 15.00;
   12220:	480b      	ldr	r0, [pc, #44]	; (12250 <FS3000_readMetersPerSecond+0xc0>)
   12222:	e7f1      	b.n	12208 <FS3000_readMetersPerSecond+0x78>
   12224:	00012171 	.word	0x00012171
   12228:	20000401 	.word	0x20000401
   1222c:	20000034 	.word	0x20000034
   12230:	00000e65 	.word	0x00000e65
   12234:	20000000 	.word	0x20000000
   12238:	000269f1 	.word	0x000269f1
   1223c:	00026059 	.word	0x00026059
   12240:	00026679 	.word	0x00026679
   12244:	00026439 	.word	0x00026439
   12248:	00025d35 	.word	0x00025d35
   1224c:	40e75c29 	.word	0x40e75c29
   12250:	41700000 	.word	0x41700000

00012254 <DMAC_Handler>:
/**
 * \brief DMA interrupt service routine.
 *
 */
void DMAC_Handler( void )
{
   12254:	b570      	push	{r4, r5, r6, lr}
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
   12256:	4b20      	ldr	r3, [pc, #128]	; (122d8 <DMAC_Handler+0x84>)
   12258:	4798      	blx	r3
	uint32_t total_size;

	system_interrupt_enter_critical_section();

	/* Get Pending channel */
	active_channel =  DMAC->INTPEND.reg & DMAC_INTPEND_ID_Msk;
   1225a:	220f      	movs	r2, #15
   1225c:	4b1f      	ldr	r3, [pc, #124]	; (122dc <DMAC_Handler+0x88>)

	Assert(_dma_active_resource[active_channel]);

	/* Get active DMA resource based on channel */
	resource = _dma_active_resource[active_channel];
   1225e:	4920      	ldr	r1, [pc, #128]	; (122e0 <DMAC_Handler+0x8c>)
	active_channel =  DMAC->INTPEND.reg & DMAC_INTPEND_ID_Msk;
   12260:	8c1b      	ldrh	r3, [r3, #32]
	/* Select the active channel */
	DMAC->CHID.reg = DMAC_CHID_ID(resource->channel_id);
	isr = DMAC->CHINTFLAG.reg;

	/* Calculate block transfer size of the DMA transfer */
	total_size = descriptor_section[resource->channel_id].BTCNT.reg;
   12262:	4c20      	ldr	r4, [pc, #128]	; (122e4 <DMAC_Handler+0x90>)
	resource = _dma_active_resource[active_channel];
   12264:	4013      	ands	r3, r2
   12266:	009b      	lsls	r3, r3, #2
   12268:	5858      	ldr	r0, [r3, r1]
	write_size = _write_back_section[resource->channel_id].BTCNT.reg;
   1226a:	4d1f      	ldr	r5, [pc, #124]	; (122e8 <DMAC_Handler+0x94>)
	DMAC->CHID.reg = DMAC_CHID_ID(resource->channel_id);
   1226c:	7803      	ldrb	r3, [r0, #0]
   1226e:	4013      	ands	r3, r2
   12270:	4a1e      	ldr	r2, [pc, #120]	; (122ec <DMAC_Handler+0x98>)
   12272:	7013      	strb	r3, [r2, #0]
	total_size = descriptor_section[resource->channel_id].BTCNT.reg;
   12274:	7801      	ldrb	r1, [r0, #0]
	isr = DMAC->CHINTFLAG.reg;
   12276:	4a1e      	ldr	r2, [pc, #120]	; (122f0 <DMAC_Handler+0x9c>)
	total_size = descriptor_section[resource->channel_id].BTCNT.reg;
   12278:	0109      	lsls	r1, r1, #4
   1227a:	1864      	adds	r4, r4, r1
	write_size = _write_back_section[resource->channel_id].BTCNT.reg;
   1227c:	1869      	adds	r1, r5, r1
	isr = DMAC->CHINTFLAG.reg;
   1227e:	7813      	ldrb	r3, [r2, #0]
	total_size = descriptor_section[resource->channel_id].BTCNT.reg;
   12280:	8864      	ldrh	r4, [r4, #2]
	write_size = _write_back_section[resource->channel_id].BTCNT.reg;
   12282:	8849      	ldrh	r1, [r1, #2]
	isr = DMAC->CHINTFLAG.reg;
   12284:	b2db      	uxtb	r3, r3
	resource->transfered_size = total_size - write_size;
   12286:	1a61      	subs	r1, r4, r1
   12288:	6141      	str	r1, [r0, #20]

	/* DMA channel interrupt handler */
	if (isr & DMAC_CHINTENCLR_TERR) {
   1228a:	001c      	movs	r4, r3
   1228c:	2101      	movs	r1, #1
   1228e:	400c      	ands	r4, r1
   12290:	d00c      	beq.n	122ac <DMAC_Handler+0x58>
		/* Clear transfer error flag */
		DMAC->CHINTFLAG.reg = DMAC_CHINTENCLR_TERR;

		/* Set I/O ERROR status */
		resource->job_status = STATUS_ERR_IO;
   12292:	2310      	movs	r3, #16
		DMAC->CHINTFLAG.reg = DMAC_CHINTENCLR_TERR;
   12294:	7011      	strb	r1, [r2, #0]
		resource->job_status = STATUS_ERR_IO;
   12296:	7443      	strb	r3, [r0, #17]

		/* Execute the callback function */
		if ((resource->callback_enable & (1<<DMA_CALLBACK_TRANSFER_ERROR)) &&
   12298:	7c03      	ldrb	r3, [r0, #16]
   1229a:	420b      	tst	r3, r1
   1229c:	d003      	beq.n	122a6 <DMAC_Handler+0x52>
				(resource->callback[DMA_CALLBACK_TRANSFER_ERROR])) {
   1229e:	6843      	ldr	r3, [r0, #4]

		/* Set job status */
		resource->job_status = STATUS_SUSPEND;

		/* Execute the callback function */
		if ((resource->callback_enable & (1 << DMA_CALLBACK_CHANNEL_SUSPEND)) &&
   122a0:	2b00      	cmp	r3, #0
   122a2:	d000      	beq.n	122a6 <DMAC_Handler+0x52>
			(resource->callback[DMA_CALLBACK_CHANNEL_SUSPEND])){
			resource->callback[DMA_CALLBACK_CHANNEL_SUSPEND](resource);
   122a4:	4798      	blx	r3
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
   122a6:	4b13      	ldr	r3, [pc, #76]	; (122f4 <DMAC_Handler+0xa0>)
   122a8:	4798      	blx	r3
		}
	}

	system_interrupt_leave_critical_section();
}
   122aa:	bd70      	pop	{r4, r5, r6, pc}
	} else if (isr & DMAC_CHINTENCLR_TCMPL) {
   122ac:	2102      	movs	r1, #2
   122ae:	420b      	tst	r3, r1
   122b0:	d006      	beq.n	122c0 <DMAC_Handler+0x6c>
		DMAC->CHINTFLAG.reg = DMAC_CHINTENCLR_TCMPL;
   122b2:	7011      	strb	r1, [r2, #0]
		if ((resource->callback_enable & (1 << DMA_CALLBACK_TRANSFER_DONE)) &&
   122b4:	7c03      	ldrb	r3, [r0, #16]
		resource->job_status = STATUS_OK;
   122b6:	7444      	strb	r4, [r0, #17]
		if ((resource->callback_enable & (1 << DMA_CALLBACK_TRANSFER_DONE)) &&
   122b8:	420b      	tst	r3, r1
   122ba:	d0f4      	beq.n	122a6 <DMAC_Handler+0x52>
				(resource->callback[DMA_CALLBACK_TRANSFER_DONE])) {
   122bc:	6883      	ldr	r3, [r0, #8]
   122be:	e7ef      	b.n	122a0 <DMAC_Handler+0x4c>
	} else if (isr & DMAC_CHINTENCLR_SUSP) {
   122c0:	2104      	movs	r1, #4
   122c2:	420b      	tst	r3, r1
   122c4:	d0ef      	beq.n	122a6 <DMAC_Handler+0x52>
		resource->job_status = STATUS_SUSPEND;
   122c6:	2306      	movs	r3, #6
		DMAC->CHINTFLAG.reg = DMAC_CHINTENCLR_SUSP;
   122c8:	7011      	strb	r1, [r2, #0]
		resource->job_status = STATUS_SUSPEND;
   122ca:	7443      	strb	r3, [r0, #17]
		if ((resource->callback_enable & (1 << DMA_CALLBACK_CHANNEL_SUSPEND)) &&
   122cc:	7c03      	ldrb	r3, [r0, #16]
   122ce:	420b      	tst	r3, r1
   122d0:	d0e9      	beq.n	122a6 <DMAC_Handler+0x52>
			(resource->callback[DMA_CALLBACK_CHANNEL_SUSPEND])){
   122d2:	68c3      	ldr	r3, [r0, #12]
   122d4:	e7e4      	b.n	122a0 <DMAC_Handler+0x4c>
   122d6:	46c0      	nop			; (mov r8, r8)
   122d8:	0001ce85 	.word	0x0001ce85
   122dc:	41004800 	.word	0x41004800
   122e0:	20000404 	.word	0x20000404
   122e4:	20004210 	.word	0x20004210
   122e8:	20000420 	.word	0x20000420
   122ec:	4100483f 	.word	0x4100483f
   122f0:	4100484e 	.word	0x4100484e
   122f4:	0001ceb9 	.word	0x0001ceb9

000122f8 <EVSYS_Handler>:

	return STATUS_OK;
}

void EVSYS_Handler(void)
{
   122f8:	b570      	push	{r4, r5, r6, lr}
	struct events_hook *current_hook = _events_inst.hook_list;
	uint32_t flag;

	/* Synch the interrupt flag buffer with the hardware register */
	flag = EVSYS->INTFLAG.reg;
   122fa:	4a0a      	ldr	r2, [pc, #40]	; (12324 <EVSYS_Handler+0x2c>)
	struct events_hook *current_hook = _events_inst.hook_list;
   122fc:	4c0a      	ldr	r4, [pc, #40]	; (12328 <EVSYS_Handler+0x30>)
	flag = EVSYS->INTFLAG.reg;
   122fe:	6993      	ldr	r3, [r2, #24]
	_events_inst.interrupt_flag_buffer |= flag;
   12300:	68a1      	ldr	r1, [r4, #8]
	struct events_hook *current_hook = _events_inst.hook_list;
   12302:	6925      	ldr	r5, [r4, #16]
	_events_inst.interrupt_flag_buffer |= flag;
   12304:	430b      	orrs	r3, r1
   12306:	60a3      	str	r3, [r4, #8]
	/* Clear all hardware interrupt flags */
	EVSYS->INTFLAG.reg = _EVENTS_INTFLAGS_MASK;
   12308:	4b08      	ldr	r3, [pc, #32]	; (1232c <EVSYS_Handler+0x34>)
   1230a:	6193      	str	r3, [r2, #24]

	/* Traverse the linked list */
	while (current_hook != NULL) {
   1230c:	2d00      	cmp	r5, #0
   1230e:	d104      	bne.n	1231a <EVSYS_Handler+0x22>
		current_hook->hook_func(current_hook->resource);
		current_hook = current_hook->next;
	}

	/* Clear acknowledged interrupt sources from the interrupt flag buffer */
	flag = _events_inst.interrupt_flag_ack_buffer;
   12310:	68e2      	ldr	r2, [r4, #12]
	_events_inst.interrupt_flag_buffer &= ~flag;
   12312:	68a3      	ldr	r3, [r4, #8]
   12314:	4393      	bics	r3, r2
   12316:	60a3      	str	r3, [r4, #8]
}
   12318:	bd70      	pop	{r4, r5, r6, pc}
		current_hook->hook_func(current_hook->resource);
   1231a:	6828      	ldr	r0, [r5, #0]
   1231c:	686b      	ldr	r3, [r5, #4]
   1231e:	4798      	blx	r3
		current_hook = current_hook->next;
   12320:	68ad      	ldr	r5, [r5, #8]
   12322:	e7f3      	b.n	1230c <EVSYS_Handler+0x14>
   12324:	42000400 	.word	0x42000400
   12328:	20000068 	.word	0x20000068
   1232c:	0f0fffff 	.word	0x0f0fffff

00012330 <_system_events_init>:
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
			break;

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
   12330:	2302      	movs	r3, #2
   12332:	4a05      	ldr	r2, [pc, #20]	; (12348 <_system_events_init+0x18>)
   12334:	6a11      	ldr	r1, [r2, #32]
   12336:	430b      	orrs	r3, r1
   12338:	6213      	str	r3, [r2, #32]
{
	/* Enable EVSYS register interface */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, PM_APBCMASK_EVSYS);

	/* Make sure the EVSYS module is properly reset */
	EVSYS->CTRL.reg = EVSYS_CTRL_SWRST;
   1233a:	2301      	movs	r3, #1
   1233c:	4a03      	ldr	r2, [pc, #12]	; (1234c <_system_events_init+0x1c>)
   1233e:	7013      	strb	r3, [r2, #0]

	while (EVSYS->CTRL.reg & EVSYS_CTRL_SWRST) {
   12340:	7811      	ldrb	r1, [r2, #0]
   12342:	4219      	tst	r1, r3
   12344:	d1fc      	bne.n	12340 <_system_events_init+0x10>
	}
}
   12346:	4770      	bx	lr
   12348:	40000400 	.word	0x40000400
   1234c:	42000400 	.word	0x42000400

00012350 <_i2c_master_wait_for_sync>:
	SercomI2cm *const i2c_hw = &(module->hw->I2CM);

#if defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_1)
	return (i2c_hw->STATUS.reg & SERCOM_I2CM_STATUS_SYNCBUSY);
#elif defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_2)
	return (i2c_hw->SYNCBUSY.reg & SERCOM_I2CM_SYNCBUSY_MASK);
   12350:	2307      	movs	r3, #7
	SercomI2cm *const i2c_hw = &(module->hw->I2CM);
   12352:	6801      	ldr	r1, [r0, #0]
	return (i2c_hw->SYNCBUSY.reg & SERCOM_I2CM_SYNCBUSY_MASK);
   12354:	69ca      	ldr	r2, [r1, #28]
		const struct i2c_master_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (i2c_master_is_syncing(module)) {
   12356:	421a      	tst	r2, r3
   12358:	d1fc      	bne.n	12354 <_i2c_master_wait_for_sync+0x4>
		/* Wait for I2C module to sync. */
	}
}
   1235a:	4770      	bx	lr

0001235c <_i2c_master_read>:
 *
 * \param[in,out] module  Pointer to software module structure
 */
static void _i2c_master_read(
		struct i2c_master_module *const module)
{
   1235c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Sanity check arguments. */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
   1235e:	6805      	ldr	r5, [r0, #0]
{
   12360:	0004      	movs	r4, r0
	bool sclsm_flag = i2c_module->CTRLA.bit.SCLSM;
   12362:	682a      	ldr	r2, [r5, #0]

	/* Find index to save next value in buffer */
	uint16_t buffer_index = module->buffer_length;
   12364:	8b46      	ldrh	r6, [r0, #26]
	buffer_index -= module->buffer_remaining;
   12366:	8b83      	ldrh	r3, [r0, #28]
   12368:	1af6      	subs	r6, r6, r3

	module->buffer_remaining--;
   1236a:	8b83      	ldrh	r3, [r0, #28]
	buffer_index -= module->buffer_remaining;
   1236c:	b2b6      	uxth	r6, r6
	module->buffer_remaining--;
   1236e:	3b01      	subs	r3, #1
   12370:	b29b      	uxth	r3, r3
   12372:	8383      	strh	r3, [r0, #28]
   12374:	7ac3      	ldrb	r3, [r0, #11]

	if (sclsm_flag) {
   12376:	0112      	lsls	r2, r2, #4
   12378:	d50a      	bpl.n	12390 <_i2c_master_read+0x34>
		if (module->send_nack && module->buffer_remaining == 1) {
   1237a:	2b00      	cmp	r3, #0
   1237c:	d00d      	beq.n	1239a <_i2c_master_read+0x3e>
   1237e:	8b83      	ldrh	r3, [r0, #28]
   12380:	2b01      	cmp	r3, #1
   12382:	d10a      	bne.n	1239a <_i2c_master_read+0x3e>
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
		}
	} else {
		if (module->send_nack && module->buffer_remaining == 0) {
			/* Set action to NACK. */
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
   12384:	2380      	movs	r3, #128	; 0x80
   12386:	686a      	ldr	r2, [r5, #4]
   12388:	02db      	lsls	r3, r3, #11
   1238a:	4313      	orrs	r3, r2
   1238c:	606b      	str	r3, [r5, #4]
   1238e:	e004      	b.n	1239a <_i2c_master_read+0x3e>
		if (module->send_nack && module->buffer_remaining == 0) {
   12390:	2b00      	cmp	r3, #0
   12392:	d002      	beq.n	1239a <_i2c_master_read+0x3e>
   12394:	8b83      	ldrh	r3, [r0, #28]
   12396:	2b00      	cmp	r3, #0
   12398:	d0f4      	beq.n	12384 <_i2c_master_read+0x28>
		}
	}

	if (module->buffer_remaining == 0) {
   1239a:	8ba3      	ldrh	r3, [r4, #28]
   1239c:	4f0a      	ldr	r7, [pc, #40]	; (123c8 <_i2c_master_read+0x6c>)
   1239e:	2b00      	cmp	r3, #0
   123a0:	d109      	bne.n	123b6 <_i2c_master_read+0x5a>
		if (module->send_stop) {
   123a2:	7aa3      	ldrb	r3, [r4, #10]
   123a4:	2b00      	cmp	r3, #0
   123a6:	d006      	beq.n	123b6 <_i2c_master_read+0x5a>
			/* Send stop condition */
			_i2c_master_wait_for_sync(module);
   123a8:	0020      	movs	r0, r4
   123aa:	47b8      	blx	r7
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
   123ac:	23c0      	movs	r3, #192	; 0xc0
   123ae:	686a      	ldr	r2, [r5, #4]
   123b0:	029b      	lsls	r3, r3, #10
   123b2:	4313      	orrs	r3, r2
   123b4:	606b      	str	r3, [r5, #4]
		}
	}
	
	/* Read byte from slave and put in buffer */
	_i2c_master_wait_for_sync(module);
   123b6:	0020      	movs	r0, r4
   123b8:	47b8      	blx	r7
	module->buffer[buffer_index] = i2c_module->DATA.reg;
   123ba:	6a23      	ldr	r3, [r4, #32]
   123bc:	3528      	adds	r5, #40	; 0x28
   123be:	199e      	adds	r6, r3, r6
   123c0:	782b      	ldrb	r3, [r5, #0]
   123c2:	b2db      	uxtb	r3, r3
   123c4:	7033      	strb	r3, [r6, #0]
}
   123c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   123c8:	00012351 	.word	0x00012351

000123cc <_i2c_master_write>:
 * Write next data. Used by interrupt handler to send next data byte to slave.
 *
 * \param[in,out] module  Pointer to software module structure
 */
static void _i2c_master_write(struct i2c_master_module *const module)
{
   123cc:	b570      	push	{r4, r5, r6, lr}
	/* Sanity check arguments. */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
   123ce:	6806      	ldr	r6, [r0, #0]
{
   123d0:	0004      	movs	r4, r0

	/* Check for ack from slave */
	if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_RXNACK)
   123d2:	8b73      	ldrh	r3, [r6, #26]
   123d4:	075b      	lsls	r3, r3, #29
   123d6:	d503      	bpl.n	123e0 <_i2c_master_write+0x14>
	{
		/* Set status */
		module->status = STATUS_ERR_OVERFLOW;
   123d8:	231e      	movs	r3, #30
   123da:	3406      	adds	r4, #6
   123dc:	77e3      	strb	r3, [r4, #31]
	module->buffer_remaining--;

	/* Write byte from buffer to slave */
	_i2c_master_wait_for_sync(module);
	i2c_module->DATA.reg = module->buffer[buffer_index];
}
   123de:	bd70      	pop	{r4, r5, r6, pc}
	uint16_t buffer_index = module->buffer_length;
   123e0:	8b45      	ldrh	r5, [r0, #26]
	buffer_index -= module->buffer_remaining;
   123e2:	8b83      	ldrh	r3, [r0, #28]
	i2c_module->DATA.reg = module->buffer[buffer_index];
   123e4:	3628      	adds	r6, #40	; 0x28
	buffer_index -= module->buffer_remaining;
   123e6:	1aed      	subs	r5, r5, r3
	module->buffer_remaining--;
   123e8:	8b83      	ldrh	r3, [r0, #28]
	buffer_index -= module->buffer_remaining;
   123ea:	b2ad      	uxth	r5, r5
	module->buffer_remaining--;
   123ec:	3b01      	subs	r3, #1
   123ee:	b29b      	uxth	r3, r3
   123f0:	8383      	strh	r3, [r0, #28]
	_i2c_master_wait_for_sync(module);
   123f2:	4b04      	ldr	r3, [pc, #16]	; (12404 <_i2c_master_write+0x38>)
   123f4:	4798      	blx	r3
	i2c_module->DATA.reg = module->buffer[buffer_index];
   123f6:	6a23      	ldr	r3, [r4, #32]
   123f8:	195d      	adds	r5, r3, r5
   123fa:	782b      	ldrb	r3, [r5, #0]
   123fc:	b2db      	uxtb	r3, r3
   123fe:	7033      	strb	r3, [r6, #0]
   12400:	e7ed      	b.n	123de <_i2c_master_write+0x12>
   12402:	46c0      	nop			; (mov r8, r8)
   12404:	00012351 	.word	0x00012351

00012408 <_i2c_master_write_packet>:
 * \retval STATUS_BUSY If module is currently busy with another transfer
 */
static enum status_code _i2c_master_write_packet(
		struct i2c_master_module *const module,
		struct i2c_master_packet *const packet)
{
   12408:	b570      	push	{r4, r5, r6, lr}
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);

	/* Switch to high speed mode */
	if (packet->high_speed) {
   1240a:	7a4b      	ldrb	r3, [r1, #9]
{
   1240c:	0005      	movs	r5, r0
   1240e:	000e      	movs	r6, r1
	SercomI2cm *const i2c_module = &(module->hw->I2CM);
   12410:	6804      	ldr	r4, [r0, #0]
	if (packet->high_speed) {
   12412:	2b00      	cmp	r3, #0
   12414:	d002      	beq.n	1241c <_i2c_master_write_packet+0x14>
		_i2c_master_send_hs_master_code(module, packet->hs_master_code);
   12416:	7a89      	ldrb	r1, [r1, #10]
   12418:	4b0f      	ldr	r3, [pc, #60]	; (12458 <_i2c_master_write_packet+0x50>)
   1241a:	4798      	blx	r3
	}

	/* Set action to ACK. */
	i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
   1241c:	6863      	ldr	r3, [r4, #4]
   1241e:	4a0f      	ldr	r2, [pc, #60]	; (1245c <_i2c_master_write_packet+0x54>)
   12420:	4013      	ands	r3, r2

	/* Save packet to software module */
	module->buffer             = packet->data;
	module->buffer_remaining   = packet->data_length;
	module->transfer_direction = I2C_TRANSFER_WRITE;
   12422:	2200      	movs	r2, #0
	i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
   12424:	6063      	str	r3, [r4, #4]
	module->buffer             = packet->data;
   12426:	6873      	ldr	r3, [r6, #4]
   12428:	622b      	str	r3, [r5, #32]
	module->buffer_remaining   = packet->data_length;
   1242a:	8873      	ldrh	r3, [r6, #2]
   1242c:	83ab      	strh	r3, [r5, #28]
	module->transfer_direction = I2C_TRANSFER_WRITE;
   1242e:	1d6b      	adds	r3, r5, #5
   12430:	77da      	strb	r2, [r3, #31]
	module->status             = STATUS_BUSY;
   12432:	2305      	movs	r3, #5
   12434:	3506      	adds	r5, #6
   12436:	77eb      	strb	r3, [r5, #31]

	/* Enable interrupts */
	i2c_module->INTENSET.reg =
   12438:	3b02      	subs	r3, #2
   1243a:	75a3      	strb	r3, [r4, #22]
   1243c:	7a72      	ldrb	r2, [r6, #9]
   1243e:	8833      	ldrh	r3, [r6, #0]
			SERCOM_I2CM_INTENSET_MB | SERCOM_I2CM_INTENSET_SB;

	/* Set address and direction bit, will send start command on bus */
	if (packet->ten_bit_address) {
   12440:	7a31      	ldrb	r1, [r6, #8]
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_WRITE |
   12442:	005b      	lsls	r3, r3, #1
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
   12444:	0392      	lsls	r2, r2, #14
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_WRITE |
   12446:	4313      	orrs	r3, r2
	if (packet->ten_bit_address) {
   12448:	2900      	cmp	r1, #0
   1244a:	d002      	beq.n	12452 <_i2c_master_write_packet+0x4a>
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
   1244c:	2280      	movs	r2, #128	; 0x80
   1244e:	0212      	lsls	r2, r2, #8
   12450:	4313      	orrs	r3, r2
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_WRITE |
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos);
	}

	return STATUS_OK;
}
   12452:	2000      	movs	r0, #0
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_WRITE |
   12454:	6263      	str	r3, [r4, #36]	; 0x24
}
   12456:	bd70      	pop	{r4, r5, r6, pc}
   12458:	000159fd 	.word	0x000159fd
   1245c:	fffbffff 	.word	0xfffbffff

00012460 <_i2c_master_read_packet>:
	module->transfer_direction = I2C_TRANSFER_READ;
   12460:	2201      	movs	r2, #1
{
   12462:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	module->buffer             = packet->data;
   12464:	684b      	ldr	r3, [r1, #4]
	SercomI2cm *const i2c_module = &(module->hw->I2CM);
   12466:	6804      	ldr	r4, [r0, #0]
	module->buffer             = packet->data;
   12468:	6203      	str	r3, [r0, #32]
	module->buffer_remaining   = packet->data_length;
   1246a:	884b      	ldrh	r3, [r1, #2]
{
   1246c:	0006      	movs	r6, r0
	module->buffer_remaining   = packet->data_length;
   1246e:	8383      	strh	r3, [r0, #28]
	module->transfer_direction = I2C_TRANSFER_READ;
   12470:	1d43      	adds	r3, r0, #5
   12472:	77da      	strb	r2, [r3, #31]
	module->status             = STATUS_BUSY;
   12474:	1d83      	adds	r3, r0, #6
   12476:	3204      	adds	r2, #4
   12478:	77da      	strb	r2, [r3, #31]
	bool sclsm_flag = i2c_module->CTRLA.bit.SCLSM;
   1247a:	6827      	ldr	r7, [r4, #0]
	if (packet->high_speed) {
   1247c:	7a4b      	ldrb	r3, [r1, #9]
	bool sclsm_flag = i2c_module->CTRLA.bit.SCLSM;
   1247e:	013f      	lsls	r7, r7, #4
{
   12480:	000d      	movs	r5, r1
	bool sclsm_flag = i2c_module->CTRLA.bit.SCLSM;
   12482:	0fff      	lsrs	r7, r7, #31
	if (packet->high_speed) {
   12484:	2b00      	cmp	r3, #0
   12486:	d002      	beq.n	1248e <_i2c_master_read_packet+0x2e>
		_i2c_master_send_hs_master_code(module, packet->hs_master_code);
   12488:	7a89      	ldrb	r1, [r1, #10]
   1248a:	4b20      	ldr	r3, [pc, #128]	; (1250c <_i2c_master_read_packet+0xac>)
   1248c:	4798      	blx	r3
	if ((sclsm_flag) && (packet->data_length == 1)) {
   1248e:	2f00      	cmp	r7, #0
   12490:	d02f      	beq.n	124f2 <_i2c_master_read_packet+0x92>
   12492:	886b      	ldrh	r3, [r5, #2]
   12494:	2b01      	cmp	r3, #1
   12496:	d12c      	bne.n	124f2 <_i2c_master_read_packet+0x92>
		i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
   12498:	2380      	movs	r3, #128	; 0x80
   1249a:	6862      	ldr	r2, [r4, #4]
   1249c:	02db      	lsls	r3, r3, #11
   1249e:	4313      	orrs	r3, r2
		i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
   124a0:	6063      	str	r3, [r4, #4]
	if (packet->ten_bit_address) {
   124a2:	7a28      	ldrb	r0, [r5, #8]
   124a4:	2800      	cmp	r0, #0
   124a6:	d028      	beq.n	124fa <_i2c_master_read_packet+0x9a>
		i2c_module->ADDR.reg = (packet->address << 1) |
   124a8:	882b      	ldrh	r3, [r5, #0]
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
   124aa:	7a6a      	ldrb	r2, [r5, #9]
		i2c_module->ADDR.reg = (packet->address << 1) |
   124ac:	005b      	lsls	r3, r3, #1
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
   124ae:	0392      	lsls	r2, r2, #14
		i2c_module->ADDR.reg = (packet->address << 1) |
   124b0:	4313      	orrs	r3, r2
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
   124b2:	2280      	movs	r2, #128	; 0x80
   124b4:	0212      	lsls	r2, r2, #8
   124b6:	4313      	orrs	r3, r2
		i2c_module->ADDR.reg = (packet->address << 1) |
   124b8:	6263      	str	r3, [r4, #36]	; 0x24
		tmp_status = _i2c_master_wait_for_bus(module);
   124ba:	0030      	movs	r0, r6
   124bc:	4b14      	ldr	r3, [pc, #80]	; (12510 <_i2c_master_read_packet+0xb0>)
   124be:	4798      	blx	r3
		i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
   124c0:	6863      	ldr	r3, [r4, #4]
   124c2:	4a14      	ldr	r2, [pc, #80]	; (12514 <_i2c_master_read_packet+0xb4>)
   124c4:	4013      	ands	r3, r2
   124c6:	6063      	str	r3, [r4, #4]
		if (tmp_status == STATUS_OK) {
   124c8:	2800      	cmp	r0, #0
   124ca:	d111      	bne.n	124f0 <_i2c_master_read_packet+0x90>
			tmp_status = _i2c_master_address_response(module);
   124cc:	0030      	movs	r0, r6
   124ce:	4b12      	ldr	r3, [pc, #72]	; (12518 <_i2c_master_read_packet+0xb8>)
   124d0:	4798      	blx	r3
		if (tmp_status == STATUS_OK) {
   124d2:	2800      	cmp	r0, #0
   124d4:	d10c      	bne.n	124f0 <_i2c_master_read_packet+0x90>
			i2c_module->INTENSET.reg =
   124d6:	2303      	movs	r3, #3
   124d8:	75a3      	strb	r3, [r4, #22]
			i2c_module->ADDR.reg = (((packet->address >> 8) | 0x78) << 1) |
   124da:	882a      	ldrh	r2, [r5, #0]
   124dc:	3375      	adds	r3, #117	; 0x75
   124de:	0a12      	lsrs	r2, r2, #8
   124e0:	4313      	orrs	r3, r2
				(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
   124e2:	2201      	movs	r2, #1
   124e4:	7a69      	ldrb	r1, [r5, #9]
			i2c_module->ADDR.reg = (((packet->address >> 8) | 0x78) << 1) |
   124e6:	005b      	lsls	r3, r3, #1
				(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos) |
   124e8:	0389      	lsls	r1, r1, #14
   124ea:	430a      	orrs	r2, r1
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_READ |
   124ec:	4313      	orrs	r3, r2
   124ee:	6263      	str	r3, [r4, #36]	; 0x24
}
   124f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
   124f2:	6863      	ldr	r3, [r4, #4]
   124f4:	4a07      	ldr	r2, [pc, #28]	; (12514 <_i2c_master_read_packet+0xb4>)
   124f6:	4013      	ands	r3, r2
   124f8:	e7d2      	b.n	124a0 <_i2c_master_read_packet+0x40>
		i2c_module->INTENSET.reg =
   124fa:	2303      	movs	r3, #3
   124fc:	75a3      	strb	r3, [r4, #22]
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_READ |
   124fe:	882b      	ldrh	r3, [r5, #0]
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos);
   12500:	7a6a      	ldrb	r2, [r5, #9]
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_READ |
   12502:	005b      	lsls	r3, r3, #1
			(packet->high_speed << SERCOM_I2CM_ADDR_HS_Pos);
   12504:	0392      	lsls	r2, r2, #14
		i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_READ |
   12506:	4313      	orrs	r3, r2
   12508:	2201      	movs	r2, #1
   1250a:	e7ef      	b.n	124ec <_i2c_master_read_packet+0x8c>
   1250c:	000159fd 	.word	0x000159fd
   12510:	000159d5 	.word	0x000159d5
   12514:	fffbffff 	.word	0xfffbffff
   12518:	000159a9 	.word	0x000159a9

0001251c <i2c_master_register_callback>:
	module->callbacks[callback_type] = callback;
   1251c:	1c93      	adds	r3, r2, #2
   1251e:	009b      	lsls	r3, r3, #2
   12520:	18c3      	adds	r3, r0, r3
   12522:	6059      	str	r1, [r3, #4]
	module->registered_callback |= (1 << callback_type);
   12524:	2301      	movs	r3, #1
   12526:	4093      	lsls	r3, r2
   12528:	7e01      	ldrb	r1, [r0, #24]
   1252a:	430b      	orrs	r3, r1
   1252c:	b2db      	uxtb	r3, r3
   1252e:	7603      	strb	r3, [r0, #24]
}
   12530:	4770      	bx	lr
	...

00012534 <i2c_master_read_packet_job>:
{
   12534:	b510      	push	{r4, lr}
	if (module->buffer_remaining > 0) {
   12536:	8b82      	ldrh	r2, [r0, #28]
{
   12538:	0003      	movs	r3, r0
		return STATUS_BUSY;
   1253a:	2005      	movs	r0, #5
	if (module->buffer_remaining > 0) {
   1253c:	2a00      	cmp	r2, #0
   1253e:	d105      	bne.n	1254c <i2c_master_read_packet_job+0x18>
	module->send_stop = true;
   12540:	3201      	adds	r2, #1
   12542:	729a      	strb	r2, [r3, #10]
	module->send_nack = true;
   12544:	72da      	strb	r2, [r3, #11]
	return _i2c_master_read_packet(module, packet);
   12546:	0018      	movs	r0, r3
   12548:	4b01      	ldr	r3, [pc, #4]	; (12550 <i2c_master_read_packet_job+0x1c>)
   1254a:	4798      	blx	r3
}
   1254c:	bd10      	pop	{r4, pc}
   1254e:	46c0      	nop			; (mov r8, r8)
   12550:	00012461 	.word	0x00012461

00012554 <i2c_master_write_packet_job>:
 * \retval STATUS_BUSY  If module is currently busy with another transfer
 */
enum status_code i2c_master_write_packet_job(
		struct i2c_master_module *const module,
		struct i2c_master_packet *const packet)
{
   12554:	b510      	push	{r4, lr}
	Assert(module);
	Assert(module->hw);
	Assert(packet);

	/* Check if the I2C module is busy with another job. */
	if (module->buffer_remaining > 0) {
   12556:	8b82      	ldrh	r2, [r0, #28]
{
   12558:	0003      	movs	r3, r0
		return STATUS_BUSY;
   1255a:	2005      	movs	r0, #5
	if (module->buffer_remaining > 0) {
   1255c:	2a00      	cmp	r2, #0
   1255e:	d105      	bne.n	1256c <i2c_master_write_packet_job+0x18>
	}

	/* Make sure we send STOP at end*/
	module->send_stop = true;
   12560:	3201      	adds	r2, #1
   12562:	729a      	strb	r2, [r3, #10]
	module->send_nack = true;
   12564:	72da      	strb	r2, [r3, #11]
	/* Start write operation */
	return _i2c_master_write_packet(module, packet);
   12566:	0018      	movs	r0, r3
   12568:	4b01      	ldr	r3, [pc, #4]	; (12570 <i2c_master_write_packet_job+0x1c>)
   1256a:	4798      	blx	r3
}
   1256c:	bd10      	pop	{r4, pc}
   1256e:	46c0      	nop			; (mov r8, r8)
   12570:	00012409 	.word	0x00012409

00012574 <_i2c_master_interrupt_handler>:
 *
 * \param[in] instance  SERCOM instance that triggered the interrupt
 */
void _i2c_master_interrupt_handler(
		uint8_t instance)
{
   12574:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Get software module for callback handling */
	struct i2c_master_module *module =
   12576:	4b5e      	ldr	r3, [pc, #376]	; (126f0 <_i2c_master_interrupt_handler+0x17c>)
   12578:	0080      	lsls	r0, r0, #2
   1257a:	58c4      	ldr	r4, [r0, r3]
			(struct i2c_master_module*)_sercom_instances[instance];

	Assert(module);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
   1257c:	6825      	ldr	r5, [r4, #0]
   1257e:	1da6      	adds	r6, r4, #6
	bool sclsm_flag = i2c_module->CTRLA.bit.SCLSM;
   12580:	682b      	ldr	r3, [r5, #0]

	/* Combine callback registered and enabled masks */
	uint8_t callback_mask = module->enabled_callback;
   12582:	7e62      	ldrb	r2, [r4, #25]
	callback_mask &= module->registered_callback;
   12584:	7e27      	ldrb	r7, [r4, #24]
	bool sclsm_flag = i2c_module->CTRLA.bit.SCLSM;
   12586:	011b      	lsls	r3, r3, #4
	callback_mask &= module->registered_callback;
   12588:	4017      	ands	r7, r2

	/* Check if the module should respond to address ack */
	if ((module->buffer_length <= 0) && (module->buffer_remaining > 0)) {
   1258a:	8b62      	ldrh	r2, [r4, #26]
	bool sclsm_flag = i2c_module->CTRLA.bit.SCLSM;
   1258c:	0fdb      	lsrs	r3, r3, #31
	if ((module->buffer_length <= 0) && (module->buffer_remaining > 0)) {
   1258e:	2a00      	cmp	r2, #0
   12590:	d12e      	bne.n	125f0 <_i2c_master_interrupt_handler+0x7c>
   12592:	8ba2      	ldrh	r2, [r4, #28]
   12594:	2a00      	cmp	r2, #0
   12596:	d02b      	beq.n	125f0 <_i2c_master_interrupt_handler+0x7c>
	if (i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB)
   12598:	2301      	movs	r3, #1
   1259a:	7e2a      	ldrb	r2, [r5, #24]
   1259c:	421a      	tst	r2, r3
   1259e:	d006      	beq.n	125ae <_i2c_master_interrupt_handler+0x3a>
		if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_ARBLOST) {
   125a0:	2202      	movs	r2, #2
		i2c_module->INTFLAG.reg = SERCOM_I2CM_INTENCLR_MB;
   125a2:	762b      	strb	r3, [r5, #24]
		if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_ARBLOST) {
   125a4:	8b6b      	ldrh	r3, [r5, #26]
   125a6:	4013      	ands	r3, r2
   125a8:	d010      	beq.n	125cc <_i2c_master_interrupt_handler+0x58>
			module->status = STATUS_ERR_PACKET_COLLISION;
   125aa:	2341      	movs	r3, #65	; 0x41
   125ac:	77f3      	strb	r3, [r6, #31]
	module->buffer_length = module->buffer_remaining;
   125ae:	8ba3      	ldrh	r3, [r4, #28]
   125b0:	b29b      	uxth	r3, r3
   125b2:	8363      	strh	r3, [r4, #26]
	if (module->status == STATUS_BUSY) {
   125b4:	7ff3      	ldrb	r3, [r6, #31]
   125b6:	2b05      	cmp	r3, #5
   125b8:	d13c      	bne.n	12634 <_i2c_master_interrupt_handler+0xc0>
	} else if ((module->buffer_length > 0) && (module->buffer_remaining > 0)){
		/* Check that bus ownership is not lost */
		if ((!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(2))) &&
				(!(sclsm_flag && (module->buffer_remaining == 1))))	{
			module->status = STATUS_ERR_PACKET_COLLISION;
		} else if (module->transfer_direction == I2C_TRANSFER_WRITE) {
   125ba:	1d63      	adds	r3, r4, #5
   125bc:	7fdb      	ldrb	r3, [r3, #31]
			_i2c_master_write(module);
   125be:	0020      	movs	r0, r4
		} else if (module->transfer_direction == I2C_TRANSFER_WRITE) {
   125c0:	2b00      	cmp	r3, #0
   125c2:	d000      	beq.n	125c6 <_i2c_master_interrupt_handler+0x52>
   125c4:	e08a      	b.n	126dc <_i2c_master_interrupt_handler+0x168>
			_i2c_master_write(module);
   125c6:	4b4b      	ldr	r3, [pc, #300]	; (126f4 <_i2c_master_interrupt_handler+0x180>)
		} else {
			_i2c_master_read(module);
   125c8:	4798      	blx	r3
   125ca:	e033      	b.n	12634 <_i2c_master_interrupt_handler+0xc0>
		else if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_RXNACK) {
   125cc:	8b6a      	ldrh	r2, [r5, #26]
   125ce:	0752      	lsls	r2, r2, #29
   125d0:	d5ed      	bpl.n	125ae <_i2c_master_interrupt_handler+0x3a>
			module->status           = STATUS_ERR_BAD_ADDRESS;
   125d2:	2218      	movs	r2, #24
   125d4:	77f2      	strb	r2, [r6, #31]
			module->buffer_remaining = 0;
   125d6:	83a3      	strh	r3, [r4, #28]
			if (module->send_stop) {
   125d8:	7aa3      	ldrb	r3, [r4, #10]
   125da:	2b00      	cmp	r3, #0
   125dc:	d0e7      	beq.n	125ae <_i2c_master_interrupt_handler+0x3a>
				_i2c_master_wait_for_sync(module);
   125de:	4b46      	ldr	r3, [pc, #280]	; (126f8 <_i2c_master_interrupt_handler+0x184>)
   125e0:	0020      	movs	r0, r4
   125e2:	4798      	blx	r3
				i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
   125e4:	23c0      	movs	r3, #192	; 0xc0
   125e6:	686a      	ldr	r2, [r5, #4]
   125e8:	029b      	lsls	r3, r3, #10
   125ea:	4313      	orrs	r3, r2
   125ec:	606b      	str	r3, [r5, #4]
   125ee:	e7de      	b.n	125ae <_i2c_master_interrupt_handler+0x3a>
	} else if ((module->buffer_length > 0) && (module->buffer_remaining <= 0) &&
   125f0:	8b62      	ldrh	r2, [r4, #26]
   125f2:	2a00      	cmp	r2, #0
   125f4:	d05f      	beq.n	126b6 <_i2c_master_interrupt_handler+0x142>
   125f6:	8ba2      	ldrh	r2, [r4, #28]
   125f8:	2a00      	cmp	r2, #0
   125fa:	d15c      	bne.n	126b6 <_i2c_master_interrupt_handler+0x142>
			(module->status == STATUS_BUSY) &&
   125fc:	7ff2      	ldrb	r2, [r6, #31]
	} else if ((module->buffer_length > 0) && (module->buffer_remaining <= 0) &&
   125fe:	2a05      	cmp	r2, #5
   12600:	d159      	bne.n	126b6 <_i2c_master_interrupt_handler+0x142>
			(module->transfer_direction == I2C_TRANSFER_WRITE)) {
   12602:	1d62      	adds	r2, r4, #5
   12604:	7fd2      	ldrb	r2, [r2, #31]
   12606:	b2d2      	uxtb	r2, r2
			(module->status == STATUS_BUSY) &&
   12608:	2a00      	cmp	r2, #0
   1260a:	d154      	bne.n	126b6 <_i2c_master_interrupt_handler+0x142>
		i2c_module->INTENCLR.reg =
   1260c:	2303      	movs	r3, #3
   1260e:	752b      	strb	r3, [r5, #20]
		module->buffer_length = 0;
   12610:	8362      	strh	r2, [r4, #26]
		module->status        = STATUS_OK;
   12612:	77f2      	strb	r2, [r6, #31]
		if (module->send_stop) {
   12614:	7aa3      	ldrb	r3, [r4, #10]
   12616:	2b00      	cmp	r3, #0
   12618:	d04a      	beq.n	126b0 <_i2c_master_interrupt_handler+0x13c>
			_i2c_master_wait_for_sync(module);
   1261a:	4b37      	ldr	r3, [pc, #220]	; (126f8 <_i2c_master_interrupt_handler+0x184>)
   1261c:	0020      	movs	r0, r4
   1261e:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
   12620:	23c0      	movs	r3, #192	; 0xc0
   12622:	686a      	ldr	r2, [r5, #4]
   12624:	029b      	lsls	r3, r3, #10
   12626:	4313      	orrs	r3, r2
   12628:	606b      	str	r3, [r5, #4]
		if (callback_mask & (1 << I2C_MASTER_CALLBACK_WRITE_COMPLETE)) {
   1262a:	07fb      	lsls	r3, r7, #31
   1262c:	d502      	bpl.n	12634 <_i2c_master_interrupt_handler+0xc0>
			module->callbacks[I2C_MASTER_CALLBACK_WRITE_COMPLETE](module);
   1262e:	68e3      	ldr	r3, [r4, #12]
   12630:	0020      	movs	r0, r4
   12632:	4798      	blx	r3
		}
	}

	/* Check if read buffer transfer is complete */
	if ((module->buffer_length > 0) && (module->buffer_remaining <= 0) &&
   12634:	8b63      	ldrh	r3, [r4, #26]
   12636:	2b00      	cmp	r3, #0
   12638:	d01b      	beq.n	12672 <_i2c_master_interrupt_handler+0xfe>
   1263a:	8ba3      	ldrh	r3, [r4, #28]
   1263c:	2b00      	cmp	r3, #0
   1263e:	d118      	bne.n	12672 <_i2c_master_interrupt_handler+0xfe>
			(module->status == STATUS_BUSY) &&
   12640:	7ff3      	ldrb	r3, [r6, #31]
	if ((module->buffer_length > 0) && (module->buffer_remaining <= 0) &&
   12642:	2b05      	cmp	r3, #5
   12644:	d115      	bne.n	12672 <_i2c_master_interrupt_handler+0xfe>
			(module->transfer_direction == I2C_TRANSFER_READ)) {
   12646:	1d63      	adds	r3, r4, #5
   12648:	7fda      	ldrb	r2, [r3, #31]
			(module->status == STATUS_BUSY) &&
   1264a:	2a01      	cmp	r2, #1
   1264c:	d111      	bne.n	12672 <_i2c_master_interrupt_handler+0xfe>
		
		/* Clear read interrupt flag */
		if (i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB) {
   1264e:	7e29      	ldrb	r1, [r5, #24]
   12650:	3201      	adds	r2, #1
   12652:	4211      	tst	r1, r2
   12654:	d000      	beq.n	12658 <_i2c_master_interrupt_handler+0xe4>
			i2c_module->INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
   12656:	762a      	strb	r2, [r5, #24]
		}
		/* Stop packet operation */
		i2c_module->INTENCLR.reg =
   12658:	2203      	movs	r2, #3
   1265a:	752a      	strb	r2, [r5, #20]
				SERCOM_I2CM_INTENCLR_MB | SERCOM_I2CM_INTENCLR_SB;
		module->buffer_length = 0;
   1265c:	2200      	movs	r2, #0
   1265e:	8362      	strh	r2, [r4, #26]
		module->status        = STATUS_OK;
   12660:	77f2      	strb	r2, [r6, #31]

		/* Call appropriate callback if enabled and registered */
		if ((callback_mask & (1 << I2C_MASTER_CALLBACK_READ_COMPLETE))
   12662:	07ba      	lsls	r2, r7, #30
   12664:	d53c      	bpl.n	126e0 <_i2c_master_interrupt_handler+0x16c>
				&& (module->transfer_direction == I2C_TRANSFER_READ)) {
   12666:	7fda      	ldrb	r2, [r3, #31]
   12668:	2a01      	cmp	r2, #1
   1266a:	d139      	bne.n	126e0 <_i2c_master_interrupt_handler+0x16c>
			module->callbacks[I2C_MASTER_CALLBACK_READ_COMPLETE](module);
   1266c:	6923      	ldr	r3, [r4, #16]
		} else if ((callback_mask & (1 << I2C_MASTER_CALLBACK_WRITE_COMPLETE))
				&& (module->transfer_direction == I2C_TRANSFER_WRITE)) {
			module->callbacks[I2C_MASTER_CALLBACK_WRITE_COMPLETE](module);
   1266e:	0020      	movs	r0, r4
   12670:	4798      	blx	r3
		}
	}

	/* Check for error */
	if ((module->status != STATUS_BUSY) && (module->status != STATUS_OK)) {
   12672:	7ff3      	ldrb	r3, [r6, #31]
   12674:	2b05      	cmp	r3, #5
   12676:	d01a      	beq.n	126ae <_i2c_master_interrupt_handler+0x13a>
   12678:	7ff3      	ldrb	r3, [r6, #31]
   1267a:	2b00      	cmp	r3, #0
   1267c:	d017      	beq.n	126ae <_i2c_master_interrupt_handler+0x13a>
		/* Stop packet operation */
		i2c_module->INTENCLR.reg = SERCOM_I2CM_INTENCLR_MB |
   1267e:	2303      	movs	r3, #3
   12680:	752b      	strb	r3, [r5, #20]
				SERCOM_I2CM_INTENCLR_SB;

		module->buffer_length = 0;
   12682:	2300      	movs	r3, #0
   12684:	8363      	strh	r3, [r4, #26]
		module->buffer_remaining = 0;
   12686:	83a3      	strh	r3, [r4, #28]

		/* Send nack and stop command unless arbitration is lost */
		if ((module->status != STATUS_ERR_PACKET_COLLISION) &&
   12688:	7ff3      	ldrb	r3, [r6, #31]
   1268a:	2b41      	cmp	r3, #65	; 0x41
   1268c:	d00a      	beq.n	126a4 <_i2c_master_interrupt_handler+0x130>
   1268e:	7aa3      	ldrb	r3, [r4, #10]
   12690:	2b00      	cmp	r3, #0
   12692:	d007      	beq.n	126a4 <_i2c_master_interrupt_handler+0x130>
				module->send_stop) {
			_i2c_master_wait_for_sync(module);
   12694:	4b18      	ldr	r3, [pc, #96]	; (126f8 <_i2c_master_interrupt_handler+0x184>)
   12696:	0020      	movs	r0, r4
   12698:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT |
   1269a:	23e0      	movs	r3, #224	; 0xe0
   1269c:	686a      	ldr	r2, [r5, #4]
   1269e:	02db      	lsls	r3, r3, #11
   126a0:	4313      	orrs	r3, r2
   126a2:	606b      	str	r3, [r5, #4]
					SERCOM_I2CM_CTRLB_CMD(3);
		}

		/* Call error callback if enabled and registered */
		if (callback_mask & (1 << I2C_MASTER_CALLBACK_ERROR)) {
   126a4:	077b      	lsls	r3, r7, #29
   126a6:	d502      	bpl.n	126ae <_i2c_master_interrupt_handler+0x13a>
			module->callbacks[I2C_MASTER_CALLBACK_ERROR](module);
   126a8:	6963      	ldr	r3, [r4, #20]
   126aa:	0020      	movs	r0, r4
   126ac:	4798      	blx	r3
		}
	}
}
   126ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			i2c_module->INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
   126b0:	2301      	movs	r3, #1
   126b2:	762b      	strb	r3, [r5, #24]
   126b4:	e7b9      	b.n	1262a <_i2c_master_interrupt_handler+0xb6>
	} else if ((module->buffer_length > 0) && (module->buffer_remaining > 0)){
   126b6:	8b62      	ldrh	r2, [r4, #26]
   126b8:	2a00      	cmp	r2, #0
   126ba:	d0bb      	beq.n	12634 <_i2c_master_interrupt_handler+0xc0>
   126bc:	8ba2      	ldrh	r2, [r4, #28]
   126be:	2a00      	cmp	r2, #0
   126c0:	d0b8      	beq.n	12634 <_i2c_master_interrupt_handler+0xc0>
		if ((!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(2))) &&
   126c2:	8b6a      	ldrh	r2, [r5, #26]
   126c4:	0692      	lsls	r2, r2, #26
   126c6:	d500      	bpl.n	126ca <_i2c_master_interrupt_handler+0x156>
   126c8:	e777      	b.n	125ba <_i2c_master_interrupt_handler+0x46>
   126ca:	2b00      	cmp	r3, #0
   126cc:	d003      	beq.n	126d6 <_i2c_master_interrupt_handler+0x162>
				(!(sclsm_flag && (module->buffer_remaining == 1))))	{
   126ce:	8ba3      	ldrh	r3, [r4, #28]
   126d0:	2b01      	cmp	r3, #1
   126d2:	d100      	bne.n	126d6 <_i2c_master_interrupt_handler+0x162>
   126d4:	e771      	b.n	125ba <_i2c_master_interrupt_handler+0x46>
			module->status = STATUS_ERR_PACKET_COLLISION;
   126d6:	2341      	movs	r3, #65	; 0x41
   126d8:	77f3      	strb	r3, [r6, #31]
   126da:	e7ab      	b.n	12634 <_i2c_master_interrupt_handler+0xc0>
			_i2c_master_read(module);
   126dc:	4b07      	ldr	r3, [pc, #28]	; (126fc <_i2c_master_interrupt_handler+0x188>)
   126de:	e773      	b.n	125c8 <_i2c_master_interrupt_handler+0x54>
		} else if ((callback_mask & (1 << I2C_MASTER_CALLBACK_WRITE_COMPLETE))
   126e0:	07fa      	lsls	r2, r7, #31
   126e2:	d5c6      	bpl.n	12672 <_i2c_master_interrupt_handler+0xfe>
				&& (module->transfer_direction == I2C_TRANSFER_WRITE)) {
   126e4:	7fdb      	ldrb	r3, [r3, #31]
   126e6:	2b00      	cmp	r3, #0
   126e8:	d1c3      	bne.n	12672 <_i2c_master_interrupt_handler+0xfe>
			module->callbacks[I2C_MASTER_CALLBACK_WRITE_COMPLETE](module);
   126ea:	68e3      	ldr	r3, [r4, #12]
   126ec:	e7bf      	b.n	1266e <_i2c_master_interrupt_handler+0xfa>
   126ee:	46c0      	nop			; (mov r8, r8)
   126f0:	20005680 	.word	0x20005680
   126f4:	000123cd 	.word	0x000123cd
   126f8:	00012351 	.word	0x00012351
   126fc:	0001235d 	.word	0x0001235d

00012700 <vBmeTask>:
                    and then add it to the queue ready to be publish or fetched over CLI.
 * @param[in]       pvParameters
 * @return          None
 */
void vBmeTask(void *pvParameters)
{
   12700:	b570      	push	{r4, r5, r6, lr}
   12702:	b0a6      	sub	sp, #152	; 0x98
	int8_t rslt;
	uint8_t n_fields;
	uint8_t i = 0;
	
	struct bme68x_data data[BME68X_N_MEAS] = { { 0 } };
   12704:	2290      	movs	r2, #144	; 0x90
   12706:	2100      	movs	r1, #0
   12708:	a802      	add	r0, sp, #8
   1270a:	4b11      	ldr	r3, [pc, #68]	; (12750 <vBmeTask+0x50>)
	while(1) {
		/* Trigger a measurement */
		rslt = bme68x_set_op_mode(BME68X_FORCED_MODE, &bme);
        
		/* Wait for the measurement to be completed */
		vTaskDelay(pdMS_TO_TICKS((uint32_t) 1000));
   1270c:	26fa      	movs	r6, #250	; 0xfa
	struct bme68x_data data[BME68X_N_MEAS] = { { 0 } };
   1270e:	4798      	blx	r3
		rslt = bme68x_set_op_mode(BME68X_FORCED_MODE, &bme);
   12710:	2401      	movs	r4, #1
		vTaskDelay(pdMS_TO_TICKS((uint32_t) 1000));
   12712:	00b6      	lsls	r6, r6, #2
		rslt = bme68x_set_op_mode(BME68X_FORCED_MODE, &bme);
   12714:	4d0f      	ldr	r5, [pc, #60]	; (12754 <vBmeTask+0x54>)
   12716:	4b10      	ldr	r3, [pc, #64]	; (12758 <vBmeTask+0x58>)
   12718:	0029      	movs	r1, r5
   1271a:	0020      	movs	r0, r4
   1271c:	4798      	blx	r3
		vTaskDelay(pdMS_TO_TICKS((uint32_t) 1000));
   1271e:	0030      	movs	r0, r6
   12720:	4b0e      	ldr	r3, [pc, #56]	; (1275c <vBmeTask+0x5c>)
   12722:	4798      	blx	r3
		
		/* Fetch the data from the registers */
		rslt = bme68x_get_data(BME68X_FORCED_MODE, &data[0], &n_fields, &bme);
   12724:	466a      	mov	r2, sp
   12726:	002b      	movs	r3, r5
   12728:	3207      	adds	r2, #7
   1272a:	a902      	add	r1, sp, #8
   1272c:	0020      	movs	r0, r4
   1272e:	4d0c      	ldr	r5, [pc, #48]	; (12760 <vBmeTask+0x60>)
   12730:	47a8      	blx	r5
		
		/* If wifi queue initialized, add data to the queue */
		if (xQueueBmeBuffer) {
   12732:	4b0c      	ldr	r3, [pc, #48]	; (12764 <vBmeTask+0x64>)
   12734:	681b      	ldr	r3, [r3, #0]
   12736:	2b00      	cmp	r3, #0
   12738:	d002      	beq.n	12740 <vBmeTask+0x40>
			WifiAddBmeDataToQueue(&data[0]);
   1273a:	a802      	add	r0, sp, #8
   1273c:	4b0a      	ldr	r3, [pc, #40]	; (12768 <vBmeTask+0x68>)
   1273e:	4798      	blx	r3
		}
		
		/* If CLI queue initialized, add data to the queue */
		if (xQueueBmeCliBuffer) {
   12740:	4b0a      	ldr	r3, [pc, #40]	; (1276c <vBmeTask+0x6c>)
   12742:	681b      	ldr	r3, [r3, #0]
   12744:	2b00      	cmp	r3, #0
   12746:	d0e5      	beq.n	12714 <vBmeTask+0x14>
			CLIAddBmeDataToQueue(&data[0]);
   12748:	a802      	add	r0, sp, #8
   1274a:	4b09      	ldr	r3, [pc, #36]	; (12770 <vBmeTask+0x70>)
   1274c:	4798      	blx	r3
   1274e:	e7e1      	b.n	12714 <vBmeTask+0x14>
   12750:	00022c47 	.word	0x00022c47
   12754:	200056d0 	.word	0x200056d0
   12758:	00013155 	.word	0x00013155
   1275c:	000185ad 	.word	0x000185ad
   12760:	00013341 	.word	0x00013341
   12764:	20000b94 	.word	0x20000b94
   12768:	00015641 	.word	0x00015641
   1276c:	200004e0 	.word	0x200004e0
   12770:	00013dfd 	.word	0x00013dfd

00012774 <calc_temperature>:

#else

/* @brief This internal API is used to calculate the temperature value. */
static float calc_temperature(uint32_t temp_adc, struct bme68x_dev *dev)
{
   12774:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    float var1;
    float var2;
    float calc_temp;

    /* calculate var1 data */
    var1 = ((((float)temp_adc / 16384.0f) - ((float)dev->calib.par_t1 / 1024.0f)) * ((float)dev->calib.par_t2));
   12776:	4c21      	ldr	r4, [pc, #132]	; (127fc <calc_temperature+0x88>)
{
   12778:	000d      	movs	r5, r1
    var1 = ((((float)temp_adc / 16384.0f) - ((float)dev->calib.par_t1 / 1024.0f)) * ((float)dev->calib.par_t2));
   1277a:	47a0      	blx	r4
   1277c:	1c07      	adds	r7, r0, #0
   1277e:	8be8      	ldrh	r0, [r5, #30]
   12780:	47a0      	blx	r4

    /* calculate var2 data */
    var2 =
        (((((float)temp_adc / 131072.0f) - ((float)dev->calib.par_t1 / 8192.0f)) *
   12782:	21dc      	movs	r1, #220	; 0xdc
   12784:	4c1e      	ldr	r4, [pc, #120]	; (12800 <calc_temperature+0x8c>)
    var1 = ((((float)temp_adc / 16384.0f) - ((float)dev->calib.par_t1 / 1024.0f)) * ((float)dev->calib.par_t2));
   12786:	1c06      	adds	r6, r0, #0
        (((((float)temp_adc / 131072.0f) - ((float)dev->calib.par_t1 / 8192.0f)) *
   12788:	0589      	lsls	r1, r1, #22
   1278a:	1c38      	adds	r0, r7, #0
   1278c:	47a0      	blx	r4
   1278e:	21e4      	movs	r1, #228	; 0xe4
   12790:	9001      	str	r0, [sp, #4]
   12792:	0589      	lsls	r1, r1, #22
   12794:	1c30      	adds	r0, r6, #0
   12796:	47a0      	blx	r4
   12798:	4b1a      	ldr	r3, [pc, #104]	; (12804 <calc_temperature+0x90>)
   1279a:	1c01      	adds	r1, r0, #0
   1279c:	9801      	ldr	r0, [sp, #4]
   1279e:	4798      	blx	r3
    var1 = ((((float)temp_adc / 16384.0f) - ((float)dev->calib.par_t1 / 1024.0f)) * ((float)dev->calib.par_t2));
   127a0:	21e2      	movs	r1, #226	; 0xe2
        (((((float)temp_adc / 131072.0f) - ((float)dev->calib.par_t1 / 8192.0f)) *
   127a2:	9001      	str	r0, [sp, #4]
    var1 = ((((float)temp_adc / 16384.0f) - ((float)dev->calib.par_t1 / 1024.0f)) * ((float)dev->calib.par_t2));
   127a4:	0589      	lsls	r1, r1, #22
   127a6:	1c38      	adds	r0, r7, #0
   127a8:	47a0      	blx	r4
   127aa:	21ea      	movs	r1, #234	; 0xea
   127ac:	1c07      	adds	r7, r0, #0
   127ae:	0589      	lsls	r1, r1, #22
   127b0:	1c30      	adds	r0, r6, #0
   127b2:	47a0      	blx	r4
   127b4:	4b13      	ldr	r3, [pc, #76]	; (12804 <calc_temperature+0x90>)
   127b6:	1c01      	adds	r1, r0, #0
   127b8:	1c38      	adds	r0, r7, #0
   127ba:	4798      	blx	r3
   127bc:	4e12      	ldr	r6, [pc, #72]	; (12808 <calc_temperature+0x94>)
   127be:	1c07      	adds	r7, r0, #0
   127c0:	2320      	movs	r3, #32
   127c2:	5ee8      	ldrsh	r0, [r5, r3]
   127c4:	47b0      	blx	r6
   127c6:	1c01      	adds	r1, r0, #0
   127c8:	1c38      	adds	r0, r7, #0
   127ca:	47a0      	blx	r4
   127cc:	1c07      	adds	r7, r0, #0
          (((float)temp_adc / 131072.0f) - ((float)dev->calib.par_t1 / 8192.0f))) * ((float)dev->calib.par_t3 * 16.0f));
   127ce:	201f      	movs	r0, #31
   127d0:	1ceb      	adds	r3, r5, #3
   127d2:	5618      	ldrsb	r0, [r3, r0]
   127d4:	47b0      	blx	r6
   127d6:	2183      	movs	r1, #131	; 0x83
   127d8:	05c9      	lsls	r1, r1, #23
   127da:	47a0      	blx	r4
        (((((float)temp_adc / 131072.0f) - ((float)dev->calib.par_t1 / 8192.0f)) *
   127dc:	9901      	ldr	r1, [sp, #4]
          (((float)temp_adc / 131072.0f) - ((float)dev->calib.par_t1 / 8192.0f))) * ((float)dev->calib.par_t3 * 16.0f));
   127de:	1c06      	adds	r6, r0, #0
        (((((float)temp_adc / 131072.0f) - ((float)dev->calib.par_t1 / 8192.0f)) *
   127e0:	1c08      	adds	r0, r1, #0
   127e2:	47a0      	blx	r4
   127e4:	1c01      	adds	r1, r0, #0
    var2 =
   127e6:	1c30      	adds	r0, r6, #0
   127e8:	47a0      	blx	r4

    /* t_fine value*/
    dev->calib.t_fine = (var1 + var2);
   127ea:	4b08      	ldr	r3, [pc, #32]	; (1280c <calc_temperature+0x98>)
    var2 =
   127ec:	1c01      	adds	r1, r0, #0
    dev->calib.t_fine = (var1 + var2);
   127ee:	1c38      	adds	r0, r7, #0
   127f0:	4798      	blx	r3

    /* compensated temperature data*/
    calc_temp = ((dev->calib.t_fine) / 5120.0f);
   127f2:	4907      	ldr	r1, [pc, #28]	; (12810 <calc_temperature+0x9c>)
    dev->calib.t_fine = (var1 + var2);
   127f4:	63a8      	str	r0, [r5, #56]	; 0x38
    calc_temp = ((dev->calib.t_fine) / 5120.0f);
   127f6:	4b07      	ldr	r3, [pc, #28]	; (12814 <calc_temperature+0xa0>)
   127f8:	4798      	blx	r3

    return calc_temp;
}
   127fa:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   127fc:	00026a91 	.word	0x00026a91
   12800:	00026439 	.word	0x00026439
   12804:	00026679 	.word	0x00026679
   12808:	000269f1 	.word	0x000269f1
   1280c:	00025d35 	.word	0x00025d35
   12810:	45a00000 	.word	0x45a00000
   12814:	00026059 	.word	0x00026059

00012818 <calc_pressure>:

/* @brief This internal API is used to calculate the pressure value. */
static float calc_pressure(uint32_t pres_adc, const struct bme68x_dev *dev)
{
   12818:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1281a:	000f      	movs	r7, r1
    float var1;
    float var2;
    float var3;
    float calc_pres;

    var1 = (((float)dev->calib.t_fine / 2.0f) - 64000.0f);
   1281c:	21fc      	movs	r1, #252	; 0xfc
   1281e:	4e5e      	ldr	r6, [pc, #376]	; (12998 <calc_pressure+0x180>)
{
   12820:	9001      	str	r0, [sp, #4]
    var1 = (((float)dev->calib.t_fine / 2.0f) - 64000.0f);
   12822:	0589      	lsls	r1, r1, #22
   12824:	6bb8      	ldr	r0, [r7, #56]	; 0x38
   12826:	47b0      	blx	r6
   12828:	495c      	ldr	r1, [pc, #368]	; (1299c <calc_pressure+0x184>)
   1282a:	4b5d      	ldr	r3, [pc, #372]	; (129a0 <calc_pressure+0x188>)
   1282c:	4798      	blx	r3
   1282e:	1c04      	adds	r4, r0, #0
    var2 = var1 * var1 * (((float)dev->calib.par_p6) / (131072.0f));
    var2 = var2 + (var1 * ((float)dev->calib.par_p5) * 2.0f);
    var2 = (var2 / 4.0f) + (((float)dev->calib.par_p4) * 65536.0f);
    var1 = (((((float)dev->calib.par_p3 * var1 * var1) / 16384.0f) + ((float)dev->calib.par_p2 * var1)) / 524288.0f);
   12830:	2028      	movs	r0, #40	; 0x28
   12832:	4b5c      	ldr	r3, [pc, #368]	; (129a4 <calc_pressure+0x18c>)
   12834:	5638      	ldrsb	r0, [r7, r0]
   12836:	4798      	blx	r3
   12838:	1c21      	adds	r1, r4, #0
   1283a:	47b0      	blx	r6
   1283c:	1c21      	adds	r1, r4, #0
   1283e:	47b0      	blx	r6
   12840:	21e2      	movs	r1, #226	; 0xe2
   12842:	0589      	lsls	r1, r1, #22
   12844:	47b0      	blx	r6
   12846:	1c05      	adds	r5, r0, #0
   12848:	2326      	movs	r3, #38	; 0x26
   1284a:	5ef8      	ldrsh	r0, [r7, r3]
   1284c:	4b55      	ldr	r3, [pc, #340]	; (129a4 <calc_pressure+0x18c>)
   1284e:	4798      	blx	r3
   12850:	1c21      	adds	r1, r4, #0
   12852:	47b0      	blx	r6
   12854:	4b54      	ldr	r3, [pc, #336]	; (129a8 <calc_pressure+0x190>)
   12856:	1c01      	adds	r1, r0, #0
   12858:	1c28      	adds	r0, r5, #0
   1285a:	4798      	blx	r3
   1285c:	21d8      	movs	r1, #216	; 0xd8
   1285e:	0589      	lsls	r1, r1, #22
   12860:	47b0      	blx	r6
    var1 = ((1.0f + (var1 / 32768.0f)) * ((float)dev->calib.par_p1));
   12862:	21e0      	movs	r1, #224	; 0xe0
   12864:	0589      	lsls	r1, r1, #22
   12866:	47b0      	blx	r6
   12868:	21fe      	movs	r1, #254	; 0xfe
   1286a:	4b4f      	ldr	r3, [pc, #316]	; (129a8 <calc_pressure+0x190>)
   1286c:	0589      	lsls	r1, r1, #22
   1286e:	4798      	blx	r3
   12870:	4b4e      	ldr	r3, [pc, #312]	; (129ac <calc_pressure+0x194>)
   12872:	1c05      	adds	r5, r0, #0
   12874:	8cb8      	ldrh	r0, [r7, #36]	; 0x24
   12876:	4798      	blx	r3
   12878:	1c29      	adds	r1, r5, #0
   1287a:	47b0      	blx	r6
    calc_pres = (1048576.0f - ((float)pres_adc));

    /* Avoid exception caused by division by zero */
    if ((int)var1 != 0)
   1287c:	4b4c      	ldr	r3, [pc, #304]	; (129b0 <calc_pressure+0x198>)
    var1 = ((1.0f + (var1 / 32768.0f)) * ((float)dev->calib.par_p1));
   1287e:	9000      	str	r0, [sp, #0]
    if ((int)var1 != 0)
   12880:	4798      	blx	r3
   12882:	2800      	cmp	r0, #0
   12884:	d100      	bne.n	12888 <calc_pressure+0x70>
   12886:	e085      	b.n	12994 <calc_pressure+0x17c>
    var2 = var1 * var1 * (((float)dev->calib.par_p6) / (131072.0f));
   12888:	202e      	movs	r0, #46	; 0x2e
   1288a:	4b46      	ldr	r3, [pc, #280]	; (129a4 <calc_pressure+0x18c>)
   1288c:	5638      	ldrsb	r0, [r7, r0]
   1288e:	4798      	blx	r3
   12890:	21dc      	movs	r1, #220	; 0xdc
   12892:	0589      	lsls	r1, r1, #22
   12894:	47b0      	blx	r6
   12896:	1c21      	adds	r1, r4, #0
   12898:	1c05      	adds	r5, r0, #0
   1289a:	1c20      	adds	r0, r4, #0
   1289c:	47b0      	blx	r6
   1289e:	1c01      	adds	r1, r0, #0
   128a0:	1c28      	adds	r0, r5, #0
   128a2:	47b0      	blx	r6
   128a4:	1c05      	adds	r5, r0, #0
    var2 = var2 + (var1 * ((float)dev->calib.par_p5) * 2.0f);
   128a6:	232c      	movs	r3, #44	; 0x2c
   128a8:	5ef8      	ldrsh	r0, [r7, r3]
   128aa:	4b3e      	ldr	r3, [pc, #248]	; (129a4 <calc_pressure+0x18c>)
   128ac:	4798      	blx	r3
   128ae:	1c21      	adds	r1, r4, #0
   128b0:	47b0      	blx	r6
   128b2:	4b3d      	ldr	r3, [pc, #244]	; (129a8 <calc_pressure+0x190>)
   128b4:	1c01      	adds	r1, r0, #0
   128b6:	4798      	blx	r3
   128b8:	4b3b      	ldr	r3, [pc, #236]	; (129a8 <calc_pressure+0x190>)
   128ba:	1c29      	adds	r1, r5, #0
   128bc:	4798      	blx	r3
    var2 = (var2 / 4.0f) + (((float)dev->calib.par_p4) * 65536.0f);
   128be:	21fa      	movs	r1, #250	; 0xfa
   128c0:	0589      	lsls	r1, r1, #22
   128c2:	47b0      	blx	r6
    calc_pres = (1048576.0f - ((float)pres_adc));
   128c4:	4b39      	ldr	r3, [pc, #228]	; (129ac <calc_pressure+0x194>)
    var2 = (var2 / 4.0f) + (((float)dev->calib.par_p4) * 65536.0f);
   128c6:	1c05      	adds	r5, r0, #0
    calc_pres = (1048576.0f - ((float)pres_adc));
   128c8:	9801      	ldr	r0, [sp, #4]
   128ca:	4798      	blx	r3
   128cc:	1c01      	adds	r1, r0, #0
   128ce:	2093      	movs	r0, #147	; 0x93
   128d0:	4b33      	ldr	r3, [pc, #204]	; (129a0 <calc_pressure+0x188>)
   128d2:	05c0      	lsls	r0, r0, #23
   128d4:	4798      	blx	r3
   128d6:	1c04      	adds	r4, r0, #0
    var2 = (var2 / 4.0f) + (((float)dev->calib.par_p4) * 65536.0f);
   128d8:	232a      	movs	r3, #42	; 0x2a
   128da:	5ef8      	ldrsh	r0, [r7, r3]
   128dc:	4b31      	ldr	r3, [pc, #196]	; (129a4 <calc_pressure+0x18c>)
   128de:	4798      	blx	r3
   128e0:	218f      	movs	r1, #143	; 0x8f
   128e2:	05c9      	lsls	r1, r1, #23
   128e4:	47b0      	blx	r6
   128e6:	4b30      	ldr	r3, [pc, #192]	; (129a8 <calc_pressure+0x190>)
   128e8:	1c29      	adds	r1, r5, #0
   128ea:	4798      	blx	r3
    {
        calc_pres = (((calc_pres - (var2 / 4096.0f)) * 6250.0f) / var1);
   128ec:	21e6      	movs	r1, #230	; 0xe6
   128ee:	0589      	lsls	r1, r1, #22
   128f0:	47b0      	blx	r6
   128f2:	4b2b      	ldr	r3, [pc, #172]	; (129a0 <calc_pressure+0x188>)
   128f4:	1c01      	adds	r1, r0, #0
   128f6:	1c20      	adds	r0, r4, #0
   128f8:	4798      	blx	r3
   128fa:	492e      	ldr	r1, [pc, #184]	; (129b4 <calc_pressure+0x19c>)
   128fc:	47b0      	blx	r6
   128fe:	4b2e      	ldr	r3, [pc, #184]	; (129b8 <calc_pressure+0x1a0>)
   12900:	9900      	ldr	r1, [sp, #0]
   12902:	4798      	blx	r3
        var1 = (((float)dev->calib.par_p9) * calc_pres * calc_pres) / 2147483648.0f;
        var2 = calc_pres * (((float)dev->calib.par_p8) / 32768.0f);
        var3 = ((calc_pres / 256.0f) * (calc_pres / 256.0f) * (calc_pres / 256.0f) * (dev->calib.par_p10 / 131072.0f));
   12904:	21ee      	movs	r1, #238	; 0xee
   12906:	0589      	lsls	r1, r1, #22
        calc_pres = (((calc_pres - (var2 / 4096.0f)) * 6250.0f) / var1);
   12908:	1c04      	adds	r4, r0, #0
        var3 = ((calc_pres / 256.0f) * (calc_pres / 256.0f) * (calc_pres / 256.0f) * (dev->calib.par_p10 / 131072.0f));
   1290a:	47b0      	blx	r6
   1290c:	1c05      	adds	r5, r0, #0
        var1 = (((float)dev->calib.par_p9) * calc_pres * calc_pres) / 2147483648.0f;
   1290e:	2332      	movs	r3, #50	; 0x32
   12910:	5ef8      	ldrsh	r0, [r7, r3]
   12912:	4b24      	ldr	r3, [pc, #144]	; (129a4 <calc_pressure+0x18c>)
   12914:	4798      	blx	r3
   12916:	1c21      	adds	r1, r4, #0
   12918:	47b0      	blx	r6
   1291a:	1c21      	adds	r1, r4, #0
   1291c:	47b0      	blx	r6
   1291e:	21c0      	movs	r1, #192	; 0xc0
   12920:	0589      	lsls	r1, r1, #22
   12922:	47b0      	blx	r6
   12924:	9000      	str	r0, [sp, #0]
        var2 = calc_pres * (((float)dev->calib.par_p8) / 32768.0f);
   12926:	2330      	movs	r3, #48	; 0x30
   12928:	5ef8      	ldrsh	r0, [r7, r3]
   1292a:	4b1e      	ldr	r3, [pc, #120]	; (129a4 <calc_pressure+0x18c>)
   1292c:	4798      	blx	r3
   1292e:	21e0      	movs	r1, #224	; 0xe0
   12930:	0589      	lsls	r1, r1, #22
   12932:	47b0      	blx	r6
   12934:	1c21      	adds	r1, r4, #0
   12936:	47b0      	blx	r6
        calc_pres = (calc_pres + (var1 + var2 + var3 + ((float)dev->calib.par_p7 * 128.0f)) / 16.0f);
   12938:	4b1b      	ldr	r3, [pc, #108]	; (129a8 <calc_pressure+0x190>)
        var2 = calc_pres * (((float)dev->calib.par_p8) / 32768.0f);
   1293a:	1c01      	adds	r1, r0, #0
        calc_pres = (calc_pres + (var1 + var2 + var3 + ((float)dev->calib.par_p7 * 128.0f)) / 16.0f);
   1293c:	9800      	ldr	r0, [sp, #0]
   1293e:	4798      	blx	r3
        var3 = ((calc_pres / 256.0f) * (calc_pres / 256.0f) * (calc_pres / 256.0f) * (dev->calib.par_p10 / 131072.0f));
   12940:	003b      	movs	r3, r7
        calc_pres = (calc_pres + (var1 + var2 + var3 + ((float)dev->calib.par_p7 * 128.0f)) / 16.0f);
   12942:	9000      	str	r0, [sp, #0]
        var3 = ((calc_pres / 256.0f) * (calc_pres / 256.0f) * (calc_pres / 256.0f) * (dev->calib.par_p10 / 131072.0f));
   12944:	3334      	adds	r3, #52	; 0x34
   12946:	7818      	ldrb	r0, [r3, #0]
   12948:	4b16      	ldr	r3, [pc, #88]	; (129a4 <calc_pressure+0x18c>)
   1294a:	4798      	blx	r3
   1294c:	21dc      	movs	r1, #220	; 0xdc
   1294e:	0589      	lsls	r1, r1, #22
   12950:	47b0      	blx	r6
   12952:	1c29      	adds	r1, r5, #0
   12954:	9001      	str	r0, [sp, #4]
   12956:	1c28      	adds	r0, r5, #0
   12958:	47b0      	blx	r6
   1295a:	1c29      	adds	r1, r5, #0
   1295c:	47b0      	blx	r6
   1295e:	1c01      	adds	r1, r0, #0
   12960:	9801      	ldr	r0, [sp, #4]
   12962:	47b0      	blx	r6
        calc_pres = (calc_pres + (var1 + var2 + var3 + ((float)dev->calib.par_p7 * 128.0f)) / 16.0f);
   12964:	4b10      	ldr	r3, [pc, #64]	; (129a8 <calc_pressure+0x190>)
        var3 = ((calc_pres / 256.0f) * (calc_pres / 256.0f) * (calc_pres / 256.0f) * (dev->calib.par_p10 / 131072.0f));
   12966:	1c01      	adds	r1, r0, #0
        calc_pres = (calc_pres + (var1 + var2 + var3 + ((float)dev->calib.par_p7 * 128.0f)) / 16.0f);
   12968:	9800      	ldr	r0, [sp, #0]
   1296a:	4798      	blx	r3
   1296c:	1c05      	adds	r5, r0, #0
   1296e:	202f      	movs	r0, #47	; 0x2f
   12970:	4b0c      	ldr	r3, [pc, #48]	; (129a4 <calc_pressure+0x18c>)
   12972:	5638      	ldrsb	r0, [r7, r0]
   12974:	4798      	blx	r3
   12976:	2186      	movs	r1, #134	; 0x86
   12978:	05c9      	lsls	r1, r1, #23
   1297a:	47b0      	blx	r6
   1297c:	4b0a      	ldr	r3, [pc, #40]	; (129a8 <calc_pressure+0x190>)
   1297e:	1c01      	adds	r1, r0, #0
   12980:	1c28      	adds	r0, r5, #0
   12982:	4798      	blx	r3
   12984:	21f6      	movs	r1, #246	; 0xf6
   12986:	0589      	lsls	r1, r1, #22
   12988:	47b0      	blx	r6
   1298a:	4b07      	ldr	r3, [pc, #28]	; (129a8 <calc_pressure+0x190>)
   1298c:	1c01      	adds	r1, r0, #0
   1298e:	1c20      	adds	r0, r4, #0
   12990:	4798      	blx	r3
    {
        calc_pres = 0;
    }

    return calc_pres;
}
   12992:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        calc_pres = 0;
   12994:	2000      	movs	r0, #0
    return calc_pres;
   12996:	e7fc      	b.n	12992 <calc_pressure+0x17a>
   12998:	00026439 	.word	0x00026439
   1299c:	477a0000 	.word	0x477a0000
   129a0:	00026679 	.word	0x00026679
   129a4:	000269f1 	.word	0x000269f1
   129a8:	00025d35 	.word	0x00025d35
   129ac:	00026a91 	.word	0x00026a91
   129b0:	000269b1 	.word	0x000269b1
   129b4:	45c35000 	.word	0x45c35000
   129b8:	00026059 	.word	0x00026059

000129bc <calc_humidity>:

/* This internal API is used to calculate the humidity in integer */
static float calc_humidity(uint16_t hum_adc, const struct bme68x_dev *dev)
{
   129bc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   129be:	000d      	movs	r5, r1
   129c0:	0006      	movs	r6, r0
    float var3;
    float var4;
    float temp_comp;

    /* compensated temperature data*/
    temp_comp = ((dev->calib.t_fine) / 5120.0f);
   129c2:	493d      	ldr	r1, [pc, #244]	; (12ab8 <calc_humidity+0xfc>)
   129c4:	4b3d      	ldr	r3, [pc, #244]	; (12abc <calc_humidity+0x100>)
   129c6:	6ba8      	ldr	r0, [r5, #56]	; 0x38
   129c8:	4798      	blx	r3
   129ca:	9000      	str	r0, [sp, #0]
    var1 = (float)((float)hum_adc) -
           (((float)dev->calib.par_h1 * 16.0f) + (((float)dev->calib.par_h3 / 2.0f) * temp_comp));
    var2 = var1 *
           ((float)(((float)dev->calib.par_h2 / 262144.0f) *
                    (1.0f + (((float)dev->calib.par_h4 / 16384.0f) * temp_comp) +
   129cc:	2015      	movs	r0, #21
   129ce:	4b3c      	ldr	r3, [pc, #240]	; (12ac0 <calc_humidity+0x104>)
   129d0:	5628      	ldrsb	r0, [r5, r0]
   129d2:	4798      	blx	r3
   129d4:	21e2      	movs	r1, #226	; 0xe2
   129d6:	4c3b      	ldr	r4, [pc, #236]	; (12ac4 <calc_humidity+0x108>)
   129d8:	0589      	lsls	r1, r1, #22
   129da:	47a0      	blx	r4
   129dc:	9900      	ldr	r1, [sp, #0]
   129de:	47a0      	blx	r4
   129e0:	21fe      	movs	r1, #254	; 0xfe
   129e2:	4b39      	ldr	r3, [pc, #228]	; (12ac8 <calc_humidity+0x10c>)
   129e4:	0589      	lsls	r1, r1, #22
   129e6:	4798      	blx	r3
   129e8:	1c07      	adds	r7, r0, #0
                     (((float)dev->calib.par_h5 / 1048576.0f) * temp_comp * temp_comp))));
   129ea:	2016      	movs	r0, #22
   129ec:	4b34      	ldr	r3, [pc, #208]	; (12ac0 <calc_humidity+0x104>)
   129ee:	5628      	ldrsb	r0, [r5, r0]
   129f0:	4798      	blx	r3
   129f2:	21d6      	movs	r1, #214	; 0xd6
   129f4:	0589      	lsls	r1, r1, #22
   129f6:	47a0      	blx	r4
   129f8:	9900      	ldr	r1, [sp, #0]
   129fa:	47a0      	blx	r4
   129fc:	9900      	ldr	r1, [sp, #0]
   129fe:	47a0      	blx	r4
                    (1.0f + (((float)dev->calib.par_h4 / 16384.0f) * temp_comp) +
   12a00:	4b31      	ldr	r3, [pc, #196]	; (12ac8 <calc_humidity+0x10c>)
                     (((float)dev->calib.par_h5 / 1048576.0f) * temp_comp * temp_comp))));
   12a02:	1c01      	adds	r1, r0, #0
                    (1.0f + (((float)dev->calib.par_h4 / 16384.0f) * temp_comp) +
   12a04:	1c38      	adds	r0, r7, #0
   12a06:	4798      	blx	r3
           ((float)(((float)dev->calib.par_h2 / 262144.0f) *
   12a08:	4b30      	ldr	r3, [pc, #192]	; (12acc <calc_humidity+0x110>)
                    (1.0f + (((float)dev->calib.par_h4 / 16384.0f) * temp_comp) +
   12a0a:	1c07      	adds	r7, r0, #0
           ((float)(((float)dev->calib.par_h2 / 262144.0f) *
   12a0c:	8a68      	ldrh	r0, [r5, #18]
   12a0e:	4798      	blx	r3
   12a10:	21da      	movs	r1, #218	; 0xda
   12a12:	0589      	lsls	r1, r1, #22
   12a14:	47a0      	blx	r4
   12a16:	1c01      	adds	r1, r0, #0
   12a18:	1c38      	adds	r0, r7, #0
   12a1a:	47a0      	blx	r4
    var1 = (float)((float)hum_adc) -
   12a1c:	4b2b      	ldr	r3, [pc, #172]	; (12acc <calc_humidity+0x110>)
           ((float)(((float)dev->calib.par_h2 / 262144.0f) *
   12a1e:	9001      	str	r0, [sp, #4]
    var1 = (float)((float)hum_adc) -
   12a20:	0030      	movs	r0, r6
   12a22:	4798      	blx	r3
   12a24:	1c07      	adds	r7, r0, #0
           (((float)dev->calib.par_h1 * 16.0f) + (((float)dev->calib.par_h3 / 2.0f) * temp_comp));
   12a26:	2014      	movs	r0, #20
   12a28:	4b25      	ldr	r3, [pc, #148]	; (12ac0 <calc_humidity+0x104>)
   12a2a:	5628      	ldrsb	r0, [r5, r0]
   12a2c:	4798      	blx	r3
   12a2e:	21fc      	movs	r1, #252	; 0xfc
   12a30:	0589      	lsls	r1, r1, #22
   12a32:	47a0      	blx	r4
   12a34:	9900      	ldr	r1, [sp, #0]
   12a36:	47a0      	blx	r4
   12a38:	4b24      	ldr	r3, [pc, #144]	; (12acc <calc_humidity+0x110>)
   12a3a:	1c06      	adds	r6, r0, #0
   12a3c:	8a28      	ldrh	r0, [r5, #16]
   12a3e:	4798      	blx	r3
   12a40:	2183      	movs	r1, #131	; 0x83
   12a42:	05c9      	lsls	r1, r1, #23
   12a44:	47a0      	blx	r4
   12a46:	4b20      	ldr	r3, [pc, #128]	; (12ac8 <calc_humidity+0x10c>)
   12a48:	1c01      	adds	r1, r0, #0
   12a4a:	1c30      	adds	r0, r6, #0
   12a4c:	4798      	blx	r3
    var1 = (float)((float)hum_adc) -
   12a4e:	4b20      	ldr	r3, [pc, #128]	; (12ad0 <calc_humidity+0x114>)
           (((float)dev->calib.par_h1 * 16.0f) + (((float)dev->calib.par_h3 / 2.0f) * temp_comp));
   12a50:	1c01      	adds	r1, r0, #0
    var1 = (float)((float)hum_adc) -
   12a52:	1c38      	adds	r0, r7, #0
   12a54:	4798      	blx	r3
   12a56:	1c01      	adds	r1, r0, #0
    var2 = var1 *
   12a58:	9801      	ldr	r0, [sp, #4]
   12a5a:	47a0      	blx	r4
   12a5c:	1c06      	adds	r6, r0, #0
    var3 = (float)dev->calib.par_h6 / 16384.0f;
    var4 = (float)dev->calib.par_h7 / 2097152.0f;
   12a5e:	2018      	movs	r0, #24
   12a60:	4b17      	ldr	r3, [pc, #92]	; (12ac0 <calc_humidity+0x104>)
   12a62:	5628      	ldrsb	r0, [r5, r0]
   12a64:	4798      	blx	r3
   12a66:	21d4      	movs	r1, #212	; 0xd4
   12a68:	0589      	lsls	r1, r1, #22
   12a6a:	47a0      	blx	r4
    calc_hum = var2 + ((var3 + (var4 * temp_comp)) * var2 * var2);
   12a6c:	9900      	ldr	r1, [sp, #0]
   12a6e:	47a0      	blx	r4
    var3 = (float)dev->calib.par_h6 / 16384.0f;
   12a70:	4b16      	ldr	r3, [pc, #88]	; (12acc <calc_humidity+0x110>)
    calc_hum = var2 + ((var3 + (var4 * temp_comp)) * var2 * var2);
   12a72:	1c07      	adds	r7, r0, #0
    var3 = (float)dev->calib.par_h6 / 16384.0f;
   12a74:	7de8      	ldrb	r0, [r5, #23]
   12a76:	4798      	blx	r3
   12a78:	21e2      	movs	r1, #226	; 0xe2
   12a7a:	0589      	lsls	r1, r1, #22
   12a7c:	47a0      	blx	r4
    calc_hum = var2 + ((var3 + (var4 * temp_comp)) * var2 * var2);
   12a7e:	4b12      	ldr	r3, [pc, #72]	; (12ac8 <calc_humidity+0x10c>)
    var3 = (float)dev->calib.par_h6 / 16384.0f;
   12a80:	1c01      	adds	r1, r0, #0
    calc_hum = var2 + ((var3 + (var4 * temp_comp)) * var2 * var2);
   12a82:	1c38      	adds	r0, r7, #0
   12a84:	4798      	blx	r3
   12a86:	1c31      	adds	r1, r6, #0
   12a88:	47a0      	blx	r4
   12a8a:	1c31      	adds	r1, r6, #0
   12a8c:	47a0      	blx	r4
   12a8e:	1c31      	adds	r1, r6, #0
   12a90:	4b0d      	ldr	r3, [pc, #52]	; (12ac8 <calc_humidity+0x10c>)
   12a92:	4798      	blx	r3
    if (calc_hum > 100.0f)
   12a94:	490f      	ldr	r1, [pc, #60]	; (12ad4 <calc_humidity+0x118>)
   12a96:	4b10      	ldr	r3, [pc, #64]	; (12ad8 <calc_humidity+0x11c>)
    calc_hum = var2 + ((var3 + (var4 * temp_comp)) * var2 * var2);
   12a98:	1c04      	adds	r4, r0, #0
    if (calc_hum > 100.0f)
   12a9a:	4798      	blx	r3
   12a9c:	2800      	cmp	r0, #0
   12a9e:	d108      	bne.n	12ab2 <calc_humidity+0xf6>
    {
        calc_hum = 100.0f;
    }
    else if (calc_hum < 0.0f)
   12aa0:	2100      	movs	r1, #0
   12aa2:	1c20      	adds	r0, r4, #0
   12aa4:	4b0d      	ldr	r3, [pc, #52]	; (12adc <calc_humidity+0x120>)
   12aa6:	4798      	blx	r3
   12aa8:	2800      	cmp	r0, #0
   12aaa:	d000      	beq.n	12aae <calc_humidity+0xf2>
    {
        calc_hum = 0.0f;
   12aac:	2400      	movs	r4, #0
    }

    return calc_hum;
}
   12aae:	1c20      	adds	r0, r4, #0
   12ab0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        calc_hum = 100.0f;
   12ab2:	4c08      	ldr	r4, [pc, #32]	; (12ad4 <calc_humidity+0x118>)
    return calc_hum;
   12ab4:	e7fb      	b.n	12aae <calc_humidity+0xf2>
   12ab6:	46c0      	nop			; (mov r8, r8)
   12ab8:	45a00000 	.word	0x45a00000
   12abc:	00026059 	.word	0x00026059
   12ac0:	000269f1 	.word	0x000269f1
   12ac4:	00026439 	.word	0x00026439
   12ac8:	00025d35 	.word	0x00025d35
   12acc:	00026a91 	.word	0x00026a91
   12ad0:	00026679 	.word	0x00026679
   12ad4:	42c80000 	.word	0x42c80000
   12ad8:	00025c89 	.word	0x00025c89
   12adc:	00025c61 	.word	0x00025c61

00012ae0 <calc_res_heat>:
    return calc_gas_res;
}

/* This internal API is used to calculate the heater resistance value using float */
static uint8_t calc_res_heat(uint16_t temp, const struct bme68x_dev *dev)
{
   12ae0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   12ae2:	0004      	movs	r4, r0
    {
        temp = 400;
    }

    var1 = (((float)dev->calib.par_gh1 / (16.0f)) + 49.0f);
    var2 = ((((float)dev->calib.par_gh2 / (32768.0f)) * (0.0005f)) + 0.00235f);
   12ae4:	4f33      	ldr	r7, [pc, #204]	; (12bb4 <calc_res_heat+0xd4>)
   12ae6:	231a      	movs	r3, #26
   12ae8:	5ec8      	ldrsh	r0, [r1, r3]
{
   12aea:	000d      	movs	r5, r1
    var2 = ((((float)dev->calib.par_gh2 / (32768.0f)) * (0.0005f)) + 0.00235f);
   12aec:	47b8      	blx	r7
   12aee:	21e0      	movs	r1, #224	; 0xe0
   12af0:	4e31      	ldr	r6, [pc, #196]	; (12bb8 <calc_res_heat+0xd8>)
   12af2:	0589      	lsls	r1, r1, #22
   12af4:	47b0      	blx	r6
   12af6:	4931      	ldr	r1, [pc, #196]	; (12bbc <calc_res_heat+0xdc>)
   12af8:	47b0      	blx	r6
   12afa:	4b31      	ldr	r3, [pc, #196]	; (12bc0 <calc_res_heat+0xe0>)
   12afc:	4931      	ldr	r1, [pc, #196]	; (12bc4 <calc_res_heat+0xe4>)
   12afe:	4798      	blx	r3
    var3 = ((float)dev->calib.par_gh3 / (1024.0f));
    var4 = (var1 * (1.0f + (var2 * (float)temp)));
   12b00:	23c8      	movs	r3, #200	; 0xc8
    var2 = ((((float)dev->calib.par_gh2 / (32768.0f)) * (0.0005f)) + 0.00235f);
   12b02:	1c06      	adds	r6, r0, #0
    var4 = (var1 * (1.0f + (var2 * (float)temp)));
   12b04:	005b      	lsls	r3, r3, #1
   12b06:	1c20      	adds	r0, r4, #0
   12b08:	429c      	cmp	r4, r3
   12b0a:	d900      	bls.n	12b0e <calc_res_heat+0x2e>
   12b0c:	1c18      	adds	r0, r3, #0
   12b0e:	4b2e      	ldr	r3, [pc, #184]	; (12bc8 <calc_res_heat+0xe8>)
   12b10:	b280      	uxth	r0, r0
   12b12:	4798      	blx	r3
   12b14:	4c28      	ldr	r4, [pc, #160]	; (12bb8 <calc_res_heat+0xd8>)
   12b16:	1c01      	adds	r1, r0, #0
   12b18:	1c30      	adds	r0, r6, #0
   12b1a:	47a0      	blx	r4
   12b1c:	21fe      	movs	r1, #254	; 0xfe
   12b1e:	4e28      	ldr	r6, [pc, #160]	; (12bc0 <calc_res_heat+0xe0>)
   12b20:	0589      	lsls	r1, r1, #22
   12b22:	47b0      	blx	r6
   12b24:	9000      	str	r0, [sp, #0]
    var1 = (((float)dev->calib.par_gh1 / (16.0f)) + 49.0f);
   12b26:	2019      	movs	r0, #25
   12b28:	5628      	ldrsb	r0, [r5, r0]
   12b2a:	47b8      	blx	r7
   12b2c:	21f6      	movs	r1, #246	; 0xf6
   12b2e:	0589      	lsls	r1, r1, #22
   12b30:	47a0      	blx	r4
   12b32:	4926      	ldr	r1, [pc, #152]	; (12bcc <calc_res_heat+0xec>)
   12b34:	47b0      	blx	r6
   12b36:	1c01      	adds	r1, r0, #0
    var4 = (var1 * (1.0f + (var2 * (float)temp)));
   12b38:	9800      	ldr	r0, [sp, #0]
   12b3a:	47a0      	blx	r4
   12b3c:	9000      	str	r0, [sp, #0]
    var3 = ((float)dev->calib.par_gh3 / (1024.0f));
   12b3e:	201c      	movs	r0, #28
   12b40:	5628      	ldrsb	r0, [r5, r0]
   12b42:	47b8      	blx	r7
   12b44:	21ea      	movs	r1, #234	; 0xea
   12b46:	0589      	lsls	r1, r1, #22
   12b48:	47a0      	blx	r4
   12b4a:	9001      	str	r0, [sp, #4]
    var5 = (var4 + (var3 * (float)dev->amb_temp));
   12b4c:	200e      	movs	r0, #14
   12b4e:	5628      	ldrsb	r0, [r5, r0]
   12b50:	47b8      	blx	r7
   12b52:	1c01      	adds	r1, r0, #0
   12b54:	9801      	ldr	r0, [sp, #4]
   12b56:	47a0      	blx	r4
   12b58:	1c01      	adds	r1, r0, #0
   12b5a:	9800      	ldr	r0, [sp, #0]
   12b5c:	47b0      	blx	r6
    res_heat =
        (uint8_t)(3.4f *
                  ((var5 * (4 / (4 + (float)dev->calib.res_heat_range)) *
   12b5e:	002b      	movs	r3, r5
    var5 = (var4 + (var3 * (float)dev->amb_temp));
   12b60:	9000      	str	r0, [sp, #0]
                  ((var5 * (4 / (4 + (float)dev->calib.res_heat_range)) *
   12b62:	333c      	adds	r3, #60	; 0x3c
   12b64:	7818      	ldrb	r0, [r3, #0]
   12b66:	4b18      	ldr	r3, [pc, #96]	; (12bc8 <calc_res_heat+0xe8>)
   12b68:	4798      	blx	r3
   12b6a:	2181      	movs	r1, #129	; 0x81
   12b6c:	05c9      	lsls	r1, r1, #23
   12b6e:	47b0      	blx	r6
   12b70:	1c01      	adds	r1, r0, #0
   12b72:	2081      	movs	r0, #129	; 0x81
   12b74:	4b16      	ldr	r3, [pc, #88]	; (12bd0 <calc_res_heat+0xf0>)
   12b76:	05c0      	lsls	r0, r0, #23
   12b78:	4798      	blx	r3
   12b7a:	1c01      	adds	r1, r0, #0
   12b7c:	9800      	ldr	r0, [sp, #0]
   12b7e:	47a0      	blx	r4
   12b80:	9000      	str	r0, [sp, #0]
                    (1 / (1 + ((float)dev->calib.res_heat_val * 0.002f)))) -
   12b82:	203d      	movs	r0, #61	; 0x3d
   12b84:	5628      	ldrsb	r0, [r5, r0]
   12b86:	47b8      	blx	r7
   12b88:	4912      	ldr	r1, [pc, #72]	; (12bd4 <calc_res_heat+0xf4>)
   12b8a:	47a0      	blx	r4
   12b8c:	21fe      	movs	r1, #254	; 0xfe
   12b8e:	0589      	lsls	r1, r1, #22
   12b90:	47b0      	blx	r6
   12b92:	1c01      	adds	r1, r0, #0
   12b94:	20fe      	movs	r0, #254	; 0xfe
   12b96:	4b0e      	ldr	r3, [pc, #56]	; (12bd0 <calc_res_heat+0xf0>)
   12b98:	0580      	lsls	r0, r0, #22
   12b9a:	4798      	blx	r3
   12b9c:	1c01      	adds	r1, r0, #0
                  ((var5 * (4 / (4 + (float)dev->calib.res_heat_range)) *
   12b9e:	9800      	ldr	r0, [sp, #0]
   12ba0:	47a0      	blx	r4
                    (1 / (1 + ((float)dev->calib.res_heat_val * 0.002f)))) -
   12ba2:	4b0d      	ldr	r3, [pc, #52]	; (12bd8 <calc_res_heat+0xf8>)
   12ba4:	490d      	ldr	r1, [pc, #52]	; (12bdc <calc_res_heat+0xfc>)
   12ba6:	4798      	blx	r3
        (uint8_t)(3.4f *
   12ba8:	490d      	ldr	r1, [pc, #52]	; (12be0 <calc_res_heat+0x100>)
   12baa:	47a0      	blx	r4
    res_heat =
   12bac:	4b0d      	ldr	r3, [pc, #52]	; (12be4 <calc_res_heat+0x104>)
   12bae:	4798      	blx	r3
                   25));

    return res_heat;
   12bb0:	b2c0      	uxtb	r0, r0
}
   12bb2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   12bb4:	000269f1 	.word	0x000269f1
   12bb8:	00026439 	.word	0x00026439
   12bbc:	3a03126f 	.word	0x3a03126f
   12bc0:	00025d35 	.word	0x00025d35
   12bc4:	3b1a0275 	.word	0x3b1a0275
   12bc8:	00026a91 	.word	0x00026a91
   12bcc:	42440000 	.word	0x42440000
   12bd0:	00026059 	.word	0x00026059
   12bd4:	3b03126f 	.word	0x3b03126f
   12bd8:	00026679 	.word	0x00026679
   12bdc:	41c80000 	.word	0x41c80000
   12be0:	4059999a 	.word	0x4059999a
   12be4:	00025d05 	.word	0x00025d05

00012be8 <null_ptr_check>:
/* This internal API is used to check the bme68x_dev for null pointers */
static int8_t null_ptr_check(const struct bme68x_dev *dev)
{
    int8_t rslt = BME68X_OK;

    if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay__us == NULL))
   12be8:	2800      	cmp	r0, #0
   12bea:	d00a      	beq.n	12c02 <null_ptr_check+0x1a>
   12bec:	6c03      	ldr	r3, [r0, #64]	; 0x40
   12bee:	2b00      	cmp	r3, #0
   12bf0:	d007      	beq.n	12c02 <null_ptr_check+0x1a>
   12bf2:	6c43      	ldr	r3, [r0, #68]	; 0x44
   12bf4:	2b00      	cmp	r3, #0
   12bf6:	d004      	beq.n	12c02 <null_ptr_check+0x1a>
   12bf8:	6c83      	ldr	r3, [r0, #72]	; 0x48
   12bfa:	4258      	negs	r0, r3
   12bfc:	4158      	adcs	r0, r3
    {
        /* Device structure pointer is not valid */
        rslt = BME68X_E_NULL_PTR;
   12bfe:	4240      	negs	r0, r0
    }

    return rslt;
}
   12c00:	4770      	bx	lr
        rslt = BME68X_E_NULL_PTR;
   12c02:	2001      	movs	r0, #1
   12c04:	e7fb      	b.n	12bfe <null_ptr_check+0x16>
	...

00012c08 <set_mem_page>:
{
   12c08:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    rslt = null_ptr_check(dev);
   12c0a:	4b19      	ldr	r3, [pc, #100]	; (12c70 <set_mem_page+0x68>)
{
   12c0c:	0005      	movs	r5, r0
    rslt = null_ptr_check(dev);
   12c0e:	0008      	movs	r0, r1
{
   12c10:	000c      	movs	r4, r1
    rslt = null_ptr_check(dev);
   12c12:	4798      	blx	r3
   12c14:	1e06      	subs	r6, r0, #0
    if (rslt == BME68X_OK)
   12c16:	d116      	bne.n	12c46 <set_mem_page+0x3e>
        if (reg_addr > 0x7f)
   12c18:	b268      	sxtb	r0, r5
            mem_page = BME68X_MEM_PAGE0;
   12c1a:	43c0      	mvns	r0, r0
        if (mem_page != dev->mem_page)
   12c1c:	7b63      	ldrb	r3, [r4, #13]
            mem_page = BME68X_MEM_PAGE0;
   12c1e:	0fc0      	lsrs	r0, r0, #31
   12c20:	0100      	lsls	r0, r0, #4
        if (mem_page != dev->mem_page)
   12c22:	4283      	cmp	r3, r0
   12c24:	d00f      	beq.n	12c46 <set_mem_page+0x3e>
            dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
   12c26:	466b      	mov	r3, sp
   12c28:	1ddd      	adds	r5, r3, #7
            dev->mem_page = mem_page;
   12c2a:	7360      	strb	r0, [r4, #13]
            dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
   12c2c:	6c27      	ldr	r7, [r4, #64]	; 0x40
   12c2e:	6863      	ldr	r3, [r4, #4]
   12c30:	2201      	movs	r2, #1
   12c32:	0029      	movs	r1, r5
   12c34:	20f3      	movs	r0, #243	; 0xf3
   12c36:	47b8      	blx	r7
   12c38:	0027      	movs	r7, r4
   12c3a:	374c      	adds	r7, #76	; 0x4c
   12c3c:	7038      	strb	r0, [r7, #0]
            if (dev->intf_rslt != 0)
   12c3e:	2800      	cmp	r0, #0
   12c40:	d003      	beq.n	12c4a <set_mem_page+0x42>
                    rslt = BME68X_E_COM_FAIL;
   12c42:	2602      	movs	r6, #2
   12c44:	4276      	negs	r6, r6
}
   12c46:	0030      	movs	r0, r6
   12c48:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
   12c4a:	2110      	movs	r1, #16
   12c4c:	7b63      	ldrb	r3, [r4, #13]
                reg = reg & (~BME68X_MEM_PAGE_MSK);
   12c4e:	782a      	ldrb	r2, [r5, #0]
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
   12c50:	400b      	ands	r3, r1
                reg = reg & (~BME68X_MEM_PAGE_MSK);
   12c52:	438a      	bics	r2, r1
                reg = reg | (dev->mem_page & BME68X_MEM_PAGE_MSK);
   12c54:	4313      	orrs	r3, r2
   12c56:	702b      	strb	r3, [r5, #0]
                dev->intf_rslt = dev->write(BME68X_REG_MEM_PAGE & BME68X_SPI_WR_MSK, &reg, 1, dev->intf_ptr);
   12c58:	6c63      	ldr	r3, [r4, #68]	; 0x44
   12c5a:	2201      	movs	r2, #1
   12c5c:	469c      	mov	ip, r3
   12c5e:	0029      	movs	r1, r5
   12c60:	6863      	ldr	r3, [r4, #4]
   12c62:	2073      	movs	r0, #115	; 0x73
   12c64:	4664      	mov	r4, ip
   12c66:	47a0      	blx	r4
   12c68:	7038      	strb	r0, [r7, #0]
                if (dev->intf_rslt != 0)
   12c6a:	2800      	cmp	r0, #0
   12c6c:	d0eb      	beq.n	12c46 <set_mem_page+0x3e>
   12c6e:	e7e8      	b.n	12c42 <set_mem_page+0x3a>
   12c70:	00012be9 	.word	0x00012be9

00012c74 <get_mem_page>:
{
   12c74:	b573      	push	{r0, r1, r4, r5, r6, lr}
    rslt = null_ptr_check(dev);
   12c76:	4b0d      	ldr	r3, [pc, #52]	; (12cac <get_mem_page+0x38>)
{
   12c78:	0004      	movs	r4, r0
    rslt = null_ptr_check(dev);
   12c7a:	4798      	blx	r3
    if (rslt == BME68X_OK)
   12c7c:	2800      	cmp	r0, #0
   12c7e:	d110      	bne.n	12ca2 <get_mem_page+0x2e>
        dev->intf_rslt = dev->read(BME68X_REG_MEM_PAGE | BME68X_SPI_RD_MSK, &reg, 1, dev->intf_ptr);
   12c80:	466b      	mov	r3, sp
   12c82:	1ddd      	adds	r5, r3, #7
   12c84:	2201      	movs	r2, #1
   12c86:	6863      	ldr	r3, [r4, #4]
   12c88:	0029      	movs	r1, r5
   12c8a:	30f3      	adds	r0, #243	; 0xf3
   12c8c:	6c26      	ldr	r6, [r4, #64]	; 0x40
   12c8e:	47b0      	blx	r6
   12c90:	0023      	movs	r3, r4
   12c92:	334c      	adds	r3, #76	; 0x4c
   12c94:	7018      	strb	r0, [r3, #0]
        if (dev->intf_rslt != 0)
   12c96:	2800      	cmp	r0, #0
   12c98:	d104      	bne.n	12ca4 <get_mem_page+0x30>
            dev->mem_page = reg & BME68X_MEM_PAGE_MSK;
   12c9a:	2210      	movs	r2, #16
   12c9c:	782b      	ldrb	r3, [r5, #0]
   12c9e:	4013      	ands	r3, r2
   12ca0:	7363      	strb	r3, [r4, #13]
}
   12ca2:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
            rslt = BME68X_E_COM_FAIL;
   12ca4:	2002      	movs	r0, #2
   12ca6:	4240      	negs	r0, r0
   12ca8:	e7fb      	b.n	12ca2 <get_mem_page+0x2e>
   12caa:	46c0      	nop			; (mov r8, r8)
   12cac:	00012be9 	.word	0x00012be9

00012cb0 <boundary_check>:
{
   12cb0:	b570      	push	{r4, r5, r6, lr}
    rslt = null_ptr_check(dev);
   12cb2:	4b0b      	ldr	r3, [pc, #44]	; (12ce0 <boundary_check+0x30>)
{
   12cb4:	0005      	movs	r5, r0
    rslt = null_ptr_check(dev);
   12cb6:	0010      	movs	r0, r2
{
   12cb8:	000e      	movs	r6, r1
   12cba:	0014      	movs	r4, r2
    rslt = null_ptr_check(dev);
   12cbc:	4798      	blx	r3
    if ((value != NULL) && (rslt == BME68X_OK))
   12cbe:	2d00      	cmp	r5, #0
   12cc0:	d00b      	beq.n	12cda <boundary_check+0x2a>
   12cc2:	2800      	cmp	r0, #0
   12cc4:	d109      	bne.n	12cda <boundary_check+0x2a>
        if (*value > max)
   12cc6:	782b      	ldrb	r3, [r5, #0]
   12cc8:	42b3      	cmp	r3, r6
   12cca:	d905      	bls.n	12cd8 <boundary_check+0x28>
            dev->info_msg |= BME68X_I_PARAM_CORR;
   12ccc:	2301      	movs	r3, #1
            *value = max;
   12cce:	702e      	strb	r6, [r5, #0]
            dev->info_msg |= BME68X_I_PARAM_CORR;
   12cd0:	344d      	adds	r4, #77	; 0x4d
   12cd2:	7822      	ldrb	r2, [r4, #0]
   12cd4:	4313      	orrs	r3, r2
   12cd6:	7023      	strb	r3, [r4, #0]
}
   12cd8:	bd70      	pop	{r4, r5, r6, pc}
        rslt = BME68X_E_NULL_PTR;
   12cda:	2001      	movs	r0, #1
   12cdc:	4240      	negs	r0, r0
   12cde:	e7fb      	b.n	12cd8 <boundary_check+0x28>
   12ce0:	00012be9 	.word	0x00012be9

00012ce4 <bme68x_i2c_read>:

/*!
 * I2C read function map to SAMD21 Platform
 */
BME68X_INTF_RET_TYPE bme68x_i2c_read(uint8_t reg_addr, uint8_t *reg_data, uint32_t len, void *intf_ptr)
{
   12ce4:	b573      	push	{r0, r1, r4, r5, r6, lr}
	uint8_t reg_add;

	Bme680Data.lenIn = len;
   12ce6:	4b0d      	ldr	r3, [pc, #52]	; (12d1c <bme68x_i2c_read+0x38>)
{
   12ce8:	0015      	movs	r5, r2
	Bme680Data.lenIn = len;
   12cea:	819a      	strh	r2, [r3, #12]
	Bme680Data.msgIn = MsgOutBme680;

	reg_add = reg_addr;
   12cec:	466a      	mov	r2, sp
   12cee:	71d0      	strb	r0, [r2, #7]
   12cf0:	3207      	adds	r2, #7
	Bme680Data.msgOut = &reg_add;
   12cf2:	605a      	str	r2, [r3, #4]
	Bme680Data.lenOut = 1;
   12cf4:	2201      	movs	r2, #1
   12cf6:	81da      	strh	r2, [r3, #14]
	Bme680Data.address = BME68X_I2C_ADDR_HIGH;
   12cf8:	3276      	adds	r2, #118	; 0x76
   12cfa:	701a      	strb	r2, [r3, #0]

	I2cReadDataWait(&Bme680Data, 0, 1000);
   12cfc:	22fa      	movs	r2, #250	; 0xfa
{
   12cfe:	000e      	movs	r6, r1
	Bme680Data.msgIn = MsgOutBme680;
   12d00:	4c07      	ldr	r4, [pc, #28]	; (12d20 <bme68x_i2c_read+0x3c>)
	I2cReadDataWait(&Bme680Data, 0, 1000);
   12d02:	0092      	lsls	r2, r2, #2
	Bme680Data.msgIn = MsgOutBme680;
   12d04:	609c      	str	r4, [r3, #8]
	I2cReadDataWait(&Bme680Data, 0, 1000);
   12d06:	2100      	movs	r1, #0
   12d08:	0018      	movs	r0, r3
   12d0a:	4b06      	ldr	r3, [pc, #24]	; (12d24 <bme68x_i2c_read+0x40>)
   12d0c:	4798      	blx	r3
	memcpy(reg_data, MsgOutBme680, len);
   12d0e:	002a      	movs	r2, r5
   12d10:	0030      	movs	r0, r6
   12d12:	0021      	movs	r1, r4
   12d14:	4b04      	ldr	r3, [pc, #16]	; (12d28 <bme68x_i2c_read+0x44>)
   12d16:	4798      	blx	r3
	
	return BME68X_INTF_RET_SUCCESS;
}
   12d18:	2000      	movs	r0, #0
   12d1a:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
   12d1c:	20004260 	.word	0x20004260
   12d20:	20004270 	.word	0x20004270
   12d24:	00014169 	.word	0x00014169
   12d28:	00022c11 	.word	0x00022c11

00012d2c <bme68x_i2c_write>:

/*!
 * I2C write function map to SAMD21 Platform
 */
BME68X_INTF_RET_TYPE bme68x_i2c_write(uint8_t reg_addr, const uint8_t *reg_data, uint32_t len, void *intf_ptr)
{	
   12d2c:	b570      	push	{r4, r5, r6, lr}
	Bme680Data.lenIn = 0;
   12d2e:	2500      	movs	r5, #0
	Bme680Data.lenOut = len+1; // accounting for register write byte as well.
	Bme680Data.msgIn =  MsgOutBme680;
	Bme680Data.msgOut = MsgOutBme680;
	Bme680Data.address = BME68X_I2C_ADDR_HIGH;
   12d30:	2677      	movs	r6, #119	; 0x77
	Bme680Data.lenIn = 0;
   12d32:	4c09      	ldr	r4, [pc, #36]	; (12d58 <bme68x_i2c_write+0x2c>)
	Bme680Data.lenOut = len+1; // accounting for register write byte as well.
   12d34:	1c53      	adds	r3, r2, #1
   12d36:	81e3      	strh	r3, [r4, #14]
	Bme680Data.msgIn =  MsgOutBme680;
   12d38:	4b08      	ldr	r3, [pc, #32]	; (12d5c <bme68x_i2c_write+0x30>)
	Bme680Data.lenIn = 0;
   12d3a:	81a5      	strh	r5, [r4, #12]
	Bme680Data.msgIn =  MsgOutBme680;
   12d3c:	60a3      	str	r3, [r4, #8]
	Bme680Data.msgOut = MsgOutBme680;
   12d3e:	6063      	str	r3, [r4, #4]
	MsgOutBme680[0] = reg_addr;
   12d40:	7018      	strb	r0, [r3, #0]
	
	/* Copying data into buffer starting from 2nd byte */
	memcpy(&MsgOutBme680[1], reg_data, len);
   12d42:	4b07      	ldr	r3, [pc, #28]	; (12d60 <bme68x_i2c_write+0x34>)
   12d44:	4807      	ldr	r0, [pc, #28]	; (12d64 <bme68x_i2c_write+0x38>)
	Bme680Data.address = BME68X_I2C_ADDR_HIGH;
   12d46:	7026      	strb	r6, [r4, #0]
	memcpy(&MsgOutBme680[1], reg_data, len);
   12d48:	4798      	blx	r3
	I2cWriteDataWait(&Bme680Data, 1000);
   12d4a:	21fa      	movs	r1, #250	; 0xfa
   12d4c:	0020      	movs	r0, r4
   12d4e:	0089      	lsls	r1, r1, #2
   12d50:	4b05      	ldr	r3, [pc, #20]	; (12d68 <bme68x_i2c_write+0x3c>)
   12d52:	4798      	blx	r3
	
	return BME68X_INTF_RET_SUCCESS;
}
   12d54:	0028      	movs	r0, r5
   12d56:	bd70      	pop	{r4, r5, r6, pc}
   12d58:	20004260 	.word	0x20004260
   12d5c:	20004270 	.word	0x20004270
   12d60:	00022c11 	.word	0x00022c11
   12d64:	20004271 	.word	0x20004271
   12d68:	00014115 	.word	0x00014115

00012d6c <bme68x_delay__us>:

/*!
 * Delay function map to SAMD21 Platform
 */
void bme68x_delay__us(uint32_t period, void *intf_ptr)
{
   12d6c:	b510      	push	{r4, lr}
    (void)intf_ptr;
	// Best I could do. Can get below 1 ms of delay using Freertos.
	vTaskDelay(pdMS_TO_TICKS((uint32_t) period / 1000.0f));  
   12d6e:	4b07      	ldr	r3, [pc, #28]	; (12d8c <bme68x_delay__us+0x20>)
   12d70:	4798      	blx	r3
   12d72:	4907      	ldr	r1, [pc, #28]	; (12d90 <bme68x_delay__us+0x24>)
   12d74:	4b07      	ldr	r3, [pc, #28]	; (12d94 <bme68x_delay__us+0x28>)
   12d76:	4798      	blx	r3
   12d78:	4b07      	ldr	r3, [pc, #28]	; (12d98 <bme68x_delay__us+0x2c>)
   12d7a:	4798      	blx	r3
   12d7c:	21fa      	movs	r1, #250	; 0xfa
   12d7e:	0089      	lsls	r1, r1, #2
   12d80:	4b06      	ldr	r3, [pc, #24]	; (12d9c <bme68x_delay__us+0x30>)
   12d82:	4348      	muls	r0, r1
   12d84:	4798      	blx	r3
   12d86:	4b06      	ldr	r3, [pc, #24]	; (12da0 <bme68x_delay__us+0x34>)
   12d88:	4798      	blx	r3
}
   12d8a:	bd10      	pop	{r4, pc}
   12d8c:	00026a91 	.word	0x00026a91
   12d90:	447a0000 	.word	0x447a0000
   12d94:	00026059 	.word	0x00026059
   12d98:	00025d05 	.word	0x00025d05
   12d9c:	000258bd 	.word	0x000258bd
   12da0:	000185ad 	.word	0x000185ad

00012da4 <calc_gas_resistance_low.isra.0>:
static float calc_gas_resistance_low(uint16_t gas_res_adc, uint8_t gas_range, const struct bme68x_dev *dev)
   12da4:	b5f0      	push	{r4, r5, r6, r7, lr}
    const float lookup_k1_range[16] = {
   12da6:	2640      	movs	r6, #64	; 0x40
static float calc_gas_resistance_low(uint16_t gas_res_adc, uint8_t gas_range, const struct bme68x_dev *dev)
   12da8:	0007      	movs	r7, r0
    const float lookup_k1_range[16] = {
   12daa:	4c29      	ldr	r4, [pc, #164]	; (12e50 <calc_gas_resistance_low.isra.0+0xac>)
static float calc_gas_resistance_low(uint16_t gas_res_adc, uint8_t gas_range, const struct bme68x_dev *dev)
   12dac:	b0a5      	sub	sp, #148	; 0x94
   12dae:	9101      	str	r1, [sp, #4]
   12db0:	9202      	str	r2, [sp, #8]
    const float lookup_k1_range[16] = {
   12db2:	0021      	movs	r1, r4
   12db4:	0032      	movs	r2, r6
   12db6:	4d27      	ldr	r5, [pc, #156]	; (12e54 <calc_gas_resistance_low.isra.0+0xb0>)
   12db8:	a804      	add	r0, sp, #16
   12dba:	47a8      	blx	r5
    const float lookup_k2_range[16] = {
   12dbc:	0032      	movs	r2, r6
   12dbe:	19a1      	adds	r1, r4, r6
   12dc0:	a814      	add	r0, sp, #80	; 0x50
   12dc2:	47a8      	blx	r5
    float gas_res_f = gas_res_adc;
   12dc4:	4b24      	ldr	r3, [pc, #144]	; (12e58 <calc_gas_resistance_low.isra.0+0xb4>)
   12dc6:	0038      	movs	r0, r7
   12dc8:	4798      	blx	r3
    calc_gas_res = 1.0f / (float)(var3 * (0.000000125f) * gas_range_f * (((gas_res_f - 512.0f) / var2) + 1.0f));
   12dca:	2188      	movs	r1, #136	; 0x88
   12dcc:	4b23      	ldr	r3, [pc, #140]	; (12e5c <calc_gas_resistance_low.isra.0+0xb8>)
   12dce:	05c9      	lsls	r1, r1, #23
   12dd0:	4798      	blx	r3
    var1 = (1340.0f + (5.0f * dev->calib.range_sw_err));
   12dd2:	4b23      	ldr	r3, [pc, #140]	; (12e60 <calc_gas_resistance_low.isra.0+0xbc>)
    calc_gas_res = 1.0f / (float)(var3 * (0.000000125f) * gas_range_f * (((gas_res_f - 512.0f) / var2) + 1.0f));
   12dd4:	9003      	str	r0, [sp, #12]
    var1 = (1340.0f + (5.0f * dev->calib.range_sw_err));
   12dd6:	9802      	ldr	r0, [sp, #8]
   12dd8:	4798      	blx	r3
   12dda:	4c22      	ldr	r4, [pc, #136]	; (12e64 <calc_gas_resistance_low.isra.0+0xc0>)
   12ddc:	4922      	ldr	r1, [pc, #136]	; (12e68 <calc_gas_resistance_low.isra.0+0xc4>)
   12dde:	47a0      	blx	r4
   12de0:	4e22      	ldr	r6, [pc, #136]	; (12e6c <calc_gas_resistance_low.isra.0+0xc8>)
   12de2:	4923      	ldr	r1, [pc, #140]	; (12e70 <calc_gas_resistance_low.isra.0+0xcc>)
   12de4:	47b0      	blx	r6
    var2 = (var1) * (1.0f + lookup_k1_range[gas_range] / 100.0f);
   12de6:	9b01      	ldr	r3, [sp, #4]
   12de8:	4d22      	ldr	r5, [pc, #136]	; (12e74 <calc_gas_resistance_low.isra.0+0xd0>)
   12dea:	009b      	lsls	r3, r3, #2
   12dec:	9302      	str	r3, [sp, #8]
   12dee:	9a02      	ldr	r2, [sp, #8]
   12df0:	ab04      	add	r3, sp, #16
    var1 = (1340.0f + (5.0f * dev->calib.range_sw_err));
   12df2:	1c07      	adds	r7, r0, #0
    var2 = (var1) * (1.0f + lookup_k1_range[gas_range] / 100.0f);
   12df4:	4920      	ldr	r1, [pc, #128]	; (12e78 <calc_gas_resistance_low.isra.0+0xd4>)
   12df6:	58d0      	ldr	r0, [r2, r3]
   12df8:	47a8      	blx	r5
   12dfa:	21fe      	movs	r1, #254	; 0xfe
   12dfc:	0589      	lsls	r1, r1, #22
   12dfe:	47b0      	blx	r6
   12e00:	1c01      	adds	r1, r0, #0
   12e02:	1c38      	adds	r0, r7, #0
   12e04:	47a0      	blx	r4
   12e06:	1c01      	adds	r1, r0, #0
    calc_gas_res = 1.0f / (float)(var3 * (0.000000125f) * gas_range_f * (((gas_res_f - 512.0f) / var2) + 1.0f));
   12e08:	9803      	ldr	r0, [sp, #12]
   12e0a:	47a8      	blx	r5
   12e0c:	21fe      	movs	r1, #254	; 0xfe
   12e0e:	0589      	lsls	r1, r1, #22
   12e10:	47b0      	blx	r6
   12e12:	1c07      	adds	r7, r0, #0
    var3 = 1.0f + (lookup_k2_range[gas_range] / 100.0f);
   12e14:	2040      	movs	r0, #64	; 0x40
   12e16:	9a02      	ldr	r2, [sp, #8]
   12e18:	ab04      	add	r3, sp, #16
   12e1a:	181b      	adds	r3, r3, r0
   12e1c:	5898      	ldr	r0, [r3, r2]
   12e1e:	4916      	ldr	r1, [pc, #88]	; (12e78 <calc_gas_resistance_low.isra.0+0xd4>)
   12e20:	47a8      	blx	r5
   12e22:	21fe      	movs	r1, #254	; 0xfe
   12e24:	0589      	lsls	r1, r1, #22
   12e26:	47b0      	blx	r6
    calc_gas_res = 1.0f / (float)(var3 * (0.000000125f) * gas_range_f * (((gas_res_f - 512.0f) / var2) + 1.0f));
   12e28:	4914      	ldr	r1, [pc, #80]	; (12e7c <calc_gas_resistance_low.isra.0+0xd8>)
   12e2a:	47a0      	blx	r4
   12e2c:	1c06      	adds	r6, r0, #0
    float gas_range_f = (1U << gas_range); /*lint !e790 / Suspicious truncation, integral to float */
   12e2e:	2001      	movs	r0, #1
   12e30:	9b01      	ldr	r3, [sp, #4]
   12e32:	4098      	lsls	r0, r3
   12e34:	4b08      	ldr	r3, [pc, #32]	; (12e58 <calc_gas_resistance_low.isra.0+0xb4>)
   12e36:	4798      	blx	r3
   12e38:	1c01      	adds	r1, r0, #0
    calc_gas_res = 1.0f / (float)(var3 * (0.000000125f) * gas_range_f * (((gas_res_f - 512.0f) / var2) + 1.0f));
   12e3a:	1c30      	adds	r0, r6, #0
   12e3c:	47a0      	blx	r4
   12e3e:	1c01      	adds	r1, r0, #0
   12e40:	1c38      	adds	r0, r7, #0
   12e42:	47a0      	blx	r4
   12e44:	1c01      	adds	r1, r0, #0
   12e46:	20fe      	movs	r0, #254	; 0xfe
   12e48:	0580      	lsls	r0, r0, #22
   12e4a:	47a8      	blx	r5
}
   12e4c:	b025      	add	sp, #148	; 0x94
   12e4e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12e50:	0002874c 	.word	0x0002874c
   12e54:	00022c11 	.word	0x00022c11
   12e58:	00026a91 	.word	0x00026a91
   12e5c:	00026679 	.word	0x00026679
   12e60:	000269f1 	.word	0x000269f1
   12e64:	00026439 	.word	0x00026439
   12e68:	40a00000 	.word	0x40a00000
   12e6c:	00025d35 	.word	0x00025d35
   12e70:	44a78000 	.word	0x44a78000
   12e74:	00026059 	.word	0x00026059
   12e78:	42c80000 	.word	0x42c80000
   12e7c:	340637bd 	.word	0x340637bd

00012e80 <bme68x_set_regs>:
{
   12e80:	b5f0      	push	{r4, r5, r6, r7, lr}
   12e82:	001d      	movs	r5, r3
   12e84:	b089      	sub	sp, #36	; 0x24
   12e86:	9101      	str	r1, [sp, #4]
    uint8_t tmp_buff[BME68X_LEN_INTERLEAVE_BUFF] = { 0 };
   12e88:	4b24      	ldr	r3, [pc, #144]	; (12f1c <bme68x_set_regs+0x9c>)
{
   12e8a:	0006      	movs	r6, r0
   12e8c:	0017      	movs	r7, r2
    uint8_t tmp_buff[BME68X_LEN_INTERLEAVE_BUFF] = { 0 };
   12e8e:	2100      	movs	r1, #0
   12e90:	2214      	movs	r2, #20
   12e92:	a803      	add	r0, sp, #12
   12e94:	4798      	blx	r3
    rslt = null_ptr_check(dev);
   12e96:	0028      	movs	r0, r5
   12e98:	4b21      	ldr	r3, [pc, #132]	; (12f20 <bme68x_set_regs+0xa0>)
   12e9a:	4798      	blx	r3
    if ((rslt == BME68X_OK) && reg_addr && reg_data)
   12e9c:	2800      	cmp	r0, #0
   12e9e:	d13b      	bne.n	12f18 <bme68x_set_regs+0x98>
   12ea0:	2e00      	cmp	r6, #0
   12ea2:	d039      	beq.n	12f18 <bme68x_set_regs+0x98>
   12ea4:	9b01      	ldr	r3, [sp, #4]
   12ea6:	2b00      	cmp	r3, #0
   12ea8:	d036      	beq.n	12f18 <bme68x_set_regs+0x98>
        if ((len > 0) && (len <= (BME68X_LEN_INTERLEAVE_BUFF / 2)))
   12eaa:	1e7b      	subs	r3, r7, #1
   12eac:	0004      	movs	r4, r0
   12eae:	2b09      	cmp	r3, #9
   12eb0:	d918      	bls.n	12ee4 <bme68x_set_regs+0x64>
            rslt = BME68X_E_INVALID_LENGTH;
   12eb2:	2004      	movs	r0, #4
   12eb4:	e028      	b.n	12f08 <bme68x_set_regs+0x88>
                if (dev->intf == BME68X_SPI_INTF)
   12eb6:	7b2b      	ldrb	r3, [r5, #12]
   12eb8:	2b00      	cmp	r3, #0
   12eba:	d128      	bne.n	12f0e <bme68x_set_regs+0x8e>
                    rslt = set_mem_page(reg_addr[index], dev);
   12ebc:	1933      	adds	r3, r6, r4
   12ebe:	7818      	ldrb	r0, [r3, #0]
   12ec0:	0029      	movs	r1, r5
   12ec2:	4b18      	ldr	r3, [pc, #96]	; (12f24 <bme68x_set_regs+0xa4>)
   12ec4:	4798      	blx	r3
                    tmp_buff[(2 * index)] = reg_addr[index] & BME68X_SPI_WR_MSK;
   12ec6:	217f      	movs	r1, #127	; 0x7f
   12ec8:	1932      	adds	r2, r6, r4
   12eca:	7812      	ldrb	r2, [r2, #0]
   12ecc:	0063      	lsls	r3, r4, #1
   12ece:	400a      	ands	r2, r1
   12ed0:	a903      	add	r1, sp, #12
   12ed2:	545a      	strb	r2, [r3, r1]
                tmp_buff[(2 * index) + 1] = reg_data[index];
   12ed4:	0063      	lsls	r3, r4, #1
   12ed6:	aa03      	add	r2, sp, #12
   12ed8:	18d3      	adds	r3, r2, r3
   12eda:	9a01      	ldr	r2, [sp, #4]
   12edc:	5d12      	ldrb	r2, [r2, r4]
            for (index = 0; index < len; index++)
   12ede:	3401      	adds	r4, #1
                tmp_buff[(2 * index) + 1] = reg_data[index];
   12ee0:	705a      	strb	r2, [r3, #1]
            for (index = 0; index < len; index++)
   12ee2:	b2a4      	uxth	r4, r4
   12ee4:	42a7      	cmp	r7, r4
   12ee6:	d8e6      	bhi.n	12eb6 <bme68x_set_regs+0x36>
            if (rslt == BME68X_OK)
   12ee8:	2800      	cmp	r0, #0
   12eea:	d10e      	bne.n	12f0a <bme68x_set_regs+0x8a>
                dev->intf_rslt = dev->write(tmp_buff[0], &tmp_buff[1], (2 * len) - 1, dev->intf_ptr);
   12eec:	ab02      	add	r3, sp, #8
   12eee:	007a      	lsls	r2, r7, #1
   12ef0:	a902      	add	r1, sp, #8
   12ef2:	7918      	ldrb	r0, [r3, #4]
   12ef4:	6c6c      	ldr	r4, [r5, #68]	; 0x44
   12ef6:	686b      	ldr	r3, [r5, #4]
   12ef8:	3a01      	subs	r2, #1
   12efa:	3105      	adds	r1, #5
   12efc:	47a0      	blx	r4
   12efe:	354c      	adds	r5, #76	; 0x4c
   12f00:	7028      	strb	r0, [r5, #0]
                if (dev->intf_rslt != 0)
   12f02:	2800      	cmp	r0, #0
   12f04:	d001      	beq.n	12f0a <bme68x_set_regs+0x8a>
                    rslt = BME68X_E_COM_FAIL;
   12f06:	2002      	movs	r0, #2
            rslt = BME68X_E_INVALID_LENGTH;
   12f08:	4240      	negs	r0, r0
}
   12f0a:	b009      	add	sp, #36	; 0x24
   12f0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
                    tmp_buff[(2 * index)] = reg_addr[index];
   12f0e:	5d31      	ldrb	r1, [r6, r4]
   12f10:	0063      	lsls	r3, r4, #1
   12f12:	aa03      	add	r2, sp, #12
   12f14:	5499      	strb	r1, [r3, r2]
   12f16:	e7dd      	b.n	12ed4 <bme68x_set_regs+0x54>
        rslt = BME68X_E_NULL_PTR;
   12f18:	2001      	movs	r0, #1
   12f1a:	e7f5      	b.n	12f08 <bme68x_set_regs+0x88>
   12f1c:	00022c47 	.word	0x00022c47
   12f20:	00012be9 	.word	0x00012be9
   12f24:	00012c09 	.word	0x00012c09

00012f28 <bme68x_get_regs>:
{
   12f28:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   12f2a:	0006      	movs	r6, r0
   12f2c:	001c      	movs	r4, r3
    rslt = null_ptr_check(dev);
   12f2e:	0018      	movs	r0, r3
   12f30:	4b11      	ldr	r3, [pc, #68]	; (12f78 <bme68x_get_regs+0x50>)
{
   12f32:	000f      	movs	r7, r1
   12f34:	9201      	str	r2, [sp, #4]
    rslt = null_ptr_check(dev);
   12f36:	4798      	blx	r3
   12f38:	1e05      	subs	r5, r0, #0
    if ((rslt == BME68X_OK) && reg_data)
   12f3a:	d11a      	bne.n	12f72 <bme68x_get_regs+0x4a>
   12f3c:	2f00      	cmp	r7, #0
   12f3e:	d018      	beq.n	12f72 <bme68x_get_regs+0x4a>
        if (dev->intf == BME68X_SPI_INTF)
   12f40:	7b23      	ldrb	r3, [r4, #12]
   12f42:	2b00      	cmp	r3, #0
   12f44:	d107      	bne.n	12f56 <bme68x_get_regs+0x2e>
            rslt = set_mem_page(reg_addr, dev);
   12f46:	0021      	movs	r1, r4
   12f48:	0030      	movs	r0, r6
   12f4a:	4b0c      	ldr	r3, [pc, #48]	; (12f7c <bme68x_get_regs+0x54>)
   12f4c:	4798      	blx	r3
   12f4e:	1e05      	subs	r5, r0, #0
            if (rslt == BME68X_OK)
   12f50:	d101      	bne.n	12f56 <bme68x_get_regs+0x2e>
                reg_addr = reg_addr | BME68X_SPI_RD_MSK;
   12f52:	2380      	movs	r3, #128	; 0x80
   12f54:	431e      	orrs	r6, r3
        dev->intf_rslt = dev->read(reg_addr, reg_data, len, dev->intf_ptr);
   12f56:	6863      	ldr	r3, [r4, #4]
   12f58:	0030      	movs	r0, r6
   12f5a:	9a01      	ldr	r2, [sp, #4]
   12f5c:	6c26      	ldr	r6, [r4, #64]	; 0x40
   12f5e:	0039      	movs	r1, r7
   12f60:	47b0      	blx	r6
   12f62:	344c      	adds	r4, #76	; 0x4c
   12f64:	7020      	strb	r0, [r4, #0]
        if (dev->intf_rslt != 0)
   12f66:	2800      	cmp	r0, #0
   12f68:	d001      	beq.n	12f6e <bme68x_get_regs+0x46>
            rslt = BME68X_E_COM_FAIL;
   12f6a:	2502      	movs	r5, #2
        rslt = BME68X_E_NULL_PTR;
   12f6c:	426d      	negs	r5, r5
}
   12f6e:	0028      	movs	r0, r5
   12f70:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        rslt = BME68X_E_NULL_PTR;
   12f72:	2501      	movs	r5, #1
   12f74:	e7fa      	b.n	12f6c <bme68x_get_regs+0x44>
   12f76:	46c0      	nop			; (mov r8, r8)
   12f78:	00012be9 	.word	0x00012be9
   12f7c:	00012c09 	.word	0x00012c09

00012f80 <bme68x_soft_reset>:
{
   12f80:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    uint8_t reg_addr = BME68X_REG_SOFT_RESET;
   12f82:	466b      	mov	r3, sp
   12f84:	1d9e      	adds	r6, r3, #6
   12f86:	23e0      	movs	r3, #224	; 0xe0
   12f88:	7033      	strb	r3, [r6, #0]
    uint8_t soft_rst_cmd = BME68X_SOFT_RESET_CMD;
   12f8a:	466b      	mov	r3, sp
   12f8c:	1ddf      	adds	r7, r3, #7
   12f8e:	23b6      	movs	r3, #182	; 0xb6
   12f90:	703b      	strb	r3, [r7, #0]
    rslt = null_ptr_check(dev);
   12f92:	4b11      	ldr	r3, [pc, #68]	; (12fd8 <bme68x_soft_reset+0x58>)
{
   12f94:	0004      	movs	r4, r0
    rslt = null_ptr_check(dev);
   12f96:	4798      	blx	r3
   12f98:	1e05      	subs	r5, r0, #0
    if (rslt == BME68X_OK)
   12f9a:	d11b      	bne.n	12fd4 <bme68x_soft_reset+0x54>
        if (dev->intf == BME68X_SPI_INTF)
   12f9c:	7b23      	ldrb	r3, [r4, #12]
   12f9e:	2b00      	cmp	r3, #0
   12fa0:	d013      	beq.n	12fca <bme68x_soft_reset+0x4a>
            rslt = bme68x_set_regs(&reg_addr, &soft_rst_cmd, 1, dev);
   12fa2:	4d0e      	ldr	r5, [pc, #56]	; (12fdc <bme68x_soft_reset+0x5c>)
   12fa4:	0023      	movs	r3, r4
   12fa6:	2201      	movs	r2, #1
   12fa8:	0039      	movs	r1, r7
   12faa:	0030      	movs	r0, r6
   12fac:	47a8      	blx	r5
   12fae:	1e05      	subs	r5, r0, #0
            if (rslt == BME68X_OK)
   12fb0:	d110      	bne.n	12fd4 <bme68x_soft_reset+0x54>
                dev->delay__us(BME68X_PERIOD_RESET, dev->intf_ptr);
   12fb2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   12fb4:	6861      	ldr	r1, [r4, #4]
   12fb6:	480a      	ldr	r0, [pc, #40]	; (12fe0 <bme68x_soft_reset+0x60>)
   12fb8:	4798      	blx	r3
                if (dev->intf == BME68X_SPI_INTF)
   12fba:	7b23      	ldrb	r3, [r4, #12]
   12fbc:	2b00      	cmp	r3, #0
   12fbe:	d109      	bne.n	12fd4 <bme68x_soft_reset+0x54>
                    rslt = get_mem_page(dev);
   12fc0:	0020      	movs	r0, r4
   12fc2:	4b08      	ldr	r3, [pc, #32]	; (12fe4 <bme68x_soft_reset+0x64>)
   12fc4:	4798      	blx	r3
   12fc6:	0005      	movs	r5, r0
   12fc8:	e004      	b.n	12fd4 <bme68x_soft_reset+0x54>
            rslt = get_mem_page(dev);
   12fca:	0020      	movs	r0, r4
   12fcc:	4b05      	ldr	r3, [pc, #20]	; (12fe4 <bme68x_soft_reset+0x64>)
   12fce:	4798      	blx	r3
   12fd0:	1e05      	subs	r5, r0, #0
        if (rslt == BME68X_OK)
   12fd2:	d0e6      	beq.n	12fa2 <bme68x_soft_reset+0x22>
}
   12fd4:	0028      	movs	r0, r5
   12fd6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   12fd8:	00012be9 	.word	0x00012be9
   12fdc:	00012e81 	.word	0x00012e81
   12fe0:	00002710 	.word	0x00002710
   12fe4:	00012c75 	.word	0x00012c75

00012fe8 <bme68x_init>:
{
   12fe8:	b5f0      	push	{r4, r5, r6, r7, lr}
   12fea:	0004      	movs	r4, r0
   12fec:	b08d      	sub	sp, #52	; 0x34
    (void) bme68x_soft_reset(dev);
   12fee:	4b57      	ldr	r3, [pc, #348]	; (1314c <bme68x_init+0x164>)
   12ff0:	4798      	blx	r3
    rslt = bme68x_get_regs(BME68X_REG_CHIP_ID, &dev->chip_id, 1, dev);
   12ff2:	0023      	movs	r3, r4
   12ff4:	2201      	movs	r2, #1
   12ff6:	0021      	movs	r1, r4
   12ff8:	20d0      	movs	r0, #208	; 0xd0
   12ffa:	4f55      	ldr	r7, [pc, #340]	; (13150 <bme68x_init+0x168>)
   12ffc:	47b8      	blx	r7
   12ffe:	1e06      	subs	r6, r0, #0
    if (rslt == BME68X_OK)
   13000:	d000      	beq.n	13004 <bme68x_init+0x1c>
   13002:	e09c      	b.n	1313e <bme68x_init+0x156>
        if (dev->chip_id == BME68X_CHIP_ID)
   13004:	7823      	ldrb	r3, [r4, #0]
   13006:	2b61      	cmp	r3, #97	; 0x61
   13008:	d000      	beq.n	1300c <bme68x_init+0x24>
   1300a:	e09b      	b.n	13144 <bme68x_init+0x15c>
    uint8_t reg_data = 0;
   1300c:	ad01      	add	r5, sp, #4
   1300e:	7028      	strb	r0, [r5, #0]
    rslt = bme68x_get_regs(BME68X_REG_VARIANT_ID, &reg_data, 1, dev);
   13010:	0023      	movs	r3, r4
   13012:	2201      	movs	r2, #1
   13014:	0029      	movs	r1, r5
   13016:	20f0      	movs	r0, #240	; 0xf0
   13018:	47b8      	blx	r7
    if (rslt == BME68X_OK)
   1301a:	2800      	cmp	r0, #0
   1301c:	d000      	beq.n	13020 <bme68x_init+0x38>
   1301e:	e08e      	b.n	1313e <bme68x_init+0x156>
        dev->variant_id = reg_data;
   13020:	782b      	ldrb	r3, [r5, #0]
    rslt = bme68x_get_regs(BME68X_REG_COEFF1, coeff_array, BME68X_LEN_COEFF1, dev);
   13022:	2217      	movs	r2, #23
        dev->variant_id = reg_data;
   13024:	60a3      	str	r3, [r4, #8]
    rslt = bme68x_get_regs(BME68X_REG_COEFF1, coeff_array, BME68X_LEN_COEFF1, dev);
   13026:	0029      	movs	r1, r5
   13028:	0023      	movs	r3, r4
   1302a:	308a      	adds	r0, #138	; 0x8a
   1302c:	47b8      	blx	r7
    if (rslt == BME68X_OK)
   1302e:	2800      	cmp	r0, #0
   13030:	d000      	beq.n	13034 <bme68x_init+0x4c>
   13032:	e083      	b.n	1313c <bme68x_init+0x154>
        rslt = bme68x_get_regs(BME68X_REG_COEFF2, &coeff_array[BME68X_LEN_COEFF1], BME68X_LEN_COEFF2, dev);
   13034:	211b      	movs	r1, #27
   13036:	0023      	movs	r3, r4
   13038:	220e      	movs	r2, #14
   1303a:	4469      	add	r1, sp
   1303c:	30e1      	adds	r0, #225	; 0xe1
   1303e:	47b8      	blx	r7
    if (rslt == BME68X_OK)
   13040:	2800      	cmp	r0, #0
   13042:	d17b      	bne.n	1313c <bme68x_init+0x154>
        rslt = bme68x_get_regs(BME68X_REG_COEFF3,
   13044:	2129      	movs	r1, #41	; 0x29
   13046:	0023      	movs	r3, r4
   13048:	2205      	movs	r2, #5
   1304a:	4469      	add	r1, sp
   1304c:	47b8      	blx	r7
    if (rslt == BME68X_OK)
   1304e:	2800      	cmp	r0, #0
   13050:	d174      	bne.n	1313c <bme68x_init+0x154>
            (uint16_t)(BME68X_CONCAT_BYTES(coeff_array[BME68X_IDX_T1_MSB], coeff_array[BME68X_IDX_T1_LSB]));
   13052:	466b      	mov	r3, sp
   13054:	3305      	adds	r3, #5
   13056:	7fda      	ldrb	r2, [r3, #31]
   13058:	7feb      	ldrb	r3, [r5, #31]
   1305a:	0212      	lsls	r2, r2, #8
   1305c:	4313      	orrs	r3, r2
        dev->calib.par_t1 =
   1305e:	83e3      	strh	r3, [r4, #30]
            (int16_t)(BME68X_CONCAT_BYTES(coeff_array[BME68X_IDX_T2_MSB], coeff_array[BME68X_IDX_T2_LSB]));
   13060:	786a      	ldrb	r2, [r5, #1]
   13062:	782b      	ldrb	r3, [r5, #0]
   13064:	0212      	lsls	r2, r2, #8
   13066:	4313      	orrs	r3, r2
        dev->calib.par_t2 =
   13068:	8423      	strh	r3, [r4, #32]
        dev->calib.par_t3 = (int8_t)(coeff_array[BME68X_IDX_T3]);
   1306a:	78aa      	ldrb	r2, [r5, #2]
   1306c:	1ce3      	adds	r3, r4, #3
   1306e:	77da      	strb	r2, [r3, #31]
            (uint16_t)(BME68X_CONCAT_BYTES(coeff_array[BME68X_IDX_P1_MSB], coeff_array[BME68X_IDX_P1_LSB]));
   13070:	796a      	ldrb	r2, [r5, #5]
   13072:	792b      	ldrb	r3, [r5, #4]
   13074:	0212      	lsls	r2, r2, #8
   13076:	4313      	orrs	r3, r2
        dev->calib.par_p1 =
   13078:	84a3      	strh	r3, [r4, #36]	; 0x24
            (int16_t)(BME68X_CONCAT_BYTES(coeff_array[BME68X_IDX_P2_MSB], coeff_array[BME68X_IDX_P2_LSB]));
   1307a:	79ea      	ldrb	r2, [r5, #7]
   1307c:	79ab      	ldrb	r3, [r5, #6]
   1307e:	0212      	lsls	r2, r2, #8
   13080:	4313      	orrs	r3, r2
        dev->calib.par_p2 =
   13082:	84e3      	strh	r3, [r4, #38]	; 0x26
        dev->calib.par_p3 = (int8_t)coeff_array[BME68X_IDX_P3];
   13084:	0023      	movs	r3, r4
   13086:	7a2a      	ldrb	r2, [r5, #8]
   13088:	3328      	adds	r3, #40	; 0x28
   1308a:	701a      	strb	r2, [r3, #0]
            (int16_t)(BME68X_CONCAT_BYTES(coeff_array[BME68X_IDX_P4_MSB], coeff_array[BME68X_IDX_P4_LSB]));
   1308c:	7aea      	ldrb	r2, [r5, #11]
   1308e:	7aab      	ldrb	r3, [r5, #10]
   13090:	0212      	lsls	r2, r2, #8
   13092:	4313      	orrs	r3, r2
        dev->calib.par_p4 =
   13094:	8563      	strh	r3, [r4, #42]	; 0x2a
            (int16_t)(BME68X_CONCAT_BYTES(coeff_array[BME68X_IDX_P5_MSB], coeff_array[BME68X_IDX_P5_LSB]));
   13096:	7b6a      	ldrb	r2, [r5, #13]
   13098:	7b2b      	ldrb	r3, [r5, #12]
   1309a:	0212      	lsls	r2, r2, #8
   1309c:	4313      	orrs	r3, r2
        dev->calib.par_p5 =
   1309e:	85a3      	strh	r3, [r4, #44]	; 0x2c
        dev->calib.par_p6 = (int8_t)(coeff_array[BME68X_IDX_P6]);
   130a0:	0023      	movs	r3, r4
   130a2:	7bea      	ldrb	r2, [r5, #15]
   130a4:	332e      	adds	r3, #46	; 0x2e
   130a6:	701a      	strb	r2, [r3, #0]
        dev->calib.par_p7 = (int8_t)(coeff_array[BME68X_IDX_P7]);
   130a8:	7baa      	ldrb	r2, [r5, #14]
   130aa:	705a      	strb	r2, [r3, #1]
            (int16_t)(BME68X_CONCAT_BYTES(coeff_array[BME68X_IDX_P8_MSB], coeff_array[BME68X_IDX_P8_LSB]));
   130ac:	7cea      	ldrb	r2, [r5, #19]
   130ae:	7cab      	ldrb	r3, [r5, #18]
   130b0:	0212      	lsls	r2, r2, #8
   130b2:	4313      	orrs	r3, r2
        dev->calib.par_p8 =
   130b4:	8623      	strh	r3, [r4, #48]	; 0x30
            (int16_t)(BME68X_CONCAT_BYTES(coeff_array[BME68X_IDX_P9_MSB], coeff_array[BME68X_IDX_P9_LSB]));
   130b6:	7d6a      	ldrb	r2, [r5, #21]
   130b8:	7d2b      	ldrb	r3, [r5, #20]
   130ba:	0212      	lsls	r2, r2, #8
   130bc:	4313      	orrs	r3, r2
        dev->calib.par_p9 =
   130be:	8663      	strh	r3, [r4, #50]	; 0x32
        dev->calib.par_p10 = (uint8_t)(coeff_array[BME68X_IDX_P10]);
   130c0:	0023      	movs	r3, r4
   130c2:	7daa      	ldrb	r2, [r5, #22]
   130c4:	3334      	adds	r3, #52	; 0x34
   130c6:	701a      	strb	r2, [r3, #0]
                       (coeff_array[BME68X_IDX_H1_LSB] & BME68X_BIT_H1_DATA_MSK));
   130c8:	220f      	movs	r2, #15
   130ca:	7e2b      	ldrb	r3, [r5, #24]
            (uint16_t)(((uint16_t)coeff_array[BME68X_IDX_H1_MSB] << 4) |
   130cc:	7e69      	ldrb	r1, [r5, #25]
                       (coeff_array[BME68X_IDX_H1_LSB] & BME68X_BIT_H1_DATA_MSK));
   130ce:	401a      	ands	r2, r3
            (uint16_t)(((uint16_t)coeff_array[BME68X_IDX_H1_MSB] << 4) |
   130d0:	0109      	lsls	r1, r1, #4
   130d2:	430a      	orrs	r2, r1
        dev->calib.par_h1 =
   130d4:	8222      	strh	r2, [r4, #16]
            (uint16_t)(((uint16_t)coeff_array[BME68X_IDX_H2_MSB] << 4) | ((coeff_array[BME68X_IDX_H2_LSB]) >> 4));
   130d6:	7dea      	ldrb	r2, [r5, #23]
   130d8:	091b      	lsrs	r3, r3, #4
   130da:	0112      	lsls	r2, r2, #4
   130dc:	4313      	orrs	r3, r2
        dev->calib.par_h2 =
   130de:	8263      	strh	r3, [r4, #18]
        dev->calib.par_h3 = (int8_t)coeff_array[BME68X_IDX_H3];
   130e0:	7eab      	ldrb	r3, [r5, #26]
   130e2:	7523      	strb	r3, [r4, #20]
        dev->calib.par_h4 = (int8_t)coeff_array[BME68X_IDX_H4];
   130e4:	7eeb      	ldrb	r3, [r5, #27]
   130e6:	7563      	strb	r3, [r4, #21]
        dev->calib.par_h5 = (int8_t)coeff_array[BME68X_IDX_H5];
   130e8:	7f2b      	ldrb	r3, [r5, #28]
   130ea:	75a3      	strb	r3, [r4, #22]
        dev->calib.par_h6 = (uint8_t)coeff_array[BME68X_IDX_H6];
   130ec:	7f6b      	ldrb	r3, [r5, #29]
   130ee:	75e3      	strb	r3, [r4, #23]
        dev->calib.par_h7 = (int8_t)coeff_array[BME68X_IDX_H7];
   130f0:	7fab      	ldrb	r3, [r5, #30]
   130f2:	7623      	strb	r3, [r4, #24]
        dev->calib.par_gh1 = (int8_t)coeff_array[BME68X_IDX_GH1];
   130f4:	ab02      	add	r3, sp, #8
   130f6:	7fdb      	ldrb	r3, [r3, #31]
   130f8:	7663      	strb	r3, [r4, #25]
            (int16_t)(BME68X_CONCAT_BYTES(coeff_array[BME68X_IDX_GH2_MSB], coeff_array[BME68X_IDX_GH2_LSB]));
   130fa:	466b      	mov	r3, sp
   130fc:	3307      	adds	r3, #7
   130fe:	7fda      	ldrb	r2, [r3, #31]
   13100:	466b      	mov	r3, sp
   13102:	3306      	adds	r3, #6
   13104:	7fdb      	ldrb	r3, [r3, #31]
   13106:	0212      	lsls	r2, r2, #8
   13108:	4313      	orrs	r3, r2
        dev->calib.par_gh2 =
   1310a:	8363      	strh	r3, [r4, #26]
        dev->calib.par_gh3 = (int8_t)coeff_array[BME68X_IDX_GH3];
   1310c:	2309      	movs	r3, #9
        dev->calib.res_heat_range = ((coeff_array[BME68X_IDX_RES_HEAT_RANGE] & BME68X_RHRANGE_MSK) / 16);
   1310e:	0022      	movs	r2, r4
        dev->calib.par_gh3 = (int8_t)coeff_array[BME68X_IDX_GH3];
   13110:	446b      	add	r3, sp
   13112:	7fdb      	ldrb	r3, [r3, #31]
        dev->calib.res_heat_range = ((coeff_array[BME68X_IDX_RES_HEAT_RANGE] & BME68X_RHRANGE_MSK) / 16);
   13114:	323c      	adds	r2, #60	; 0x3c
        dev->calib.par_gh3 = (int8_t)coeff_array[BME68X_IDX_GH3];
   13116:	7723      	strb	r3, [r4, #28]
        dev->calib.res_heat_range = ((coeff_array[BME68X_IDX_RES_HEAT_RANGE] & BME68X_RHRANGE_MSK) / 16);
   13118:	ab03      	add	r3, sp, #12
   1311a:	7fdb      	ldrb	r3, [r3, #31]
   1311c:	069b      	lsls	r3, r3, #26
   1311e:	0f9b      	lsrs	r3, r3, #30
   13120:	7013      	strb	r3, [r2, #0]
        dev->calib.res_heat_val = (int8_t)coeff_array[BME68X_IDX_RES_HEAT_VAL];
   13122:	220a      	movs	r2, #10
   13124:	0023      	movs	r3, r4
   13126:	446a      	add	r2, sp
   13128:	7fd2      	ldrb	r2, [r2, #31]
   1312a:	333d      	adds	r3, #61	; 0x3d
   1312c:	701a      	strb	r2, [r3, #0]
        dev->calib.range_sw_err = ((int8_t)(coeff_array[BME68X_IDX_RANGE_SW_ERR] & BME68X_RSERROR_MSK)) / 16;
   1312e:	232d      	movs	r3, #45	; 0x2d
   13130:	446b      	add	r3, sp
   13132:	781b      	ldrb	r3, [r3, #0]
   13134:	343e      	adds	r4, #62	; 0x3e
   13136:	b25b      	sxtb	r3, r3
   13138:	111b      	asrs	r3, r3, #4
   1313a:	7023      	strb	r3, [r4, #0]
   1313c:	2600      	movs	r6, #0
}
   1313e:	0030      	movs	r0, r6
   13140:	b00d      	add	sp, #52	; 0x34
   13142:	bdf0      	pop	{r4, r5, r6, r7, pc}
            rslt = BME68X_E_DEV_NOT_FOUND;
   13144:	2603      	movs	r6, #3
   13146:	4276      	negs	r6, r6
   13148:	e7f9      	b.n	1313e <bme68x_init+0x156>
   1314a:	46c0      	nop			; (mov r8, r8)
   1314c:	00012f81 	.word	0x00012f81
   13150:	00012f29 	.word	0x00012f29

00013154 <bme68x_set_op_mode>:
    uint8_t reg_addr = BME68X_REG_CTRL_MEAS;
   13154:	2374      	movs	r3, #116	; 0x74
{
   13156:	b5f0      	push	{r4, r5, r6, r7, lr}
   13158:	000e      	movs	r6, r1
            pow_mode = (tmp_pow_mode & BME68X_MODE_MSK);
   1315a:	2703      	movs	r7, #3
{
   1315c:	b085      	sub	sp, #20
    uint8_t reg_addr = BME68X_REG_CTRL_MEAS;
   1315e:	aa02      	add	r2, sp, #8
{
   13160:	9001      	str	r0, [sp, #4]
    uint8_t reg_addr = BME68X_REG_CTRL_MEAS;
   13162:	71d3      	strb	r3, [r2, #7]
        rslt = bme68x_get_regs(BME68X_REG_CTRL_MEAS, &tmp_pow_mode, 1, dev);
   13164:	ab02      	add	r3, sp, #8
   13166:	1d9c      	adds	r4, r3, #6
   13168:	4d17      	ldr	r5, [pc, #92]	; (131c8 <bme68x_set_op_mode+0x74>)
   1316a:	0033      	movs	r3, r6
   1316c:	2201      	movs	r2, #1
   1316e:	0021      	movs	r1, r4
   13170:	2074      	movs	r0, #116	; 0x74
   13172:	47a8      	blx	r5
   13174:	1e05      	subs	r5, r0, #0
        if (rslt == BME68X_OK)
   13176:	d112      	bne.n	1319e <bme68x_set_op_mode+0x4a>
            pow_mode = (tmp_pow_mode & BME68X_MODE_MSK);
   13178:	7823      	ldrb	r3, [r4, #0]
            if (pow_mode != BME68X_SLEEP_MODE)
   1317a:	423b      	tst	r3, r7
   1317c:	d012      	beq.n	131a4 <bme68x_set_op_mode+0x50>
                tmp_pow_mode &= ~BME68X_MODE_MSK; /* Set to sleep */
   1317e:	43bb      	bics	r3, r7
                rslt = bme68x_set_regs(&reg_addr, &tmp_pow_mode, 1, dev);
   13180:	a802      	add	r0, sp, #8
                tmp_pow_mode &= ~BME68X_MODE_MSK; /* Set to sleep */
   13182:	7023      	strb	r3, [r4, #0]
                rslt = bme68x_set_regs(&reg_addr, &tmp_pow_mode, 1, dev);
   13184:	0021      	movs	r1, r4
   13186:	0033      	movs	r3, r6
   13188:	2201      	movs	r2, #1
   1318a:	3007      	adds	r0, #7
   1318c:	4c0f      	ldr	r4, [pc, #60]	; (131cc <bme68x_set_op_mode+0x78>)
   1318e:	47a0      	blx	r4
                dev->delay__us(BME68X_PERIOD_POLL, dev->intf_ptr);
   13190:	6871      	ldr	r1, [r6, #4]
                rslt = bme68x_set_regs(&reg_addr, &tmp_pow_mode, 1, dev);
   13192:	0005      	movs	r5, r0
                dev->delay__us(BME68X_PERIOD_POLL, dev->intf_ptr);
   13194:	6cb3      	ldr	r3, [r6, #72]	; 0x48
   13196:	480e      	ldr	r0, [pc, #56]	; (131d0 <bme68x_set_op_mode+0x7c>)
   13198:	4798      	blx	r3
    } while ((pow_mode != BME68X_SLEEP_MODE) && (rslt == BME68X_OK));
   1319a:	2d00      	cmp	r5, #0
   1319c:	d0e2      	beq.n	13164 <bme68x_set_op_mode+0x10>
}
   1319e:	0028      	movs	r0, r5
   131a0:	b005      	add	sp, #20
   131a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if ((op_mode != BME68X_SLEEP_MODE) && (rslt == BME68X_OK))
   131a4:	9a01      	ldr	r2, [sp, #4]
   131a6:	2a00      	cmp	r2, #0
   131a8:	d0f9      	beq.n	1319e <bme68x_set_op_mode+0x4a>
        tmp_pow_mode = (tmp_pow_mode & ~BME68X_MODE_MSK) | (op_mode & BME68X_MODE_MSK);
   131aa:	9a01      	ldr	r2, [sp, #4]
   131ac:	43bb      	bics	r3, r7
   131ae:	403a      	ands	r2, r7
   131b0:	4313      	orrs	r3, r2
        rslt = bme68x_set_regs(&reg_addr, &tmp_pow_mode, 1, dev);
   131b2:	a802      	add	r0, sp, #8
        tmp_pow_mode = (tmp_pow_mode & ~BME68X_MODE_MSK) | (op_mode & BME68X_MODE_MSK);
   131b4:	7023      	strb	r3, [r4, #0]
        rslt = bme68x_set_regs(&reg_addr, &tmp_pow_mode, 1, dev);
   131b6:	0021      	movs	r1, r4
   131b8:	0033      	movs	r3, r6
   131ba:	2201      	movs	r2, #1
   131bc:	3007      	adds	r0, #7
   131be:	4c03      	ldr	r4, [pc, #12]	; (131cc <bme68x_set_op_mode+0x78>)
   131c0:	47a0      	blx	r4
   131c2:	0005      	movs	r5, r0
   131c4:	e7eb      	b.n	1319e <bme68x_set_op_mode+0x4a>
   131c6:	46c0      	nop			; (mov r8, r8)
   131c8:	00012f29 	.word	0x00012f29
   131cc:	00012e81 	.word	0x00012e81
   131d0:	00002710 	.word	0x00002710

000131d4 <bme68x_get_op_mode>:
{
   131d4:	b573      	push	{r0, r1, r4, r5, r6, lr}
   131d6:	000b      	movs	r3, r1
   131d8:	1e04      	subs	r4, r0, #0
    if (op_mode)
   131da:	d00b      	beq.n	131f4 <bme68x_get_op_mode+0x20>
        rslt = bme68x_get_regs(BME68X_REG_CTRL_MEAS, &mode, 1, dev);
   131dc:	466a      	mov	r2, sp
   131de:	1dd5      	adds	r5, r2, #7
   131e0:	0029      	movs	r1, r5
   131e2:	2201      	movs	r2, #1
   131e4:	2074      	movs	r0, #116	; 0x74
   131e6:	4e05      	ldr	r6, [pc, #20]	; (131fc <bme68x_get_op_mode+0x28>)
   131e8:	47b0      	blx	r6
        *op_mode = mode & BME68X_MODE_MSK;
   131ea:	2203      	movs	r2, #3
   131ec:	782b      	ldrb	r3, [r5, #0]
   131ee:	4013      	ands	r3, r2
   131f0:	7023      	strb	r3, [r4, #0]
}
   131f2:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
        rslt = BME68X_E_NULL_PTR;
   131f4:	2001      	movs	r0, #1
   131f6:	4240      	negs	r0, r0
   131f8:	e7fb      	b.n	131f2 <bme68x_get_op_mode+0x1e>
   131fa:	46c0      	nop			; (mov r8, r8)
   131fc:	00012f29 	.word	0x00012f29

00013200 <bme68x_set_conf>:
{
   13200:	b5f0      	push	{r4, r5, r6, r7, lr}
   13202:	000d      	movs	r5, r1
   13204:	b089      	sub	sp, #36	; 0x24
    uint8_t reg_array[BME68X_LEN_CONFIG] = { 0x71, 0x72, 0x73, 0x74, 0x75 };
   13206:	2205      	movs	r2, #5
   13208:	4945      	ldr	r1, [pc, #276]	; (13320 <bme68x_set_conf+0x120>)
   1320a:	4b46      	ldr	r3, [pc, #280]	; (13324 <bme68x_set_conf+0x124>)
{
   1320c:	0004      	movs	r4, r0
    uint8_t data_array[BME68X_LEN_CONFIG] = { 0 };
   1320e:	ae06      	add	r6, sp, #24
    uint8_t reg_array[BME68X_LEN_CONFIG] = { 0x71, 0x72, 0x73, 0x74, 0x75 };
   13210:	a804      	add	r0, sp, #16
   13212:	4798      	blx	r3
    uint8_t data_array[BME68X_LEN_CONFIG] = { 0 };
   13214:	2100      	movs	r1, #0
   13216:	4b44      	ldr	r3, [pc, #272]	; (13328 <bme68x_set_conf+0x128>)
   13218:	2205      	movs	r2, #5
   1321a:	0030      	movs	r0, r6
   1321c:	4798      	blx	r3
    rslt = bme68x_get_op_mode(&current_op_mode, dev);
   1321e:	ab02      	add	r3, sp, #8
   13220:	1dd8      	adds	r0, r3, #7
   13222:	0029      	movs	r1, r5
   13224:	4b41      	ldr	r3, [pc, #260]	; (1332c <bme68x_set_conf+0x12c>)
   13226:	4798      	blx	r3
    if (rslt == BME68X_OK)
   13228:	2800      	cmp	r0, #0
   1322a:	d000      	beq.n	1322e <bme68x_set_conf+0x2e>
   1322c:	e073      	b.n	13316 <bme68x_set_conf+0x116>
        rslt = bme68x_set_op_mode(BME68X_SLEEP_MODE, dev);
   1322e:	0029      	movs	r1, r5
   13230:	4b3f      	ldr	r3, [pc, #252]	; (13330 <bme68x_set_conf+0x130>)
   13232:	4798      	blx	r3
   13234:	9001      	str	r0, [sp, #4]
    if (conf == NULL)
   13236:	2c00      	cmp	r4, #0
   13238:	d100      	bne.n	1323c <bme68x_set_conf+0x3c>
   1323a:	e06e      	b.n	1331a <bme68x_set_conf+0x11a>
    else if (rslt == BME68X_OK)
   1323c:	2800      	cmp	r0, #0
   1323e:	d15d      	bne.n	132fc <bme68x_set_conf+0xfc>
        rslt = bme68x_get_regs(reg_array[0], data_array, BME68X_LEN_CONFIG, dev);
   13240:	ab02      	add	r3, sp, #8
   13242:	7a18      	ldrb	r0, [r3, #8]
   13244:	2205      	movs	r2, #5
   13246:	002b      	movs	r3, r5
   13248:	0031      	movs	r1, r6
   1324a:	4f3a      	ldr	r7, [pc, #232]	; (13334 <bme68x_set_conf+0x134>)
   1324c:	47b8      	blx	r7
        dev->info_msg = BME68X_OK;
   1324e:	466a      	mov	r2, sp
   13250:	002b      	movs	r3, r5
   13252:	7912      	ldrb	r2, [r2, #4]
   13254:	334d      	adds	r3, #77	; 0x4d
   13256:	701a      	strb	r2, [r3, #0]
        if (rslt == BME68X_OK)
   13258:	2800      	cmp	r0, #0
   1325a:	d14f      	bne.n	132fc <bme68x_set_conf+0xfc>
            rslt = boundary_check(&conf->filter, BME68X_FILTER_SIZE_127, dev);
   1325c:	1ce0      	adds	r0, r4, #3
   1325e:	002a      	movs	r2, r5
   13260:	2107      	movs	r1, #7
   13262:	4f35      	ldr	r7, [pc, #212]	; (13338 <bme68x_set_conf+0x138>)
   13264:	47b8      	blx	r7
        if (rslt == BME68X_OK)
   13266:	2800      	cmp	r0, #0
   13268:	d148      	bne.n	132fc <bme68x_set_conf+0xfc>
            rslt = boundary_check(&conf->os_temp, BME68X_OS_16X, dev);
   1326a:	1c60      	adds	r0, r4, #1
   1326c:	002a      	movs	r2, r5
   1326e:	2105      	movs	r1, #5
   13270:	47b8      	blx	r7
        if (rslt == BME68X_OK)
   13272:	2800      	cmp	r0, #0
   13274:	d142      	bne.n	132fc <bme68x_set_conf+0xfc>
            rslt = boundary_check(&conf->os_pres, BME68X_OS_16X, dev);
   13276:	1ca0      	adds	r0, r4, #2
   13278:	002a      	movs	r2, r5
   1327a:	2105      	movs	r1, #5
   1327c:	47b8      	blx	r7
        if (rslt == BME68X_OK)
   1327e:	2800      	cmp	r0, #0
   13280:	d13c      	bne.n	132fc <bme68x_set_conf+0xfc>
            rslt = boundary_check(&conf->os_hum, BME68X_OS_16X, dev);
   13282:	002a      	movs	r2, r5
   13284:	2105      	movs	r1, #5
   13286:	0020      	movs	r0, r4
   13288:	47b8      	blx	r7
        if (rslt == BME68X_OK)
   1328a:	2800      	cmp	r0, #0
   1328c:	d136      	bne.n	132fc <bme68x_set_conf+0xfc>
            rslt = boundary_check(&conf->odr, BME68X_ODR_NONE, dev);
   1328e:	1d20      	adds	r0, r4, #4
   13290:	002a      	movs	r2, r5
   13292:	2108      	movs	r1, #8
   13294:	47b8      	blx	r7
        if (rslt == BME68X_OK)
   13296:	2800      	cmp	r0, #0
   13298:	d130      	bne.n	132fc <bme68x_set_conf+0xfc>
            data_array[4] = BME68X_SET_BITS(data_array[4], BME68X_FILTER, conf->filter);
   1329a:	211c      	movs	r1, #28
   1329c:	78e2      	ldrb	r2, [r4, #3]
   1329e:	7933      	ldrb	r3, [r6, #4]
   132a0:	0092      	lsls	r2, r2, #2
   132a2:	438b      	bics	r3, r1
   132a4:	400a      	ands	r2, r1
            data_array[3] = BME68X_SET_BITS(data_array[3], BME68X_OST, conf->os_temp);
   132a6:	7867      	ldrb	r7, [r4, #1]
            data_array[4] = BME68X_SET_BITS(data_array[4], BME68X_FILTER, conf->filter);
   132a8:	431a      	orrs	r2, r3
            data_array[3] = BME68X_SET_BITS(data_array[3], BME68X_OST, conf->os_temp);
   132aa:	78f3      	ldrb	r3, [r6, #3]
   132ac:	301f      	adds	r0, #31
   132ae:	017f      	lsls	r7, r7, #5
   132b0:	4003      	ands	r3, r0
   132b2:	433b      	orrs	r3, r7
            data_array[3] = BME68X_SET_BITS(data_array[3], BME68X_OSP, conf->os_pres);
   132b4:	78a7      	ldrb	r7, [r4, #2]
   132b6:	438b      	bics	r3, r1
   132b8:	00bf      	lsls	r7, r7, #2
   132ba:	4039      	ands	r1, r7
            data_array[1] = BME68X_SET_BITS_POS_0(data_array[1], BME68X_OSH, conf->os_hum);
   132bc:	2707      	movs	r7, #7
            data_array[3] = BME68X_SET_BITS(data_array[3], BME68X_OSP, conf->os_pres);
   132be:	4319      	orrs	r1, r3
   132c0:	70f1      	strb	r1, [r6, #3]
            data_array[1] = BME68X_SET_BITS_POS_0(data_array[1], BME68X_OSH, conf->os_hum);
   132c2:	7873      	ldrb	r3, [r6, #1]
   132c4:	7821      	ldrb	r1, [r4, #0]
   132c6:	43bb      	bics	r3, r7
   132c8:	4039      	ands	r1, r7
   132ca:	430b      	orrs	r3, r1
   132cc:	7073      	strb	r3, [r6, #1]
            if (conf->odr != BME68X_ODR_NONE)
   132ce:	7923      	ldrb	r3, [r4, #4]
            data_array[4] = BME68X_SET_BITS(data_array[4], BME68X_FILTER, conf->filter);
   132d0:	b252      	sxtb	r2, r2
                odr3 = 0;
   132d2:	2100      	movs	r1, #0
            if (conf->odr != BME68X_ODR_NONE)
   132d4:	2b08      	cmp	r3, #8
   132d6:	d101      	bne.n	132dc <bme68x_set_conf+0xdc>
    uint8_t odr20 = 0, odr3 = 1;
   132d8:	2101      	movs	r1, #1
   132da:	2300      	movs	r3, #0
            data_array[4] = BME68X_SET_BITS(data_array[4], BME68X_ODR20, odr20);
   132dc:	4002      	ands	r2, r0
   132de:	015b      	lsls	r3, r3, #5
   132e0:	431a      	orrs	r2, r3
   132e2:	7132      	strb	r2, [r6, #4]
            data_array[0] = BME68X_SET_BITS(data_array[0], BME68X_ODR3, odr3);
   132e4:	227f      	movs	r2, #127	; 0x7f
   132e6:	7833      	ldrb	r3, [r6, #0]
   132e8:	01c9      	lsls	r1, r1, #7
   132ea:	4013      	ands	r3, r2
   132ec:	430b      	orrs	r3, r1
   132ee:	7033      	strb	r3, [r6, #0]
        rslt = bme68x_set_regs(reg_array, data_array, BME68X_LEN_CONFIG, dev);
   132f0:	3a7a      	subs	r2, #122	; 0x7a
   132f2:	002b      	movs	r3, r5
   132f4:	0031      	movs	r1, r6
   132f6:	a804      	add	r0, sp, #16
   132f8:	4c10      	ldr	r4, [pc, #64]	; (1333c <bme68x_set_conf+0x13c>)
   132fa:	47a0      	blx	r4
    if ((current_op_mode != BME68X_SLEEP_MODE) && (rslt == BME68X_OK))
   132fc:	ab02      	add	r3, sp, #8
   132fe:	3307      	adds	r3, #7
   13300:	781b      	ldrb	r3, [r3, #0]
   13302:	2b00      	cmp	r3, #0
   13304:	d005      	beq.n	13312 <bme68x_set_conf+0x112>
   13306:	2800      	cmp	r0, #0
   13308:	d103      	bne.n	13312 <bme68x_set_conf+0x112>
        rslt = bme68x_set_op_mode(current_op_mode, dev);
   1330a:	0018      	movs	r0, r3
   1330c:	0029      	movs	r1, r5
   1330e:	4b08      	ldr	r3, [pc, #32]	; (13330 <bme68x_set_conf+0x130>)
   13310:	4798      	blx	r3
}
   13312:	b009      	add	sp, #36	; 0x24
   13314:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (conf == NULL)
   13316:	2c00      	cmp	r4, #0
   13318:	d1f0      	bne.n	132fc <bme68x_set_conf+0xfc>
        rslt = BME68X_E_NULL_PTR;
   1331a:	2001      	movs	r0, #1
   1331c:	4240      	negs	r0, r0
   1331e:	e7ed      	b.n	132fc <bme68x_set_conf+0xfc>
   13320:	000287cc 	.word	0x000287cc
   13324:	00022c11 	.word	0x00022c11
   13328:	00022c47 	.word	0x00022c47
   1332c:	000131d5 	.word	0x000131d5
   13330:	00013155 	.word	0x00013155
   13334:	00012f29 	.word	0x00012f29
   13338:	00012cb1 	.word	0x00012cb1
   1333c:	00012e81 	.word	0x00012e81

00013340 <bme68x_get_data>:
{
   13340:	b5f0      	push	{r4, r5, r6, r7, lr}
   13342:	001d      	movs	r5, r3
   13344:	b0b5      	sub	sp, #212	; 0xd4
   13346:	9002      	str	r0, [sp, #8]
   13348:	9100      	str	r1, [sp, #0]
   1334a:	9204      	str	r2, [sp, #16]
    struct bme68x_data *field_ptr[3] = { 0 };
   1334c:	2100      	movs	r1, #0
   1334e:	220c      	movs	r2, #12
   13350:	4fcc      	ldr	r7, [pc, #816]	; (13684 <bme68x_get_data+0x344>)
    struct bme68x_data field_data[3] = { { 0 } };
   13352:	ac22      	add	r4, sp, #136	; 0x88
    struct bme68x_data *field_ptr[3] = { 0 };
   13354:	a80a      	add	r0, sp, #40	; 0x28
   13356:	47b8      	blx	r7
    struct bme68x_data field_data[3] = { { 0 } };
   13358:	2248      	movs	r2, #72	; 0x48
   1335a:	2100      	movs	r1, #0
   1335c:	0020      	movs	r0, r4
   1335e:	47b8      	blx	r7
    field_ptr[1] = &field_data[1];
   13360:	ab28      	add	r3, sp, #160	; 0xa0
   13362:	930b      	str	r3, [sp, #44]	; 0x2c
    field_ptr[2] = &field_data[2];
   13364:	ab2e      	add	r3, sp, #184	; 0xb8
   13366:	930c      	str	r3, [sp, #48]	; 0x30
    rslt = null_ptr_check(dev);
   13368:	0028      	movs	r0, r5
   1336a:	4bc7      	ldr	r3, [pc, #796]	; (13688 <bme68x_get_data+0x348>)
    field_ptr[0] = &field_data[0];
   1336c:	940a      	str	r4, [sp, #40]	; 0x28
    rslt = null_ptr_check(dev);
   1336e:	4798      	blx	r3
   13370:	1e06      	subs	r6, r0, #0
    if ((rslt == BME68X_OK) && (data != NULL))
   13372:	d005      	beq.n	13380 <bme68x_get_data+0x40>
        rslt = BME68X_E_NULL_PTR;
   13374:	2301      	movs	r3, #1
   13376:	425b      	negs	r3, r3
   13378:	9301      	str	r3, [sp, #4]
}
   1337a:	9801      	ldr	r0, [sp, #4]
   1337c:	b035      	add	sp, #212	; 0xd4
   1337e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if ((rslt == BME68X_OK) && (data != NULL))
   13380:	9b00      	ldr	r3, [sp, #0]
   13382:	2b00      	cmp	r3, #0
   13384:	d0f6      	beq.n	13374 <bme68x_get_data+0x34>
        if (op_mode == BME68X_FORCED_MODE)
   13386:	9b02      	ldr	r3, [sp, #8]
   13388:	2b01      	cmp	r3, #1
   1338a:	d000      	beq.n	1338e <bme68x_get_data+0x4e>
   1338c:	e096      	b.n	134bc <bme68x_get_data+0x17c>
    uint8_t buff[BME68X_LEN_FIELD] = { 0 };
   1338e:	ac15      	add	r4, sp, #84	; 0x54
   13390:	0001      	movs	r1, r0
   13392:	2211      	movs	r2, #17
   13394:	0020      	movs	r0, r4
   13396:	47b8      	blx	r7
        rslt = bme68x_get_regs(((uint8_t)(BME68X_REG_FIELD0 + (index * BME68X_LEN_FIELD_OFFSET))),
   13398:	0021      	movs	r1, r4
   1339a:	002b      	movs	r3, r5
   1339c:	2211      	movs	r2, #17
   1339e:	4ebb      	ldr	r6, [pc, #748]	; (1368c <bme68x_get_data+0x34c>)
   133a0:	201d      	movs	r0, #29
   133a2:	47b0      	blx	r6
        data->status = buff[0] & BME68X_NEW_DATA_MSK;
   133a4:	7823      	ldrb	r3, [r4, #0]
   133a6:	227f      	movs	r2, #127	; 0x7f
   133a8:	0019      	movs	r1, r3
        data->gas_index = buff[0] & BME68X_GAS_INDEX_MSK;
   133aa:	260f      	movs	r6, #15
        data->status = buff[0] & BME68X_NEW_DATA_MSK;
   133ac:	4391      	bics	r1, r2
   133ae:	000a      	movs	r2, r1
   133b0:	9900      	ldr	r1, [sp, #0]
        data->gas_index = buff[0] & BME68X_GAS_INDEX_MSK;
   133b2:	4033      	ands	r3, r6
        data->status = buff[0] & BME68X_NEW_DATA_MSK;
   133b4:	700a      	strb	r2, [r1, #0]
        data->gas_index = buff[0] & BME68X_GAS_INDEX_MSK;
   133b6:	704b      	strb	r3, [r1, #1]
        rslt = bme68x_get_regs(((uint8_t)(BME68X_REG_FIELD0 + (index * BME68X_LEN_FIELD_OFFSET))),
   133b8:	9003      	str	r0, [sp, #12]
   133ba:	9001      	str	r0, [sp, #4]
        data->meas_index = buff[1];
   133bc:	7863      	ldrb	r3, [r4, #1]
   133be:	708b      	strb	r3, [r1, #2]
        adc_pres = (uint32_t)(((uint32_t)buff[2] * 4096) | ((uint32_t)buff[3] * 16) | ((uint32_t)buff[4] / 16));
   133c0:	78a3      	ldrb	r3, [r4, #2]
   133c2:	78e1      	ldrb	r1, [r4, #3]
   133c4:	031b      	lsls	r3, r3, #12
   133c6:	0109      	lsls	r1, r1, #4
   133c8:	430b      	orrs	r3, r1
   133ca:	7921      	ldrb	r1, [r4, #4]
   133cc:	0909      	lsrs	r1, r1, #4
   133ce:	430b      	orrs	r3, r1
   133d0:	9305      	str	r3, [sp, #20]
        adc_hum = (uint16_t)(((uint32_t)buff[8] * 256) | (uint32_t)buff[9]);
   133d2:	7a23      	ldrb	r3, [r4, #8]
        adc_temp = (uint32_t)(((uint32_t)buff[5] * 4096) | ((uint32_t)buff[6] * 16) | ((uint32_t)buff[7] / 16));
   133d4:	7967      	ldrb	r7, [r4, #5]
   133d6:	79a0      	ldrb	r0, [r4, #6]
        adc_hum = (uint16_t)(((uint32_t)buff[8] * 256) | (uint32_t)buff[9]);
   133d8:	7a61      	ldrb	r1, [r4, #9]
   133da:	021b      	lsls	r3, r3, #8
   133dc:	4319      	orrs	r1, r3
        adc_temp = (uint32_t)(((uint32_t)buff[5] * 4096) | ((uint32_t)buff[6] * 16) | ((uint32_t)buff[7] / 16));
   133de:	0100      	lsls	r0, r0, #4
   133e0:	033f      	lsls	r7, r7, #12
   133e2:	4307      	orrs	r7, r0
   133e4:	79e0      	ldrb	r0, [r4, #7]
        adc_hum = (uint16_t)(((uint32_t)buff[8] * 256) | (uint32_t)buff[9]);
   133e6:	9106      	str	r1, [sp, #24]
        adc_gas_res_low = (uint16_t)((uint32_t)buff[13] * 4 | (((uint32_t)buff[14]) / 64));
   133e8:	7ba3      	ldrb	r3, [r4, #14]
   133ea:	7b61      	ldrb	r1, [r4, #13]
        adc_temp = (uint32_t)(((uint32_t)buff[5] * 4096) | ((uint32_t)buff[6] * 16) | ((uint32_t)buff[7] / 16));
   133ec:	0900      	lsrs	r0, r0, #4
        adc_gas_res_low = (uint16_t)((uint32_t)buff[13] * 4 | (((uint32_t)buff[14]) / 64));
   133ee:	0089      	lsls	r1, r1, #2
        adc_temp = (uint32_t)(((uint32_t)buff[5] * 4096) | ((uint32_t)buff[6] * 16) | ((uint32_t)buff[7] / 16));
   133f0:	4307      	orrs	r7, r0
        adc_gas_res_low = (uint16_t)((uint32_t)buff[13] * 4 | (((uint32_t)buff[14]) / 64));
   133f2:	0998      	lsrs	r0, r3, #6
   133f4:	4308      	orrs	r0, r1
   133f6:	9007      	str	r0, [sp, #28]
        adc_gas_res_high = (uint16_t)((uint32_t)buff[15] * 4 | (((uint32_t)buff[16]) / 64));
   133f8:	7be1      	ldrb	r1, [r4, #15]
        gas_range_l = buff[14] & BME68X_GAS_RANGE_MSK;
   133fa:	401e      	ands	r6, r3
        adc_gas_res_high = (uint16_t)((uint32_t)buff[15] * 4 | (((uint32_t)buff[16]) / 64));
   133fc:	9108      	str	r1, [sp, #32]
        if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
   133fe:	68a9      	ldr	r1, [r5, #8]
        adc_gas_res_high = (uint16_t)((uint32_t)buff[15] * 4 | (((uint32_t)buff[16]) / 64));
   13400:	7c24      	ldrb	r4, [r4, #16]
   13402:	2020      	movs	r0, #32
        if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
   13404:	2901      	cmp	r1, #1
   13406:	d14b      	bne.n	134a0 <bme68x_get_data+0x160>
            data->status |= buff[16] & BME68X_HEAT_STAB_MSK;
   13408:	2310      	movs	r3, #16
            data->status |= buff[16] & BME68X_GASM_VALID_MSK;
   1340a:	b261      	sxtb	r1, r4
   1340c:	4008      	ands	r0, r1
   1340e:	4302      	orrs	r2, r0
            data->status |= buff[16] & BME68X_HEAT_STAB_MSK;
   13410:	4019      	ands	r1, r3
   13412:	430a      	orrs	r2, r1
            data->status |= buff[14] & BME68X_HEAT_STAB_MSK;
   13414:	9b00      	ldr	r3, [sp, #0]
                data->temperature = calc_temperature(adc_temp, dev);
   13416:	0029      	movs	r1, r5
            data->status |= buff[14] & BME68X_HEAT_STAB_MSK;
   13418:	701a      	strb	r2, [r3, #0]
                data->temperature = calc_temperature(adc_temp, dev);
   1341a:	0038      	movs	r0, r7
   1341c:	4b9c      	ldr	r3, [pc, #624]	; (13690 <bme68x_get_data+0x350>)
   1341e:	4798      	blx	r3
   13420:	9b00      	ldr	r3, [sp, #0]
                data->pressure = calc_pressure(adc_pres, dev);
   13422:	0029      	movs	r1, r5
                data->temperature = calc_temperature(adc_temp, dev);
   13424:	6098      	str	r0, [r3, #8]
                data->pressure = calc_pressure(adc_pres, dev);
   13426:	4b9b      	ldr	r3, [pc, #620]	; (13694 <bme68x_get_data+0x354>)
   13428:	9805      	ldr	r0, [sp, #20]
   1342a:	4798      	blx	r3
   1342c:	9b00      	ldr	r3, [sp, #0]
                data->humidity = calc_humidity(adc_hum, dev);
   1342e:	0029      	movs	r1, r5
                data->pressure = calc_pressure(adc_pres, dev);
   13430:	60d8      	str	r0, [r3, #12]
                data->humidity = calc_humidity(adc_hum, dev);
   13432:	4b99      	ldr	r3, [pc, #612]	; (13698 <bme68x_get_data+0x358>)
   13434:	9806      	ldr	r0, [sp, #24]
   13436:	4798      	blx	r3
   13438:	9b00      	ldr	r3, [sp, #0]
   1343a:	6118      	str	r0, [r3, #16]
                if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
   1343c:	68ab      	ldr	r3, [r5, #8]
   1343e:	2b01      	cmp	r3, #1
   13440:	d135      	bne.n	134ae <bme68x_get_data+0x16e>
        adc_gas_res_high = (uint16_t)((uint32_t)buff[15] * 4 | (((uint32_t)buff[16]) / 64));
   13442:	9b08      	ldr	r3, [sp, #32]
   13444:	09a5      	lsrs	r5, r4, #6
   13446:	0098      	lsls	r0, r3, #2
    int32_t var2 = (int32_t)gas_res_adc - INT32_C(512);
   13448:	4328      	orrs	r0, r5
    var2 *= INT32_C(3);
   1344a:	2503      	movs	r5, #3
    int32_t var2 = (int32_t)gas_res_adc - INT32_C(512);
   1344c:	4b93      	ldr	r3, [pc, #588]	; (1369c <bme68x_get_data+0x35c>)
   1344e:	18c0      	adds	r0, r0, r3
    var2 *= INT32_C(3);
   13450:	4345      	muls	r5, r0
    uint32_t var1 = UINT32_C(262144) >> gas_range;
   13452:	230f      	movs	r3, #15
   13454:	2080      	movs	r0, #128	; 0x80
   13456:	401c      	ands	r4, r3
   13458:	02c0      	lsls	r0, r0, #11
   1345a:	40e0      	lsrs	r0, r4
    calc_gas_res = 1000000.0f * (float)var1 / (float)var2;
   1345c:	4b90      	ldr	r3, [pc, #576]	; (136a0 <bme68x_get_data+0x360>)
   1345e:	4798      	blx	r3
   13460:	4990      	ldr	r1, [pc, #576]	; (136a4 <bme68x_get_data+0x364>)
   13462:	4b91      	ldr	r3, [pc, #580]	; (136a8 <bme68x_get_data+0x368>)
   13464:	4798      	blx	r3
    var2 = INT32_C(4096) + var2;
   13466:	2380      	movs	r3, #128	; 0x80
   13468:	015b      	lsls	r3, r3, #5
    calc_gas_res = 1000000.0f * (float)var1 / (float)var2;
   1346a:	1c04      	adds	r4, r0, #0
    var2 = INT32_C(4096) + var2;
   1346c:	18e8      	adds	r0, r5, r3
    calc_gas_res = 1000000.0f * (float)var1 / (float)var2;
   1346e:	4b8f      	ldr	r3, [pc, #572]	; (136ac <bme68x_get_data+0x36c>)
   13470:	4798      	blx	r3
   13472:	4b8f      	ldr	r3, [pc, #572]	; (136b0 <bme68x_get_data+0x370>)
   13474:	1c01      	adds	r1, r0, #0
   13476:	1c20      	adds	r0, r4, #0
   13478:	4798      	blx	r3
                    data->gas_resistance = calc_gas_resistance_low(adc_gas_res_low, gas_range_l, dev);
   1347a:	9b00      	ldr	r3, [sp, #0]
   1347c:	6158      	str	r0, [r3, #20]
            if (rslt == BME68X_OK)
   1347e:	9b03      	ldr	r3, [sp, #12]
   13480:	2b00      	cmp	r3, #0
   13482:	d000      	beq.n	13486 <bme68x_get_data+0x146>
   13484:	e132      	b.n	136ec <bme68x_get_data+0x3ac>
                if (data->status & BME68X_NEW_DATA_MSK)
   13486:	9b00      	ldr	r3, [sp, #0]
   13488:	781b      	ldrb	r3, [r3, #0]
   1348a:	2b7f      	cmp	r3, #127	; 0x7f
   1348c:	d800      	bhi.n	13490 <bme68x_get_data+0x150>
   1348e:	e130      	b.n	136f2 <bme68x_get_data+0x3b2>
        if (n_data == NULL)
   13490:	9b04      	ldr	r3, [sp, #16]
   13492:	2b00      	cmp	r3, #0
   13494:	d100      	bne.n	13498 <bme68x_get_data+0x158>
   13496:	e76d      	b.n	13374 <bme68x_get_data+0x34>
            *n_data = new_fields;
   13498:	466a      	mov	r2, sp
   1349a:	7a12      	ldrb	r2, [r2, #8]
   1349c:	701a      	strb	r2, [r3, #0]
   1349e:	e76c      	b.n	1337a <bme68x_get_data+0x3a>
            data->status |= buff[14] & BME68X_GASM_VALID_MSK;
   134a0:	b259      	sxtb	r1, r3
            data->status |= buff[14] & BME68X_HEAT_STAB_MSK;
   134a2:	2310      	movs	r3, #16
            data->status |= buff[14] & BME68X_GASM_VALID_MSK;
   134a4:	4008      	ands	r0, r1
   134a6:	4302      	orrs	r2, r0
            data->status |= buff[14] & BME68X_HEAT_STAB_MSK;
   134a8:	400b      	ands	r3, r1
   134aa:	431a      	orrs	r2, r3
   134ac:	e7b2      	b.n	13414 <bme68x_get_data+0xd4>
                    data->gas_resistance = calc_gas_resistance_low(adc_gas_res_low, gas_range_l, dev);
   134ae:	223e      	movs	r2, #62	; 0x3e
   134b0:	0031      	movs	r1, r6
   134b2:	56aa      	ldrsb	r2, [r5, r2]
   134b4:	9807      	ldr	r0, [sp, #28]
   134b6:	4b7f      	ldr	r3, [pc, #508]	; (136b4 <bme68x_get_data+0x374>)
   134b8:	4798      	blx	r3
   134ba:	e7de      	b.n	1347a <bme68x_get_data+0x13a>
        else if ((op_mode == BME68X_PARALLEL_MODE) || (op_mode == BME68X_SEQUENTIAL_MODE))
   134bc:	9b02      	ldr	r3, [sp, #8]
   134be:	3b02      	subs	r3, #2
   134c0:	2b01      	cmp	r3, #1
   134c2:	d900      	bls.n	134c6 <bme68x_get_data+0x186>
   134c4:	e118      	b.n	136f8 <bme68x_get_data+0x3b8>
    uint8_t buff[BME68X_LEN_FIELD * 3] = { 0 };
   134c6:	0001      	movs	r1, r0
   134c8:	2233      	movs	r2, #51	; 0x33
   134ca:	a815      	add	r0, sp, #84	; 0x54
   134cc:	47b8      	blx	r7
    uint8_t set_val[30] = { 0 }; /* idac, res_heat, gas_wait */
   134ce:	221e      	movs	r2, #30
   134d0:	0031      	movs	r1, r6
   134d2:	a80d      	add	r0, sp, #52	; 0x34
   134d4:	47b8      	blx	r7
        rslt = bme68x_get_regs(BME68X_REG_FIELD0, buff, (uint32_t) BME68X_LEN_FIELD * 3, dev);
   134d6:	002b      	movs	r3, r5
   134d8:	2233      	movs	r2, #51	; 0x33
   134da:	a915      	add	r1, sp, #84	; 0x54
   134dc:	201d      	movs	r0, #29
   134de:	4c6b      	ldr	r4, [pc, #428]	; (1368c <bme68x_get_data+0x34c>)
   134e0:	47a0      	blx	r4
   134e2:	9001      	str	r0, [sp, #4]
    if (rslt == BME68X_OK)
   134e4:	2800      	cmp	r0, #0
   134e6:	d000      	beq.n	134ea <bme68x_get_data+0x1aa>
   134e8:	e080      	b.n	135ec <bme68x_get_data+0x2ac>
        rslt = bme68x_get_regs(BME68X_REG_IDAC_HEAT0, set_val, 30, dev);
   134ea:	002b      	movs	r3, r5
   134ec:	221e      	movs	r2, #30
   134ee:	a90d      	add	r1, sp, #52	; 0x34
   134f0:	2050      	movs	r0, #80	; 0x50
   134f2:	47a0      	blx	r4
   134f4:	ac15      	add	r4, sp, #84	; 0x54
   134f6:	9001      	str	r0, [sp, #4]
   134f8:	9602      	str	r6, [sp, #8]
    for (i = 0; ((i < 3) && (rslt == BME68X_OK)); i++)
   134fa:	2800      	cmp	r0, #0
   134fc:	d176      	bne.n	135ec <bme68x_get_data+0x2ac>
        data[i]->status = buff[off] & BME68X_NEW_DATA_MSK;
   134fe:	9a02      	ldr	r2, [sp, #8]
   13500:	ab0a      	add	r3, sp, #40	; 0x28
   13502:	58d6      	ldr	r6, [r2, r3]
   13504:	7822      	ldrb	r2, [r4, #0]
   13506:	237f      	movs	r3, #127	; 0x7f
   13508:	0011      	movs	r1, r2
   1350a:	4399      	bics	r1, r3
        data[i]->gas_index = buff[off] & BME68X_GAS_INDEX_MSK;
   1350c:	3b70      	subs	r3, #112	; 0x70
   1350e:	401a      	ands	r2, r3
        data[i]->meas_index = buff[off + 1];
   13510:	7863      	ldrb	r3, [r4, #1]
            (uint32_t) (((uint32_t) buff[off + 2] * 4096) | ((uint32_t) buff[off + 3] * 16) |
   13512:	78e0      	ldrb	r0, [r4, #3]
        data[i]->meas_index = buff[off + 1];
   13514:	70b3      	strb	r3, [r6, #2]
            (uint32_t) (((uint32_t) buff[off + 2] * 4096) | ((uint32_t) buff[off + 3] * 16) |
   13516:	78a3      	ldrb	r3, [r4, #2]
   13518:	0100      	lsls	r0, r0, #4
   1351a:	031b      	lsls	r3, r3, #12
   1351c:	4303      	orrs	r3, r0
                        ((uint32_t) buff[off + 4] / 16));
   1351e:	7920      	ldrb	r0, [r4, #4]
        adc_hum = (uint16_t) (((uint32_t) buff[off + 8] * 256) | (uint32_t) buff[off + 9]);
   13520:	7a67      	ldrb	r7, [r4, #9]
                        ((uint32_t) buff[off + 4] / 16));
   13522:	0900      	lsrs	r0, r0, #4
        adc_pres =
   13524:	4303      	orrs	r3, r0
   13526:	9305      	str	r3, [sp, #20]
            (uint32_t) (((uint32_t) buff[off + 5] * 4096) | ((uint32_t) buff[off + 6] * 16) |
   13528:	7960      	ldrb	r0, [r4, #5]
   1352a:	79a3      	ldrb	r3, [r4, #6]
   1352c:	0300      	lsls	r0, r0, #12
   1352e:	011b      	lsls	r3, r3, #4
   13530:	4318      	orrs	r0, r3
                        ((uint32_t) buff[off + 7] / 16));
   13532:	79e3      	ldrb	r3, [r4, #7]
        data[i]->status = buff[off] & BME68X_NEW_DATA_MSK;
   13534:	7031      	strb	r1, [r6, #0]
                        ((uint32_t) buff[off + 7] / 16));
   13536:	091b      	lsrs	r3, r3, #4
        adc_temp =
   13538:	4318      	orrs	r0, r3
        adc_hum = (uint16_t) (((uint32_t) buff[off + 8] * 256) | (uint32_t) buff[off + 9]);
   1353a:	7a23      	ldrb	r3, [r4, #8]
        adc_temp =
   1353c:	9006      	str	r0, [sp, #24]
        adc_hum = (uint16_t) (((uint32_t) buff[off + 8] * 256) | (uint32_t) buff[off + 9]);
   1353e:	021b      	lsls	r3, r3, #8
   13540:	431f      	orrs	r7, r3
        adc_gas_res_low = (uint16_t) ((uint32_t) buff[off + 13] * 4 | (((uint32_t) buff[off + 14]) / 64));
   13542:	7b63      	ldrb	r3, [r4, #13]
        if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
   13544:	68a8      	ldr	r0, [r5, #8]
        adc_gas_res_low = (uint16_t) ((uint32_t) buff[off + 13] * 4 | (((uint32_t) buff[off + 14]) / 64));
   13546:	9308      	str	r3, [sp, #32]
   13548:	7ba3      	ldrb	r3, [r4, #14]
        adc_hum = (uint16_t) (((uint32_t) buff[off + 8] * 256) | (uint32_t) buff[off + 9]);
   1354a:	9707      	str	r7, [sp, #28]
        adc_gas_res_low = (uint16_t) ((uint32_t) buff[off + 13] * 4 | (((uint32_t) buff[off + 14]) / 64));
   1354c:	9303      	str	r3, [sp, #12]
        adc_gas_res_high = (uint16_t) ((uint32_t) buff[off + 15] * 4 | (((uint32_t) buff[off + 16]) / 64));
   1354e:	7be3      	ldrb	r3, [r4, #15]
        data[i]->gas_index = buff[off] & BME68X_GAS_INDEX_MSK;
   13550:	7072      	strb	r2, [r6, #1]
        adc_gas_res_high = (uint16_t) ((uint32_t) buff[off + 15] * 4 | (((uint32_t) buff[off + 16]) / 64));
   13552:	9309      	str	r3, [sp, #36]	; 0x24
   13554:	7c27      	ldrb	r7, [r4, #16]
   13556:	2320      	movs	r3, #32
        if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
   13558:	2801      	cmp	r0, #1
   1355a:	d15c      	bne.n	13616 <bme68x_get_data+0x2d6>
            data[i]->status |= buff[off + 16] & BME68X_GASM_VALID_MSK;
   1355c:	b278      	sxtb	r0, r7
            data[i]->status |= buff[off + 14] & BME68X_GASM_VALID_MSK;
   1355e:	4003      	ands	r3, r0
   13560:	430b      	orrs	r3, r1
            data[i]->status |= buff[off + 14] & BME68X_HEAT_STAB_MSK;
   13562:	2110      	movs	r1, #16
   13564:	4001      	ands	r1, r0
   13566:	4319      	orrs	r1, r3
        data[i]->idac = set_val[data[i]->gas_index];
   13568:	ab0d      	add	r3, sp, #52	; 0x34
            data[i]->status |= buff[off + 14] & BME68X_HEAT_STAB_MSK;
   1356a:	7031      	strb	r1, [r6, #0]
        data[i]->idac = set_val[data[i]->gas_index];
   1356c:	5c99      	ldrb	r1, [r3, r2]
        data[i]->res_heat = set_val[10 + data[i]->gas_index];
   1356e:	189a      	adds	r2, r3, r2
   13570:	7a93      	ldrb	r3, [r2, #10]
        data[i]->idac = set_val[data[i]->gas_index];
   13572:	7131      	strb	r1, [r6, #4]
        data[i]->res_heat = set_val[10 + data[i]->gas_index];
   13574:	70f3      	strb	r3, [r6, #3]
        data[i]->gas_wait = set_val[20 + data[i]->gas_index];
   13576:	7d13      	ldrb	r3, [r2, #20]
        data[i]->temperature = calc_temperature(adc_temp, dev);
   13578:	0029      	movs	r1, r5
        data[i]->gas_wait = set_val[20 + data[i]->gas_index];
   1357a:	7173      	strb	r3, [r6, #5]
        data[i]->temperature = calc_temperature(adc_temp, dev);
   1357c:	9806      	ldr	r0, [sp, #24]
   1357e:	4b44      	ldr	r3, [pc, #272]	; (13690 <bme68x_get_data+0x350>)
   13580:	4798      	blx	r3
        data[i]->pressure = calc_pressure(adc_pres, dev);
   13582:	0029      	movs	r1, r5
        data[i]->temperature = calc_temperature(adc_temp, dev);
   13584:	60b0      	str	r0, [r6, #8]
        data[i]->pressure = calc_pressure(adc_pres, dev);
   13586:	4b43      	ldr	r3, [pc, #268]	; (13694 <bme68x_get_data+0x354>)
   13588:	9805      	ldr	r0, [sp, #20]
   1358a:	4798      	blx	r3
        data[i]->humidity = calc_humidity(adc_hum, dev);
   1358c:	4b42      	ldr	r3, [pc, #264]	; (13698 <bme68x_get_data+0x358>)
        data[i]->pressure = calc_pressure(adc_pres, dev);
   1358e:	60f0      	str	r0, [r6, #12]
        data[i]->humidity = calc_humidity(adc_hum, dev);
   13590:	0029      	movs	r1, r5
   13592:	9807      	ldr	r0, [sp, #28]
   13594:	4798      	blx	r3
        if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
   13596:	68ab      	ldr	r3, [r5, #8]
        data[i]->humidity = calc_humidity(adc_hum, dev);
   13598:	6130      	str	r0, [r6, #16]
        if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
   1359a:	2b01      	cmp	r3, #1
   1359c:	d13f      	bne.n	1361e <bme68x_get_data+0x2de>
        adc_gas_res_high = (uint16_t) ((uint32_t) buff[off + 15] * 4 | (((uint32_t) buff[off + 16]) / 64));
   1359e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   135a0:	09b8      	lsrs	r0, r7, #6
   135a2:	009b      	lsls	r3, r3, #2
    int32_t var2 = (int32_t)gas_res_adc - INT32_C(512);
   135a4:	4318      	orrs	r0, r3
   135a6:	4b3d      	ldr	r3, [pc, #244]	; (1369c <bme68x_get_data+0x35c>)
   135a8:	18c0      	adds	r0, r0, r3
    var2 *= INT32_C(3);
   135aa:	2303      	movs	r3, #3
   135ac:	4343      	muls	r3, r0
    uint32_t var1 = UINT32_C(262144) >> gas_range;
   135ae:	2080      	movs	r0, #128	; 0x80
    var2 *= INT32_C(3);
   135b0:	9303      	str	r3, [sp, #12]
    uint32_t var1 = UINT32_C(262144) >> gas_range;
   135b2:	230f      	movs	r3, #15
   135b4:	02c0      	lsls	r0, r0, #11
   135b6:	401f      	ands	r7, r3
   135b8:	40f8      	lsrs	r0, r7
    calc_gas_res = 1000000.0f * (float)var1 / (float)var2;
   135ba:	4b39      	ldr	r3, [pc, #228]	; (136a0 <bme68x_get_data+0x360>)
   135bc:	4798      	blx	r3
   135be:	4939      	ldr	r1, [pc, #228]	; (136a4 <bme68x_get_data+0x364>)
   135c0:	4b39      	ldr	r3, [pc, #228]	; (136a8 <bme68x_get_data+0x368>)
   135c2:	4798      	blx	r3
    var2 = INT32_C(4096) + var2;
   135c4:	2280      	movs	r2, #128	; 0x80
   135c6:	0152      	lsls	r2, r2, #5
   135c8:	4694      	mov	ip, r2
   135ca:	9b03      	ldr	r3, [sp, #12]
    calc_gas_res = 1000000.0f * (float)var1 / (float)var2;
   135cc:	1c07      	adds	r7, r0, #0
    var2 = INT32_C(4096) + var2;
   135ce:	4463      	add	r3, ip
   135d0:	0018      	movs	r0, r3
    calc_gas_res = 1000000.0f * (float)var1 / (float)var2;
   135d2:	4b36      	ldr	r3, [pc, #216]	; (136ac <bme68x_get_data+0x36c>)
   135d4:	4798      	blx	r3
   135d6:	4b36      	ldr	r3, [pc, #216]	; (136b0 <bme68x_get_data+0x370>)
   135d8:	1c01      	adds	r1, r0, #0
   135da:	1c38      	adds	r0, r7, #0
   135dc:	4798      	blx	r3
   135de:	9b02      	ldr	r3, [sp, #8]
            data[i]->gas_resistance = calc_gas_resistance_low(adc_gas_res_low, gas_range_l, dev);
   135e0:	6170      	str	r0, [r6, #20]
   135e2:	3304      	adds	r3, #4
   135e4:	3411      	adds	r4, #17
   135e6:	9302      	str	r3, [sp, #8]
    for (i = 0; ((i < 3) && (rslt == BME68X_OK)); i++)
   135e8:	2b0c      	cmp	r3, #12
   135ea:	d188      	bne.n	134fe <bme68x_get_data+0x1be>
   135ec:	2300      	movs	r3, #0
            for (i = 0; (i < 3) && (rslt == BME68X_OK); i++)
   135ee:	9a01      	ldr	r2, [sp, #4]
            new_fields = 0;
   135f0:	9302      	str	r3, [sp, #8]
            for (i = 0; (i < 3) && (rslt == BME68X_OK); i++)
   135f2:	429a      	cmp	r2, r3
   135f4:	d160      	bne.n	136b8 <bme68x_get_data+0x378>
                if (field_ptr[i]->status & BME68X_NEW_DATA_MSK)
   135f6:	aa0a      	add	r2, sp, #40	; 0x28
   135f8:	589a      	ldr	r2, [r3, r2]
   135fa:	9203      	str	r2, [sp, #12]
   135fc:	7812      	ldrb	r2, [r2, #0]
   135fe:	2a7f      	cmp	r2, #127	; 0x7f
   13600:	d903      	bls.n	1360a <bme68x_get_data+0x2ca>
                    new_fields++;
   13602:	9a02      	ldr	r2, [sp, #8]
   13604:	3201      	adds	r2, #1
   13606:	b2d2      	uxtb	r2, r2
   13608:	9202      	str	r2, [sp, #8]
   1360a:	3304      	adds	r3, #4
            for (i = 0; (i < 3) && (rslt == BME68X_OK); i++)
   1360c:	2b0c      	cmp	r3, #12
   1360e:	d1f2      	bne.n	135f6 <bme68x_get_data+0x2b6>
   13610:	2000      	movs	r0, #0
   13612:	0001      	movs	r1, r0
   13614:	e019      	b.n	1364a <bme68x_get_data+0x30a>
            data[i]->status |= buff[off + 14] & BME68X_GASM_VALID_MSK;
   13616:	4668      	mov	r0, sp
   13618:	7b00      	ldrb	r0, [r0, #12]
   1361a:	b240      	sxtb	r0, r0
   1361c:	e79f      	b.n	1355e <bme68x_get_data+0x21e>
            data[i]->gas_resistance = calc_gas_resistance_low(adc_gas_res_low, gas_range_l, dev);
   1361e:	210f      	movs	r1, #15
   13620:	223e      	movs	r2, #62	; 0x3e
   13622:	9b03      	ldr	r3, [sp, #12]
        adc_gas_res_low = (uint16_t) ((uint32_t) buff[off + 13] * 4 | (((uint32_t) buff[off + 14]) / 64));
   13624:	9803      	ldr	r0, [sp, #12]
            data[i]->gas_resistance = calc_gas_resistance_low(adc_gas_res_low, gas_range_l, dev);
   13626:	4019      	ands	r1, r3
        adc_gas_res_low = (uint16_t) ((uint32_t) buff[off + 13] * 4 | (((uint32_t) buff[off + 14]) / 64));
   13628:	9b08      	ldr	r3, [sp, #32]
   1362a:	0980      	lsrs	r0, r0, #6
   1362c:	009b      	lsls	r3, r3, #2
            data[i]->gas_resistance = calc_gas_resistance_low(adc_gas_res_low, gas_range_l, dev);
   1362e:	56aa      	ldrsb	r2, [r5, r2]
   13630:	4318      	orrs	r0, r3
   13632:	4b20      	ldr	r3, [pc, #128]	; (136b4 <bme68x_get_data+0x374>)
   13634:	4798      	blx	r3
   13636:	e7d2      	b.n	135de <bme68x_get_data+0x29e>
    else if (field[high_index]->status & BME68X_NEW_DATA_MSK)
   13638:	2b7f      	cmp	r3, #127	; 0x7f
   1363a:	d81f      	bhi.n	1367c <bme68x_get_data+0x33c>
                for (j = i + 1; j < 3; j++)
   1363c:	3201      	adds	r2, #1
   1363e:	b2d2      	uxtb	r2, r2
   13640:	2a03      	cmp	r2, #3
   13642:	d105      	bne.n	13650 <bme68x_get_data+0x310>
   13644:	3004      	adds	r0, #4
            for (i = 0; (i < 2) && (rslt == BME68X_OK); i++)
   13646:	2902      	cmp	r1, #2
   13648:	d036      	beq.n	136b8 <bme68x_get_data+0x378>
                for (j = i + 1; j < 3; j++)
   1364a:	3101      	adds	r1, #1
   1364c:	b2c9      	uxtb	r1, r1
   1364e:	000a      	movs	r2, r1
    meas_index1 = (int16_t)field[low_index]->meas_index;
   13650:	ab0a      	add	r3, sp, #40	; 0x28
   13652:	58c5      	ldr	r5, [r0, r3]
    meas_index2 = (int16_t)field[high_index]->meas_index;
   13654:	0094      	lsls	r4, r2, #2
   13656:	18e4      	adds	r4, r4, r3
   13658:	6826      	ldr	r6, [r4, #0]
    if ((field[low_index]->status & BME68X_NEW_DATA_MSK) && (field[high_index]->status & BME68X_NEW_DATA_MSK))
   1365a:	782f      	ldrb	r7, [r5, #0]
   1365c:	7833      	ldrb	r3, [r6, #0]
   1365e:	2f7f      	cmp	r7, #127	; 0x7f
   13660:	d9ea      	bls.n	13638 <bme68x_get_data+0x2f8>
   13662:	2b7f      	cmp	r3, #127	; 0x7f
   13664:	d9e8      	bls.n	13638 <bme68x_get_data+0x2f8>
        int16_t diff = meas_index2 - meas_index1;
   13666:	78af      	ldrb	r7, [r5, #2]
   13668:	78b3      	ldrb	r3, [r6, #2]
   1366a:	1bdb      	subs	r3, r3, r7
   1366c:	b29b      	uxth	r3, r3
   1366e:	b21f      	sxth	r7, r3
        if (((diff > -3) && (diff < 0)) || (diff > 2))
   13670:	3302      	adds	r3, #2
   13672:	b29b      	uxth	r3, r3
   13674:	2b01      	cmp	r3, #1
   13676:	d901      	bls.n	1367c <bme68x_get_data+0x33c>
   13678:	2f02      	cmp	r7, #2
   1367a:	dddf      	ble.n	1363c <bme68x_get_data+0x2fc>
    field[index1] = field[index2];
   1367c:	ab0a      	add	r3, sp, #40	; 0x28
   1367e:	50c6      	str	r6, [r0, r3]
    field[index2] = temp;
   13680:	6025      	str	r5, [r4, #0]
   13682:	e7db      	b.n	1363c <bme68x_get_data+0x2fc>
   13684:	00022c47 	.word	0x00022c47
   13688:	00012be9 	.word	0x00012be9
   1368c:	00012f29 	.word	0x00012f29
   13690:	00012775 	.word	0x00012775
   13694:	00012819 	.word	0x00012819
   13698:	000129bd 	.word	0x000129bd
   1369c:	fffffe00 	.word	0xfffffe00
   136a0:	00026a91 	.word	0x00026a91
   136a4:	49742400 	.word	0x49742400
   136a8:	00026439 	.word	0x00026439
   136ac:	000269f1 	.word	0x000269f1
   136b0:	00026059 	.word	0x00026059
   136b4:	00012da5 	.word	0x00012da5
   136b8:	2100      	movs	r1, #0
            for (i = 0; ((i < 3) && (rslt == BME68X_OK)); i++)
   136ba:	9b01      	ldr	r3, [sp, #4]
                data[i] = *field_ptr[i];
   136bc:	2006      	movs	r0, #6
            for (i = 0; ((i < 3) && (rslt == BME68X_OK)); i++)
   136be:	428b      	cmp	r3, r1
   136c0:	d10e      	bne.n	136e0 <bme68x_get_data+0x3a0>
                data[i] = *field_ptr[i];
   136c2:	0003      	movs	r3, r0
   136c4:	aa0a      	add	r2, sp, #40	; 0x28
   136c6:	588a      	ldr	r2, [r1, r2]
   136c8:	434b      	muls	r3, r1
   136ca:	9203      	str	r2, [sp, #12]
   136cc:	9a00      	ldr	r2, [sp, #0]
   136ce:	3104      	adds	r1, #4
   136d0:	18d3      	adds	r3, r2, r3
   136d2:	9a03      	ldr	r2, [sp, #12]
   136d4:	ca70      	ldmia	r2!, {r4, r5, r6}
   136d6:	c370      	stmia	r3!, {r4, r5, r6}
   136d8:	ca70      	ldmia	r2!, {r4, r5, r6}
   136da:	c370      	stmia	r3!, {r4, r5, r6}
            for (i = 0; ((i < 3) && (rslt == BME68X_OK)); i++)
   136dc:	290c      	cmp	r1, #12
   136de:	d1f0      	bne.n	136c2 <bme68x_get_data+0x382>
            if (new_fields == 0)
   136e0:	9b02      	ldr	r3, [sp, #8]
   136e2:	2b00      	cmp	r3, #0
   136e4:	d000      	beq.n	136e8 <bme68x_get_data+0x3a8>
   136e6:	e6d3      	b.n	13490 <bme68x_get_data+0x150>
                rslt = BME68X_W_NO_NEW_DATA;
   136e8:	2302      	movs	r3, #2
   136ea:	e007      	b.n	136fc <bme68x_get_data+0x3bc>
    uint8_t i = 0, j = 0, new_fields = 0;
   136ec:	2300      	movs	r3, #0
   136ee:	9302      	str	r3, [sp, #8]
   136f0:	e6ce      	b.n	13490 <bme68x_get_data+0x150>
                    new_fields = 0;
   136f2:	9b03      	ldr	r3, [sp, #12]
   136f4:	9302      	str	r3, [sp, #8]
   136f6:	e7f7      	b.n	136e8 <bme68x_get_data+0x3a8>
            rslt = BME68X_W_DEFINE_OP_MODE;
   136f8:	2301      	movs	r3, #1
    uint8_t i = 0, j = 0, new_fields = 0;
   136fa:	9002      	str	r0, [sp, #8]
                rslt = BME68X_W_NO_NEW_DATA;
   136fc:	9301      	str	r3, [sp, #4]
   136fe:	e6c7      	b.n	13490 <bme68x_get_data+0x150>

00013700 <bme68x_set_heatr_conf>:
{
   13700:	b5f0      	push	{r4, r5, r6, r7, lr}
   13702:	b095      	sub	sp, #84	; 0x54
   13704:	9101      	str	r1, [sp, #4]
    uint8_t ctrl_gas_addr[2] = { BME68X_REG_CTRL_GAS_0, BME68X_REG_CTRL_GAS_1 };
   13706:	4995      	ldr	r1, [pc, #596]	; (1395c <bme68x_set_heatr_conf+0x25c>)
{
   13708:	9000      	str	r0, [sp, #0]
   1370a:	9202      	str	r2, [sp, #8]
    uint8_t ctrl_gas_addr[2] = { BME68X_REG_CTRL_GAS_0, BME68X_REG_CTRL_GAS_1 };
   1370c:	4b94      	ldr	r3, [pc, #592]	; (13960 <bme68x_set_heatr_conf+0x260>)
   1370e:	2202      	movs	r2, #2
   13710:	3105      	adds	r1, #5
   13712:	a807      	add	r0, sp, #28
   13714:	4798      	blx	r3
    if (conf != NULL)
   13716:	9b01      	ldr	r3, [sp, #4]
   13718:	2b00      	cmp	r3, #0
   1371a:	d100      	bne.n	1371e <bme68x_set_heatr_conf+0x1e>
   1371c:	e118      	b.n	13950 <bme68x_set_heatr_conf+0x250>
        rslt = bme68x_set_op_mode(BME68X_SLEEP_MODE, dev);
   1371e:	9902      	ldr	r1, [sp, #8]
   13720:	2000      	movs	r0, #0
   13722:	4b90      	ldr	r3, [pc, #576]	; (13964 <bme68x_set_heatr_conf+0x264>)
   13724:	4798      	blx	r3
   13726:	1e04      	subs	r4, r0, #0
        if (rslt == BME68X_OK)
   13728:	d173      	bne.n	13812 <bme68x_set_heatr_conf+0x112>
    uint8_t heater_dur_shared_addr = BME68X_REG_SHD_HEATR_DUR;
   1372a:	226e      	movs	r2, #110	; 0x6e
   1372c:	ab06      	add	r3, sp, #24
    uint8_t rh_reg_addr[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
   1372e:	ae08      	add	r6, sp, #32
    uint8_t heater_dur_shared_addr = BME68X_REG_SHD_HEATR_DUR;
   13730:	70da      	strb	r2, [r3, #3]
    uint8_t rh_reg_addr[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
   13732:	4d8d      	ldr	r5, [pc, #564]	; (13968 <bme68x_set_heatr_conf+0x268>)
   13734:	0001      	movs	r1, r0
   13736:	3a64      	subs	r2, #100	; 0x64
   13738:	0030      	movs	r0, r6
   1373a:	47a8      	blx	r5
    uint8_t rh_reg_data[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
   1373c:	220a      	movs	r2, #10
   1373e:	0021      	movs	r1, r4
   13740:	a80b      	add	r0, sp, #44	; 0x2c
   13742:	47a8      	blx	r5
    uint8_t gw_reg_data[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
   13744:	af11      	add	r7, sp, #68	; 0x44
    uint8_t gw_reg_addr[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
   13746:	220a      	movs	r2, #10
   13748:	0021      	movs	r1, r4
   1374a:	a80e      	add	r0, sp, #56	; 0x38
   1374c:	47a8      	blx	r5
    uint8_t gw_reg_data[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
   1374e:	220a      	movs	r2, #10
   13750:	0021      	movs	r1, r4
   13752:	0038      	movs	r0, r7
   13754:	47a8      	blx	r5
    switch (op_mode)
   13756:	9b00      	ldr	r3, [sp, #0]
   13758:	2b02      	cmp	r3, #2
   1375a:	d100      	bne.n	1375e <bme68x_set_heatr_conf+0x5e>
   1375c:	e099      	b.n	13892 <bme68x_set_heatr_conf+0x192>
   1375e:	2b03      	cmp	r3, #3
   13760:	d05e      	beq.n	13820 <bme68x_set_heatr_conf+0x120>
   13762:	2b01      	cmp	r3, #1
   13764:	d000      	beq.n	13768 <bme68x_set_heatr_conf+0x68>
   13766:	e0f6      	b.n	13956 <bme68x_set_heatr_conf+0x256>
            rh_reg_addr[0] = BME68X_REG_RES_HEAT0;
   13768:	3359      	adds	r3, #89	; 0x59
   1376a:	7033      	strb	r3, [r6, #0]
            rh_reg_data[0] = calc_res_heat(conf->heatr_temp, dev);
   1376c:	9b01      	ldr	r3, [sp, #4]
   1376e:	9902      	ldr	r1, [sp, #8]
   13770:	8858      	ldrh	r0, [r3, #2]
   13772:	4b7e      	ldr	r3, [pc, #504]	; (1396c <bme68x_set_heatr_conf+0x26c>)
   13774:	4798      	blx	r3
   13776:	ab06      	add	r3, sp, #24
            gw_reg_addr[0] = BME68X_REG_GAS_WAIT0;
   13778:	2120      	movs	r1, #32
            rh_reg_data[0] = calc_res_heat(conf->heatr_temp, dev);
   1377a:	7518      	strb	r0, [r3, #20]
            gw_reg_addr[0] = BME68X_REG_GAS_WAIT0;
   1377c:	2364      	movs	r3, #100	; 0x64
   1377e:	aa06      	add	r2, sp, #24
   13780:	1852      	adds	r2, r2, r1
   13782:	7013      	strb	r3, [r2, #0]
            gw_reg_data[0] = calc_gas_wait(conf->heatr_dur);
   13784:	9b01      	ldr	r3, [sp, #4]
    if (dur >= 0xfc0)
   13786:	497a      	ldr	r1, [pc, #488]	; (13970 <bme68x_set_heatr_conf+0x270>)
            gw_reg_data[0] = calc_gas_wait(conf->heatr_dur);
   13788:	889a      	ldrh	r2, [r3, #4]
        durval = 0xff; /* Max duration*/
   1378a:	23ff      	movs	r3, #255	; 0xff
    if (dur >= 0xfc0)
   1378c:	428a      	cmp	r2, r1
   1378e:	d804      	bhi.n	1379a <bme68x_set_heatr_conf+0x9a>
        while (dur > 0x3F)
   13790:	2a3f      	cmp	r2, #63	; 0x3f
   13792:	d841      	bhi.n	13818 <bme68x_set_heatr_conf+0x118>
        durval = (uint8_t)(dur + (factor * 64));
   13794:	01a4      	lsls	r4, r4, #6
   13796:	18a4      	adds	r4, r4, r2
   13798:	b2e3      	uxtb	r3, r4
            (*nb_conv) = 0;
   1379a:	2600      	movs	r6, #0
            gw_reg_data[0] = calc_gas_wait(conf->heatr_dur);
   1379c:	703b      	strb	r3, [r7, #0]
        rslt = bme68x_set_regs(rh_reg_addr, rh_reg_data, write_len, dev);
   1379e:	9b02      	ldr	r3, [sp, #8]
   137a0:	9a00      	ldr	r2, [sp, #0]
   137a2:	a90b      	add	r1, sp, #44	; 0x2c
   137a4:	a808      	add	r0, sp, #32
   137a6:	4f73      	ldr	r7, [pc, #460]	; (13974 <bme68x_set_heatr_conf+0x274>)
   137a8:	47b8      	blx	r7
   137aa:	1e04      	subs	r4, r0, #0
    if (rslt == BME68X_OK)
   137ac:	d131      	bne.n	13812 <bme68x_set_heatr_conf+0x112>
        rslt = bme68x_set_regs(gw_reg_addr, gw_reg_data, write_len, dev);
   137ae:	ad11      	add	r5, sp, #68	; 0x44
   137b0:	9b02      	ldr	r3, [sp, #8]
   137b2:	9a00      	ldr	r2, [sp, #0]
   137b4:	0029      	movs	r1, r5
   137b6:	a80e      	add	r0, sp, #56	; 0x38
   137b8:	47b8      	blx	r7
   137ba:	1e04      	subs	r4, r0, #0
        if (rslt == BME68X_OK)
   137bc:	d129      	bne.n	13812 <bme68x_set_heatr_conf+0x112>
            rslt = bme68x_get_regs(BME68X_REG_CTRL_GAS_0, ctrl_gas_data, 2, dev);
   137be:	4c6e      	ldr	r4, [pc, #440]	; (13978 <bme68x_set_heatr_conf+0x278>)
   137c0:	9b02      	ldr	r3, [sp, #8]
   137c2:	2202      	movs	r2, #2
   137c4:	0029      	movs	r1, r5
   137c6:	2070      	movs	r0, #112	; 0x70
   137c8:	47a0      	blx	r4
   137ca:	1e04      	subs	r4, r0, #0
            if (rslt == BME68X_OK)
   137cc:	d121      	bne.n	13812 <bme68x_set_heatr_conf+0x112>
                if (conf->enable == BME68X_ENABLE)
   137ce:	9b01      	ldr	r3, [sp, #4]
   137d0:	781a      	ldrb	r2, [r3, #0]
   137d2:	2a01      	cmp	r2, #1
   137d4:	d000      	beq.n	137d8 <bme68x_set_heatr_conf+0xd8>
   137d6:	e0b6      	b.n	13946 <bme68x_set_heatr_conf+0x246>
                    if (dev->variant_id == BME68X_VARIANT_GAS_HIGH)
   137d8:	9b02      	ldr	r3, [sp, #8]
   137da:	689b      	ldr	r3, [r3, #8]
   137dc:	9300      	str	r3, [sp, #0]
   137de:	2b01      	cmp	r3, #1
   137e0:	d100      	bne.n	137e4 <bme68x_set_heatr_conf+0xe4>
   137e2:	e0b3      	b.n	1394c <bme68x_set_heatr_conf+0x24c>
                ctrl_gas_data[0] = BME68X_SET_BITS(ctrl_gas_data[0], BME68X_HCTRL, hctrl);
   137e4:	2108      	movs	r1, #8
   137e6:	782b      	ldrb	r3, [r5, #0]
   137e8:	00e4      	lsls	r4, r4, #3
   137ea:	438b      	bics	r3, r1
   137ec:	431c      	orrs	r4, r3
                ctrl_gas_data[1] = BME68X_SET_BITS_POS_0(ctrl_gas_data[1], BME68X_NBCONV, nb_conv);
   137ee:	786b      	ldrb	r3, [r5, #1]
   137f0:	3107      	adds	r1, #7
   137f2:	438b      	bics	r3, r1
   137f4:	400e      	ands	r6, r1
   137f6:	431e      	orrs	r6, r3
                ctrl_gas_data[1] = BME68X_SET_BITS(ctrl_gas_data[1], BME68X_RUN_GAS, run_gas);
   137f8:	2330      	movs	r3, #48	; 0x30
   137fa:	0112      	lsls	r2, r2, #4
   137fc:	439e      	bics	r6, r3
                ctrl_gas_data[0] = BME68X_SET_BITS(ctrl_gas_data[0], BME68X_HCTRL, hctrl);
   137fe:	702c      	strb	r4, [r5, #0]
                ctrl_gas_data[1] = BME68X_SET_BITS(ctrl_gas_data[1], BME68X_RUN_GAS, run_gas);
   13800:	4316      	orrs	r6, r2
                rslt = bme68x_set_regs(ctrl_gas_addr, ctrl_gas_data, 2, dev);
   13802:	4c5c      	ldr	r4, [pc, #368]	; (13974 <bme68x_set_heatr_conf+0x274>)
   13804:	9b02      	ldr	r3, [sp, #8]
   13806:	2202      	movs	r2, #2
   13808:	0029      	movs	r1, r5
   1380a:	a807      	add	r0, sp, #28
                ctrl_gas_data[1] = BME68X_SET_BITS(ctrl_gas_data[1], BME68X_RUN_GAS, run_gas);
   1380c:	706e      	strb	r6, [r5, #1]
                rslt = bme68x_set_regs(ctrl_gas_addr, ctrl_gas_data, 2, dev);
   1380e:	47a0      	blx	r4
   13810:	0004      	movs	r4, r0
}
   13812:	0020      	movs	r0, r4
   13814:	b015      	add	sp, #84	; 0x54
   13816:	bdf0      	pop	{r4, r5, r6, r7, pc}
            factor += 1;
   13818:	3401      	adds	r4, #1
            dur = dur / 4;
   1381a:	0892      	lsrs	r2, r2, #2
            factor += 1;
   1381c:	b2e4      	uxtb	r4, r4
   1381e:	e7b7      	b.n	13790 <bme68x_set_heatr_conf+0x90>
            if ((!conf->heatr_dur_prof) || (!conf->heatr_temp_prof))
   13820:	9b01      	ldr	r3, [sp, #4]
   13822:	68dd      	ldr	r5, [r3, #12]
   13824:	2d00      	cmp	r5, #0
   13826:	d100      	bne.n	1382a <bme68x_set_heatr_conf+0x12a>
   13828:	e092      	b.n	13950 <bme68x_set_heatr_conf+0x250>
   1382a:	689b      	ldr	r3, [r3, #8]
   1382c:	9303      	str	r3, [sp, #12]
   1382e:	2b00      	cmp	r3, #0
   13830:	d100      	bne.n	13834 <bme68x_set_heatr_conf+0x134>
   13832:	e08d      	b.n	13950 <bme68x_set_heatr_conf+0x250>
            for (i = 0; i < conf->profile_len; i++)
   13834:	0027      	movs	r7, r4
   13836:	9b01      	ldr	r3, [sp, #4]
   13838:	7c1b      	ldrb	r3, [r3, #16]
                rh_reg_addr[i] = BME68X_REG_RES_HEAT0 + i;
   1383a:	9604      	str	r6, [sp, #16]
            for (i = 0; i < conf->profile_len; i++)
   1383c:	9300      	str	r3, [sp, #0]
                rh_reg_data[i] = calc_res_heat(conf->heatr_temp_prof[i], dev);
   1383e:	ab0b      	add	r3, sp, #44	; 0x2c
   13840:	9305      	str	r3, [sp, #20]
            for (i = 0; i < conf->profile_len; i++)
   13842:	9b00      	ldr	r3, [sp, #0]
   13844:	b2fc      	uxtb	r4, r7
   13846:	42a3      	cmp	r3, r4
   13848:	d801      	bhi.n	1384e <bme68x_set_heatr_conf+0x14e>
   1384a:	001e      	movs	r6, r3
   1384c:	e7a7      	b.n	1379e <bme68x_set_heatr_conf+0x9e>
                rh_reg_addr[i] = BME68X_REG_RES_HEAT0 + i;
   1384e:	0023      	movs	r3, r4
   13850:	9a04      	ldr	r2, [sp, #16]
   13852:	335a      	adds	r3, #90	; 0x5a
   13854:	54bb      	strb	r3, [r7, r2]
                rh_reg_data[i] = calc_res_heat(conf->heatr_temp_prof[i], dev);
   13856:	9b03      	ldr	r3, [sp, #12]
   13858:	007e      	lsls	r6, r7, #1
   1385a:	5b98      	ldrh	r0, [r3, r6]
   1385c:	9902      	ldr	r1, [sp, #8]
   1385e:	4b43      	ldr	r3, [pc, #268]	; (1396c <bme68x_set_heatr_conf+0x26c>)
   13860:	4798      	blx	r3
   13862:	9b05      	ldr	r3, [sp, #20]
                gw_reg_addr[i] = BME68X_REG_GAS_WAIT0 + i;
   13864:	3464      	adds	r4, #100	; 0x64
                rh_reg_data[i] = calc_res_heat(conf->heatr_temp_prof[i], dev);
   13866:	54f8      	strb	r0, [r7, r3]
                gw_reg_addr[i] = BME68X_REG_GAS_WAIT0 + i;
   13868:	ab0e      	add	r3, sp, #56	; 0x38
   1386a:	54fc      	strb	r4, [r7, r3]
                gw_reg_data[i] = calc_gas_wait(conf->heatr_dur_prof[i]);
   1386c:	5ba9      	ldrh	r1, [r5, r6]
    if (dur >= 0xfc0)
   1386e:	4b40      	ldr	r3, [pc, #256]	; (13970 <bme68x_set_heatr_conf+0x270>)
        durval = 0xff; /* Max duration*/
   13870:	22ff      	movs	r2, #255	; 0xff
    if (dur >= 0xfc0)
   13872:	4299      	cmp	r1, r3
   13874:	d805      	bhi.n	13882 <bme68x_set_heatr_conf+0x182>
   13876:	2300      	movs	r3, #0
        while (dur > 0x3F)
   13878:	293f      	cmp	r1, #63	; 0x3f
   1387a:	d806      	bhi.n	1388a <bme68x_set_heatr_conf+0x18a>
        durval = (uint8_t)(dur + (factor * 64));
   1387c:	019b      	lsls	r3, r3, #6
   1387e:	185b      	adds	r3, r3, r1
   13880:	b2da      	uxtb	r2, r3
                gw_reg_data[i] = calc_gas_wait(conf->heatr_dur_prof[i]);
   13882:	ab11      	add	r3, sp, #68	; 0x44
   13884:	54fa      	strb	r2, [r7, r3]
   13886:	3701      	adds	r7, #1
   13888:	e7db      	b.n	13842 <bme68x_set_heatr_conf+0x142>
            factor += 1;
   1388a:	3301      	adds	r3, #1
            dur = dur / 4;
   1388c:	0889      	lsrs	r1, r1, #2
            factor += 1;
   1388e:	b2db      	uxtb	r3, r3
   13890:	e7f2      	b.n	13878 <bme68x_set_heatr_conf+0x178>
            if ((!conf->heatr_dur_prof) || (!conf->heatr_temp_prof))
   13892:	9b01      	ldr	r3, [sp, #4]
   13894:	68db      	ldr	r3, [r3, #12]
   13896:	9303      	str	r3, [sp, #12]
   13898:	2b00      	cmp	r3, #0
   1389a:	d059      	beq.n	13950 <bme68x_set_heatr_conf+0x250>
   1389c:	9b01      	ldr	r3, [sp, #4]
   1389e:	689b      	ldr	r3, [r3, #8]
   138a0:	9304      	str	r3, [sp, #16]
   138a2:	2b00      	cmp	r3, #0
   138a4:	d054      	beq.n	13950 <bme68x_set_heatr_conf+0x250>
            if (conf->shared_heatr_dur == 0)
   138a6:	9b01      	ldr	r3, [sp, #4]
   138a8:	8a5f      	ldrh	r7, [r3, #18]
   138aa:	2f00      	cmp	r7, #0
   138ac:	d100      	bne.n	138b0 <bme68x_set_heatr_conf+0x1b0>
                rslt = BME68X_W_DEFINE_SHD_HEATR_DUR;
   138ae:	2403      	movs	r4, #3
            for (i = 0; i < conf->profile_len; i++)
   138b0:	2500      	movs	r5, #0
   138b2:	9b01      	ldr	r3, [sp, #4]
   138b4:	7c1b      	ldrb	r3, [r3, #16]
   138b6:	9300      	str	r3, [sp, #0]
   138b8:	9b00      	ldr	r3, [sp, #0]
   138ba:	b2ee      	uxtb	r6, r5
   138bc:	42b3      	cmp	r3, r6
   138be:	d822      	bhi.n	13906 <bme68x_set_heatr_conf+0x206>
    if (dur >= 0x783)
   138c0:	4a2e      	ldr	r2, [pc, #184]	; (1397c <bme68x_set_heatr_conf+0x27c>)
        heatdurval = 0xff; /* Max duration */
   138c2:	23ff      	movs	r3, #255	; 0xff
    if (dur >= 0x783)
   138c4:	4297      	cmp	r7, r2
   138c6:	d80d      	bhi.n	138e4 <bme68x_set_heatr_conf+0x1e4>
        dur = (uint16_t)(((uint32_t)dur * 1000) / 477);
   138c8:	20fa      	movs	r0, #250	; 0xfa
   138ca:	21de      	movs	r1, #222	; 0xde
   138cc:	0080      	lsls	r0, r0, #2
   138ce:	4b2c      	ldr	r3, [pc, #176]	; (13980 <bme68x_set_heatr_conf+0x280>)
   138d0:	4378      	muls	r0, r7
   138d2:	31ff      	adds	r1, #255	; 0xff
   138d4:	4798      	blx	r3
    uint8_t factor = 0;
   138d6:	2300      	movs	r3, #0
        dur = (uint16_t)(((uint32_t)dur * 1000) / 477);
   138d8:	b280      	uxth	r0, r0
        while (dur > 0x3F)
   138da:	283f      	cmp	r0, #63	; 0x3f
   138dc:	d82f      	bhi.n	1393e <bme68x_set_heatr_conf+0x23e>
        heatdurval = (uint8_t)(dur + (factor * 64));
   138de:	019b      	lsls	r3, r3, #6
   138e0:	181b      	adds	r3, r3, r0
   138e2:	b2db      	uxtb	r3, r3
            shared_dur = calc_heatr_dur_shared(conf->shared_heatr_dur);
   138e4:	aa06      	add	r2, sp, #24
   138e6:	1c91      	adds	r1, r2, #2
   138e8:	700b      	strb	r3, [r1, #0]
            if (rslt == BME68X_OK)
   138ea:	2c00      	cmp	r4, #0
   138ec:	d000      	beq.n	138f0 <bme68x_set_heatr_conf+0x1f0>
   138ee:	e790      	b.n	13812 <bme68x_set_heatr_conf+0x112>
                rslt = bme68x_set_regs(&heater_dur_shared_addr, &shared_dur, 1, dev);
   138f0:	a806      	add	r0, sp, #24
   138f2:	4c20      	ldr	r4, [pc, #128]	; (13974 <bme68x_set_heatr_conf+0x274>)
   138f4:	9b02      	ldr	r3, [sp, #8]
   138f6:	2201      	movs	r2, #1
   138f8:	3003      	adds	r0, #3
   138fa:	47a0      	blx	r4
   138fc:	1e04      	subs	r4, r0, #0
    if (rslt == BME68X_OK)
   138fe:	d000      	beq.n	13902 <bme68x_set_heatr_conf+0x202>
   13900:	e787      	b.n	13812 <bme68x_set_heatr_conf+0x112>
   13902:	9e00      	ldr	r6, [sp, #0]
   13904:	e74b      	b.n	1379e <bme68x_set_heatr_conf+0x9e>
                rh_reg_addr[i] = BME68X_REG_RES_HEAT0 + i;
   13906:	0033      	movs	r3, r6
   13908:	2108      	movs	r1, #8
   1390a:	aa06      	add	r2, sp, #24
   1390c:	1852      	adds	r2, r2, r1
   1390e:	335a      	adds	r3, #90	; 0x5a
   13910:	5553      	strb	r3, [r2, r5]
                rh_reg_data[i] = calc_res_heat(conf->heatr_temp_prof[i], dev);
   13912:	9b04      	ldr	r3, [sp, #16]
   13914:	006a      	lsls	r2, r5, #1
   13916:	5a98      	ldrh	r0, [r3, r2]
   13918:	9902      	ldr	r1, [sp, #8]
   1391a:	4b14      	ldr	r3, [pc, #80]	; (1396c <bme68x_set_heatr_conf+0x26c>)
   1391c:	4798      	blx	r3
   1391e:	2214      	movs	r2, #20
   13920:	ab06      	add	r3, sp, #24
   13922:	189b      	adds	r3, r3, r2
   13924:	5558      	strb	r0, [r3, r5]
                gw_reg_addr[i] = BME68X_REG_GAS_WAIT0 + i;
   13926:	320c      	adds	r2, #12
   13928:	ab06      	add	r3, sp, #24
   1392a:	189b      	adds	r3, r3, r2
   1392c:	3664      	adds	r6, #100	; 0x64
   1392e:	555e      	strb	r6, [r3, r5]
                gw_reg_data[i] = (uint8_t) conf->heatr_dur_prof[i];
   13930:	9b03      	ldr	r3, [sp, #12]
   13932:	006a      	lsls	r2, r5, #1
   13934:	5a9a      	ldrh	r2, [r3, r2]
   13936:	ab11      	add	r3, sp, #68	; 0x44
   13938:	54ea      	strb	r2, [r5, r3]
   1393a:	3501      	adds	r5, #1
   1393c:	e7bc      	b.n	138b8 <bme68x_set_heatr_conf+0x1b8>
            factor += 1;
   1393e:	3301      	adds	r3, #1
            dur = dur >> 2;
   13940:	0880      	lsrs	r0, r0, #2
            factor += 1;
   13942:	b2db      	uxtb	r3, r3
   13944:	e7c9      	b.n	138da <bme68x_set_heatr_conf+0x1da>
                    run_gas = BME68X_DISABLE_GAS_MEAS;
   13946:	0002      	movs	r2, r0
                    hctrl = BME68X_DISABLE_HEATER;
   13948:	2401      	movs	r4, #1
   1394a:	e74b      	b.n	137e4 <bme68x_set_heatr_conf+0xe4>
                        run_gas = BME68X_ENABLE_GAS_MEAS_H;
   1394c:	2202      	movs	r2, #2
   1394e:	e749      	b.n	137e4 <bme68x_set_heatr_conf+0xe4>
                rslt = BME68X_E_NULL_PTR;
   13950:	2401      	movs	r4, #1
   13952:	4264      	negs	r4, r4
   13954:	e75d      	b.n	13812 <bme68x_set_heatr_conf+0x112>
            rslt = BME68X_W_DEFINE_OP_MODE;
   13956:	2401      	movs	r4, #1
    return rslt;
   13958:	e75b      	b.n	13812 <bme68x_set_heatr_conf+0x112>
   1395a:	46c0      	nop			; (mov r8, r8)
   1395c:	000287cc 	.word	0x000287cc
   13960:	00022c11 	.word	0x00022c11
   13964:	00013155 	.word	0x00013155
   13968:	00022c47 	.word	0x00022c47
   1396c:	00012ae1 	.word	0x00012ae1
   13970:	00000fbf 	.word	0x00000fbf
   13974:	00012e81 	.word	0x00012e81
   13978:	00012f29 	.word	0x00012f29
   1397c:	00000782 	.word	0x00000782
   13980:	000258bd 	.word	0x000258bd

00013984 <bme68x_default_config>:
	conf.os_pres = BME68X_OS_16X;
   13984:	2305      	movs	r3, #5
int8_t bme68x_default_config(struct bme68x_dev *dev) {
   13986:	b530      	push	{r4, r5, lr}
   13988:	0005      	movs	r5, r0
	conf.os_hum = BME68X_OS_1X;
   1398a:	2401      	movs	r4, #1
int8_t bme68x_default_config(struct bme68x_dev *dev) {
   1398c:	b089      	sub	sp, #36	; 0x24
	conf.os_hum = BME68X_OS_1X;
   1398e:	a801      	add	r0, sp, #4
	conf.os_pres = BME68X_OS_16X;
   13990:	7083      	strb	r3, [r0, #2]
	conf.os_temp = BME68X_OS_2X;
   13992:	3b03      	subs	r3, #3
	rslt = bme68x_set_conf(&conf, dev);
   13994:	0029      	movs	r1, r5
	conf.os_temp = BME68X_OS_2X;
   13996:	7043      	strb	r3, [r0, #1]
	rslt = bme68x_set_conf(&conf, dev);
   13998:	4b08      	ldr	r3, [pc, #32]	; (139bc <bme68x_default_config+0x38>)
	conf.os_hum = BME68X_OS_1X;
   1399a:	7004      	strb	r4, [r0, #0]
	rslt = bme68x_set_conf(&conf, dev);
   1399c:	4798      	blx	r3
	heatr_conf.heatr_dur = BME68X_HEATR_DUR1;
   1399e:	23fa      	movs	r3, #250	; 0xfa
	heatr_conf.enable = BME68X_ENABLE;
   139a0:	a903      	add	r1, sp, #12
	heatr_conf.heatr_dur = BME68X_HEATR_DUR1;
   139a2:	009b      	lsls	r3, r3, #2
   139a4:	808b      	strh	r3, [r1, #4]
	heatr_conf.heatr_temp = BME68X_HIGH_TEMP;
   139a6:	23af      	movs	r3, #175	; 0xaf
   139a8:	005b      	lsls	r3, r3, #1
   139aa:	804b      	strh	r3, [r1, #2]
	rslt = bme68x_set_heatr_conf(BME68X_FORCED_MODE, &heatr_conf, dev);
   139ac:	002a      	movs	r2, r5
   139ae:	0020      	movs	r0, r4
   139b0:	4b03      	ldr	r3, [pc, #12]	; (139c0 <bme68x_default_config+0x3c>)
	heatr_conf.enable = BME68X_ENABLE;
   139b2:	700c      	strb	r4, [r1, #0]
	rslt = bme68x_set_heatr_conf(BME68X_FORCED_MODE, &heatr_conf, dev);
   139b4:	4798      	blx	r3
}
   139b6:	b009      	add	sp, #36	; 0x24
   139b8:	bd30      	pop	{r4, r5, pc}
   139ba:	46c0      	nop			; (mov r8, r8)
   139bc:	00013201 	.word	0x00013201
   139c0:	00013701 	.word	0x00013701

000139c4 <bme68x_interface_init>:
/*!
 * BME680 interface init function. Maps platform specific functions to 
 * device descriptor.
 */
int8_t bme68x_interface_init(struct bme68x_dev *bme, uint8_t intf)
{
   139c4:	b537      	push	{r0, r1, r2, r4, r5, lr}
   139c6:	1e04      	subs	r4, r0, #0
	// Assuming the I2C has been initialized before. 
    int8_t rslt = BME68X_OK;
	uint8_t dev_addr;

    if (bme != NULL)
   139c8:	d014      	beq.n	139f4 <bme68x_interface_init+0x30>
   139ca:	466b      	mov	r3, sp
   139cc:	1ddd      	adds	r5, r3, #7

#if defined(PC)
        setbuf(stdout, NULL);
#endif
        /* Bus configuration : I2C */
        if (intf == BME68X_I2C_INTF)
   139ce:	2901      	cmp	r1, #1
   139d0:	d106      	bne.n	139e0 <bme68x_interface_init+0x1c>
        {
            dev_addr = BME68X_I2C_ADDR_HIGH;
   139d2:	2377      	movs	r3, #119	; 0x77
   139d4:	702b      	strb	r3, [r5, #0]
            bme->read = bme68x_i2c_read;
   139d6:	4b09      	ldr	r3, [pc, #36]	; (139fc <bme68x_interface_init+0x38>)
            bme->write = bme68x_i2c_write;
            bme->intf = BME68X_I2C_INTF;
   139d8:	7301      	strb	r1, [r0, #12]
            bme->read = bme68x_i2c_read;
   139da:	6403      	str	r3, [r0, #64]	; 0x40
            bme->write = bme68x_i2c_write;
   139dc:	4b08      	ldr	r3, [pc, #32]	; (13a00 <bme68x_interface_init+0x3c>)
   139de:	6443      	str	r3, [r0, #68]	; 0x44
        else if (intf == BME68X_SPI_INTF)
        {
			/* Not required for our application */
        }

        delay_ms(100);
   139e0:	2064      	movs	r0, #100	; 0x64
   139e2:	4b08      	ldr	r3, [pc, #32]	; (13a04 <bme68x_interface_init+0x40>)
   139e4:	4798      	blx	r3

        bme->delay__us = bme68x_delay__us;
   139e6:	4b08      	ldr	r3, [pc, #32]	; (13a08 <bme68x_interface_init+0x44>)
    int8_t rslt = BME68X_OK;
   139e8:	2000      	movs	r0, #0
        bme->delay__us = bme68x_delay__us;
   139ea:	64a3      	str	r3, [r4, #72]	; 0x48
        bme->intf_ptr = &dev_addr;
        bme->amb_temp = 25; /* The ambient temperature in deg C is used for defining the heater temperature */
   139ec:	2319      	movs	r3, #25
        bme->intf_ptr = &dev_addr;
   139ee:	6065      	str	r5, [r4, #4]
        bme->amb_temp = 25; /* The ambient temperature in deg C is used for defining the heater temperature */
   139f0:	73a3      	strb	r3, [r4, #14]
    {
        rslt = BME68X_E_NULL_PTR;
    }

    return rslt;
}
   139f2:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
        rslt = BME68X_E_NULL_PTR;
   139f4:	2001      	movs	r0, #1
   139f6:	4240      	negs	r0, r0
   139f8:	e7fb      	b.n	139f2 <bme68x_interface_init+0x2e>
   139fa:	46c0      	nop			; (mov r8, r8)
   139fc:	00012ce5 	.word	0x00012ce5
   13a00:	00012d2d 	.word	0x00012d2d
   13a04:	0001a3b1 	.word	0x0001a3b1
   13a08:	00012d6d 	.word	0x00012d6d

00013a0c <CLI_GetEnvData>:
/******************************************************************************
 * CLI Functions - Define here
 ******************************************************************************/
// CLI_GetImuData. Reads from the environmental sensor queue.
BaseType_t CLI_GetEnvData( int8_t *pcWriteBuffer,size_t xWriteBufferLen,const int8_t *pcCommandString )
{
   13a0c:	b570      	push	{r4, r5, r6, lr}
   13a0e:	b0aa      	sub	sp, #168	; 0xa8
	struct bme68x_data data[BME68X_N_MEAS] = { { 0 } };
   13a10:	2290      	movs	r2, #144	; 0x90
   13a12:	4b11      	ldr	r3, [pc, #68]	; (13a58 <CLI_GetEnvData+0x4c>)
{
   13a14:	0005      	movs	r5, r0
   13a16:	000e      	movs	r6, r1
	struct bme68x_data data[BME68X_N_MEAS] = { { 0 } };
   13a18:	a806      	add	r0, sp, #24
   13a1a:	2100      	movs	r1, #0
   13a1c:	4798      	blx	r3
	
	if (pdPASS == xQueueReceive(xQueueBmeCliBuffer, &data[0], 0)) {
   13a1e:	4b0f      	ldr	r3, [pc, #60]	; (13a5c <CLI_GetEnvData+0x50>)
   13a20:	2200      	movs	r2, #0
   13a22:	6818      	ldr	r0, [r3, #0]
   13a24:	a906      	add	r1, sp, #24
   13a26:	4b0e      	ldr	r3, [pc, #56]	; (13a60 <CLI_GetEnvData+0x54>)
   13a28:	4798      	blx	r3
   13a2a:	2801      	cmp	r0, #1
   13a2c:	d111      	bne.n	13a52 <CLI_GetEnvData+0x46>
		snprintf(pcWriteBuffer, xWriteBufferLen, "T: %0.2f H: %0.2f P: %0.2f \r\n", data[0].temperature, data[0].humidity, data[0].pressure);
   13a2e:	4c0d      	ldr	r4, [pc, #52]	; (13a64 <CLI_GetEnvData+0x58>)
   13a30:	9809      	ldr	r0, [sp, #36]	; 0x24
   13a32:	47a0      	blx	r4
   13a34:	9004      	str	r0, [sp, #16]
   13a36:	9105      	str	r1, [sp, #20]
   13a38:	980a      	ldr	r0, [sp, #40]	; 0x28
   13a3a:	47a0      	blx	r4
   13a3c:	9002      	str	r0, [sp, #8]
   13a3e:	9103      	str	r1, [sp, #12]
   13a40:	9808      	ldr	r0, [sp, #32]
   13a42:	47a0      	blx	r4
   13a44:	4a08      	ldr	r2, [pc, #32]	; (13a68 <CLI_GetEnvData+0x5c>)
   13a46:	9000      	str	r0, [sp, #0]
   13a48:	9101      	str	r1, [sp, #4]
   13a4a:	4b08      	ldr	r3, [pc, #32]	; (13a6c <CLI_GetEnvData+0x60>)
   13a4c:	0031      	movs	r1, r6
   13a4e:	0028      	movs	r0, r5
   13a50:	4798      	blx	r3
	}
	
	return pdFALSE;
}
   13a52:	2000      	movs	r0, #0
   13a54:	b02a      	add	sp, #168	; 0xa8
   13a56:	bd70      	pop	{r4, r5, r6, pc}
   13a58:	00022c47 	.word	0x00022c47
   13a5c:	200004e0 	.word	0x200004e0
   13a60:	00017905 	.word	0x00017905
   13a64:	0002866d 	.word	0x0002866d
   13a68:	000287ed 	.word	0x000287ed
   13a6c:	00023781 	.word	0x00023781

00013a70 <xCliClearTerminalScreen>:
// THIS COMMAND USES vt100 TERMINAL COMMANDS TO CLEAR THE SCREEN ON A TERMINAL PROGRAM LIKE TERA TERM
// SEE http://www.csie.ntu.edu.tw/~r92094/c++/VT100.html for more info
// CLI SPECIFIC COMMANDS
static char bufCli[CLI_MSG_LEN];
BaseType_t xCliClearTerminalScreen(char *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString)
{
   13a70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   13a72:	0006      	movs	r6, r0
   13a74:	000f      	movs	r7, r1
    char clearScreen = ASCII_ESC;
    snprintf(bufCli, CLI_MSG_LEN - 1, "%c[2J", clearScreen);
   13a76:	4d06      	ldr	r5, [pc, #24]	; (13a90 <xCliClearTerminalScreen+0x20>)
   13a78:	231b      	movs	r3, #27
   13a7a:	0028      	movs	r0, r5
   13a7c:	4c05      	ldr	r4, [pc, #20]	; (13a94 <xCliClearTerminalScreen+0x24>)
   13a7e:	4a06      	ldr	r2, [pc, #24]	; (13a98 <xCliClearTerminalScreen+0x28>)
   13a80:	210f      	movs	r1, #15
   13a82:	47a0      	blx	r4
    snprintf(pcWriteBuffer, xWriteBufferLen, bufCli);
   13a84:	002a      	movs	r2, r5
   13a86:	0039      	movs	r1, r7
   13a88:	0030      	movs	r0, r6
   13a8a:	47a0      	blx	r4
    return pdFALSE;
}
   13a8c:	2000      	movs	r0, #0
   13a8e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   13a90:	20000470 	.word	0x20000470
   13a94:	00023781 	.word	0x00023781
   13a98:	000289e0 	.word	0x000289e0

00013a9c <CLI_OTAU>:
{
	//f_unlink(bootloader_flag);
	
	FIL file_object;
	
	bootloader_flag[0] = LUN_ID_SD_MMC_0_MEM + '0';
   13a9c:	2330      	movs	r3, #48	; 0x30
{
   13a9e:	b510      	push	{r4, lr}
	bootloader_flag[0] = LUN_ID_SD_MMC_0_MEM + '0';
   13aa0:	4910      	ldr	r1, [pc, #64]	; (13ae4 <CLI_OTAU+0x48>)
{
   13aa2:	b08a      	sub	sp, #40	; 0x28
	bootloader_flag[0] = LUN_ID_SD_MMC_0_MEM + '0';
   13aa4:	700b      	strb	r3, [r1, #0]
	FRESULT res = f_open(&file_object, (char const *)bootloader_flag, FA_CREATE_ALWAYS | FA_WRITE);
   13aa6:	220a      	movs	r2, #10
   13aa8:	a801      	add	r0, sp, #4
   13aaa:	4b0f      	ldr	r3, [pc, #60]	; (13ae8 <CLI_OTAU+0x4c>)
   13aac:	4798      	blx	r3
   13aae:	4c0f      	ldr	r4, [pc, #60]	; (13aec <CLI_OTAU+0x50>)
   13ab0:	1e02      	subs	r2, r0, #0

	if (res != FR_OK) {
   13ab2:	d013      	beq.n	13adc <CLI_OTAU+0x40>
		LogMessage(LOG_INFO_LVL, "[FAIL] res %d\r\n", res);
   13ab4:	490e      	ldr	r1, [pc, #56]	; (13af0 <CLI_OTAU+0x54>)
   13ab6:	2000      	movs	r0, #0
   13ab8:	4b0e      	ldr	r3, [pc, #56]	; (13af4 <CLI_OTAU+0x58>)
   13aba:	4798      	blx	r3
		} else {
		SerialConsoleWriteString("boot_flag.txt added!\r\n");
	}
	
	WifiHandlerSetState(WIFI_DOWNLOAD_INIT);
   13abc:	2002      	movs	r0, #2
   13abe:	4b0e      	ldr	r3, [pc, #56]	; (13af8 <CLI_OTAU+0x5c>)
   13ac0:	4798      	blx	r3
	const TickType_t xDelay= 70000 / portTICK_PERIOD_MS;
	vTaskDelay( xDelay );
   13ac2:	4b0e      	ldr	r3, [pc, #56]	; (13afc <CLI_OTAU+0x60>)
   13ac4:	480e      	ldr	r0, [pc, #56]	; (13b00 <CLI_OTAU+0x64>)
   13ac6:	4798      	blx	r3
	
	SerialConsoleWriteString("Reseting for FW!\r\n");
   13ac8:	480e      	ldr	r0, [pc, #56]	; (13b04 <CLI_OTAU+0x68>)
   13aca:	47a0      	blx	r4
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
   13acc:	f3bf 8f4f 	dsb	sy
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                     /* Ensure all outstanding memory accesses included
                                                                  buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
   13ad0:	4a0d      	ldr	r2, [pc, #52]	; (13b08 <CLI_OTAU+0x6c>)
   13ad2:	4b0e      	ldr	r3, [pc, #56]	; (13b0c <CLI_OTAU+0x70>)
   13ad4:	60da      	str	r2, [r3, #12]
   13ad6:	f3bf 8f4f 	dsb	sy
   13ada:	e7fe      	b.n	13ada <CLI_OTAU+0x3e>
		SerialConsoleWriteString("boot_flag.txt added!\r\n");
   13adc:	480c      	ldr	r0, [pc, #48]	; (13b10 <CLI_OTAU+0x74>)
   13ade:	47a0      	blx	r4
   13ae0:	e7ec      	b.n	13abc <CLI_OTAU+0x20>
   13ae2:	46c0      	nop			; (mov r8, r8)
   13ae4:	2000007c 	.word	0x2000007c
   13ae8:	0002028d 	.word	0x0002028d
   13aec:	00019335 	.word	0x00019335
   13af0:	00028829 	.word	0x00028829
   13af4:	000193d9 	.word	0x000193d9
   13af8:	000155e5 	.word	0x000155e5
   13afc:	000185ad 	.word	0x000185ad
   13b00:	00011170 	.word	0x00011170
   13b04:	00028850 	.word	0x00028850
   13b08:	05fa0004 	.word	0x05fa0004
   13b0c:	e000ed00 	.word	0xe000ed00
   13b10:	00028839 	.word	0x00028839

00013b14 <CLI_AirFlow>:
	return pdFALSE;
}

// CLI_OTAU. Read data from the FS-3000 sensor and print it to serialbuffer and sends to the mqtt server
BaseType_t CLI_AirFlow(int8_t *pcWriteBuffer, size_t xWriteBufferLen, const int8_t *pcCommandString)
{
   13b14:	b530      	push	{r4, r5, lr}
	float air_speed = FS3000_readMetersPerSecond();
   13b16:	4b0a      	ldr	r3, [pc, #40]	; (13b40 <CLI_AirFlow+0x2c>)
{
   13b18:	b085      	sub	sp, #20
   13b1a:	000d      	movs	r5, r1
   13b1c:	0004      	movs	r4, r0
	float air_speed = FS3000_readMetersPerSecond();
   13b1e:	4798      	blx	r3

	snprintf(pcWriteBuffer, xWriteBufferLen, "AirFlow: %0.2f m/s \r\n", air_speed);
   13b20:	4b08      	ldr	r3, [pc, #32]	; (13b44 <CLI_AirFlow+0x30>)
	float air_speed = FS3000_readMetersPerSecond();
   13b22:	9003      	str	r0, [sp, #12]
	snprintf(pcWriteBuffer, xWriteBufferLen, "AirFlow: %0.2f m/s \r\n", air_speed);
   13b24:	4798      	blx	r3
   13b26:	4a08      	ldr	r2, [pc, #32]	; (13b48 <CLI_AirFlow+0x34>)
   13b28:	9000      	str	r0, [sp, #0]
   13b2a:	9101      	str	r1, [sp, #4]
   13b2c:	4b07      	ldr	r3, [pc, #28]	; (13b4c <CLI_AirFlow+0x38>)
   13b2e:	0029      	movs	r1, r5
   13b30:	0020      	movs	r0, r4
   13b32:	4798      	blx	r3
	
	WifiAddAirDataToQueue(&air_speed);
   13b34:	a803      	add	r0, sp, #12
   13b36:	4b06      	ldr	r3, [pc, #24]	; (13b50 <CLI_AirFlow+0x3c>)
   13b38:	4798      	blx	r3

	return pdFALSE;
}
   13b3a:	2000      	movs	r0, #0
   13b3c:	b005      	add	sp, #20
   13b3e:	bd30      	pop	{r4, r5, pc}
   13b40:	00012191 	.word	0x00012191
   13b44:	0002866d 	.word	0x0002866d
   13b48:	000287d7 	.word	0x000287d7
   13b4c:	00023781 	.word	0x00023781
   13b50:	00015625 	.word	0x00015625

00013b54 <CLI_GetImuData>:
{
   13b54:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (pdPASS == xQueueReceive(xQueueImuCliBuffer, &mg, 0)) {
   13b56:	4b10      	ldr	r3, [pc, #64]	; (13b98 <CLI_GetImuData+0x44>)
   13b58:	4c10      	ldr	r4, [pc, #64]	; (13b9c <CLI_GetImuData+0x48>)
{
   13b5a:	b087      	sub	sp, #28
   13b5c:	0006      	movs	r6, r0
   13b5e:	000f      	movs	r7, r1
	if (pdPASS == xQueueReceive(xQueueImuCliBuffer, &mg, 0)) {
   13b60:	6818      	ldr	r0, [r3, #0]
   13b62:	2200      	movs	r2, #0
   13b64:	0021      	movs	r1, r4
   13b66:	4b0e      	ldr	r3, [pc, #56]	; (13ba0 <CLI_GetImuData+0x4c>)
   13b68:	4798      	blx	r3
   13b6a:	2801      	cmp	r0, #1
   13b6c:	d111      	bne.n	13b92 <CLI_GetImuData+0x3e>
		snprintf((char *)pcWriteBuffer, xWriteBufferLen, "Acc [mg]: %0.2f %0.2f %0.2f\r\n", mg.xmg, mg.ymg, mg.zmg);
   13b6e:	68a0      	ldr	r0, [r4, #8]
   13b70:	4d0c      	ldr	r5, [pc, #48]	; (13ba4 <CLI_GetImuData+0x50>)
   13b72:	47a8      	blx	r5
   13b74:	9004      	str	r0, [sp, #16]
   13b76:	9105      	str	r1, [sp, #20]
   13b78:	6860      	ldr	r0, [r4, #4]
   13b7a:	47a8      	blx	r5
   13b7c:	9002      	str	r0, [sp, #8]
   13b7e:	9103      	str	r1, [sp, #12]
   13b80:	6820      	ldr	r0, [r4, #0]
   13b82:	47a8      	blx	r5
   13b84:	4a08      	ldr	r2, [pc, #32]	; (13ba8 <CLI_GetImuData+0x54>)
   13b86:	9000      	str	r0, [sp, #0]
   13b88:	9101      	str	r1, [sp, #4]
   13b8a:	4b08      	ldr	r3, [pc, #32]	; (13bac <CLI_GetImuData+0x58>)
   13b8c:	0039      	movs	r1, r7
   13b8e:	0030      	movs	r0, r6
   13b90:	4798      	blx	r3
}
   13b92:	2000      	movs	r0, #0
   13b94:	b007      	add	sp, #28
   13b96:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13b98:	200004e4 	.word	0x200004e4
   13b9c:	20000484 	.word	0x20000484
   13ba0:	00017905 	.word	0x00017905
   13ba4:	0002866d 	.word	0x0002866d
   13ba8:	0002880b 	.word	0x0002880b
   13bac:	00023781 	.word	0x00023781

00013bb0 <vCommandConsoleTask>:
{
   13bb0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    FreeRTOS_CLIRegisterCommand(&xOTAUCommand);
   13bb2:	4c63      	ldr	r4, [pc, #396]	; (13d40 <vCommandConsoleTask+0x190>)
   13bb4:	4863      	ldr	r0, [pc, #396]	; (13d44 <vCommandConsoleTask+0x194>)
   13bb6:	47a0      	blx	r4
    FreeRTOS_CLIRegisterCommand(&xImuGetCommand);
   13bb8:	4863      	ldr	r0, [pc, #396]	; (13d48 <vCommandConsoleTask+0x198>)
   13bba:	47a0      	blx	r4
    FreeRTOS_CLIRegisterCommand(&xClearScreen);
   13bbc:	4863      	ldr	r0, [pc, #396]	; (13d4c <vCommandConsoleTask+0x19c>)
   13bbe:	47a0      	blx	r4
	FreeRTOS_CLIRegisterCommand(&xAirFlow);
   13bc0:	4863      	ldr	r0, [pc, #396]	; (13d50 <vCommandConsoleTask+0x1a0>)
   13bc2:	47a0      	blx	r4
	FreeRTOS_CLIRegisterCommand(&xEnvGetCommand);
   13bc4:	4863      	ldr	r0, [pc, #396]	; (13d54 <vCommandConsoleTask+0x1a4>)
   13bc6:	47a0      	blx	r4
	xQueueBmeCliBuffer = xQueueCreate(1, sizeof(struct bme68x_data));
   13bc8:	4c63      	ldr	r4, [pc, #396]	; (13d58 <vCommandConsoleTask+0x1a8>)
   13bca:	2200      	movs	r2, #0
   13bcc:	2118      	movs	r1, #24
   13bce:	2001      	movs	r0, #1
   13bd0:	47a0      	blx	r4
   13bd2:	4b62      	ldr	r3, [pc, #392]	; (13d5c <vCommandConsoleTask+0x1ac>)
    xQueueImuCliBuffer = xQueueCreate(1, sizeof(struct ImuDataPacket_float));
   13bd4:	2200      	movs	r2, #0
	xQueueBmeCliBuffer = xQueueCreate(1, sizeof(struct bme68x_data));
   13bd6:	6018      	str	r0, [r3, #0]
    xQueueImuCliBuffer = xQueueCreate(1, sizeof(struct ImuDataPacket_float));
   13bd8:	210c      	movs	r1, #12
   13bda:	2001      	movs	r0, #1
   13bdc:	47a0      	blx	r4
   13bde:	4b60      	ldr	r3, [pc, #384]	; (13d60 <vCommandConsoleTask+0x1b0>)
    SerialConsoleWriteString((char *)pcWelcomeMessage);
   13be0:	4f60      	ldr	r7, [pc, #384]	; (13d64 <vCommandConsoleTask+0x1b4>)
    xQueueImuCliBuffer = xQueueCreate(1, sizeof(struct ImuDataPacket_float));
   13be2:	6018      	str	r0, [r3, #0]
    SerialConsoleWriteString((char *)pcWelcomeMessage);
   13be4:	4860      	ldr	r0, [pc, #384]	; (13d68 <vCommandConsoleTask+0x1b8>)
   13be6:	47b8      	blx	r7
    cliCharReadySemaphore = xSemaphoreCreateBinary();
   13be8:	2203      	movs	r2, #3
   13bea:	2100      	movs	r1, #0
   13bec:	2001      	movs	r0, #1
   13bee:	47a0      	blx	r4
   13bf0:	4b5e      	ldr	r3, [pc, #376]	; (13d6c <vCommandConsoleTask+0x1bc>)
   13bf2:	1e04      	subs	r4, r0, #0
   13bf4:	6018      	str	r0, [r3, #0]
    if (cliCharReadySemaphore == NULL) {
   13bf6:	d106      	bne.n	13c06 <vCommandConsoleTask+0x56>
        LogMessage(LOG_ERROR_LVL, "Could not allocate semaphore\r\n");
   13bf8:	2003      	movs	r0, #3
   13bfa:	4b5d      	ldr	r3, [pc, #372]	; (13d70 <vCommandConsoleTask+0x1c0>)
   13bfc:	495d      	ldr	r1, [pc, #372]	; (13d74 <vCommandConsoleTask+0x1c4>)
   13bfe:	4798      	blx	r3
        vTaskSuspend(NULL);
   13c00:	0020      	movs	r0, r4
   13c02:	4b5d      	ldr	r3, [pc, #372]	; (13d78 <vCommandConsoleTask+0x1c8>)
   13c04:	4798      	blx	r3
            cInputIndex = 0;
   13c06:	2600      	movs	r6, #0
    int ret = SerialConsoleReadCharacter((uint8_t *)character);
   13c08:	4668      	mov	r0, sp
   13c0a:	4c5c      	ldr	r4, [pc, #368]	; (13d7c <vCommandConsoleTask+0x1cc>)
        ret = SerialConsoleReadCharacter((uint8_t *)character);
   13c0c:	47a0      	blx	r4
    while (ret == -1) {
   13c0e:	1c43      	adds	r3, r0, #1
   13c10:	d02d      	beq.n	13c6e <vCommandConsoleTask+0xbe>
           if (cRxedChar[0] == '\n' || cRxedChar[0] == '\r') {
   13c12:	466b      	mov	r3, sp
   13c14:	781b      	ldrb	r3, [r3, #0]
   13c16:	4d5a      	ldr	r5, [pc, #360]	; (13d80 <vCommandConsoleTask+0x1d0>)
   13c18:	2b0a      	cmp	r3, #10
   13c1a:	d001      	beq.n	13c20 <vCommandConsoleTask+0x70>
   13c1c:	2b0d      	cmp	r3, #13
   13c1e:	d12d      	bne.n	13c7c <vCommandConsoleTask+0xcc>
            isEscapeCode = false;
   13c20:	2400      	movs	r4, #0
            SerialConsoleWriteString((char *)"\r\n");
   13c22:	4858      	ldr	r0, [pc, #352]	; (13d84 <vCommandConsoleTask+0x1d4>)
   13c24:	47b8      	blx	r7
            pcEscapeCodePos = 0;
   13c26:	4b58      	ldr	r3, [pc, #352]	; (13d88 <vCommandConsoleTask+0x1d8>)
            strncpy(pcLastCommand, pcInputString, MAX_INPUT_LENGTH_CLI - 1);
   13c28:	4e58      	ldr	r6, [pc, #352]	; (13d8c <vCommandConsoleTask+0x1dc>)
            isEscapeCode = false;
   13c2a:	702c      	strb	r4, [r5, #0]
            strncpy(pcLastCommand, pcInputString, MAX_INPUT_LENGTH_CLI - 1);
   13c2c:	4d58      	ldr	r5, [pc, #352]	; (13d90 <vCommandConsoleTask+0x1e0>)
            pcEscapeCodePos = 0;
   13c2e:	701c      	strb	r4, [r3, #0]
            strncpy(pcLastCommand, pcInputString, MAX_INPUT_LENGTH_CLI - 1);
   13c30:	2209      	movs	r2, #9
   13c32:	0029      	movs	r1, r5
   13c34:	0030      	movs	r0, r6
   13c36:	4b57      	ldr	r3, [pc, #348]	; (13d94 <vCommandConsoleTask+0x1e4>)
   13c38:	4798      	blx	r3
            pcLastCommand[MAX_INPUT_LENGTH_CLI - 1] = 0;  // Ensure null termination
   13c3a:	7274      	strb	r4, [r6, #9]
                xMoreDataToFollow = FreeRTOS_CLIProcessCommand(pcInputString,        /* The command string.*/
   13c3c:	4c56      	ldr	r4, [pc, #344]	; (13d98 <vCommandConsoleTask+0x1e8>)
   13c3e:	2232      	movs	r2, #50	; 0x32
   13c40:	4b56      	ldr	r3, [pc, #344]	; (13d9c <vCommandConsoleTask+0x1ec>)
   13c42:	0021      	movs	r1, r4
   13c44:	0028      	movs	r0, r5
   13c46:	4798      	blx	r3
                pcOutputString[MAX_OUTPUT_LENGTH_CLI - 1] = 0;
   13c48:	0023      	movs	r3, r4
   13c4a:	2200      	movs	r2, #0
                xMoreDataToFollow = FreeRTOS_CLIProcessCommand(pcInputString,        /* The command string.*/
   13c4c:	0006      	movs	r6, r0
                pcOutputString[MAX_OUTPUT_LENGTH_CLI - 1] = 0;
   13c4e:	3331      	adds	r3, #49	; 0x31
                SerialConsoleWriteString(pcOutputString);
   13c50:	0020      	movs	r0, r4
                pcOutputString[MAX_OUTPUT_LENGTH_CLI - 1] = 0;
   13c52:	701a      	strb	r2, [r3, #0]
                SerialConsoleWriteString(pcOutputString);
   13c54:	47b8      	blx	r7
            } while (xMoreDataToFollow != pdFALSE);
   13c56:	2e00      	cmp	r6, #0
   13c58:	d1f0      	bne.n	13c3c <vCommandConsoleTask+0x8c>
            memset(pcInputString, 0x00, MAX_INPUT_LENGTH_CLI);
   13c5a:	0031      	movs	r1, r6
   13c5c:	220a      	movs	r2, #10
   13c5e:	0028      	movs	r0, r5
   13c60:	4d4f      	ldr	r5, [pc, #316]	; (13da0 <vCommandConsoleTask+0x1f0>)
   13c62:	47a8      	blx	r5
            memset(pcOutputString, 0, MAX_OUTPUT_LENGTH_CLI);
   13c64:	2232      	movs	r2, #50	; 0x32
   13c66:	0031      	movs	r1, r6
   13c68:	0020      	movs	r0, r4
   13c6a:	47a8      	blx	r5
   13c6c:	e7cc      	b.n	13c08 <vCommandConsoleTask+0x58>
        xSemaphoreTake(cliCharReadySemaphore, portMAX_DELAY);
   13c6e:	4b3f      	ldr	r3, [pc, #252]	; (13d6c <vCommandConsoleTask+0x1bc>)
   13c70:	0001      	movs	r1, r0
   13c72:	6818      	ldr	r0, [r3, #0]
   13c74:	4b4b      	ldr	r3, [pc, #300]	; (13da4 <vCommandConsoleTask+0x1f4>)
   13c76:	4798      	blx	r3
        ret = SerialConsoleReadCharacter((uint8_t *)character);
   13c78:	4668      	mov	r0, sp
   13c7a:	e7c7      	b.n	13c0c <vCommandConsoleTask+0x5c>
            if (true == isEscapeCode) {
   13c7c:	782a      	ldrb	r2, [r5, #0]
   13c7e:	2a00      	cmp	r2, #0
   13c80:	d037      	beq.n	13cf2 <vCommandConsoleTask+0x142>
                if (pcEscapeCodePos < CLI_PC_ESCAPE_CODE_SIZE) {
   13c82:	4a41      	ldr	r2, [pc, #260]	; (13d88 <vCommandConsoleTask+0x1d8>)
   13c84:	7811      	ldrb	r1, [r2, #0]
   13c86:	2903      	cmp	r1, #3
   13c88:	d82f      	bhi.n	13cea <vCommandConsoleTask+0x13a>
                    pcEscapeCodes[pcEscapeCodePos++] = cRxedChar[0];
   13c8a:	1c48      	adds	r0, r1, #1
   13c8c:	7010      	strb	r0, [r2, #0]
   13c8e:	4846      	ldr	r0, [pc, #280]	; (13da8 <vCommandConsoleTask+0x1f8>)
   13c90:	5443      	strb	r3, [r0, r1]
                if (pcEscapeCodePos >= CLI_PC_MIN_ESCAPE_CODE_SIZE) {
   13c92:	7813      	ldrb	r3, [r2, #0]
   13c94:	2b01      	cmp	r3, #1
   13c96:	d9b7      	bls.n	13c08 <vCommandConsoleTask+0x58>
                    if (strcasecmp(pcEscapeCodes, "oa")) {
   13c98:	4944      	ldr	r1, [pc, #272]	; (13dac <vCommandConsoleTask+0x1fc>)
   13c9a:	4843      	ldr	r0, [pc, #268]	; (13da8 <vCommandConsoleTask+0x1f8>)
   13c9c:	4b44      	ldr	r3, [pc, #272]	; (13db0 <vCommandConsoleTask+0x200>)
   13c9e:	4798      	blx	r3
   13ca0:	2800      	cmp	r0, #0
   13ca2:	d01d      	beq.n	13ce0 <vCommandConsoleTask+0x130>
                        sprintf(pcInputString, "%c[2K\r>", 27);
   13ca4:	4c3a      	ldr	r4, [pc, #232]	; (13d90 <vCommandConsoleTask+0x1e0>)
   13ca6:	221b      	movs	r2, #27
   13ca8:	4942      	ldr	r1, [pc, #264]	; (13db4 <vCommandConsoleTask+0x204>)
   13caa:	4b43      	ldr	r3, [pc, #268]	; (13db8 <vCommandConsoleTask+0x208>)
   13cac:	0020      	movs	r0, r4
   13cae:	4798      	blx	r3
                        SerialConsoleWriteString((char *)pcInputString);
   13cb0:	0020      	movs	r0, r4
   13cb2:	47b8      	blx	r7
                        memset(pcInputString, 0x00, MAX_INPUT_LENGTH_CLI);
   13cb4:	220a      	movs	r2, #10
   13cb6:	2100      	movs	r1, #0
   13cb8:	4b39      	ldr	r3, [pc, #228]	; (13da0 <vCommandConsoleTask+0x1f0>)
   13cba:	0020      	movs	r0, r4
   13cbc:	4798      	blx	r3
                        strncpy(pcInputString, pcLastCommand, MAX_INPUT_LENGTH_CLI - 1);
   13cbe:	4b35      	ldr	r3, [pc, #212]	; (13d94 <vCommandConsoleTask+0x1e4>)
   13cc0:	2209      	movs	r2, #9
   13cc2:	4932      	ldr	r1, [pc, #200]	; (13d8c <vCommandConsoleTask+0x1dc>)
   13cc4:	0020      	movs	r0, r4
   13cc6:	4798      	blx	r3
                        cInputIndex = (strlen(pcInputString) < MAX_INPUT_LENGTH_CLI - 1) ? strlen(pcLastCommand) : MAX_INPUT_LENGTH_CLI - 1;
   13cc8:	0020      	movs	r0, r4
   13cca:	4e3c      	ldr	r6, [pc, #240]	; (13dbc <vCommandConsoleTask+0x20c>)
   13ccc:	47b0      	blx	r6
   13cce:	0003      	movs	r3, r0
   13cd0:	2009      	movs	r0, #9
   13cd2:	2b08      	cmp	r3, #8
   13cd4:	d801      	bhi.n	13cda <vCommandConsoleTask+0x12a>
   13cd6:	482d      	ldr	r0, [pc, #180]	; (13d8c <vCommandConsoleTask+0x1dc>)
   13cd8:	47b0      	blx	r6
   13cda:	b2c6      	uxtb	r6, r0
                        SerialConsoleWriteString(pcInputString);
   13cdc:	0020      	movs	r0, r4
   13cde:	47b8      	blx	r7
                    isEscapeCode = false;
   13ce0:	2300      	movs	r3, #0
                    pcEscapeCodePos = 0;
   13ce2:	4a29      	ldr	r2, [pc, #164]	; (13d88 <vCommandConsoleTask+0x1d8>)
                    isEscapeCode = false;
   13ce4:	702b      	strb	r3, [r5, #0]
                    pcEscapeCodePos = 0;
   13ce6:	7013      	strb	r3, [r2, #0]
   13ce8:	e78e      	b.n	13c08 <vCommandConsoleTask+0x58>
                    isEscapeCode = false;
   13cea:	2300      	movs	r3, #0
   13cec:	702b      	strb	r3, [r5, #0]
                    pcEscapeCodePos = 0;
   13cee:	7013      	strb	r3, [r2, #0]
   13cf0:	e7cf      	b.n	13c92 <vCommandConsoleTask+0xe2>
            } else if (cRxedChar[0] == ASCII_BACKSPACE || cRxedChar[0] == ASCII_DELETE) {
   13cf2:	2b08      	cmp	r3, #8
   13cf4:	d001      	beq.n	13cfa <vCommandConsoleTask+0x14a>
   13cf6:	2b7f      	cmp	r3, #127	; 0x7f
   13cf8:	d10f      	bne.n	13d1a <vCommandConsoleTask+0x16a>
                char erase[4] = {0x08, 0x20, 0x08, 0x00};
   13cfa:	2204      	movs	r2, #4
   13cfc:	4930      	ldr	r1, [pc, #192]	; (13dc0 <vCommandConsoleTask+0x210>)
   13cfe:	a801      	add	r0, sp, #4
   13d00:	4b30      	ldr	r3, [pc, #192]	; (13dc4 <vCommandConsoleTask+0x214>)
   13d02:	4798      	blx	r3
                SerialConsoleWriteString(erase);
   13d04:	a801      	add	r0, sp, #4
   13d06:	47b8      	blx	r7
                if (cInputIndex > 0) {
   13d08:	2e00      	cmp	r6, #0
   13d0a:	d100      	bne.n	13d0e <vCommandConsoleTask+0x15e>
   13d0c:	e77c      	b.n	13c08 <vCommandConsoleTask+0x58>
                    pcInputString[cInputIndex] = 0;
   13d0e:	2200      	movs	r2, #0
                    cInputIndex--;
   13d10:	3e01      	subs	r6, #1
                    pcInputString[cInputIndex] = 0;
   13d12:	4b1f      	ldr	r3, [pc, #124]	; (13d90 <vCommandConsoleTask+0x1e0>)
                    cInputIndex--;
   13d14:	b2f6      	uxtb	r6, r6
                    pcInputString[cInputIndex] = 0;
   13d16:	559a      	strb	r2, [r3, r6]
            } else if (cRxedChar[0] == ASCII_BACKSPACE || cRxedChar[0] == ASCII_DELETE) {
   13d18:	e776      	b.n	13c08 <vCommandConsoleTask+0x58>
            else if (cRxedChar[0] == ASCII_ESC) {
   13d1a:	2b1b      	cmp	r3, #27
   13d1c:	d104      	bne.n	13d28 <vCommandConsoleTask+0x178>
                isEscapeCode = true;  // Next characters will be code arguments
   13d1e:	3b1a      	subs	r3, #26
   13d20:	702b      	strb	r3, [r5, #0]
                pcEscapeCodePos = 0;
   13d22:	4b19      	ldr	r3, [pc, #100]	; (13d88 <vCommandConsoleTask+0x1d8>)
   13d24:	701a      	strb	r2, [r3, #0]
   13d26:	e76f      	b.n	13c08 <vCommandConsoleTask+0x58>
                if (cInputIndex < MAX_INPUT_LENGTH_CLI) {
   13d28:	2e09      	cmp	r6, #9
   13d2a:	d803      	bhi.n	13d34 <vCommandConsoleTask+0x184>
                    pcInputString[cInputIndex] = cRxedChar[0];
   13d2c:	4a18      	ldr	r2, [pc, #96]	; (13d90 <vCommandConsoleTask+0x1e0>)
   13d2e:	5593      	strb	r3, [r2, r6]
                    cInputIndex++;
   13d30:	3601      	adds	r6, #1
   13d32:	b2f6      	uxtb	r6, r6
                cRxedChar[1] = 0;
   13d34:	2300      	movs	r3, #0
   13d36:	466a      	mov	r2, sp
                SerialConsoleWriteString(&cRxedChar[0]);
   13d38:	4668      	mov	r0, sp
                cRxedChar[1] = 0;
   13d3a:	7053      	strb	r3, [r2, #1]
                SerialConsoleWriteString(&cRxedChar[0]);
   13d3c:	47b8      	blx	r7
   13d3e:	e763      	b.n	13c08 <vCommandConsoleTask+0x58>
   13d40:	00015ad9 	.word	0x00015ad9
   13d44:	00028a08 	.word	0x00028a08
   13d48:	000289f8 	.word	0x000289f8
   13d4c:	000289d0 	.word	0x000289d0
   13d50:	000289c0 	.word	0x000289c0
   13d54:	000289e8 	.word	0x000289e8
   13d58:	00017229 	.word	0x00017229
   13d5c:	200004e0 	.word	0x200004e0
   13d60:	200004e4 	.word	0x200004e4
   13d64:	00019335 	.word	0x00019335
   13d68:	00028863 	.word	0x00028863
   13d6c:	200042b0 	.word	0x200042b0
   13d70:	000193d9 	.word	0x000193d9
   13d74:	00028995 	.word	0x00028995
   13d78:	0001870d 	.word	0x0001870d
   13d7c:	000193ad 	.word	0x000193ad
   13d80:	20000480 	.word	0x20000480
   13d84:	0002927a 	.word	0x0002927a
   13d88:	20000490 	.word	0x20000490
   13d8c:	2000049f 	.word	0x2000049f
   13d90:	20000495 	.word	0x20000495
   13d94:	000238f3 	.word	0x000238f3
   13d98:	200004a9 	.word	0x200004a9
   13d9c:	00015b1d 	.word	0x00015b1d
   13da0:	00022c47 	.word	0x00022c47
   13da4:	00017b9d 	.word	0x00017b9d
   13da8:	20000491 	.word	0x20000491
   13dac:	000289b4 	.word	0x000289b4
   13db0:	00023829 	.word	0x00023829
   13db4:	000289b7 	.word	0x000289b7
   13db8:	000237e5 	.word	0x000237e5
   13dbc:	000238c3 	.word	0x000238c3
   13dc0:	000287d3 	.word	0x000287d3
   13dc4:	00022c11 	.word	0x00022c11

00013dc8 <CliCharReadySemaphoreGiveFromISR>:
    xHigherPriorityTaskWoken = pdFALSE;
   13dc8:	2300      	movs	r3, #0
{
   13dca:	b510      	push	{r4, lr}
    xHigherPriorityTaskWoken = pdFALSE;
   13dcc:	4c07      	ldr	r4, [pc, #28]	; (13dec <CliCharReadySemaphoreGiveFromISR+0x24>)
   13dce:	6023      	str	r3, [r4, #0]
    xSemaphoreGiveFromISR(cliCharReadySemaphore, &xHigherPriorityTaskWoken);
   13dd0:	4b07      	ldr	r3, [pc, #28]	; (13df0 <CliCharReadySemaphoreGiveFromISR+0x28>)
   13dd2:	0021      	movs	r1, r4
   13dd4:	6818      	ldr	r0, [r3, #0]
   13dd6:	4b07      	ldr	r3, [pc, #28]	; (13df4 <CliCharReadySemaphoreGiveFromISR+0x2c>)
   13dd8:	4798      	blx	r3
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
   13dda:	6823      	ldr	r3, [r4, #0]
   13ddc:	2b00      	cmp	r3, #0
   13dde:	d003      	beq.n	13de8 <CliCharReadySemaphoreGiveFromISR+0x20>
   13de0:	2280      	movs	r2, #128	; 0x80
   13de2:	4b05      	ldr	r3, [pc, #20]	; (13df8 <CliCharReadySemaphoreGiveFromISR+0x30>)
   13de4:	0552      	lsls	r2, r2, #21
   13de6:	601a      	str	r2, [r3, #0]
}
   13de8:	bd10      	pop	{r4, pc}
   13dea:	46c0      	nop			; (mov r8, r8)
   13dec:	200004dc 	.word	0x200004dc
   13df0:	200042b0 	.word	0x200042b0
   13df4:	000178f5 	.word	0x000178f5
   13df8:	e000ed04 	.word	0xe000ed04

00013dfc <CLIAddBmeDataToQueue>:

// Helper function to add bme680 data to the CLI queue.
int CLIAddBmeDataToQueue(struct bme68x_data *bmePacket)
{
   13dfc:	b510      	push	{r4, lr}
   13dfe:	0001      	movs	r1, r0
	int error = xQueueSend(xQueueBmeCliBuffer, bmePacket, (TickType_t)10);
   13e00:	4803      	ldr	r0, [pc, #12]	; (13e10 <CLIAddBmeDataToQueue+0x14>)
   13e02:	2300      	movs	r3, #0
   13e04:	220a      	movs	r2, #10
   13e06:	4c03      	ldr	r4, [pc, #12]	; (13e14 <CLIAddBmeDataToQueue+0x18>)
   13e08:	6800      	ldr	r0, [r0, #0]
   13e0a:	47a0      	blx	r4
	return error;
}
   13e0c:	bd10      	pop	{r4, pc}
   13e0e:	46c0      	nop			; (mov r8, r8)
   13e10:	200004e0 	.word	0x200004e0
   13e14:	0001735d 	.word	0x0001735d

00013e18 <CLIAddImuDataToQueue>:

// Helper function to add bme680 data to the CLI queue.
int CLIAddImuDataToQueue(struct ImuDataPacket_float *imuPacket)
{
   13e18:	b510      	push	{r4, lr}
   13e1a:	0001      	movs	r1, r0
    int error = xQueueSend(xQueueImuCliBuffer, imuPacket, (TickType_t)10);
   13e1c:	4803      	ldr	r0, [pc, #12]	; (13e2c <CLIAddImuDataToQueue+0x14>)
   13e1e:	2300      	movs	r3, #0
   13e20:	220a      	movs	r2, #10
   13e22:	4c03      	ldr	r4, [pc, #12]	; (13e30 <CLIAddImuDataToQueue+0x18>)
   13e24:	6800      	ldr	r0, [r0, #0]
   13e26:	47a0      	blx	r4
    return error;
}
   13e28:	bd10      	pop	{r4, pc}
   13e2a:	46c0      	nop			; (mov r8, r8)
   13e2c:	200004e4 	.word	0x200004e4
   13e30:	0001735d 	.word	0x0001735d

00013e34 <I2cSensorsRxComplete>:
					and is currently waiting for a notification that it has finished.
 * @param[in]		i2c Pointer to I2C structure used inside the Atmel ASFv3  framework
 * @return			This function is a callback, and it is registered as such when we send an I2C reception on this I2C bus.
 * @note        
 *****************************************************************************/
void I2cSensorsRxComplete(struct i2c_master_module *const module){
   13e34:	b513      	push	{r0, r1, r4, lr}
	
	I2cSensorBusState.i2cState = I2C_BUS_READY;
	I2cSensorBusState.rxDoneFlag = true;
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
   13e36:	2400      	movs	r4, #0
	
	xSemaphoreGiveFromISR( sensorI2cSemaphoreHandle, &xHigherPriorityTaskWoken );
   13e38:	4b07      	ldr	r3, [pc, #28]	; (13e58 <I2cSensorsRxComplete+0x24>)
   13e3a:	a901      	add	r1, sp, #4
   13e3c:	6818      	ldr	r0, [r3, #0]
   13e3e:	4b07      	ldr	r3, [pc, #28]	; (13e5c <I2cSensorsRxComplete+0x28>)
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
   13e40:	9401      	str	r4, [sp, #4]
	xSemaphoreGiveFromISR( sensorI2cSemaphoreHandle, &xHigherPriorityTaskWoken );
   13e42:	4798      	blx	r3
	sensorTransmitError = false;
   13e44:	4b06      	ldr	r3, [pc, #24]	; (13e60 <I2cSensorsRxComplete+0x2c>)
   13e46:	701c      	strb	r4, [r3, #0]
	portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
   13e48:	9b01      	ldr	r3, [sp, #4]
   13e4a:	42a3      	cmp	r3, r4
   13e4c:	d003      	beq.n	13e56 <I2cSensorsRxComplete+0x22>
   13e4e:	2280      	movs	r2, #128	; 0x80
   13e50:	4b04      	ldr	r3, [pc, #16]	; (13e64 <I2cSensorsRxComplete+0x30>)
   13e52:	0552      	lsls	r2, r2, #21
   13e54:	601a      	str	r2, [r3, #0]
}
   13e56:	bd13      	pop	{r0, r1, r4, pc}
   13e58:	200042e0 	.word	0x200042e0
   13e5c:	000178f5 	.word	0x000178f5
   13e60:	200004e8 	.word	0x200004e8
   13e64:	e000ed04 	.word	0xe000ed04

00013e68 <I2cSensorsTxComplete>:
   13e68:	b510      	push	{r4, lr}
   13e6a:	4b01      	ldr	r3, [pc, #4]	; (13e70 <I2cSensorsTxComplete+0x8>)
   13e6c:	4798      	blx	r3
   13e6e:	bd10      	pop	{r4, pc}
   13e70:	00013e35 	.word	0x00013e35

00013e74 <I2cSensorsError>:
					and is currently waiting for a notification that it has finished.
 * @param[in]		i2c Pointer to I2C structure used inside the Atmel ASFv3  framework
 * @return			This function is a callback, and it is registered as such when we send an I2C reception on this I2C bus.
 * @note        
 *****************************************************************************/
void I2cSensorsError(struct i2c_master_module *const module){
   13e74:	b513      	push	{r0, r1, r4, lr}
	
	I2cSensorBusState.i2cState = I2C_BUS_READY;
	I2cSensorBusState.txDoneFlag = true;
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
   13e76:	2400      	movs	r4, #0
	
	xSemaphoreGiveFromISR( sensorI2cSemaphoreHandle, &xHigherPriorityTaskWoken );
   13e78:	4b07      	ldr	r3, [pc, #28]	; (13e98 <I2cSensorsError+0x24>)
   13e7a:	a901      	add	r1, sp, #4
   13e7c:	6818      	ldr	r0, [r3, #0]
   13e7e:	4b07      	ldr	r3, [pc, #28]	; (13e9c <I2cSensorsError+0x28>)
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
   13e80:	9401      	str	r4, [sp, #4]
	xSemaphoreGiveFromISR( sensorI2cSemaphoreHandle, &xHigherPriorityTaskWoken );
   13e82:	4798      	blx	r3
	sensorTransmitError = false;
   13e84:	4b06      	ldr	r3, [pc, #24]	; (13ea0 <I2cSensorsError+0x2c>)
   13e86:	701c      	strb	r4, [r3, #0]
	portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
   13e88:	9b01      	ldr	r3, [sp, #4]
   13e8a:	42a3      	cmp	r3, r4
   13e8c:	d003      	beq.n	13e96 <I2cSensorsError+0x22>
   13e8e:	2280      	movs	r2, #128	; 0x80
   13e90:	4b04      	ldr	r3, [pc, #16]	; (13ea4 <I2cSensorsError+0x30>)
   13e92:	0552      	lsls	r2, r2, #21
   13e94:	601a      	str	r2, [r3, #0]
}
   13e96:	bd13      	pop	{r0, r1, r4, pc}
   13e98:	200042e0 	.word	0x200042e0
   13e9c:	000178f5 	.word	0x000178f5
   13ea0:	200004e8 	.word	0x200004e8
   13ea4:	e000ed04 	.word	0xe000ed04

00013ea8 <I2cDriverRegisterSensorBusCallbacks>:

void I2cDriverRegisterSensorBusCallbacks(void)
{
   13ea8:	b570      	push	{r4, r5, r6, lr}
	/* Register callback function. */
	i2c_master_register_callback(&i2cSensorBusInstance, I2cSensorsTxComplete,I2C_MASTER_CALLBACK_WRITE_COMPLETE);
   13eaa:	4c0c      	ldr	r4, [pc, #48]	; (13edc <I2cDriverRegisterSensorBusCallbacks+0x34>)
   13eac:	4d0c      	ldr	r5, [pc, #48]	; (13ee0 <I2cDriverRegisterSensorBusCallbacks+0x38>)
   13eae:	0020      	movs	r0, r4
   13eb0:	2200      	movs	r2, #0
   13eb2:	490c      	ldr	r1, [pc, #48]	; (13ee4 <I2cDriverRegisterSensorBusCallbacks+0x3c>)
   13eb4:	47a8      	blx	r5
	/* Sanity check */
	Assert(module);
	Assert(module->hw);

	/* Mark callback as enabled */
	module->enabled_callback |= (1 << callback_type);
   13eb6:	2201      	movs	r2, #1
   13eb8:	7e63      	ldrb	r3, [r4, #25]
	i2c_master_enable_callback(&i2cSensorBusInstance,I2C_MASTER_CALLBACK_WRITE_COMPLETE);
	
	i2c_master_register_callback(&i2cSensorBusInstance, I2cSensorsRxComplete, I2C_MASTER_CALLBACK_READ_COMPLETE);
   13eba:	0020      	movs	r0, r4
   13ebc:	4313      	orrs	r3, r2
   13ebe:	490a      	ldr	r1, [pc, #40]	; (13ee8 <I2cDriverRegisterSensorBusCallbacks+0x40>)
   13ec0:	7663      	strb	r3, [r4, #25]
   13ec2:	47a8      	blx	r5
   13ec4:	2202      	movs	r2, #2
   13ec6:	7e63      	ldrb	r3, [r4, #25]
	i2c_master_enable_callback(&i2cSensorBusInstance,I2C_MASTER_CALLBACK_READ_COMPLETE);
	
	i2c_master_register_callback(&i2cSensorBusInstance, I2cSensorsError,I2C_MASTER_CALLBACK_ERROR);
   13ec8:	4908      	ldr	r1, [pc, #32]	; (13eec <I2cDriverRegisterSensorBusCallbacks+0x44>)
   13eca:	4313      	orrs	r3, r2
   13ecc:	0020      	movs	r0, r4
   13ece:	7663      	strb	r3, [r4, #25]
   13ed0:	47a8      	blx	r5
   13ed2:	2304      	movs	r3, #4
   13ed4:	7e62      	ldrb	r2, [r4, #25]
   13ed6:	4313      	orrs	r3, r2
   13ed8:	7663      	strb	r3, [r4, #25]
	i2c_master_enable_callback(&i2cSensorBusInstance,I2C_MASTER_CALLBACK_ERROR);
}
   13eda:	bd70      	pop	{r4, r5, r6, pc}
   13edc:	200042b8 	.word	0x200042b8
   13ee0:	0001251d 	.word	0x0001251d
   13ee4:	00013e69 	.word	0x00013e69
   13ee8:	00013e35 	.word	0x00013e35
   13eec:	00013e75 	.word	0x00013e75

00013ef0 <I2cInitializeDriver>:
	config->baud_rate_high_speed = I2C_MASTER_BAUD_RATE_3400KHZ;
	config->transfer_speed       = I2C_MASTER_SPEED_STANDARD_AND_FAST;
#endif
	config->generator_source = GCLK_GENERATOR_0;
	config->run_in_standby   = false;
	config->start_hold_time  = I2C_MASTER_START_HOLD_TIME_300NS_600NS;
   13ef0:	2280      	movs	r2, #128	; 0x80
	config->baud_rate        = I2C_MASTER_BAUD_RATE_100KHZ;
   13ef2:	2364      	movs	r3, #100	; 0x64
 * @fn			int32_t I2cInitializeDriver(void)
 * @brief       Function call to initialize the I2C driver\
 * @details     This function must be called from an RTOS thread if using RTOS, and must be called before any I2C call
 * @note        
 *****************************************************************************/
 int32_t I2cInitializeDriver(void){
   13ef4:	b570      	push	{r4, r5, r6, lr}
   13ef6:	b08e      	sub	sp, #56	; 0x38
   13ef8:	ac01      	add	r4, sp, #4
	config->start_hold_time  = I2C_MASTER_START_HOLD_TIME_300NS_600NS;
   13efa:	0392      	lsls	r2, r2, #14
   13efc:	6122      	str	r2, [r4, #16]
	config->buffer_timeout   = 65535;
	config->unknown_bus_state_timeout = 65535;
   13efe:	2201      	movs	r2, #1
	config->baud_rate        = I2C_MASTER_BAUD_RATE_100KHZ;
   13f00:	9301      	str	r3, [sp, #4]
	config->baud_rate_high_speed = I2C_MASTER_BAUD_RATE_3400KHZ;
   13f02:	4b30      	ldr	r3, [pc, #192]	; (13fc4 <I2cInitializeDriver+0xd4>)
	config->unknown_bus_state_timeout = 65535;
   13f04:	4252      	negs	r2, r2
	config->baud_rate_high_speed = I2C_MASTER_BAUD_RATE_3400KHZ;
   13f06:	6063      	str	r3, [r4, #4]
	config->transfer_speed       = I2C_MASTER_SPEED_STANDARD_AND_FAST;
   13f08:	2300      	movs	r3, #0
	config->unknown_bus_state_timeout = 65535;
   13f0a:	82a2      	strh	r2, [r4, #20]
	config->pinmux_pad0      = PINMUX_DEFAULT;
	config->pinmux_pad1      = PINMUX_DEFAULT;
	config->scl_low_timeout  = false;
   13f0c:	320a      	adds	r2, #10
   13f0e:	446a      	add	r2, sp
   13f10:	77d3      	strb	r3, [r2, #31]
	config->inactive_timeout = I2C_MASTER_INACTIVE_TIMEOUT_DISABLED;
#ifdef FEATURE_I2C_SCL_STRETCH_MODE
	config->scl_stretch_only_after_ack_bit = false;
   13f12:	aa0c      	add	r2, sp, #48	; 0x30
   13f14:	7013      	strb	r3, [r2, #0]
#endif
#ifdef FEATURE_I2C_SCL_EXTEND_TIMEOUT
	config->slave_scl_low_extend_timeout   = false;
   13f16:	2231      	movs	r2, #49	; 0x31
   13f18:	446a      	add	r2, sp
   13f1a:	7013      	strb	r3, [r2, #0]
	config->master_scl_low_extend_timeout  = false;
   13f1c:	2232      	movs	r2, #50	; 0x32
	config_i2c_master.buffer_timeout = 10000;
   13f1e:	2503      	movs	r5, #3
   13f20:	446a      	add	r2, sp
	config->transfer_speed       = I2C_MASTER_SPEED_STANDARD_AND_FAST;
   13f22:	60a3      	str	r3, [r4, #8]
	config->generator_source = GCLK_GENERATOR_0;
   13f24:	7323      	strb	r3, [r4, #12]
	config->run_in_standby   = false;
   13f26:	7623      	strb	r3, [r4, #24]
	config->inactive_timeout = I2C_MASTER_INACTIVE_TIMEOUT_DISABLED;
   13f28:	62a3      	str	r3, [r4, #40]	; 0x28
	config->master_scl_low_extend_timeout  = false;
   13f2a:	7013      	strb	r3, [r2, #0]
#endif
	/* The typical value is 215ns */
	config->sda_scl_rise_time_ns = 215;
   13f2c:	33d7      	adds	r3, #215	; 0xd7
   13f2e:	8623      	strh	r3, [r4, #48]	; 0x30
	config_i2c_master.pinmux_pad0 = PINMUX_PA08C_SERCOM0_PAD0;
   13f30:	4b25      	ldr	r3, [pc, #148]	; (13fc8 <I2cInitializeDriver+0xd8>)
   13f32:	61e3      	str	r3, [r4, #28]
	config_i2c_master.pinmux_pad1 = PINMUX_PA09C_SERCOM0_PAD1;
   13f34:	4b25      	ldr	r3, [pc, #148]	; (13fcc <I2cInitializeDriver+0xdc>)
   13f36:	6223      	str	r3, [r4, #32]
	config_i2c_master.buffer_timeout = 10000;
   13f38:	4b25      	ldr	r3, [pc, #148]	; (13fd0 <I2cInitializeDriver+0xe0>)
   13f3a:	82e3      	strh	r3, [r4, #22]
		errCodeAsf = i2c_master_init(&i2cSensorBusInstance, SERCOM0, &config_i2c_master);
   13f3c:	4e25      	ldr	r6, [pc, #148]	; (13fd4 <I2cInitializeDriver+0xe4>)
   13f3e:	0022      	movs	r2, r4
   13f40:	4925      	ldr	r1, [pc, #148]	; (13fd8 <I2cInitializeDriver+0xe8>)
   13f42:	0030      	movs	r0, r6
   13f44:	4b25      	ldr	r3, [pc, #148]	; (13fdc <I2cInitializeDriver+0xec>)
   13f46:	4798      	blx	r3
		if(STATUS_OK == errCodeAsf){
   13f48:	2800      	cmp	r0, #0
   13f4a:	d133      	bne.n	13fb4 <I2cInitializeDriver+0xc4>
	return (i2c_hw->SYNCBUSY.reg & SERCOM_I2CM_SYNCBUSY_MASK);
   13f4c:	2207      	movs	r2, #7
{
	/* Sanity check of arguments */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
   13f4e:	6835      	ldr	r5, [r6, #0]
	return (i2c_hw->SYNCBUSY.reg & SERCOM_I2CM_SYNCBUSY_MASK);
   13f50:	69ec      	ldr	r4, [r5, #28]
   13f52:	4014      	ands	r4, r2
	while (i2c_master_is_syncing(module)) {
   13f54:	d1fc      	bne.n	13f50 <I2cInitializeDriver+0x60>

	/* Wait for module to sync */
	_i2c_master_wait_for_sync(module);

	/* Enable module */
	i2c_module->CTRLA.reg |= SERCOM_I2CM_CTRLA_ENABLE;
   13f56:	2302      	movs	r3, #2
   13f58:	682a      	ldr	r2, [r5, #0]
   13f5a:	4313      	orrs	r3, r2
   13f5c:	602b      	str	r3, [r5, #0]

#if I2C_MASTER_CALLBACK_MODE == true
	/* Enable module interrupts */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
   13f5e:	6830      	ldr	r0, [r6, #0]
   13f60:	4b1f      	ldr	r3, [pc, #124]	; (13fe0 <I2cInitializeDriver+0xf0>)
   13f62:	4798      	blx	r3
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
   13f64:	231f      	movs	r3, #31
   13f66:	4018      	ands	r0, r3
   13f68:	3b1e      	subs	r3, #30
   13f6a:	4083      	lsls	r3, r0
   13f6c:	4a1d      	ldr	r2, [pc, #116]	; (13fe4 <I2cInitializeDriver+0xf4>)
   13f6e:	6013      	str	r3, [r2, #0]
#endif
	/* Start timeout if bus state is unknown */
	while (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(1))) {
   13f70:	2210      	movs	r2, #16
		timeout_counter++;
		if(timeout_counter >= (module->unknown_bus_state_timeout)) {
   13f72:	88f0      	ldrh	r0, [r6, #6]
	while (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(1))) {
   13f74:	8b69      	ldrh	r1, [r5, #26]
   13f76:	4211      	tst	r1, r2
   13f78:	d103      	bne.n	13f82 <I2cInitializeDriver+0x92>
		timeout_counter++;
   13f7a:	3401      	adds	r4, #1
		if(timeout_counter >= (module->unknown_bus_state_timeout)) {
   13f7c:	4284      	cmp	r4, r0
   13f7e:	d3f9      	bcc.n	13f74 <I2cInitializeDriver+0x84>
			/* Timeout, force bus state to idle */
			i2c_module->STATUS.reg = SERCOM_I2CM_STATUS_BUSSTATE(1);
   13f80:	836a      	strh	r2, [r5, #26]


	error = I2cDriverConfigureSensorBus();
	if(STATUS_OK != error) goto exit;
	
	I2cDriverRegisterSensorBusCallbacks();
   13f82:	4b19      	ldr	r3, [pc, #100]	; (13fe8 <I2cInitializeDriver+0xf8>)
   13f84:	4798      	blx	r3
	
		
	sensorI2cMutexHandle = xSemaphoreCreateMutex();
   13f86:	4b19      	ldr	r3, [pc, #100]	; (13fec <I2cInitializeDriver+0xfc>)
   13f88:	2001      	movs	r0, #1
   13f8a:	4798      	blx	r3
   13f8c:	4c18      	ldr	r4, [pc, #96]	; (13ff0 <I2cInitializeDriver+0x100>)
	
	sensorI2cSemaphoreHandle = xSemaphoreCreateBinary();
   13f8e:	2203      	movs	r2, #3
	sensorI2cMutexHandle = xSemaphoreCreateMutex();
   13f90:	6020      	str	r0, [r4, #0]
	sensorI2cSemaphoreHandle = xSemaphoreCreateBinary();
   13f92:	4b18      	ldr	r3, [pc, #96]	; (13ff4 <I2cInitializeDriver+0x104>)
   13f94:	2100      	movs	r1, #0
   13f96:	2001      	movs	r0, #1
   13f98:	4798      	blx	r3
   13f9a:	4a17      	ldr	r2, [pc, #92]	; (13ff8 <I2cInitializeDriver+0x108>)
   13f9c:	0003      	movs	r3, r0
   13f9e:	6010      	str	r0, [r2, #0]
	//xSemaphoreGive(sensorI2cSemaphoreHandle);

	
	if(NULL == sensorI2cMutexHandle || NULL == sensorI2cSemaphoreHandle){
   13fa0:	6822      	ldr	r2, [r4, #0]
		error = STATUS_SUSPEND;	//Could not initialize mutex!
   13fa2:	2006      	movs	r0, #6
	if(NULL == sensorI2cMutexHandle || NULL == sensorI2cSemaphoreHandle){
   13fa4:	2a00      	cmp	r2, #0
   13fa6:	d003      	beq.n	13fb0 <I2cInitializeDriver+0xc0>
   13fa8:	425a      	negs	r2, r3
   13faa:	4153      	adcs	r3, r2
   13fac:	425b      	negs	r3, r3
   13fae:	4018      	ands	r0, r3
		goto exit;
	}

	exit:
	return error;		
}
   13fb0:	b00e      	add	sp, #56	; 0x38
   13fb2:	bd70      	pop	{r4, r5, r6, pc}
   13fb4:	3d01      	subs	r5, #1
			i2c_master_reset(&i2cSensorBusInstance);
   13fb6:	0030      	movs	r0, r6
   13fb8:	4b10      	ldr	r3, [pc, #64]	; (13ffc <I2cInitializeDriver+0x10c>)
   13fba:	b2ed      	uxtb	r5, r5
   13fbc:	4798      	blx	r3
	for(uint8_t i = I2C_INIT_ATTEMPTS; i != 0; i--){
   13fbe:	2d00      	cmp	r5, #0
   13fc0:	d1bc      	bne.n	13f3c <I2cInitializeDriver+0x4c>
   13fc2:	e7c3      	b.n	13f4c <I2cInitializeDriver+0x5c>
   13fc4:	00000d48 	.word	0x00000d48
   13fc8:	00080002 	.word	0x00080002
   13fcc:	00090002 	.word	0x00090002
   13fd0:	00002710 	.word	0x00002710
   13fd4:	200042b8 	.word	0x200042b8
   13fd8:	42000800 	.word	0x42000800
   13fdc:	00015669 	.word	0x00015669
   13fe0:	0001d699 	.word	0x0001d699
   13fe4:	e000e100 	.word	0xe000e100
   13fe8:	00013ea9 	.word	0x00013ea9
   13fec:	000175f5 	.word	0x000175f5
   13ff0:	200042b4 	.word	0x200042b4
   13ff4:	00017229 	.word	0x00017229
   13ff8:	200042e0 	.word	0x200042e0
   13ffc:	00015941 	.word	0x00015941

00014000 <I2cWriteData>:
 * @param[in]   data Pointer to I2C data structure which has all the information needed to send an I2C message
 * @return      Returns an error message in case of error. See ErrCodes.h
 * @note        
 *****************************************************************************/

int32_t I2cWriteData(I2C_Data *data){
   14000:	b510      	push	{r4, lr}
	I2C_Bus_State * busI2cState;
	struct i2c_master_packet *writePacket = NULL;
	struct i2c_master_packet *readPacket = NULL;
	
	//Check parameters
	if(data == NULL || data->msgOut == NULL){
   14002:	2800      	cmp	r0, #0
   14004:	d011      	beq.n	1402a <I2cWriteData+0x2a>
   14006:	6843      	ldr	r3, [r0, #4]
   14008:	2b00      	cmp	r3, #0
   1400a:	d00e      	beq.n	1402a <I2cWriteData+0x2a>
		error = ERR_INVALID_ARG;
		goto exit;
	}

	//Prepare to write
	sensorPacketWrite.address = data->address;
   1400c:	7802      	ldrb	r2, [r0, #0]
   1400e:	4908      	ldr	r1, [pc, #32]	; (14030 <I2cWriteData+0x30>)
   14010:	800a      	strh	r2, [r1, #0]
	sensorPacketWrite.data = (uint8_t*) data->msgOut;
   14012:	604b      	str	r3, [r1, #4]
	sensorPacketWrite.data_length = data->lenOut;
   14014:	89c3      	ldrh	r3, [r0, #14]
	
	//Write

	 hwError = i2c_master_write_packet_job(&i2cSensorBusInstance, &sensorPacketWrite);
   14016:	4807      	ldr	r0, [pc, #28]	; (14034 <I2cWriteData+0x34>)
	sensorPacketWrite.data_length = data->lenOut;
   14018:	804b      	strh	r3, [r1, #2]
	 hwError = i2c_master_write_packet_job(&i2cSensorBusInstance, &sensorPacketWrite);
   1401a:	4b07      	ldr	r3, [pc, #28]	; (14038 <I2cWriteData+0x38>)
   1401c:	4798      	blx	r3
	int32_t error = ERROR_NONE;
   1401e:	2300      	movs	r3, #0
	
	if(STATUS_OK != hwError)
   14020:	4298      	cmp	r0, r3
   14022:	d000      	beq.n	14026 <I2cWriteData+0x26>
	{
		error = ERROR_IO;
   14024:	3b06      	subs	r3, #6
		goto exit;
	}
	
	exit:
	return error;
}
   14026:	0018      	movs	r0, r3
   14028:	bd10      	pop	{r4, pc}
		error = ERR_INVALID_ARG;
   1402a:	2308      	movs	r3, #8
   1402c:	425b      	negs	r3, r3
   1402e:	e7fa      	b.n	14026 <I2cWriteData+0x26>
   14030:	200042e4 	.word	0x200042e4
   14034:	200042b8 	.word	0x200042b8
   14038:	00012555 	.word	0x00012555

0001403c <I2cReadData>:
 * @details     
 * @param[in]   data Pointer to I2C data structure which has all the information needed to send an I2C message
 * @return      Returns an error message in case of error. See ErrCodes.h
 * @note        
 *****************************************************************************/
int32_t I2cReadData(I2C_Data *data){
   1403c:	b510      	push	{r4, lr}
	struct i2c_master_packet *writePacket = NULL;
	struct i2c_master_packet *readPacket = NULL;
	
	
	//Check parameters
	if(data == NULL || data->msgOut == NULL){
   1403e:	2800      	cmp	r0, #0
   14040:	d012      	beq.n	14068 <I2cReadData+0x2c>
   14042:	6843      	ldr	r3, [r0, #4]
   14044:	2b00      	cmp	r3, #0
   14046:	d00f      	beq.n	14068 <I2cReadData+0x2c>
		error = ERR_INVALID_ARG;
		goto exit;
	}

	//Prepare to read
	sensorPacketWrite.address = data->address;
   14048:	7803      	ldrb	r3, [r0, #0]
   1404a:	4909      	ldr	r1, [pc, #36]	; (14070 <I2cReadData+0x34>)
   1404c:	800b      	strh	r3, [r1, #0]
	sensorPacketWrite.data = data->msgIn;
   1404e:	6883      	ldr	r3, [r0, #8]
   14050:	604b      	str	r3, [r1, #4]
	sensorPacketWrite.data_length = data->lenIn;
   14052:	8983      	ldrh	r3, [r0, #12]
	
	//Read
	hwError = i2c_master_read_packet_job(&i2cSensorBusInstance, &sensorPacketWrite);
   14054:	4807      	ldr	r0, [pc, #28]	; (14074 <I2cReadData+0x38>)
	sensorPacketWrite.data_length = data->lenIn;
   14056:	804b      	strh	r3, [r1, #2]
	hwError = i2c_master_read_packet_job(&i2cSensorBusInstance, &sensorPacketWrite);
   14058:	4b07      	ldr	r3, [pc, #28]	; (14078 <I2cReadData+0x3c>)
   1405a:	4798      	blx	r3
	int32_t error = ERROR_NONE;
   1405c:	2300      	movs	r3, #0
	
	if(STATUS_OK != hwError)
   1405e:	4298      	cmp	r0, r3
   14060:	d000      	beq.n	14064 <I2cReadData+0x28>
	{
		error = ERROR_IO;
   14062:	3b06      	subs	r3, #6
		goto exit;
	}
	
	exit:
	return error;
}
   14064:	0018      	movs	r0, r3
   14066:	bd10      	pop	{r4, pc}
		error = ERR_INVALID_ARG;
   14068:	2308      	movs	r3, #8
   1406a:	425b      	negs	r3, r3
   1406c:	e7fa      	b.n	14064 <I2cReadData+0x28>
   1406e:	46c0      	nop			; (mov r8, r8)
   14070:	200042e4 	.word	0x200042e4
   14074:	200042b8 	.word	0x200042b8
   14078:	00012535 	.word	0x00012535

0001407c <I2cFreeMutex>:
int32_t I2cFreeMutex(void){
	
	int32_t error = ERROR_NONE;
	
	//students to fill out. Check what the function has to return
	if (xSemaphoreGive(sensorI2cMutexHandle) != pdTRUE)
   1407c:	2300      	movs	r3, #0
int32_t I2cFreeMutex(void){
   1407e:	b510      	push	{r4, lr}
	if (xSemaphoreGive(sensorI2cMutexHandle) != pdTRUE)
   14080:	4805      	ldr	r0, [pc, #20]	; (14098 <I2cFreeMutex+0x1c>)
   14082:	001a      	movs	r2, r3
   14084:	0019      	movs	r1, r3
   14086:	6800      	ldr	r0, [r0, #0]
   14088:	4c04      	ldr	r4, [pc, #16]	; (1409c <I2cFreeMutex+0x20>)
   1408a:	47a0      	blx	r4
	int32_t error = ERROR_NONE;
   1408c:	2300      	movs	r3, #0
	if (xSemaphoreGive(sensorI2cMutexHandle) != pdTRUE)
   1408e:	2801      	cmp	r0, #1
   14090:	d000      	beq.n	14094 <I2cFreeMutex+0x18>
		error = ERROR_NOT_INITIALIZED;
   14092:	3b14      	subs	r3, #20
	
	return error;
}
   14094:	0018      	movs	r0, r3
   14096:	bd10      	pop	{r4, pc}
   14098:	200042b4 	.word	0x200042b4
   1409c:	0001735d 	.word	0x0001735d

000140a0 <I2cGetMutex>:
 * @details     
 * @param[in]   waitTime Time to wait for the mutex to be freed.
 * @return      Returns (ERROR_NONE) if we got the mutex, (ERROR_NOT_READY) if we time out before we got it
 * @note        
 *****************************************************************************/
int32_t I2cGetMutex(TickType_t waitTime){
   140a0:	b510      	push	{r4, lr}
	
	int32_t error = ERROR_NONE;
	//students to fill out. Check what the function has to return
	
	if (xSemaphoreTake(sensorI2cMutexHandle, waitTime) != pdTRUE)
   140a2:	4b05      	ldr	r3, [pc, #20]	; (140b8 <I2cGetMutex+0x18>)
int32_t I2cGetMutex(TickType_t waitTime){
   140a4:	0001      	movs	r1, r0
	if (xSemaphoreTake(sensorI2cMutexHandle, waitTime) != pdTRUE)
   140a6:	6818      	ldr	r0, [r3, #0]
   140a8:	4b04      	ldr	r3, [pc, #16]	; (140bc <I2cGetMutex+0x1c>)
   140aa:	4798      	blx	r3
	int32_t error = ERROR_NONE;
   140ac:	2300      	movs	r3, #0
	if (xSemaphoreTake(sensorI2cMutexHandle, waitTime) != pdTRUE)
   140ae:	2801      	cmp	r0, #1
   140b0:	d000      	beq.n	140b4 <I2cGetMutex+0x14>
		error = ERROR_NOT_READY;
   140b2:	3b1d      	subs	r3, #29
		
	return error;
}
   140b4:	0018      	movs	r0, r3
   140b6:	bd10      	pop	{r4, pc}
   140b8:	200042b4 	.word	0x200042b4
   140bc:	00017b9d 	.word	0x00017b9d

000140c0 <I2cOnlyReadWait>:
				the delay an I2C device needs to make a measurement.
 * @param[in]   xMaxBlockTime Maximum time for the thread to wait until the I2C mutex is free.
 * @return      Returns an error message in case of error.
 * @note        
 *****************************************************************************/
int32_t I2cOnlyReadWait(I2C_Data *data, const TickType_t xMaxBlockTime){
   140c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   140c2:	0004      	movs	r4, r0

	int32_t error = ERROR_NONE;
	SemaphoreHandle_t semHandle = NULL;

	//---0. Get Mutex
	error = I2cGetMutex(xMaxBlockTime);
   140c4:	4b0d      	ldr	r3, [pc, #52]	; (140fc <I2cOnlyReadWait+0x3c>)
   140c6:	0008      	movs	r0, r1
int32_t I2cOnlyReadWait(I2C_Data *data, const TickType_t xMaxBlockTime){
   140c8:	000e      	movs	r6, r1
	error = I2cGetMutex(xMaxBlockTime);
   140ca:	4798      	blx	r3
	//error=0;
	if(ERROR_NONE != error) goto exit;
   140cc:	2800      	cmp	r0, #0
   140ce:	d113      	bne.n	140f8 <I2cOnlyReadWait+0x38>
	*handle = sensorI2cSemaphoreHandle;
   140d0:	4b0b      	ldr	r3, [pc, #44]	; (14100 <I2cOnlyReadWait+0x40>)
	//---1. Get Semaphore Handle
	error = I2cGetSemaphoreHandle(&semHandle);
	if(ERROR_NONE != error) goto exit;

	//---6. Initiate Read data //TIP: SEE "I2cReadData", which is analogous to "I2cWriteData"
	error = I2cReadData(data);
   140d2:	0020      	movs	r0, r4
	*handle = sensorI2cSemaphoreHandle;
   140d4:	681f      	ldr	r7, [r3, #0]
	error = I2cReadData(data);
   140d6:	4b0b      	ldr	r3, [pc, #44]	; (14104 <I2cOnlyReadWait+0x44>)
   140d8:	4798      	blx	r3
   140da:	4c0b      	ldr	r4, [pc, #44]	; (14108 <I2cOnlyReadWait+0x48>)
   140dc:	1e05      	subs	r5, r0, #0
	if (ERROR_NONE != error){
   140de:	d10a      	bne.n	140f6 <I2cOnlyReadWait+0x36>
		goto exitError0;
	}
	
	//---2. Wait for binary semaphore to tell us that we are done!
	if (xSemaphoreTake(semHandle, xMaxBlockTime) == pdTRUE ) {
   140e0:	0031      	movs	r1, r6
   140e2:	0038      	movs	r0, r7
   140e4:	4b09      	ldr	r3, [pc, #36]	; (1410c <I2cOnlyReadWait+0x4c>)
   140e6:	4798      	blx	r3
   140e8:	2801      	cmp	r0, #1
   140ea:	d104      	bne.n	140f6 <I2cOnlyReadWait+0x36>
	 return sensorTransmitError;
   140ec:	4b08      	ldr	r3, [pc, #32]	; (14110 <I2cOnlyReadWait+0x50>)
		/* The transmission ended as expected. We now delay until the I2C sensor is finished */
		if (I2cGetTaskErrorStatus()) {
   140ee:	781a      	ldrb	r2, [r3, #0]
   140f0:	2a00      	cmp	r2, #0
   140f2:	d000      	beq.n	140f6 <I2cOnlyReadWait+0x36>
	sensorTransmitError = value;
   140f4:	701d      	strb	r5, [r3, #0]

exit:
return error;

exitError0:
error = I2cFreeMutex();
   140f6:	47a0      	blx	r4

return error;

}
   140f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   140fa:	46c0      	nop			; (mov r8, r8)
   140fc:	000140a1 	.word	0x000140a1
   14100:	200042e0 	.word	0x200042e0
   14104:	0001403d 	.word	0x0001403d
   14108:	0001407d 	.word	0x0001407d
   1410c:	00017b9d 	.word	0x00017b9d
   14110:	200004e8 	.word	0x200004e8

00014114 <I2cWriteDataWait>:
				the delay an I2C device needs to make a measurement.
 * @param[in]   xMaxBlockTime Maximum time for the thread to wait until the I2C mutex is free.
 * @return      Returns an error message in case of error.
 * @note        
 *****************************************************************************/
int32_t I2cWriteDataWait(I2C_Data *data, const TickType_t xMaxBlockTime){
   14114:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   14116:	0004      	movs	r4, r0

	int32_t error = ERROR_NONE;
	SemaphoreHandle_t semHandle = NULL;

	//---0. Get Mutex
	error = I2cGetMutex(xMaxBlockTime);
   14118:	4b0d      	ldr	r3, [pc, #52]	; (14150 <I2cWriteDataWait+0x3c>)
   1411a:	0008      	movs	r0, r1
int32_t I2cWriteDataWait(I2C_Data *data, const TickType_t xMaxBlockTime){
   1411c:	000e      	movs	r6, r1
	error = I2cGetMutex(xMaxBlockTime);
   1411e:	4798      	blx	r3
	//error=0;
	if(ERROR_NONE != error) goto exit;
   14120:	2800      	cmp	r0, #0
   14122:	d113      	bne.n	1414c <I2cWriteDataWait+0x38>
	*handle = sensorI2cSemaphoreHandle;
   14124:	4b0b      	ldr	r3, [pc, #44]	; (14154 <I2cWriteDataWait+0x40>)
	//---1. Get Semaphore Handle
	error = I2cGetSemaphoreHandle(&semHandle);
	if(ERROR_NONE != error) goto exit;

	//---2. Initiate sending data
	error = I2cWriteData(data);
   14126:	0020      	movs	r0, r4
	*handle = sensorI2cSemaphoreHandle;
   14128:	681f      	ldr	r7, [r3, #0]
	error = I2cWriteData(data);
   1412a:	4b0b      	ldr	r3, [pc, #44]	; (14158 <I2cWriteDataWait+0x44>)
   1412c:	4798      	blx	r3
   1412e:	4c0b      	ldr	r4, [pc, #44]	; (1415c <I2cWriteDataWait+0x48>)
   14130:	1e05      	subs	r5, r0, #0
	if (ERROR_NONE != error){
   14132:	d10a      	bne.n	1414a <I2cWriteDataWait+0x36>
		goto exitError0;
	}

	//---2. Wait for binary semaphore to tell us that we are done!
	if( xSemaphoreTake(semHandle, xMaxBlockTime) == pdTRUE ){
   14134:	0031      	movs	r1, r6
   14136:	0038      	movs	r0, r7
   14138:	4b09      	ldr	r3, [pc, #36]	; (14160 <I2cWriteDataWait+0x4c>)
   1413a:	4798      	blx	r3
   1413c:	2801      	cmp	r0, #1
   1413e:	d104      	bne.n	1414a <I2cWriteDataWait+0x36>
	 return sensorTransmitError;
   14140:	4b08      	ldr	r3, [pc, #32]	; (14164 <I2cWriteDataWait+0x50>)
		/* The transmission ended as expected. We now delay until the I2C sensor is finished */
		if(I2cGetTaskErrorStatus()){
   14142:	781a      	ldrb	r2, [r3, #0]
   14144:	2a00      	cmp	r2, #0
   14146:	d000      	beq.n	1414a <I2cWriteDataWait+0x36>
	sensorTransmitError = value;
   14148:	701d      	strb	r5, [r3, #0]

exit:
return error;

exitError0:
error = I2cFreeMutex();
   1414a:	47a0      	blx	r4

return error;

}
   1414c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1414e:	46c0      	nop			; (mov r8, r8)
   14150:	000140a1 	.word	0x000140a1
   14154:	200042e0 	.word	0x200042e0
   14158:	00014001 	.word	0x00014001
   1415c:	0001407d 	.word	0x0001407d
   14160:	00017b9d 	.word	0x00017b9d
   14164:	200004e8 	.word	0x200004e8

00014168 <I2cReadDataWait>:
 * @param[in]   xMaxBlockTime Maximum time for the thread to wait until the I2C mutex is free.
 * @return      Returns an error message in case of error. See ErrCodes.h
 * @note        THIS IS THE FREERTOS VERSION! DO NOT Declare #define USE_FREERTOS if you wish to use the baremetal version!      
				students to fill!
 *****************************************************************************/
int32_t I2cReadDataWait(I2C_Data *data, const TickType_t delay, const TickType_t xMaxBlockTime) {
   14168:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	
	int32_t error = ERROR_NONE;
	SemaphoreHandle_t semHandle = NULL;
	
	//---0. Get Mutex
	error = I2cGetMutex(xMaxBlockTime);
   1416a:	4b18      	ldr	r3, [pc, #96]	; (141cc <I2cReadDataWait+0x64>)
int32_t I2cReadDataWait(I2C_Data *data, const TickType_t delay, const TickType_t xMaxBlockTime) {
   1416c:	0007      	movs	r7, r0
	error = I2cGetMutex(xMaxBlockTime);
   1416e:	0010      	movs	r0, r2
int32_t I2cReadDataWait(I2C_Data *data, const TickType_t delay, const TickType_t xMaxBlockTime) {
   14170:	9101      	str	r1, [sp, #4]
   14172:	0015      	movs	r5, r2
	error = I2cGetMutex(xMaxBlockTime);
   14174:	4798      	blx	r3
	if(ERROR_NONE != error) goto exit;
   14176:	2800      	cmp	r0, #0
   14178:	d114      	bne.n	141a4 <I2cReadDataWait+0x3c>
	*handle = sensorI2cSemaphoreHandle;
   1417a:	4b15      	ldr	r3, [pc, #84]	; (141d0 <I2cReadDataWait+0x68>)
	//---1. Get Semaphore Handle
	error = I2cGetSemaphoreHandle(&semHandle);
	if (ERROR_NONE != error) goto exit;
	
	//---2. Initiate sending data
	error = I2cWriteData(data);
   1417c:	0038      	movs	r0, r7
	*handle = sensorI2cSemaphoreHandle;
   1417e:	681e      	ldr	r6, [r3, #0]
	error = I2cWriteData(data);
   14180:	4b14      	ldr	r3, [pc, #80]	; (141d4 <I2cReadDataWait+0x6c>)
   14182:	4798      	blx	r3
	if (ERROR_NONE != error){
   14184:	2800      	cmp	r0, #0
   14186:	d10b      	bne.n	141a0 <I2cReadDataWait+0x38>
		goto exitError0;
	}
	
	//---2. Wait for binary semaphore to tell us that we are done!
	if (xSemaphoreTake(semHandle, xMaxBlockTime) == pdTRUE) {
   14188:	0029      	movs	r1, r5
   1418a:	0030      	movs	r0, r6
   1418c:	4b12      	ldr	r3, [pc, #72]	; (141d8 <I2cReadDataWait+0x70>)
   1418e:	4798      	blx	r3
   14190:	2801      	cmp	r0, #1
   14192:	d105      	bne.n	141a0 <I2cReadDataWait+0x38>
	 return sensorTransmitError;
   14194:	4c11      	ldr	r4, [pc, #68]	; (141dc <I2cReadDataWait+0x74>)
		/* The transmission ended as expected. We now delay until the I2C sensor is finished */
		if (I2cGetTaskErrorStatus()) {
   14196:	7823      	ldrb	r3, [r4, #0]
   14198:	2b00      	cmp	r3, #0
   1419a:	d004      	beq.n	141a6 <I2cReadDataWait+0x3e>
	sensorTransmitError = value;
   1419c:	2300      	movs	r3, #0
   1419e:	7023      	strb	r3, [r4, #0]

	exit:
	return error;

	exitError0:
	error = I2cFreeMutex();
   141a0:	4b0f      	ldr	r3, [pc, #60]	; (141e0 <I2cReadDataWait+0x78>)
   141a2:	4798      	blx	r3

	return error;
   141a4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		vTaskDelay(delay);
   141a6:	9801      	ldr	r0, [sp, #4]
   141a8:	4b0e      	ldr	r3, [pc, #56]	; (141e4 <I2cReadDataWait+0x7c>)
   141aa:	4798      	blx	r3
	error = I2cReadData(data);
   141ac:	0038      	movs	r0, r7
   141ae:	4b0e      	ldr	r3, [pc, #56]	; (141e8 <I2cReadDataWait+0x80>)
   141b0:	4798      	blx	r3
	if (ERROR_NONE != error){
   141b2:	2800      	cmp	r0, #0
   141b4:	d1f4      	bne.n	141a0 <I2cReadDataWait+0x38>
	if (xSemaphoreTake(semHandle, xMaxBlockTime) == pdTRUE ) {
   141b6:	0029      	movs	r1, r5
   141b8:	0030      	movs	r0, r6
   141ba:	4b07      	ldr	r3, [pc, #28]	; (141d8 <I2cReadDataWait+0x70>)
   141bc:	4798      	blx	r3
   141be:	2801      	cmp	r0, #1
   141c0:	d1ee      	bne.n	141a0 <I2cReadDataWait+0x38>
		if (I2cGetTaskErrorStatus()) {
   141c2:	7823      	ldrb	r3, [r4, #0]
   141c4:	2b00      	cmp	r3, #0
   141c6:	d1e9      	bne.n	1419c <I2cReadDataWait+0x34>
   141c8:	e7ea      	b.n	141a0 <I2cReadDataWait+0x38>
   141ca:	46c0      	nop			; (mov r8, r8)
   141cc:	000140a1 	.word	0x000140a1
   141d0:	200042e0 	.word	0x200042e0
   141d4:	00014001 	.word	0x00014001
   141d8:	00017b9d 	.word	0x00017b9d
   141dc:	200004e8 	.word	0x200004e8
   141e0:	0001407d 	.word	0x0001407d
   141e4:	000185ad 	.word	0x000185ad
   141e8:	0001403d 	.word	0x0001403d

000141ec <vImuTask>:
                    and then add it to the queue ready to be publish or fetched over CLI.
 * @param[in]       pvParameters
 * @return          None
 */
void vImuTask(void *pvParameters)
{
   141ec:	b5f0      	push	{r4, r5, r6, r7, lr}
	
	// Structure definition that holds IMU data
	struct ImuDataPacket_float imuData;
	int16_t data_raw_acceleration[3];
	
	stmdev_ctx_t *dev_ctx = GetImuStruct();
   141ee:	4b18      	ldr	r3, [pc, #96]	; (14250 <vImuTask+0x64>)
{
   141f0:	b089      	sub	sp, #36	; 0x24
	stmdev_ctx_t *dev_ctx = GetImuStruct();
   141f2:	4798      	blx	r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
   141f4:	2680      	movs	r6, #128	; 0x80
		if (xQueueImuBuffer) {
			WifiAddImuDataToQueue(&imuData);
		}
		
		port_pin_set_output_level(LED_0_PIN, LED_0_ACTIVE);
		vTaskDelay(500);
   141f6:	27fa      	movs	r7, #250	; 0xfa
	stmdev_ctx_t *dev_ctx = GetImuStruct();
   141f8:	9001      	str	r0, [sp, #4]
   141fa:	0436      	lsls	r6, r6, #16
		vTaskDelay(500);
   141fc:	007f      	lsls	r7, r7, #1
		lsm6dso_acceleration_raw_get(dev_ctx, data_raw_acceleration);		
   141fe:	ac03      	add	r4, sp, #12
   14200:	4b14      	ldr	r3, [pc, #80]	; (14254 <vImuTask+0x68>)
   14202:	0021      	movs	r1, r4
   14204:	9801      	ldr	r0, [sp, #4]
   14206:	4798      	blx	r3
		imuData.xmg = lsm6dso_from_fs2_to_mg(data_raw_acceleration[0]);
   14208:	4d13      	ldr	r5, [pc, #76]	; (14258 <vImuTask+0x6c>)
   1420a:	2300      	movs	r3, #0
   1420c:	5ee0      	ldrsh	r0, [r4, r3]
   1420e:	47a8      	blx	r5
   14210:	9005      	str	r0, [sp, #20]
		imuData.ymg = lsm6dso_from_fs2_to_mg(data_raw_acceleration[1]);
   14212:	2302      	movs	r3, #2
   14214:	5ee0      	ldrsh	r0, [r4, r3]
   14216:	47a8      	blx	r5
   14218:	9006      	str	r0, [sp, #24]
		imuData.zmg = lsm6dso_from_fs2_to_mg(data_raw_acceleration[2]);
   1421a:	2304      	movs	r3, #4
   1421c:	5ee0      	ldrsh	r0, [r4, r3]
   1421e:	47a8      	blx	r5
		if (xQueueImuBuffer) {
   14220:	4b0e      	ldr	r3, [pc, #56]	; (1425c <vImuTask+0x70>)
		imuData.zmg = lsm6dso_from_fs2_to_mg(data_raw_acceleration[2]);
   14222:	9007      	str	r0, [sp, #28]
		if (xQueueImuBuffer) {
   14224:	681b      	ldr	r3, [r3, #0]
   14226:	2b00      	cmp	r3, #0
   14228:	d002      	beq.n	14230 <vImuTask+0x44>
			WifiAddImuDataToQueue(&imuData);
   1422a:	a805      	add	r0, sp, #20
   1422c:	4b0c      	ldr	r3, [pc, #48]	; (14260 <vImuTask+0x74>)
   1422e:	4798      	blx	r3
   14230:	4c0c      	ldr	r4, [pc, #48]	; (14264 <vImuTask+0x78>)
		vTaskDelay(500);
   14232:	0038      	movs	r0, r7
   14234:	6166      	str	r6, [r4, #20]
   14236:	4d0c      	ldr	r5, [pc, #48]	; (14268 <vImuTask+0x7c>)
   14238:	47a8      	blx	r5
		
		if (xQueueImuCliBuffer) {
   1423a:	4b0c      	ldr	r3, [pc, #48]	; (1426c <vImuTask+0x80>)
   1423c:	681b      	ldr	r3, [r3, #0]
   1423e:	2b00      	cmp	r3, #0
   14240:	d002      	beq.n	14248 <vImuTask+0x5c>
			CLIAddImuDataToQueue(&imuData);
   14242:	a805      	add	r0, sp, #20
   14244:	4b0a      	ldr	r3, [pc, #40]	; (14270 <vImuTask+0x84>)
   14246:	4798      	blx	r3
		port_base->OUTSET.reg = pin_mask;
   14248:	61a6      	str	r6, [r4, #24]
		}

		port_pin_set_output_level(LED_0_PIN, LED_0_INACTIVE);
		vTaskDelay(500);
   1424a:	0038      	movs	r0, r7
   1424c:	47a8      	blx	r5
		lsm6dso_acceleration_raw_get(dev_ctx, data_raw_acceleration);		
   1424e:	e7d6      	b.n	141fe <vImuTask+0x12>
   14250:	0001478d 	.word	0x0001478d
   14254:	00014415 	.word	0x00014415
   14258:	00014309 	.word	0x00014309
   1425c:	20000b98 	.word	0x20000b98
   14260:	00015609 	.word	0x00015609
   14264:	41004400 	.word	0x41004400
   14268:	000185ad 	.word	0x000185ad
   1426c:	200004e4 	.word	0x200004e4
   14270:	00013e19 	.word	0x00013e19

00014274 <platform_read>:
 * @param[in]   len Length of the data to be read
 * @return      Returns what the function "I2cReadDataWait" returns
 * @note        STUDENTS TO FILL  
*****************************************************************************/
static int32_t platform_read(void *handle, uint8_t reg, uint8_t *bufp, uint16_t len)
{
   14274:	b5f0      	push	{r4, r5, r6, r7, lr}
   14276:	b085      	sub	sp, #20
   14278:	001f      	movs	r7, r3
	//imuData.address = 0x6B;
	//
	//error = I2cReadDataWait(&imuData, 0, 100);
	//memcpy(bufp, msgOutImu, len);
	
	uint8_t reg_data = reg | SPI_READ_COMMAND;
   1427a:	ab02      	add	r3, sp, #8
{
   1427c:	0005      	movs	r5, r0
	uint8_t reg_data = reg | SPI_READ_COMMAND;
   1427e:	1dd8      	adds	r0, r3, #7
   14280:	2380      	movs	r3, #128	; 0x80
		port_base->OUTCLR.reg = pin_mask;
   14282:	2680      	movs	r6, #128	; 0x80
   14284:	4c0a      	ldr	r4, [pc, #40]	; (142b0 <platform_read+0x3c>)
   14286:	425b      	negs	r3, r3
   14288:	430b      	orrs	r3, r1
   1428a:	02b6      	lsls	r6, r6, #10
{
   1428c:	9201      	str	r2, [sp, #4]
	uint8_t reg_data = reg | SPI_READ_COMMAND;
   1428e:	7003      	strb	r3, [r0, #0]
	uint16_t dummy_data = 0;
	
	//spi_select_slave((struct spi_module*) handle, &slave, true);
	port_pin_set_output_level(SLAVE_SELECT_PIN, false);
	spi_write_buffer_wait((struct spi_module*) handle, &reg_data, 1);
   14290:	0001      	movs	r1, r0
   14292:	6166      	str	r6, [r4, #20]
   14294:	2201      	movs	r2, #1
   14296:	0028      	movs	r0, r5
   14298:	4b06      	ldr	r3, [pc, #24]	; (142b4 <platform_read+0x40>)
   1429a:	4798      	blx	r3
	spi_read_buffer_wait((struct spi_module*) handle, bufp, len, dummy_data);
   1429c:	2300      	movs	r3, #0
   1429e:	003a      	movs	r2, r7
   142a0:	9901      	ldr	r1, [sp, #4]
   142a2:	0028      	movs	r0, r5
   142a4:	4d04      	ldr	r5, [pc, #16]	; (142b8 <platform_read+0x44>)
   142a6:	47a8      	blx	r5
	port_pin_set_output_level(SLAVE_SELECT_PIN, true);
	//spi_select_slave((struct spi_module*) handle, &slave, false);
	
	return 0;
}
   142a8:	2000      	movs	r0, #0
		port_base->OUTSET.reg = pin_mask;
   142aa:	61a6      	str	r6, [r4, #24]
   142ac:	b005      	add	sp, #20
   142ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
   142b0:	41004400 	.word	0x41004400
   142b4:	0001db2d 	.word	0x0001db2d
   142b8:	0001da21 	.word	0x0001da21

000142bc <platform_write>:
{
   142bc:	b5f0      	push	{r4, r5, r6, r7, lr}
		port_base->OUTCLR.reg = pin_mask;
   142be:	2780      	movs	r7, #128	; 0x80
   142c0:	0006      	movs	r6, r0
   142c2:	b085      	sub	sp, #20
   142c4:	9301      	str	r3, [sp, #4]
   142c6:	4c09      	ldr	r4, [pc, #36]	; (142ec <platform_write+0x30>)
	uint8_t reg_data = reg;
   142c8:	ab02      	add	r3, sp, #8
   142ca:	71d9      	strb	r1, [r3, #7]
   142cc:	02bf      	lsls	r7, r7, #10
   142ce:	3307      	adds	r3, #7
{
   142d0:	9200      	str	r2, [sp, #0]
	spi_write_buffer_wait((struct spi_module*) handle, &reg_data, 1);
   142d2:	0019      	movs	r1, r3
   142d4:	4d06      	ldr	r5, [pc, #24]	; (142f0 <platform_write+0x34>)
   142d6:	6167      	str	r7, [r4, #20]
   142d8:	2201      	movs	r2, #1
   142da:	47a8      	blx	r5
	spi_write_buffer_wait((struct spi_module*) handle, bufp, len);
   142dc:	9a01      	ldr	r2, [sp, #4]
   142de:	9900      	ldr	r1, [sp, #0]
   142e0:	0030      	movs	r0, r6
   142e2:	47a8      	blx	r5
}
   142e4:	2000      	movs	r0, #0
		port_base->OUTSET.reg = pin_mask;
   142e6:	61a7      	str	r7, [r4, #24]
   142e8:	b005      	add	sp, #20
   142ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
   142ec:	41004400 	.word	0x41004400
   142f0:	0001db2d 	.word	0x0001db2d

000142f4 <lsm6dso_read_reg>:
{
   142f4:	b510      	push	{r4, lr}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
   142f6:	6844      	ldr	r4, [r0, #4]
   142f8:	6880      	ldr	r0, [r0, #8]
   142fa:	47a0      	blx	r4
}
   142fc:	bd10      	pop	{r4, pc}

000142fe <lsm6dso_write_reg>:
{
   142fe:	b510      	push	{r4, lr}
  ret = ctx->write_reg(ctx->handle, reg, data, len);
   14300:	6804      	ldr	r4, [r0, #0]
   14302:	6880      	ldr	r0, [r0, #8]
   14304:	47a0      	blx	r4
}
   14306:	bd10      	pop	{r4, pc}

00014308 <lsm6dso_from_fs2_to_mg>:
{
   14308:	b510      	push	{r4, lr}
  return ((float_t)lsb) * 0.061f;
   1430a:	4b03      	ldr	r3, [pc, #12]	; (14318 <lsm6dso_from_fs2_to_mg+0x10>)
   1430c:	4798      	blx	r3
   1430e:	4903      	ldr	r1, [pc, #12]	; (1431c <lsm6dso_from_fs2_to_mg+0x14>)
   14310:	4b03      	ldr	r3, [pc, #12]	; (14320 <lsm6dso_from_fs2_to_mg+0x18>)
   14312:	4798      	blx	r3
}
   14314:	bd10      	pop	{r4, pc}
   14316:	46c0      	nop			; (mov r8, r8)
   14318:	000269f1 	.word	0x000269f1
   1431c:	3d79db23 	.word	0x3d79db23
   14320:	00026439 	.word	0x00026439

00014324 <lsm6dso_xl_full_scale_set>:
{
   14324:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t *)&reg, 1);
   14326:	ac01      	add	r4, sp, #4
{
   14328:	000e      	movs	r6, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t *)&reg, 1);
   1432a:	2301      	movs	r3, #1
   1432c:	0022      	movs	r2, r4
   1432e:	2110      	movs	r1, #16
   14330:	4f09      	ldr	r7, [pc, #36]	; (14358 <lsm6dso_xl_full_scale_set+0x34>)
{
   14332:	0005      	movs	r5, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t *)&reg, 1);
   14334:	47b8      	blx	r7
  if (ret == 0)
   14336:	2800      	cmp	r0, #0
   14338:	d10d      	bne.n	14356 <lsm6dso_xl_full_scale_set+0x32>
    reg.fs_xl = (uint8_t) val;
   1433a:	2103      	movs	r1, #3
   1433c:	230c      	movs	r3, #12
   1433e:	400e      	ands	r6, r1
   14340:	7821      	ldrb	r1, [r4, #0]
   14342:	00b6      	lsls	r6, r6, #2
   14344:	4399      	bics	r1, r3
   14346:	4331      	orrs	r1, r6
   14348:	7021      	strb	r1, [r4, #0]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t *)&reg, 1);
   1434a:	0022      	movs	r2, r4
   1434c:	3b0b      	subs	r3, #11
   1434e:	2110      	movs	r1, #16
   14350:	0028      	movs	r0, r5
   14352:	4c02      	ldr	r4, [pc, #8]	; (1435c <lsm6dso_xl_full_scale_set+0x38>)
   14354:	47a0      	blx	r4
}
   14356:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   14358:	000142f5 	.word	0x000142f5
   1435c:	000142ff 	.word	0x000142ff

00014360 <lsm6dso_gy_full_scale_set>:
{
   14360:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t *)&reg, 1);
   14362:	ac01      	add	r4, sp, #4
{
   14364:	000e      	movs	r6, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t *)&reg, 1);
   14366:	2301      	movs	r3, #1
   14368:	0022      	movs	r2, r4
   1436a:	2111      	movs	r1, #17
   1436c:	4f09      	ldr	r7, [pc, #36]	; (14394 <lsm6dso_gy_full_scale_set+0x34>)
{
   1436e:	0005      	movs	r5, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t *)&reg, 1);
   14370:	47b8      	blx	r7
  if (ret == 0)
   14372:	2800      	cmp	r0, #0
   14374:	d10d      	bne.n	14392 <lsm6dso_gy_full_scale_set+0x32>
    reg.fs_g = (uint8_t) val;
   14376:	2107      	movs	r1, #7
   14378:	230e      	movs	r3, #14
   1437a:	400e      	ands	r6, r1
   1437c:	7821      	ldrb	r1, [r4, #0]
   1437e:	0076      	lsls	r6, r6, #1
   14380:	4399      	bics	r1, r3
   14382:	4331      	orrs	r1, r6
   14384:	7021      	strb	r1, [r4, #0]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t *)&reg, 1);
   14386:	0022      	movs	r2, r4
   14388:	3b0d      	subs	r3, #13
   1438a:	2111      	movs	r1, #17
   1438c:	0028      	movs	r0, r5
   1438e:	4c02      	ldr	r4, [pc, #8]	; (14398 <lsm6dso_gy_full_scale_set+0x38>)
   14390:	47a0      	blx	r4
}
   14392:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   14394:	000142f5 	.word	0x000142f5
   14398:	000142ff 	.word	0x000142ff

0001439c <lsm6dso_block_data_update_set>:
{
   1439c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t *)&reg, 1);
   1439e:	ac01      	add	r4, sp, #4
{
   143a0:	000e      	movs	r6, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t *)&reg, 1);
   143a2:	2301      	movs	r3, #1
   143a4:	0022      	movs	r2, r4
   143a6:	2112      	movs	r1, #18
   143a8:	4f09      	ldr	r7, [pc, #36]	; (143d0 <lsm6dso_block_data_update_set+0x34>)
{
   143aa:	0005      	movs	r5, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t *)&reg, 1);
   143ac:	47b8      	blx	r7
  if (ret == 0)
   143ae:	2800      	cmp	r0, #0
   143b0:	d10c      	bne.n	143cc <lsm6dso_block_data_update_set+0x30>
    reg.bdu = val;
   143b2:	2301      	movs	r3, #1
   143b4:	2240      	movs	r2, #64	; 0x40
   143b6:	7821      	ldrb	r1, [r4, #0]
   143b8:	401e      	ands	r6, r3
   143ba:	4391      	bics	r1, r2
   143bc:	01b6      	lsls	r6, r6, #6
   143be:	4331      	orrs	r1, r6
   143c0:	7021      	strb	r1, [r4, #0]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t *)&reg, 1);
   143c2:	0022      	movs	r2, r4
   143c4:	2112      	movs	r1, #18
   143c6:	0028      	movs	r0, r5
   143c8:	4c02      	ldr	r4, [pc, #8]	; (143d4 <lsm6dso_block_data_update_set+0x38>)
   143ca:	47a0      	blx	r4
}
   143cc:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   143ce:	46c0      	nop			; (mov r8, r8)
   143d0:	000142f5 	.word	0x000142f5
   143d4:	000142ff 	.word	0x000142ff

000143d8 <lsm6dso_xl_offset_weight_set>:
{
   143d8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL6_C, (uint8_t *)&reg, 1);
   143da:	ac01      	add	r4, sp, #4
{
   143dc:	000e      	movs	r6, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL6_C, (uint8_t *)&reg, 1);
   143de:	2301      	movs	r3, #1
   143e0:	0022      	movs	r2, r4
   143e2:	2115      	movs	r1, #21
   143e4:	4f09      	ldr	r7, [pc, #36]	; (1440c <lsm6dso_xl_offset_weight_set+0x34>)
{
   143e6:	0005      	movs	r5, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL6_C, (uint8_t *)&reg, 1);
   143e8:	47b8      	blx	r7
  if (ret == 0)
   143ea:	2800      	cmp	r0, #0
   143ec:	d10c      	bne.n	14408 <lsm6dso_xl_offset_weight_set+0x30>
    reg.usr_off_w = (uint8_t)val;
   143ee:	2301      	movs	r3, #1
   143f0:	2208      	movs	r2, #8
   143f2:	7821      	ldrb	r1, [r4, #0]
   143f4:	401e      	ands	r6, r3
   143f6:	4391      	bics	r1, r2
   143f8:	00f6      	lsls	r6, r6, #3
   143fa:	4331      	orrs	r1, r6
   143fc:	7021      	strb	r1, [r4, #0]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL6_C, (uint8_t *)&reg, 1);
   143fe:	0022      	movs	r2, r4
   14400:	2115      	movs	r1, #21
   14402:	0028      	movs	r0, r5
   14404:	4c02      	ldr	r4, [pc, #8]	; (14410 <lsm6dso_xl_offset_weight_set+0x38>)
   14406:	47a0      	blx	r4
}
   14408:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1440a:	46c0      	nop			; (mov r8, r8)
   1440c:	000142f5 	.word	0x000142f5
   14410:	000142ff 	.word	0x000142ff

00014414 <lsm6dso_acceleration_raw_get>:
{
   14414:	b537      	push	{r0, r1, r2, r4, r5, lr}
  ret = lsm6dso_read_reg(ctx, LSM6DSO_OUTX_L_A, buff, 6);
   14416:	2306      	movs	r3, #6
{
   14418:	000c      	movs	r4, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_OUTX_L_A, buff, 6);
   1441a:	466a      	mov	r2, sp
   1441c:	4d0a      	ldr	r5, [pc, #40]	; (14448 <lsm6dso_acceleration_raw_get+0x34>)
   1441e:	2128      	movs	r1, #40	; 0x28
   14420:	47a8      	blx	r5
  val[0] = (val[0] * 256) + (int16_t)buff[0];
   14422:	466b      	mov	r3, sp
   14424:	785a      	ldrb	r2, [r3, #1]
   14426:	781b      	ldrb	r3, [r3, #0]
   14428:	0212      	lsls	r2, r2, #8
   1442a:	189b      	adds	r3, r3, r2
   1442c:	8023      	strh	r3, [r4, #0]
  val[1] = (val[1] * 256) + (int16_t)buff[2];
   1442e:	466b      	mov	r3, sp
   14430:	78da      	ldrb	r2, [r3, #3]
   14432:	789b      	ldrb	r3, [r3, #2]
   14434:	0212      	lsls	r2, r2, #8
   14436:	189b      	adds	r3, r3, r2
   14438:	8063      	strh	r3, [r4, #2]
  val[2] = (val[2] * 256) + (int16_t)buff[4];
   1443a:	466b      	mov	r3, sp
   1443c:	795a      	ldrb	r2, [r3, #5]
   1443e:	791b      	ldrb	r3, [r3, #4]
   14440:	0212      	lsls	r2, r2, #8
   14442:	189b      	adds	r3, r3, r2
   14444:	80a3      	strh	r3, [r4, #4]
}
   14446:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
   14448:	000142f5 	.word	0x000142f5

0001444c <lsm6dso_mem_bank_set>:
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FUNC_CFG_ACCESS, (uint8_t *)&reg, 1);
   1444c:	2301      	movs	r3, #1
{
   1444e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FUNC_CFG_ACCESS, (uint8_t *)&reg, 1);
   14450:	ac01      	add	r4, sp, #4
{
   14452:	000e      	movs	r6, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FUNC_CFG_ACCESS, (uint8_t *)&reg, 1);
   14454:	0022      	movs	r2, r4
   14456:	0019      	movs	r1, r3
   14458:	4f08      	ldr	r7, [pc, #32]	; (1447c <lsm6dso_mem_bank_set+0x30>)
{
   1445a:	0005      	movs	r5, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FUNC_CFG_ACCESS, (uint8_t *)&reg, 1);
   1445c:	47b8      	blx	r7
  if (ret == 0)
   1445e:	2800      	cmp	r0, #0
   14460:	d10b      	bne.n	1447a <lsm6dso_mem_bank_set+0x2e>
    reg.reg_access = (uint8_t)val;
   14462:	233f      	movs	r3, #63	; 0x3f
   14464:	7821      	ldrb	r1, [r4, #0]
   14466:	01b6      	lsls	r6, r6, #6
   14468:	4019      	ands	r1, r3
   1446a:	4331      	orrs	r1, r6
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FUNC_CFG_ACCESS, (uint8_t *)&reg, 1);
   1446c:	3b3e      	subs	r3, #62	; 0x3e
    reg.reg_access = (uint8_t)val;
   1446e:	7021      	strb	r1, [r4, #0]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FUNC_CFG_ACCESS, (uint8_t *)&reg, 1);
   14470:	0022      	movs	r2, r4
   14472:	0019      	movs	r1, r3
   14474:	0028      	movs	r0, r5
   14476:	4c02      	ldr	r4, [pc, #8]	; (14480 <lsm6dso_mem_bank_set+0x34>)
   14478:	47a0      	blx	r4
}
   1447a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1447c:	000142f5 	.word	0x000142f5
   14480:	000142ff 	.word	0x000142ff

00014484 <lsm6dso_device_id_get>:
{
   14484:	b510      	push	{r4, lr}
   14486:	000a      	movs	r2, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_WHO_AM_I, buff, 1);
   14488:	2301      	movs	r3, #1
   1448a:	210f      	movs	r1, #15
   1448c:	4c01      	ldr	r4, [pc, #4]	; (14494 <lsm6dso_device_id_get+0x10>)
   1448e:	47a0      	blx	r4
}
   14490:	bd10      	pop	{r4, pc}
   14492:	46c0      	nop			; (mov r8, r8)
   14494:	000142f5 	.word	0x000142f5

00014498 <lsm6dso_reset_set>:
{
   14498:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t *)&reg, 1);
   1449a:	ac01      	add	r4, sp, #4
{
   1449c:	000e      	movs	r6, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t *)&reg, 1);
   1449e:	2301      	movs	r3, #1
   144a0:	0022      	movs	r2, r4
   144a2:	2112      	movs	r1, #18
   144a4:	4f08      	ldr	r7, [pc, #32]	; (144c8 <lsm6dso_reset_set+0x30>)
{
   144a6:	0005      	movs	r5, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t *)&reg, 1);
   144a8:	47b8      	blx	r7
  if (ret == 0)
   144aa:	2800      	cmp	r0, #0
   144ac:	d10a      	bne.n	144c4 <lsm6dso_reset_set+0x2c>
    reg.sw_reset = val;
   144ae:	2301      	movs	r3, #1
   144b0:	7821      	ldrb	r1, [r4, #0]
   144b2:	401e      	ands	r6, r3
   144b4:	4399      	bics	r1, r3
   144b6:	4331      	orrs	r1, r6
   144b8:	7021      	strb	r1, [r4, #0]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t *)&reg, 1);
   144ba:	0022      	movs	r2, r4
   144bc:	2112      	movs	r1, #18
   144be:	0028      	movs	r0, r5
   144c0:	4c02      	ldr	r4, [pc, #8]	; (144cc <lsm6dso_reset_set+0x34>)
   144c2:	47a0      	blx	r4
}
   144c4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   144c6:	46c0      	nop			; (mov r8, r8)
   144c8:	000142f5 	.word	0x000142f5
   144cc:	000142ff 	.word	0x000142ff

000144d0 <lsm6dso_i3c_disable_set>:
{
   144d0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL9_XL, (uint8_t *)&ctrl9_xl, 1);
   144d2:	ae01      	add	r6, sp, #4
{
   144d4:	000c      	movs	r4, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL9_XL, (uint8_t *)&ctrl9_xl, 1);
   144d6:	2301      	movs	r3, #1
   144d8:	0032      	movs	r2, r6
   144da:	2118      	movs	r1, #24
   144dc:	4f16      	ldr	r7, [pc, #88]	; (14538 <lsm6dso_i3c_disable_set+0x68>)
{
   144de:	0005      	movs	r5, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL9_XL, (uint8_t *)&ctrl9_xl, 1);
   144e0:	47b8      	blx	r7
  if (ret == 0)
   144e2:	2800      	cmp	r0, #0
   144e4:	d127      	bne.n	14536 <lsm6dso_i3c_disable_set+0x66>
    ctrl9_xl.i3c_disable = ((uint8_t)val & 0x80U) >> 7;
   144e6:	2701      	movs	r7, #1
   144e8:	2102      	movs	r1, #2
   144ea:	09e2      	lsrs	r2, r4, #7
   144ec:	40ba      	lsls	r2, r7
   144ee:	7833      	ldrb	r3, [r6, #0]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL9_XL, (uint8_t *)&ctrl9_xl, 1);
   144f0:	0028      	movs	r0, r5
    ctrl9_xl.i3c_disable = ((uint8_t)val & 0x80U) >> 7;
   144f2:	438b      	bics	r3, r1
   144f4:	4313      	orrs	r3, r2
   144f6:	7033      	strb	r3, [r6, #0]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL9_XL, (uint8_t *)&ctrl9_xl, 1);
   144f8:	0032      	movs	r2, r6
   144fa:	003b      	movs	r3, r7
   144fc:	3116      	adds	r1, #22
   144fe:	4e0f      	ldr	r6, [pc, #60]	; (1453c <lsm6dso_i3c_disable_set+0x6c>)
   14500:	47b0      	blx	r6
  if (ret == 0)
   14502:	2800      	cmp	r0, #0
   14504:	d117      	bne.n	14536 <lsm6dso_i3c_disable_set+0x66>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_I3C_BUS_AVB,
   14506:	003b      	movs	r3, r7
   14508:	466a      	mov	r2, sp
   1450a:	2162      	movs	r1, #98	; 0x62
   1450c:	0028      	movs	r0, r5
   1450e:	4e0a      	ldr	r6, [pc, #40]	; (14538 <lsm6dso_i3c_disable_set+0x68>)
   14510:	47b0      	blx	r6
  if (ret == 0)
   14512:	2800      	cmp	r0, #0
   14514:	d10f      	bne.n	14536 <lsm6dso_i3c_disable_set+0x66>
    i3c_bus_avb.i3c_bus_avb_sel = (uint8_t)val & 0x03U;
   14516:	2303      	movs	r3, #3
   14518:	401c      	ands	r4, r3
   1451a:	409c      	lsls	r4, r3
   1451c:	466b      	mov	r3, sp
   1451e:	2218      	movs	r2, #24
   14520:	781b      	ldrb	r3, [r3, #0]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_I3C_BUS_AVB,
   14522:	2162      	movs	r1, #98	; 0x62
    i3c_bus_avb.i3c_bus_avb_sel = (uint8_t)val & 0x03U;
   14524:	4393      	bics	r3, r2
   14526:	431c      	orrs	r4, r3
   14528:	466b      	mov	r3, sp
    ret = lsm6dso_write_reg(ctx, LSM6DSO_I3C_BUS_AVB,
   1452a:	466a      	mov	r2, sp
    i3c_bus_avb.i3c_bus_avb_sel = (uint8_t)val & 0x03U;
   1452c:	701c      	strb	r4, [r3, #0]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_I3C_BUS_AVB,
   1452e:	0028      	movs	r0, r5
   14530:	003b      	movs	r3, r7
   14532:	4c02      	ldr	r4, [pc, #8]	; (1453c <lsm6dso_i3c_disable_set+0x6c>)
   14534:	47a0      	blx	r4
}
   14536:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   14538:	000142f5 	.word	0x000142f5
   1453c:	000142ff 	.word	0x000142ff

00014540 <lsm6dso_fsm_enable_get>:
{
   14540:	b570      	push	{r4, r5, r6, lr}
   14542:	000e      	movs	r6, r1
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   14544:	4d08      	ldr	r5, [pc, #32]	; (14568 <lsm6dso_fsm_enable_get+0x28>)
   14546:	2102      	movs	r1, #2
{
   14548:	0004      	movs	r4, r0
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   1454a:	47a8      	blx	r5
  if (ret == 0)
   1454c:	2800      	cmp	r0, #0
   1454e:	d10a      	bne.n	14566 <lsm6dso_fsm_enable_get+0x26>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_FSM_ENABLE_A, (uint8_t *) val, 2);
   14550:	0032      	movs	r2, r6
   14552:	2302      	movs	r3, #2
   14554:	2146      	movs	r1, #70	; 0x46
   14556:	0020      	movs	r0, r4
   14558:	4e04      	ldr	r6, [pc, #16]	; (1456c <lsm6dso_fsm_enable_get+0x2c>)
   1455a:	47b0      	blx	r6
  if (ret == 0)
   1455c:	2800      	cmp	r0, #0
   1455e:	d102      	bne.n	14566 <lsm6dso_fsm_enable_get+0x26>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   14560:	0001      	movs	r1, r0
   14562:	0020      	movs	r0, r4
   14564:	47a8      	blx	r5
}
   14566:	bd70      	pop	{r4, r5, r6, pc}
   14568:	0001444d 	.word	0x0001444d
   1456c:	000142f5 	.word	0x000142f5

00014570 <lsm6dso_fsm_data_rate_get>:
{
   14570:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   14572:	4b12      	ldr	r3, [pc, #72]	; (145bc <lsm6dso_fsm_data_rate_get+0x4c>)
{
   14574:	000c      	movs	r4, r1
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   14576:	2102      	movs	r1, #2
{
   14578:	0005      	movs	r5, r0
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   1457a:	4798      	blx	r3
  if (ret == 0)
   1457c:	2800      	cmp	r0, #0
   1457e:	d115      	bne.n	145ac <lsm6dso_fsm_data_rate_get+0x3c>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_EMB_FUNC_ODR_CFG_B,
   14580:	ae01      	add	r6, sp, #4
   14582:	2301      	movs	r3, #1
   14584:	0032      	movs	r2, r6
   14586:	215f      	movs	r1, #95	; 0x5f
   14588:	0028      	movs	r0, r5
   1458a:	4f0d      	ldr	r7, [pc, #52]	; (145c0 <lsm6dso_fsm_data_rate_get+0x50>)
   1458c:	47b8      	blx	r7
  if (ret == 0)
   1458e:	2800      	cmp	r0, #0
   14590:	d10c      	bne.n	145ac <lsm6dso_fsm_data_rate_get+0x3c>
    switch (reg.fsm_odr)
   14592:	7830      	ldrb	r0, [r6, #0]
   14594:	06c0      	lsls	r0, r0, #27
   14596:	0f80      	lsrs	r0, r0, #30
   14598:	f011 f986 	bl	258a8 <__gnu_thumb1_case_uqi>
   1459c:	0d0b0902 	.word	0x0d0b0902
        *val = LSM6DSO_ODR_FSM_12Hz5;
   145a0:	2300      	movs	r3, #0
        *val = LSM6DSO_ODR_FSM_104Hz;
   145a2:	7023      	strb	r3, [r4, #0]
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   145a4:	2100      	movs	r1, #0
   145a6:	0028      	movs	r0, r5
   145a8:	4b04      	ldr	r3, [pc, #16]	; (145bc <lsm6dso_fsm_data_rate_get+0x4c>)
   145aa:	4798      	blx	r3
}
   145ac:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        *val = LSM6DSO_ODR_FSM_26Hz;
   145ae:	2301      	movs	r3, #1
   145b0:	e7f7      	b.n	145a2 <lsm6dso_fsm_data_rate_get+0x32>
        *val = LSM6DSO_ODR_FSM_52Hz;
   145b2:	2302      	movs	r3, #2
   145b4:	e7f5      	b.n	145a2 <lsm6dso_fsm_data_rate_get+0x32>
        *val = LSM6DSO_ODR_FSM_104Hz;
   145b6:	2303      	movs	r3, #3
   145b8:	e7f3      	b.n	145a2 <lsm6dso_fsm_data_rate_get+0x32>
   145ba:	46c0      	nop			; (mov r8, r8)
   145bc:	0001444d 	.word	0x0001444d
   145c0:	000142f5 	.word	0x000142f5

000145c4 <lsm6dso_xl_data_rate_set>:
{
   145c4:	b573      	push	{r0, r1, r4, r5, r6, lr}
  ret =  lsm6dso_fsm_enable_get(ctx, &fsm_enable);
   145c6:	ae01      	add	r6, sp, #4
{
   145c8:	000c      	movs	r4, r1
  ret =  lsm6dso_fsm_enable_get(ctx, &fsm_enable);
   145ca:	4b33      	ldr	r3, [pc, #204]	; (14698 <lsm6dso_xl_data_rate_set+0xd4>)
   145cc:	0031      	movs	r1, r6
{
   145ce:	0005      	movs	r5, r0
  ret =  lsm6dso_fsm_enable_get(ctx, &fsm_enable);
   145d0:	4798      	blx	r3
  if (ret == 0)
   145d2:	2800      	cmp	r0, #0
   145d4:	d151      	bne.n	1467a <lsm6dso_xl_data_rate_set+0xb6>
    if ((fsm_enable.fsm_enable_a.fsm1_en  |
   145d6:	7832      	ldrb	r2, [r6, #0]
         fsm_enable.fsm_enable_a.fsm2_en  |
   145d8:	0793      	lsls	r3, r2, #30
    if ((fsm_enable.fsm_enable_a.fsm1_en  |
   145da:	07d1      	lsls	r1, r2, #31
         fsm_enable.fsm_enable_a.fsm2_en  |
   145dc:	4319      	orrs	r1, r3
         fsm_enable.fsm_enable_a.fsm3_en  |
   145de:	0753      	lsls	r3, r2, #29
   145e0:	430b      	orrs	r3, r1
         fsm_enable.fsm_enable_a.fsm4_en  |
   145e2:	0711      	lsls	r1, r2, #28
   145e4:	430b      	orrs	r3, r1
         fsm_enable.fsm_enable_a.fsm5_en  |
   145e6:	06d1      	lsls	r1, r2, #27
   145e8:	4319      	orrs	r1, r3
         fsm_enable.fsm_enable_a.fsm6_en  |
   145ea:	0693      	lsls	r3, r2, #26
   145ec:	4319      	orrs	r1, r3
         fsm_enable.fsm_enable_a.fsm7_en  |
   145ee:	0653      	lsls	r3, r2, #25
   145f0:	430b      	orrs	r3, r1
         fsm_enable.fsm_enable_a.fsm8_en  |
   145f2:	09d2      	lsrs	r2, r2, #7
         fsm_enable.fsm_enable_a.fsm6_en  |
   145f4:	0fdb      	lsrs	r3, r3, #31
         fsm_enable.fsm_enable_a.fsm7_en  |
   145f6:	4313      	orrs	r3, r2
         fsm_enable.fsm_enable_b.fsm9_en  |
   145f8:	7872      	ldrb	r2, [r6, #1]
   145fa:	07d1      	lsls	r1, r2, #31
   145fc:	0fc9      	lsrs	r1, r1, #31
         fsm_enable.fsm_enable_a.fsm8_en  |
   145fe:	430b      	orrs	r3, r1
         fsm_enable.fsm_enable_b.fsm10_en |
   14600:	0791      	lsls	r1, r2, #30
   14602:	0fc9      	lsrs	r1, r1, #31
         fsm_enable.fsm_enable_b.fsm9_en  |
   14604:	430b      	orrs	r3, r1
         fsm_enable.fsm_enable_b.fsm11_en |
   14606:	0751      	lsls	r1, r2, #29
   14608:	0fc9      	lsrs	r1, r1, #31
         fsm_enable.fsm_enable_b.fsm10_en |
   1460a:	430b      	orrs	r3, r1
         fsm_enable.fsm_enable_b.fsm12_en |
   1460c:	0711      	lsls	r1, r2, #28
   1460e:	0fc9      	lsrs	r1, r1, #31
         fsm_enable.fsm_enable_b.fsm11_en |
   14610:	430b      	orrs	r3, r1
         fsm_enable.fsm_enable_b.fsm13_en |
   14612:	06d1      	lsls	r1, r2, #27
   14614:	0fc9      	lsrs	r1, r1, #31
         fsm_enable.fsm_enable_b.fsm12_en |
   14616:	430b      	orrs	r3, r1
         fsm_enable.fsm_enable_b.fsm14_en |
   14618:	0691      	lsls	r1, r2, #26
   1461a:	0fc9      	lsrs	r1, r1, #31
         fsm_enable.fsm_enable_b.fsm13_en |
   1461c:	430b      	orrs	r3, r1
         fsm_enable.fsm_enable_b.fsm15_en |
   1461e:	0651      	lsls	r1, r2, #25
   14620:	0fc9      	lsrs	r1, r1, #31
         fsm_enable.fsm_enable_b.fsm14_en |
   14622:	430b      	orrs	r3, r1
         fsm_enable.fsm_enable_b.fsm16_en) == PROPERTY_ENABLE)
   14624:	09d2      	lsrs	r2, r2, #7
         fsm_enable.fsm_enable_b.fsm15_en |
   14626:	4313      	orrs	r3, r2
    if ((fsm_enable.fsm_enable_a.fsm1_en  |
   14628:	07db      	lsls	r3, r3, #31
   1462a:	d510      	bpl.n	1464e <lsm6dso_xl_data_rate_set+0x8a>
      ret =  lsm6dso_fsm_data_rate_get(ctx, &fsm_odr);
   1462c:	466b      	mov	r3, sp
   1462e:	1cde      	adds	r6, r3, #3
   14630:	0031      	movs	r1, r6
   14632:	0028      	movs	r0, r5
   14634:	4b19      	ldr	r3, [pc, #100]	; (1469c <lsm6dso_xl_data_rate_set+0xd8>)
   14636:	4798      	blx	r3
      if (ret == 0)
   14638:	2800      	cmp	r0, #0
   1463a:	d11e      	bne.n	1467a <lsm6dso_xl_data_rate_set+0xb6>
        switch (fsm_odr)
   1463c:	7830      	ldrb	r0, [r6, #0]
   1463e:	2803      	cmp	r0, #3
   14640:	d805      	bhi.n	1464e <lsm6dso_xl_data_rate_set+0x8a>
   14642:	f011 f931 	bl	258a8 <__gnu_thumb1_case_uqi>
   14646:	1b02      	.short	0x1b02
   14648:	231f      	.short	0x231f
            if (val == LSM6DSO_XL_ODR_OFF)
   1464a:	2c00      	cmp	r4, #0
   1464c:	d022      	beq.n	14694 <lsm6dso_xl_data_rate_set+0xd0>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t *)&reg, 1);
   1464e:	2301      	movs	r3, #1
   14650:	466a      	mov	r2, sp
   14652:	2110      	movs	r1, #16
   14654:	0028      	movs	r0, r5
   14656:	4e12      	ldr	r6, [pc, #72]	; (146a0 <lsm6dso_xl_data_rate_set+0xdc>)
   14658:	47b0      	blx	r6
  if (ret == 0)
   1465a:	2800      	cmp	r0, #0
   1465c:	d10d      	bne.n	1467a <lsm6dso_xl_data_rate_set+0xb6>
    reg.odr_xl = (uint8_t) odr_xl;
   1465e:	466a      	mov	r2, sp
   14660:	0123      	lsls	r3, r4, #4
   14662:	7814      	ldrb	r4, [r2, #0]
   14664:	220f      	movs	r2, #15
   14666:	4014      	ands	r4, r2
   14668:	431c      	orrs	r4, r3
   1466a:	466b      	mov	r3, sp
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t *)&reg, 1);
   1466c:	466a      	mov	r2, sp
    reg.odr_xl = (uint8_t) odr_xl;
   1466e:	701c      	strb	r4, [r3, #0]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t *)&reg, 1);
   14670:	2110      	movs	r1, #16
   14672:	2301      	movs	r3, #1
   14674:	0028      	movs	r0, r5
   14676:	4c0b      	ldr	r4, [pc, #44]	; (146a4 <lsm6dso_xl_data_rate_set+0xe0>)
   14678:	47a0      	blx	r4
}
   1467a:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
            if (val == LSM6DSO_XL_ODR_OFF)
   1467c:	2c01      	cmp	r4, #1
   1467e:	d8e6      	bhi.n	1464e <lsm6dso_xl_data_rate_set+0x8a>
              odr_xl = LSM6DSO_XL_ODR_26Hz;
   14680:	2402      	movs	r4, #2
   14682:	e7e4      	b.n	1464e <lsm6dso_xl_data_rate_set+0x8a>
            if (val == LSM6DSO_XL_ODR_OFF)
   14684:	2c02      	cmp	r4, #2
   14686:	d8e2      	bhi.n	1464e <lsm6dso_xl_data_rate_set+0x8a>
              odr_xl = LSM6DSO_XL_ODR_52Hz;
   14688:	2403      	movs	r4, #3
   1468a:	e7e0      	b.n	1464e <lsm6dso_xl_data_rate_set+0x8a>
            if (val == LSM6DSO_XL_ODR_OFF)
   1468c:	2c03      	cmp	r4, #3
   1468e:	d8de      	bhi.n	1464e <lsm6dso_xl_data_rate_set+0x8a>
              odr_xl = LSM6DSO_XL_ODR_104Hz;
   14690:	2404      	movs	r4, #4
   14692:	e7dc      	b.n	1464e <lsm6dso_xl_data_rate_set+0x8a>
              odr_xl = LSM6DSO_XL_ODR_12Hz5;
   14694:	2401      	movs	r4, #1
   14696:	e7da      	b.n	1464e <lsm6dso_xl_data_rate_set+0x8a>
   14698:	00014541 	.word	0x00014541
   1469c:	00014571 	.word	0x00014571
   146a0:	000142f5 	.word	0x000142f5
   146a4:	000142ff 	.word	0x000142ff

000146a8 <lsm6dso_gy_data_rate_set>:
{
   146a8:	b573      	push	{r0, r1, r4, r5, r6, lr}
  ret =  lsm6dso_fsm_enable_get(ctx, &fsm_enable);
   146aa:	ae01      	add	r6, sp, #4
{
   146ac:	000c      	movs	r4, r1
  ret =  lsm6dso_fsm_enable_get(ctx, &fsm_enable);
   146ae:	4b33      	ldr	r3, [pc, #204]	; (1477c <lsm6dso_gy_data_rate_set+0xd4>)
   146b0:	0031      	movs	r1, r6
{
   146b2:	0005      	movs	r5, r0
  ret =  lsm6dso_fsm_enable_get(ctx, &fsm_enable);
   146b4:	4798      	blx	r3
  if (ret == 0)
   146b6:	2800      	cmp	r0, #0
   146b8:	d151      	bne.n	1475e <lsm6dso_gy_data_rate_set+0xb6>
    if ((fsm_enable.fsm_enable_a.fsm1_en  |
   146ba:	7832      	ldrb	r2, [r6, #0]
         fsm_enable.fsm_enable_a.fsm2_en  |
   146bc:	0793      	lsls	r3, r2, #30
    if ((fsm_enable.fsm_enable_a.fsm1_en  |
   146be:	07d1      	lsls	r1, r2, #31
         fsm_enable.fsm_enable_a.fsm2_en  |
   146c0:	4319      	orrs	r1, r3
         fsm_enable.fsm_enable_a.fsm3_en  |
   146c2:	0753      	lsls	r3, r2, #29
   146c4:	430b      	orrs	r3, r1
         fsm_enable.fsm_enable_a.fsm4_en  |
   146c6:	0711      	lsls	r1, r2, #28
   146c8:	430b      	orrs	r3, r1
         fsm_enable.fsm_enable_a.fsm5_en  |
   146ca:	06d1      	lsls	r1, r2, #27
   146cc:	4319      	orrs	r1, r3
         fsm_enable.fsm_enable_a.fsm6_en  |
   146ce:	0693      	lsls	r3, r2, #26
   146d0:	4319      	orrs	r1, r3
         fsm_enable.fsm_enable_a.fsm7_en  |
   146d2:	0653      	lsls	r3, r2, #25
   146d4:	430b      	orrs	r3, r1
         fsm_enable.fsm_enable_a.fsm8_en  |
   146d6:	09d2      	lsrs	r2, r2, #7
         fsm_enable.fsm_enable_a.fsm6_en  |
   146d8:	0fdb      	lsrs	r3, r3, #31
         fsm_enable.fsm_enable_a.fsm7_en  |
   146da:	4313      	orrs	r3, r2
         fsm_enable.fsm_enable_b.fsm9_en  |
   146dc:	7872      	ldrb	r2, [r6, #1]
   146de:	07d1      	lsls	r1, r2, #31
   146e0:	0fc9      	lsrs	r1, r1, #31
         fsm_enable.fsm_enable_a.fsm8_en  |
   146e2:	430b      	orrs	r3, r1
         fsm_enable.fsm_enable_b.fsm10_en |
   146e4:	0791      	lsls	r1, r2, #30
   146e6:	0fc9      	lsrs	r1, r1, #31
         fsm_enable.fsm_enable_b.fsm9_en  |
   146e8:	430b      	orrs	r3, r1
         fsm_enable.fsm_enable_b.fsm11_en |
   146ea:	0751      	lsls	r1, r2, #29
   146ec:	0fc9      	lsrs	r1, r1, #31
         fsm_enable.fsm_enable_b.fsm10_en |
   146ee:	430b      	orrs	r3, r1
         fsm_enable.fsm_enable_b.fsm12_en |
   146f0:	0711      	lsls	r1, r2, #28
   146f2:	0fc9      	lsrs	r1, r1, #31
         fsm_enable.fsm_enable_b.fsm11_en |
   146f4:	430b      	orrs	r3, r1
         fsm_enable.fsm_enable_b.fsm13_en |
   146f6:	06d1      	lsls	r1, r2, #27
   146f8:	0fc9      	lsrs	r1, r1, #31
         fsm_enable.fsm_enable_b.fsm12_en |
   146fa:	430b      	orrs	r3, r1
         fsm_enable.fsm_enable_b.fsm14_en |
   146fc:	0691      	lsls	r1, r2, #26
   146fe:	0fc9      	lsrs	r1, r1, #31
         fsm_enable.fsm_enable_b.fsm13_en |
   14700:	430b      	orrs	r3, r1
         fsm_enable.fsm_enable_b.fsm15_en |
   14702:	0651      	lsls	r1, r2, #25
   14704:	0fc9      	lsrs	r1, r1, #31
         fsm_enable.fsm_enable_b.fsm14_en |
   14706:	430b      	orrs	r3, r1
         fsm_enable.fsm_enable_b.fsm16_en) == PROPERTY_ENABLE)
   14708:	09d2      	lsrs	r2, r2, #7
         fsm_enable.fsm_enable_b.fsm15_en |
   1470a:	4313      	orrs	r3, r2
    if ((fsm_enable.fsm_enable_a.fsm1_en  |
   1470c:	07db      	lsls	r3, r3, #31
   1470e:	d510      	bpl.n	14732 <lsm6dso_gy_data_rate_set+0x8a>
      ret =  lsm6dso_fsm_data_rate_get(ctx, &fsm_odr);
   14710:	466b      	mov	r3, sp
   14712:	1cde      	adds	r6, r3, #3
   14714:	0031      	movs	r1, r6
   14716:	0028      	movs	r0, r5
   14718:	4b19      	ldr	r3, [pc, #100]	; (14780 <lsm6dso_gy_data_rate_set+0xd8>)
   1471a:	4798      	blx	r3
      if (ret == 0)
   1471c:	2800      	cmp	r0, #0
   1471e:	d11e      	bne.n	1475e <lsm6dso_gy_data_rate_set+0xb6>
        switch (fsm_odr)
   14720:	7830      	ldrb	r0, [r6, #0]
   14722:	2803      	cmp	r0, #3
   14724:	d805      	bhi.n	14732 <lsm6dso_gy_data_rate_set+0x8a>
   14726:	f011 f8bf 	bl	258a8 <__gnu_thumb1_case_uqi>
   1472a:	1b02      	.short	0x1b02
   1472c:	231f      	.short	0x231f
            if (val == LSM6DSO_GY_ODR_OFF)
   1472e:	2c00      	cmp	r4, #0
   14730:	d022      	beq.n	14778 <lsm6dso_gy_data_rate_set+0xd0>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t *)&reg, 1);
   14732:	2301      	movs	r3, #1
   14734:	466a      	mov	r2, sp
   14736:	2111      	movs	r1, #17
   14738:	0028      	movs	r0, r5
   1473a:	4e12      	ldr	r6, [pc, #72]	; (14784 <lsm6dso_gy_data_rate_set+0xdc>)
   1473c:	47b0      	blx	r6
  if (ret == 0)
   1473e:	2800      	cmp	r0, #0
   14740:	d10d      	bne.n	1475e <lsm6dso_gy_data_rate_set+0xb6>
    reg.odr_g = (uint8_t) odr_gy;
   14742:	466a      	mov	r2, sp
   14744:	0123      	lsls	r3, r4, #4
   14746:	7814      	ldrb	r4, [r2, #0]
   14748:	220f      	movs	r2, #15
   1474a:	4014      	ands	r4, r2
   1474c:	431c      	orrs	r4, r3
   1474e:	466b      	mov	r3, sp
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t *)&reg, 1);
   14750:	466a      	mov	r2, sp
    reg.odr_g = (uint8_t) odr_gy;
   14752:	701c      	strb	r4, [r3, #0]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t *)&reg, 1);
   14754:	2111      	movs	r1, #17
   14756:	2301      	movs	r3, #1
   14758:	0028      	movs	r0, r5
   1475a:	4c0b      	ldr	r4, [pc, #44]	; (14788 <lsm6dso_gy_data_rate_set+0xe0>)
   1475c:	47a0      	blx	r4
}
   1475e:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
            if (val == LSM6DSO_GY_ODR_OFF)
   14760:	2c01      	cmp	r4, #1
   14762:	d8e6      	bhi.n	14732 <lsm6dso_gy_data_rate_set+0x8a>
              odr_gy = LSM6DSO_GY_ODR_26Hz;
   14764:	2402      	movs	r4, #2
   14766:	e7e4      	b.n	14732 <lsm6dso_gy_data_rate_set+0x8a>
            if (val == LSM6DSO_GY_ODR_OFF)
   14768:	2c02      	cmp	r4, #2
   1476a:	d8e2      	bhi.n	14732 <lsm6dso_gy_data_rate_set+0x8a>
              odr_gy = LSM6DSO_GY_ODR_52Hz;
   1476c:	2403      	movs	r4, #3
   1476e:	e7e0      	b.n	14732 <lsm6dso_gy_data_rate_set+0x8a>
            if (val == LSM6DSO_GY_ODR_OFF)
   14770:	2c03      	cmp	r4, #3
   14772:	d8de      	bhi.n	14732 <lsm6dso_gy_data_rate_set+0x8a>
              odr_gy = LSM6DSO_GY_ODR_104Hz;
   14774:	2404      	movs	r4, #4
   14776:	e7dc      	b.n	14732 <lsm6dso_gy_data_rate_set+0x8a>
              odr_gy = LSM6DSO_GY_ODR_12Hz5;
   14778:	2401      	movs	r4, #1
   1477a:	e7da      	b.n	14732 <lsm6dso_gy_data_rate_set+0x8a>
   1477c:	00014541 	.word	0x00014541
   14780:	00014571 	.word	0x00014571
   14784:	000142f5 	.word	0x000142f5
   14788:	000142ff 	.word	0x000142ff

0001478c <GetImuStruct>:


stmdev_ctx_t * GetImuStruct(void)
{
 return &dev_ctx;
}
   1478c:	4800      	ldr	r0, [pc, #0]	; (14790 <GetImuStruct+0x4>)
   1478e:	4770      	bx	lr
   14790:	2000008c 	.word	0x2000008c

00014794 <InitImu>:



int32_t InitImu(void)
{
   14794:	b573      	push	{r0, r1, r4, r5, r6, lr}
	uint8_t rst;
	int32_t error = 0;
	uint8_t whoamI = 0;
   14796:	466b      	mov	r3, sp
   14798:	2600      	movs	r6, #0

  /* Check device ID */
  lsm6dso_device_id_get(&dev_ctx, &whoamI);
   1479a:	4c18      	ldr	r4, [pc, #96]	; (147fc <InitImu+0x68>)
	uint8_t whoamI = 0;
   1479c:	1ddd      	adds	r5, r3, #7
   1479e:	71de      	strb	r6, [r3, #7]
  lsm6dso_device_id_get(&dev_ctx, &whoamI);
   147a0:	0029      	movs	r1, r5
   147a2:	4b17      	ldr	r3, [pc, #92]	; (14800 <InitImu+0x6c>)
   147a4:	0020      	movs	r0, r4
   147a6:	4798      	blx	r3
  
   if (whoamI != LSM6DSO_ID)
   147a8:	782b      	ldrb	r3, [r5, #0]
   147aa:	2b6c      	cmp	r3, #108	; 0x6c
   147ac:	d122      	bne.n	147f4 <InitImu+0x60>
		return -1;
  
  /*
   * Restore default configuration
   */
  error = lsm6dso_reset_set(&dev_ctx, PROPERTY_ENABLE);
   147ae:	2101      	movs	r1, #1
   147b0:	4b14      	ldr	r3, [pc, #80]	; (14804 <InitImu+0x70>)
   147b2:	0020      	movs	r0, r4
   147b4:	4798      	blx	r3
  //do {
    //error |= lsm6dso_reset_get(&dev_ctx, &rst);
  //} while (rst);   // edited reset not working on the PCB

  /* Disable I3C interface */
  lsm6dso_i3c_disable_set(&dev_ctx, LSM6DSO_I3C_DISABLE);
   147b6:	2180      	movs	r1, #128	; 0x80
   147b8:	4b13      	ldr	r3, [pc, #76]	; (14808 <InitImu+0x74>)
  error = lsm6dso_reset_set(&dev_ctx, PROPERTY_ENABLE);
   147ba:	0005      	movs	r5, r0
  lsm6dso_i3c_disable_set(&dev_ctx, LSM6DSO_I3C_DISABLE);
   147bc:	0020      	movs	r0, r4
   147be:	4798      	blx	r3
  /* Enable Block Data Update */
  lsm6dso_block_data_update_set(&dev_ctx, PROPERTY_ENABLE);
   147c0:	2101      	movs	r1, #1
   147c2:	4b12      	ldr	r3, [pc, #72]	; (1480c <InitImu+0x78>)
   147c4:	0020      	movs	r0, r4
   147c6:	4798      	blx	r3
  /* Weight of XL user offset to 2^(-10) g/LSB */
  lsm6dso_xl_offset_weight_set(&dev_ctx, LSM6DSO_LSb_16mg);  //1 msg
   147c8:	2101      	movs	r1, #1
   147ca:	4b11      	ldr	r3, [pc, #68]	; (14810 <InitImu+0x7c>)
   147cc:	0020      	movs	r0, r4
   147ce:	4798      	blx	r3
  /* Accelerometer X,Y,Z axis user offset correction expressed
   * in twos complement. Set X to 48mg, Y tp 64 mg, Z to -127 mg
   */

  /* Set Output Data Rate */
  lsm6dso_xl_data_rate_set(&dev_ctx, LSM6DSO_XL_ODR_833Hz);  // edited change speed here
   147d0:	2107      	movs	r1, #7
   147d2:	4b10      	ldr	r3, [pc, #64]	; (14814 <InitImu+0x80>)
   147d4:	0020      	movs	r0, r4
   147d6:	4798      	blx	r3
  lsm6dso_gy_data_rate_set(&dev_ctx,  LSM6DSO_GY_ODR_833Hz);
   147d8:	2107      	movs	r1, #7
   147da:	4b0f      	ldr	r3, [pc, #60]	; (14818 <InitImu+0x84>)
   147dc:	0020      	movs	r0, r4
   147de:	4798      	blx	r3
  /* Set full scale */
  lsm6dso_xl_full_scale_set(&dev_ctx, LSM6DSO_2g);
   147e0:	0031      	movs	r1, r6
   147e2:	4b0e      	ldr	r3, [pc, #56]	; (1481c <InitImu+0x88>)
   147e4:	0020      	movs	r0, r4
   147e6:	4798      	blx	r3
  lsm6dso_gy_full_scale_set(&dev_ctx, LSM6DSO_500dps);
   147e8:	2102      	movs	r1, #2
   147ea:	0020      	movs	r0, r4
   147ec:	4b0c      	ldr	r3, [pc, #48]	; (14820 <InitImu+0x8c>)
   147ee:	4798      	blx	r3
  /* Accelerometer - LPF1 + LPF2 path */
  //lsm6dso_xl_hp_path_on_out_set(&dev_ctx, LSM6DSO_LP_ODR_DIV_100);
  //lsm6dso_xl_filter_lp2_set(&dev_ctx, PROPERTY_ENABLE);

  return error;
}
   147f0:	0028      	movs	r0, r5
   147f2:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
		return -1;
   147f4:	2501      	movs	r5, #1
   147f6:	426d      	negs	r5, r5
   147f8:	e7fa      	b.n	147f0 <InitImu+0x5c>
   147fa:	46c0      	nop			; (mov r8, r8)
   147fc:	2000008c 	.word	0x2000008c
   14800:	00014485 	.word	0x00014485
   14804:	00014499 	.word	0x00014499
   14808:	000144d1 	.word	0x000144d1
   1480c:	0001439d 	.word	0x0001439d
   14810:	000143d9 	.word	0x000143d9
   14814:	000145c5 	.word	0x000145c5
   14818:	000146a9 	.word	0x000146a9
   1481c:	00014325 	.word	0x00014325
   14820:	00014361 	.word	0x00014361

00014824 <configure_spi_master>:
* @param[out]	
* @return		
* @note         
*****************************************************************************/
void configure_spi_master(void)
{
   14824:	b5f0      	push	{r4, r5, r6, r7, lr}
   14826:	b08f      	sub	sp, #60	; 0x3c
	config->input_pull = PORT_PIN_PULL_UP;
   14828:	466b      	mov	r3, sp
{
	Assert(slave);
	Assert(config);

	slave->ss_pin          = config->ss_pin;
	slave->address_enabled = config->address_enabled;
   1482a:	2600      	movs	r6, #0
   1482c:	2401      	movs	r4, #1
	slave->ss_pin          = config->ss_pin;
   1482e:	2011      	movs	r0, #17
   14830:	4d29      	ldr	r5, [pc, #164]	; (148d8 <configure_spi_master+0xb4>)
   14832:	705c      	strb	r4, [r3, #1]
	config->powersave  = false;
   14834:	709e      	strb	r6, [r3, #2]
	/* Get default config for pin */
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);

	/* Edit config to set the pin as output */
	pin_conf.direction = PORT_PIN_DIR_OUTPUT;
   14836:	701c      	strb	r4, [r3, #0]

	/* Set config on Slave Select pin */
	port_pin_set_config(slave->ss_pin, &pin_conf);
   14838:	4669      	mov	r1, sp
   1483a:	4b28      	ldr	r3, [pc, #160]	; (148dc <configure_spi_master+0xb8>)
	slave->ss_pin          = config->ss_pin;
   1483c:	7028      	strb	r0, [r5, #0]
	slave->address_enabled = config->address_enabled;
   1483e:	706e      	strb	r6, [r5, #1]
	slave->address         = config->address;
   14840:	70ae      	strb	r6, [r5, #2]
	port_pin_set_config(slave->ss_pin, &pin_conf);
   14842:	4798      	blx	r3
	port_pin_set_output_level(slave->ss_pin, true);
   14844:	782a      	ldrb	r2, [r5, #0]
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
	uint8_t port_index  = (gpio_pin / 128);
	uint8_t group_index = (gpio_pin / 32);
   14846:	0953      	lsrs	r3, r2, #5

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
   14848:	09d5      	lsrs	r5, r2, #7
   1484a:	42b5      	cmp	r5, r6
   1484c:	d141      	bne.n	148d2 <configure_spi_master+0xae>
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
   1484e:	271f      	movs	r7, #31
   14850:	0021      	movs	r1, r4
   14852:	403a      	ands	r2, r7
   14854:	4091      	lsls	r1, r2
   14856:	000a      	movs	r2, r1
		port_base->OUTSET.reg = pin_mask;
   14858:	4921      	ldr	r1, [pc, #132]	; (148e0 <configure_spi_master+0xbc>)
   1485a:	01db      	lsls	r3, r3, #7
   1485c:	185b      	adds	r3, r3, r1
   1485e:	619a      	str	r2, [r3, #24]
	config->mode             = SPI_MODE_MASTER;
   14860:	466b      	mov	r3, sp
	config->character_size   = SPI_CHARACTER_SIZE_8BIT;
   14862:	741d      	strb	r5, [r3, #16]
	config->run_in_standby   = false;
   14864:	745d      	strb	r5, [r3, #17]
	config->receiver_enable  = true;
   14866:	749c      	strb	r4, [r3, #18]
	config->master_slave_select_enable= false;
   14868:	751d      	strb	r5, [r3, #20]
	config->mode             = SPI_MODE_MASTER;
   1486a:	701c      	strb	r4, [r3, #0]
	config->generator_source = GCLK_GENERATOR_0;
   1486c:	3305      	adds	r3, #5
   1486e:	77dd      	strb	r5, [r3, #31]
	memset(&(config->mode_specific), 0, sizeof(config->mode_specific));
   14870:	0029      	movs	r1, r5
   14872:	220c      	movs	r2, #12
   14874:	4b1b      	ldr	r3, [pc, #108]	; (148e4 <configure_spi_master+0xc0>)
   14876:	a806      	add	r0, sp, #24
	config->data_order       = SPI_DATA_ORDER_MSB;
   14878:	9501      	str	r5, [sp, #4]
	memset(&(config->mode_specific), 0, sizeof(config->mode_specific));
   1487a:	4798      	blx	r3
	slave_dev_config.ss_pin = SLAVE_SELECT_PIN;
	spi_attach_slave(&slave, &slave_dev_config);
	
	/* Configure, initialize and enable SERCOM SPI module */
	spi_get_config_defaults(&config_spi_master);
	config_spi_master.mux_setting = CONF_MASTER_MUX_SETTING;
   1487c:	2398      	movs	r3, #152	; 0x98
   1487e:	035b      	lsls	r3, r3, #13
   14880:	9303      	str	r3, [sp, #12]
	config_spi_master.pinmux_pad0 = CONF_MASTER_PINMUX_PAD0;
   14882:	4b19      	ldr	r3, [pc, #100]	; (148e8 <configure_spi_master+0xc4>)
	/* Works upto 1 MHZ with small jumpers. Doesn't work with long jumper wires. 	*/
	config_spi_master.mode_specific.master.baudrate = 1000000;  // 1 MHZ clock.
	config_spi_master.transfer_mode = SPI_TRANSFER_MODE_1;  // works with both mode 0 and mode 1
	config_spi_master.select_slave_low_detect_enable = false;

	spi_init(&spi_master_instance, CONF_MASTER_SPI_MODULE, &config_spi_master);
   14884:	4e19      	ldr	r6, [pc, #100]	; (148ec <configure_spi_master+0xc8>)
	config_spi_master.pinmux_pad0 = CONF_MASTER_PINMUX_PAD0;
   14886:	930a      	str	r3, [sp, #40]	; 0x28
	config_spi_master.pinmux_pad1 = CONF_MASTER_PINMUX_PAD1;
   14888:	4b19      	ldr	r3, [pc, #100]	; (148f0 <configure_spi_master+0xcc>)
	spi_init(&spi_master_instance, CONF_MASTER_SPI_MODULE, &config_spi_master);
   1488a:	466a      	mov	r2, sp
	config_spi_master.pinmux_pad1 = CONF_MASTER_PINMUX_PAD1;
   1488c:	930b      	str	r3, [sp, #44]	; 0x2c
	config_spi_master.pinmux_pad2 = CONF_MASTER_PINMUX_PAD2;
   1488e:	2301      	movs	r3, #1
   14890:	425b      	negs	r3, r3
   14892:	930c      	str	r3, [sp, #48]	; 0x30
	config_spi_master.pinmux_pad3 = CONF_MASTER_PINMUX_PAD3;
   14894:	4b17      	ldr	r3, [pc, #92]	; (148f4 <configure_spi_master+0xd0>)
	spi_init(&spi_master_instance, CONF_MASTER_SPI_MODULE, &config_spi_master);
   14896:	4918      	ldr	r1, [pc, #96]	; (148f8 <configure_spi_master+0xd4>)
	config_spi_master.pinmux_pad3 = CONF_MASTER_PINMUX_PAD3;
   14898:	930d      	str	r3, [sp, #52]	; 0x34
	config_spi_master.mode_specific.master.baudrate = 1000000;  // 1 MHZ clock.
   1489a:	4b18      	ldr	r3, [pc, #96]	; (148fc <configure_spi_master+0xd8>)
	spi_init(&spi_master_instance, CONF_MASTER_SPI_MODULE, &config_spi_master);
   1489c:	0030      	movs	r0, r6
	config_spi_master.mode_specific.master.baudrate = 1000000;  // 1 MHZ clock.
   1489e:	9306      	str	r3, [sp, #24]
	config_spi_master.transfer_mode = SPI_TRANSFER_MODE_1;  // works with both mode 0 and mode 1
   148a0:	2380      	movs	r3, #128	; 0x80
   148a2:	055b      	lsls	r3, r3, #21
   148a4:	9302      	str	r3, [sp, #8]
	config_spi_master.select_slave_low_detect_enable = false;
   148a6:	466b      	mov	r3, sp
   148a8:	74dd      	strb	r5, [r3, #19]
	spi_init(&spi_master_instance, CONF_MASTER_SPI_MODULE, &config_spi_master);
   148aa:	4b15      	ldr	r3, [pc, #84]	; (14900 <configure_spi_master+0xdc>)
   148ac:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
   148ae:	6835      	ldr	r5, [r6, #0]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
   148b0:	4b14      	ldr	r3, [pc, #80]	; (14904 <configure_spi_master+0xe0>)
   148b2:	0028      	movs	r0, r5
   148b4:	4798      	blx	r3
   148b6:	4007      	ands	r7, r0
   148b8:	40bc      	lsls	r4, r7
   148ba:	4b13      	ldr	r3, [pc, #76]	; (14908 <configure_spi_master+0xe4>)
   148bc:	601c      	str	r4, [r3, #0]
	SercomSpi *const spi_module = &(module->hw->SPI);
   148be:	6832      	ldr	r2, [r6, #0]
	return (spi_module->SYNCBUSY.reg);
   148c0:	69d3      	ldr	r3, [r2, #28]
#  endif

	while (spi_is_syncing(module)) {
   148c2:	2b00      	cmp	r3, #0
   148c4:	d1fc      	bne.n	148c0 <configure_spi_master+0x9c>
		/* Wait until the synchronization is complete */
	}

	/* Enable SPI */
	spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
   148c6:	682a      	ldr	r2, [r5, #0]
   148c8:	3302      	adds	r3, #2
   148ca:	4313      	orrs	r3, r2
   148cc:	602b      	str	r3, [r5, #0]
	spi_enable(&spi_master_instance);
   148ce:	b00f      	add	sp, #60	; 0x3c
   148d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   148d2:	61b6      	str	r6, [r6, #24]
   148d4:	deff      	udf	#255	; 0xff
   148d6:	46c0      	nop			; (mov r8, r8)
   148d8:	20000098 	.word	0x20000098
   148dc:	0001d0dd 	.word	0x0001d0dd
   148e0:	41004400 	.word	0x41004400
   148e4:	00022c47 	.word	0x00022c47
   148e8:	00220003 	.word	0x00220003
   148ec:	200042f0 	.word	0x200042f0
   148f0:	00230003 	.word	0x00230003
   148f4:	00150002 	.word	0x00150002
   148f8:	42001c00 	.word	0x42001c00
   148fc:	000f4240 	.word	0x000f4240
   14900:	0001d859 	.word	0x0001d859
   14904:	0001d699 	.word	0x0001d699
   14908:	e000e100 	.word	0xe000e100

0001490c <AutomateTurbine>:
* @param[in]	InputInt Use me to describe inputs to functions
* @param[out]	*pvParameters Use me to describe outputs of functions passed as arguments
* @return		Use me to explain the return of an argument.
* @note         
*****************************************************************************/
void AutomateTurbine(int degree)  {
   1490c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    // get the number of steps 
    int steps = ((float) degree / 1.8);
   1490e:	4b1f      	ldr	r3, [pc, #124]	; (1498c <AutomateTurbine+0x80>)
   14910:	4798      	blx	r3
   14912:	4b1f      	ldr	r3, [pc, #124]	; (14990 <AutomateTurbine+0x84>)
   14914:	4798      	blx	r3
   14916:	4a1f      	ldr	r2, [pc, #124]	; (14994 <AutomateTurbine+0x88>)
   14918:	4b1f      	ldr	r3, [pc, #124]	; (14998 <AutomateTurbine+0x8c>)
   1491a:	4c20      	ldr	r4, [pc, #128]	; (1499c <AutomateTurbine+0x90>)
   1491c:	47a0      	blx	r4
   1491e:	4b20      	ldr	r3, [pc, #128]	; (149a0 <AutomateTurbine+0x94>)
   14920:	4798      	blx	r3
   14922:	2308      	movs	r3, #8
    //set the direction and make sure the motor rotate in different directions each time  
    port_pin_set_output_level(DIRECTION, (bool)1);
    // rotate the motor 
    for(int i=0; i<steps;i++){
   14924:	2500      	movs	r5, #0
   14926:	4c1f      	ldr	r4, [pc, #124]	; (149a4 <AutomateTurbine+0x98>)
    int steps = ((float) degree / 1.8);
   14928:	9001      	str	r0, [sp, #4]
   1492a:	61a3      	str	r3, [r4, #24]
    for(int i=0; i<steps;i++){
   1492c:	9b01      	ldr	r3, [sp, #4]
   1492e:	429d      	cmp	r5, r3
   14930:	db0c      	blt.n	1494c <AutomateTurbine+0x40>
        delay_ms(50);
        port_pin_set_output_level(STEP,(bool)0);
        delay_ms(50);
    }
	
    int new_steps = steps - MaxSpeedDir;
   14932:	4b1d      	ldr	r3, [pc, #116]	; (149a8 <AutomateTurbine+0x9c>)
   14934:	9a01      	ldr	r2, [sp, #4]
   14936:	681b      	ldr	r3, [r3, #0]
    // position the turbine in the direction of maxi air velocity 
    //change the direction of the motor
    port_pin_set_output_level(DIRECTION,(bool)0); 
    for(int i=0; i < new_steps; i++){
   14938:	2500      	movs	r5, #0
    int new_steps = steps - MaxSpeedDir;
   1493a:	1ad3      	subs	r3, r2, r3
   1493c:	9301      	str	r3, [sp, #4]
		port_base->OUTCLR.reg = pin_mask;
   1493e:	2308      	movs	r3, #8
		port_base->OUTSET.reg = pin_mask;
   14940:	2604      	movs	r6, #4
		port_base->OUTCLR.reg = pin_mask;
   14942:	6163      	str	r3, [r4, #20]
    for(int i=0; i < new_steps; i++){
   14944:	9b01      	ldr	r3, [sp, #4]
   14946:	429d      	cmp	r5, r3
   14948:	db17      	blt.n	1497a <AutomateTurbine+0x6e>
        port_pin_set_output_level(STEP,(bool)1);
        delay_ms(50);
        port_pin_set_output_level(STEP,(bool)0);
        delay_ms(50);
    }
   1494a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
        AirVelocity = FS3000_readMetersPerSecond();
   1494c:	4b17      	ldr	r3, [pc, #92]	; (149ac <AutomateTurbine+0xa0>)
   1494e:	4798      	blx	r3
        if(AirVelocity > compare){
   14950:	4e17      	ldr	r6, [pc, #92]	; (149b0 <AutomateTurbine+0xa4>)
   14952:	4b18      	ldr	r3, [pc, #96]	; (149b4 <AutomateTurbine+0xa8>)
   14954:	6831      	ldr	r1, [r6, #0]
        AirVelocity = FS3000_readMetersPerSecond();
   14956:	1c07      	adds	r7, r0, #0
        if(AirVelocity > compare){
   14958:	4798      	blx	r3
   1495a:	2800      	cmp	r0, #0
   1495c:	d002      	beq.n	14964 <AutomateTurbine+0x58>
			MaxSpeedDir = i; 
   1495e:	4b12      	ldr	r3, [pc, #72]	; (149a8 <AutomateTurbine+0x9c>)
            compare = AirVelocity;
   14960:	6037      	str	r7, [r6, #0]
			MaxSpeedDir = i; 
   14962:	601d      	str	r5, [r3, #0]
		port_base->OUTSET.reg = pin_mask;
   14964:	2304      	movs	r3, #4
        delay_ms(50);
   14966:	2032      	movs	r0, #50	; 0x32
   14968:	61a3      	str	r3, [r4, #24]
   1496a:	4e13      	ldr	r6, [pc, #76]	; (149b8 <AutomateTurbine+0xac>)
   1496c:	47b0      	blx	r6
		port_base->OUTCLR.reg = pin_mask;
   1496e:	2304      	movs	r3, #4
        delay_ms(50);
   14970:	2032      	movs	r0, #50	; 0x32
   14972:	6163      	str	r3, [r4, #20]
   14974:	47b0      	blx	r6
    for(int i=0; i<steps;i++){
   14976:	3501      	adds	r5, #1
   14978:	e7d8      	b.n	1492c <AutomateTurbine+0x20>
        delay_ms(50);
   1497a:	2032      	movs	r0, #50	; 0x32
   1497c:	4f0e      	ldr	r7, [pc, #56]	; (149b8 <AutomateTurbine+0xac>)
		port_base->OUTSET.reg = pin_mask;
   1497e:	61a6      	str	r6, [r4, #24]
   14980:	47b8      	blx	r7
		port_base->OUTCLR.reg = pin_mask;
   14982:	6166      	str	r6, [r4, #20]
        delay_ms(50);
   14984:	2032      	movs	r0, #50	; 0x32
   14986:	47b8      	blx	r7
    for(int i=0; i < new_steps; i++){
   14988:	3501      	adds	r5, #1
   1498a:	e7db      	b.n	14944 <AutomateTurbine+0x38>
   1498c:	000269f1 	.word	0x000269f1
   14990:	0002866d 	.word	0x0002866d
   14994:	cccccccd 	.word	0xcccccccd
   14998:	3ffccccc 	.word	0x3ffccccc
   1499c:	0002713d 	.word	0x0002713d
   149a0:	00028511 	.word	0x00028511
   149a4:	41004400 	.word	0x41004400
   149a8:	200004ec 	.word	0x200004ec
   149ac:	00012191 	.word	0x00012191
   149b0:	2000009c 	.word	0x2000009c
   149b4:	00025c89 	.word	0x00025c89
   149b8:	0001a3b1 	.word	0x0001a3b1

000149bc <add_state>:
 * \brief Add state parameter at download processing state.
 * \param[in] mask Check download_state.
 */
static void add_state(download_state mask)
{
    down_state |= mask;
   149bc:	4b02      	ldr	r3, [pc, #8]	; (149c8 <add_state+0xc>)
   149be:	781a      	ldrb	r2, [r3, #0]
   149c0:	4310      	orrs	r0, r2
   149c2:	7018      	strb	r0, [r3, #0]
}
   149c4:	4770      	bx	lr
   149c6:	46c0      	nop			; (mov r8, r8)
   149c8:	200004f1 	.word	0x200004f1

000149cc <extint_detection_callback>:
}

volatile bool isPressed = false;
void extint_detection_callback(void)
{
	isPressed = true;
   149cc:	2201      	movs	r2, #1
   149ce:	4b01      	ldr	r3, [pc, #4]	; (149d4 <extint_detection_callback+0x8>)
   149d0:	701a      	strb	r2, [r3, #0]
}
   149d2:	4770      	bx	lr
   149d4:	2000074c 	.word	0x2000074c

000149d8 <socket_resolve_handler>:
{
   149d8:	b510      	push	{r4, lr}
    mqtt_socket_resolve_handler(doamin_name, server_ip);
   149da:	4b01      	ldr	r3, [pc, #4]	; (149e0 <socket_resolve_handler+0x8>)
   149dc:	4798      	blx	r3
}
   149de:	bd10      	pop	{r4, pc}
   149e0:	000210c5 	.word	0x000210c5

000149e4 <socket_event_handler>:
{
   149e4:	b510      	push	{r4, lr}
    mqtt_socket_event_handler(sock, msg_type, msg_data);
   149e6:	4b01      	ldr	r3, [pc, #4]	; (149ec <socket_event_handler+0x8>)
   149e8:	4798      	blx	r3
}
   149ea:	bd10      	pop	{r4, pc}
   149ec:	000210b9 	.word	0x000210b9

000149f0 <configure_mqtt>:
{
   149f0:	b510      	push	{r4, lr}
   149f2:	b086      	sub	sp, #24
    mqtt_get_config_defaults(&mqtt_conf);
   149f4:	4668      	mov	r0, sp
   149f6:	4b14      	ldr	r3, [pc, #80]	; (14a48 <configure_mqtt+0x58>)
   149f8:	4798      	blx	r3
    mqtt_conf.read_buffer = mqtt_read_buffer;
   149fa:	4b14      	ldr	r3, [pc, #80]	; (14a4c <configure_mqtt+0x5c>)
    mqtt_conf.send_buffer = mqtt_send_buffer;
   149fc:	4a14      	ldr	r2, [pc, #80]	; (14a50 <configure_mqtt+0x60>)
    mqtt_conf.read_buffer = mqtt_read_buffer;
   149fe:	9302      	str	r3, [sp, #8]
    mqtt_conf.read_buffer_size = MAIN_MQTT_BUFFER_SIZE;
   14a00:	2380      	movs	r3, #128	; 0x80
    mqtt_conf.send_buffer = mqtt_send_buffer;
   14a02:	9204      	str	r2, [sp, #16]
    mqtt_conf.port = CLOUDMQTT_PORT;
   14a04:	466a      	mov	r2, sp
    mqtt_conf.read_buffer_size = MAIN_MQTT_BUFFER_SIZE;
   14a06:	009b      	lsls	r3, r3, #2
   14a08:	9303      	str	r3, [sp, #12]
    mqtt_conf.send_buffer_size = MAIN_MQTT_BUFFER_SIZE;
   14a0a:	9305      	str	r3, [sp, #20]
    mqtt_conf.port = CLOUDMQTT_PORT;
   14a0c:	4b11      	ldr	r3, [pc, #68]	; (14a54 <configure_mqtt+0x64>)
    result = mqtt_init(&mqtt_inst, &mqtt_conf);
   14a0e:	4c12      	ldr	r4, [pc, #72]	; (14a58 <configure_mqtt+0x68>)
    mqtt_conf.port = CLOUDMQTT_PORT;
   14a10:	8013      	strh	r3, [r2, #0]
    mqtt_conf.keep_alive = 6000;
   14a12:	4b12      	ldr	r3, [pc, #72]	; (14a5c <configure_mqtt+0x6c>)
    result = mqtt_init(&mqtt_inst, &mqtt_conf);
   14a14:	4669      	mov	r1, sp
    mqtt_conf.keep_alive = 6000;
   14a16:	8093      	strh	r3, [r2, #4]
    result = mqtt_init(&mqtt_inst, &mqtt_conf);
   14a18:	0020      	movs	r0, r4
   14a1a:	4b11      	ldr	r3, [pc, #68]	; (14a60 <configure_mqtt+0x70>)
   14a1c:	4798      	blx	r3
   14a1e:	1e02      	subs	r2, r0, #0
    if (result < 0) {
   14a20:	da04      	bge.n	14a2c <configure_mqtt+0x3c>
        LogMessage(LOG_DEBUG_LVL, "MQTT initialization failed. Error code is (%d)\r\n", result);
   14a22:	4910      	ldr	r1, [pc, #64]	; (14a64 <configure_mqtt+0x74>)
   14a24:	2001      	movs	r0, #1
   14a26:	4b10      	ldr	r3, [pc, #64]	; (14a68 <configure_mqtt+0x78>)
   14a28:	4798      	blx	r3
   14a2a:	e7fe      	b.n	14a2a <configure_mqtt+0x3a>
    result = mqtt_register_callback(&mqtt_inst, mqtt_callback);
   14a2c:	490f      	ldr	r1, [pc, #60]	; (14a6c <configure_mqtt+0x7c>)
   14a2e:	0020      	movs	r0, r4
   14a30:	4b0f      	ldr	r3, [pc, #60]	; (14a70 <configure_mqtt+0x80>)
   14a32:	4798      	blx	r3
   14a34:	1e02      	subs	r2, r0, #0
    if (result < 0) {
   14a36:	da04      	bge.n	14a42 <configure_mqtt+0x52>
        LogMessage(LOG_DEBUG_LVL, "MQTT register callback failed. Error code is (%d)\r\n", result);
   14a38:	490e      	ldr	r1, [pc, #56]	; (14a74 <configure_mqtt+0x84>)
   14a3a:	2001      	movs	r0, #1
   14a3c:	4b0a      	ldr	r3, [pc, #40]	; (14a68 <configure_mqtt+0x78>)
   14a3e:	4798      	blx	r3
   14a40:	e7fe      	b.n	14a40 <configure_mqtt+0x50>
}
   14a42:	b006      	add	sp, #24
   14a44:	bd10      	pop	{r4, pc}
   14a46:	46c0      	nop			; (mov r8, r8)
   14a48:	0002108d 	.word	0x0002108d
   14a4c:	20000788 	.word	0x20000788
   14a50:	20000988 	.word	0x20000988
   14a54:	0000075b 	.word	0x0000075b
   14a58:	20000750 	.word	0x20000750
   14a5c:	00001770 	.word	0x00001770
   14a60:	00020ffd 	.word	0x00020ffd
   14a64:	00028a37 	.word	0x00028a37
   14a68:	000193d9 	.word	0x000193d9
   14a6c:	00014b6d 	.word	0x00014b6d
   14a70:	000210a9 	.word	0x000210a9
   14a74:	00028a68 	.word	0x00028a68

00014a78 <resolve_cb>:
{
   14a78:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   14a7a:	000c      	movs	r4, r1
    LogMessage(LOG_DEBUG_LVL,
   14a7c:	21ff      	movs	r1, #255	; 0xff
   14a7e:	0023      	movs	r3, r4
{
   14a80:	0005      	movs	r5, r0
               (int)IPV4_BYTE(u32ServerIP, 3));
   14a82:	0e22      	lsrs	r2, r4, #24
    LogMessage(LOG_DEBUG_LVL,
   14a84:	9202      	str	r2, [sp, #8]
               (int)IPV4_BYTE(u32ServerIP, 2),
   14a86:	0c22      	lsrs	r2, r4, #16
    LogMessage(LOG_DEBUG_LVL,
   14a88:	400a      	ands	r2, r1
   14a8a:	9201      	str	r2, [sp, #4]
               (int)IPV4_BYTE(u32ServerIP, 1),
   14a8c:	0a22      	lsrs	r2, r4, #8
    LogMessage(LOG_DEBUG_LVL,
   14a8e:	400a      	ands	r2, r1
   14a90:	400b      	ands	r3, r1
   14a92:	9200      	str	r2, [sp, #0]
   14a94:	4e04      	ldr	r6, [pc, #16]	; (14aa8 <resolve_cb+0x30>)
   14a96:	0002      	movs	r2, r0
   14a98:	4904      	ldr	r1, [pc, #16]	; (14aac <resolve_cb+0x34>)
   14a9a:	2001      	movs	r0, #1
   14a9c:	47b0      	blx	r6
    http_client_socket_resolve_handler(pu8DomainName, u32ServerIP);
   14a9e:	0028      	movs	r0, r5
   14aa0:	0021      	movs	r1, r4
   14aa2:	4b03      	ldr	r3, [pc, #12]	; (14ab0 <resolve_cb+0x38>)
   14aa4:	4798      	blx	r3
}
   14aa6:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}
   14aa8:	000193d9 	.word	0x000193d9
   14aac:	00028d82 	.word	0x00028d82
   14ab0:	00021c09 	.word	0x00021c09

00014ab4 <socket_cb>:
{
   14ab4:	b510      	push	{r4, lr}
    http_client_socket_event_handler(sock, u8Msg, pvMsg);
   14ab6:	4b01      	ldr	r3, [pc, #4]	; (14abc <socket_cb+0x8>)
   14ab8:	4798      	blx	r3
}
   14aba:	bd10      	pop	{r4, pc}
   14abc:	00022681 	.word	0x00022681

00014ac0 <SubscribeHandlerAutoma>:
{
   14ac0:	b570      	push	{r4, r5, r6, lr}
   14ac2:	0004      	movs	r4, r0
	LogMessage(LOG_DEBUG_LVL, "%.*s\r\n", msgData->topicName->lenstring.len, msgData->topicName->lenstring.data);
   14ac4:	6842      	ldr	r2, [r0, #4]
   14ac6:	4909      	ldr	r1, [pc, #36]	; (14aec <SubscribeHandlerAutoma+0x2c>)
   14ac8:	6893      	ldr	r3, [r2, #8]
   14aca:	2001      	movs	r0, #1
   14acc:	6852      	ldr	r2, [r2, #4]
   14ace:	4d08      	ldr	r5, [pc, #32]	; (14af0 <SubscribeHandlerAutoma+0x30>)
   14ad0:	47a8      	blx	r5
	if (strncmp(msgData->message->payload, "1", 1) ==  0)
   14ad2:	6823      	ldr	r3, [r4, #0]
   14ad4:	689b      	ldr	r3, [r3, #8]
   14ad6:	781b      	ldrb	r3, [r3, #0]
   14ad8:	2b31      	cmp	r3, #49	; 0x31
   14ada:	d105      	bne.n	14ae8 <SubscribeHandlerAutoma+0x28>
		SerialConsoleWriteString("Starting Wind Routine\r\n");
   14adc:	4805      	ldr	r0, [pc, #20]	; (14af4 <SubscribeHandlerAutoma+0x34>)
   14ade:	4b06      	ldr	r3, [pc, #24]	; (14af8 <SubscribeHandlerAutoma+0x38>)
   14ae0:	4798      	blx	r3
		AutomateTurbine(120);
   14ae2:	2078      	movs	r0, #120	; 0x78
   14ae4:	4b05      	ldr	r3, [pc, #20]	; (14afc <SubscribeHandlerAutoma+0x3c>)
   14ae6:	4798      	blx	r3
}
   14ae8:	bd70      	pop	{r4, r5, r6, pc}
   14aea:	46c0      	nop			; (mov r8, r8)
   14aec:	00028a18 	.word	0x00028a18
   14af0:	000193d9 	.word	0x000193d9
   14af4:	00028a1f 	.word	0x00028a1f
   14af8:	00019335 	.word	0x00019335
   14afc:	0001490d 	.word	0x0001490d

00014b00 <start_download>:
{
   14b00:	b537      	push	{r0, r1, r2, r4, r5, lr}
    return ((down_state & mask) != 0);
   14b02:	2501      	movs	r5, #1
   14b04:	4b0f      	ldr	r3, [pc, #60]	; (14b44 <start_download+0x44>)
   14b06:	4a10      	ldr	r2, [pc, #64]	; (14b48 <start_download+0x48>)
   14b08:	781b      	ldrb	r3, [r3, #0]
        LogMessage(LOG_DEBUG_LVL, "start_download: MMC storage not ready.\r\n");
   14b0a:	4910      	ldr	r1, [pc, #64]	; (14b4c <start_download+0x4c>)
    if (!is_state_set(STORAGE_READY)) {
   14b0c:	422b      	tst	r3, r5
   14b0e:	d002      	beq.n	14b16 <start_download+0x16>
    if (!is_state_set(WIFI_CONNECTED)) {
   14b10:	0799      	lsls	r1, r3, #30
   14b12:	d403      	bmi.n	14b1c <start_download+0x1c>
        LogMessage(LOG_DEBUG_LVL, "start_download: Wi-Fi is not connected.\r\n");
   14b14:	490e      	ldr	r1, [pc, #56]	; (14b50 <start_download+0x50>)
        LogMessage(LOG_DEBUG_LVL, "start_download: running download already.\r\n");
   14b16:	0028      	movs	r0, r5
   14b18:	4790      	blx	r2
}
   14b1a:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    if (is_state_set(GET_REQUESTED)) {
   14b1c:	0759      	lsls	r1, r3, #29
   14b1e:	d501      	bpl.n	14b24 <start_download+0x24>
        LogMessage(LOG_DEBUG_LVL, "start_download: request is sent already.\r\n");
   14b20:	490c      	ldr	r1, [pc, #48]	; (14b54 <start_download+0x54>)
   14b22:	e7f8      	b.n	14b16 <start_download+0x16>
    if (is_state_set(DOWNLOADING)) {
   14b24:	2408      	movs	r4, #8
   14b26:	401c      	ands	r4, r3
   14b28:	d001      	beq.n	14b2e <start_download+0x2e>
        LogMessage(LOG_DEBUG_LVL, "start_download: running download already.\r\n");
   14b2a:	490b      	ldr	r1, [pc, #44]	; (14b58 <start_download+0x58>)
   14b2c:	e7f3      	b.n	14b16 <start_download+0x16>
    LogMessage(LOG_DEBUG_LVL, "start_download: sending HTTP request...\r\n");
   14b2e:	0028      	movs	r0, r5
   14b30:	490a      	ldr	r1, [pc, #40]	; (14b5c <start_download+0x5c>)
   14b32:	4790      	blx	r2
    int http_req_status = http_client_send_request(&http_client_module_inst, MAIN_HTTP_FILE_URL, HTTP_METHOD_GET, NULL, NULL);
   14b34:	9400      	str	r4, [sp, #0]
   14b36:	0023      	movs	r3, r4
   14b38:	002a      	movs	r2, r5
   14b3a:	4909      	ldr	r1, [pc, #36]	; (14b60 <start_download+0x60>)
   14b3c:	4c09      	ldr	r4, [pc, #36]	; (14b64 <start_download+0x64>)
   14b3e:	480a      	ldr	r0, [pc, #40]	; (14b68 <start_download+0x68>)
   14b40:	47a0      	blx	r4
   14b42:	e7ea      	b.n	14b1a <start_download+0x1a>
   14b44:	200004f1 	.word	0x200004f1
   14b48:	000193d9 	.word	0x000193d9
   14b4c:	00028daf 	.word	0x00028daf
   14b50:	00028dd8 	.word	0x00028dd8
   14b54:	00028e02 	.word	0x00028e02
   14b58:	00028e2d 	.word	0x00028e2d
   14b5c:	00028e59 	.word	0x00028e59
   14b60:	00028e83 	.word	0x00028e83
   14b64:	0002204d 	.word	0x0002204d
   14b68:	20004384 	.word	0x20004384

00014b6c <mqtt_callback>:
{
   14b6c:	b570      	push	{r4, r5, r6, lr}
   14b6e:	0006      	movs	r6, r0
   14b70:	b086      	sub	sp, #24
   14b72:	000c      	movs	r4, r1
    switch (type) {
   14b74:	2901      	cmp	r1, #1
   14b76:	d028      	beq.n	14bca <mqtt_callback+0x5e>
   14b78:	2905      	cmp	r1, #5
   14b7a:	d035      	beq.n	14be8 <mqtt_callback+0x7c>
   14b7c:	2900      	cmp	r1, #0
   14b7e:	d118      	bne.n	14bb2 <mqtt_callback+0x46>
            if (data->sock_connected.result >= 0) {
   14b80:	6813      	ldr	r3, [r2, #0]
   14b82:	4d1c      	ldr	r5, [pc, #112]	; (14bf4 <mqtt_callback+0x88>)
   14b84:	2b00      	cmp	r3, #0
   14b86:	db16      	blt.n	14bb6 <mqtt_callback+0x4a>
                LogMessage(LOG_DEBUG_LVL, "\r\nConnecting to Broker...");
   14b88:	491b      	ldr	r1, [pc, #108]	; (14bf8 <mqtt_callback+0x8c>)
   14b8a:	2001      	movs	r0, #1
   14b8c:	47a8      	blx	r5
                if (0 != mqtt_connect_broker(module_inst, 1, CLOUDMQTT_USER_ID, CLOUDMQTT_USER_PASSWORD, CLOUDMQTT_USER_ID, NULL, NULL, 0, 0, 0)) {
   14b8e:	4a1b      	ldr	r2, [pc, #108]	; (14bfc <mqtt_callback+0x90>)
   14b90:	9405      	str	r4, [sp, #20]
   14b92:	9404      	str	r4, [sp, #16]
   14b94:	9403      	str	r4, [sp, #12]
   14b96:	9402      	str	r4, [sp, #8]
   14b98:	9401      	str	r4, [sp, #4]
   14b9a:	2101      	movs	r1, #1
   14b9c:	9200      	str	r2, [sp, #0]
   14b9e:	0013      	movs	r3, r2
   14ba0:	0030      	movs	r0, r6
   14ba2:	4c17      	ldr	r4, [pc, #92]	; (14c00 <mqtt_callback+0x94>)
   14ba4:	47a0      	blx	r4
                    LogMessage(LOG_DEBUG_LVL, "MQTT Connected to broker\r\n");
   14ba6:	4917      	ldr	r1, [pc, #92]	; (14c04 <mqtt_callback+0x98>)
                if (0 != mqtt_connect_broker(module_inst, 1, CLOUDMQTT_USER_ID, CLOUDMQTT_USER_PASSWORD, CLOUDMQTT_USER_ID, NULL, NULL, 0, 0, 0)) {
   14ba8:	2800      	cmp	r0, #0
   14baa:	d000      	beq.n	14bae <mqtt_callback+0x42>
                    LogMessage(LOG_DEBUG_LVL, "MQTT  Error - NOT Connected to broker\r\n");
   14bac:	4916      	ldr	r1, [pc, #88]	; (14c08 <mqtt_callback+0x9c>)
   14bae:	2001      	movs	r0, #1
   14bb0:	47a8      	blx	r5
}
   14bb2:	b006      	add	sp, #24
   14bb4:	bd70      	pop	{r4, r5, r6, pc}
                LogMessage(LOG_DEBUG_LVL, "Connect fail to server(%s)! retry it automatically.\r\n", main_mqtt_broker);
   14bb6:	4c15      	ldr	r4, [pc, #84]	; (14c0c <mqtt_callback+0xa0>)
   14bb8:	4915      	ldr	r1, [pc, #84]	; (14c10 <mqtt_callback+0xa4>)
   14bba:	0022      	movs	r2, r4
   14bbc:	2001      	movs	r0, #1
   14bbe:	47a8      	blx	r5
                mqtt_connect(module_inst, main_mqtt_broker); /* Retry that. */
   14bc0:	0021      	movs	r1, r4
   14bc2:	0030      	movs	r0, r6
   14bc4:	4b13      	ldr	r3, [pc, #76]	; (14c14 <mqtt_callback+0xa8>)
   14bc6:	4798      	blx	r3
   14bc8:	e7f3      	b.n	14bb2 <mqtt_callback+0x46>
            if (data->connected.result == MQTT_CONN_RESULT_ACCEPT) {
   14bca:	7812      	ldrb	r2, [r2, #0]
   14bcc:	4d09      	ldr	r5, [pc, #36]	; (14bf4 <mqtt_callback+0x88>)
   14bce:	2a00      	cmp	r2, #0
   14bd0:	d106      	bne.n	14be0 <mqtt_callback+0x74>
				mqtt_subscribe(module_inst, AUTOMATE_TOPIC, 1, SubscribeHandlerAutoma);
   14bd2:	000a      	movs	r2, r1
   14bd4:	4b10      	ldr	r3, [pc, #64]	; (14c18 <mqtt_callback+0xac>)
   14bd6:	4911      	ldr	r1, [pc, #68]	; (14c1c <mqtt_callback+0xb0>)
   14bd8:	4e11      	ldr	r6, [pc, #68]	; (14c20 <mqtt_callback+0xb4>)
   14bda:	47b0      	blx	r6
                LogMessage(LOG_DEBUG_LVL, "MQTT Connected\r\n");
   14bdc:	4911      	ldr	r1, [pc, #68]	; (14c24 <mqtt_callback+0xb8>)
   14bde:	e7e6      	b.n	14bae <mqtt_callback+0x42>
                LogMessage(LOG_DEBUG_LVL, "MQTT broker decline your access! error code %d\r\n", data->connected.result);
   14be0:	4911      	ldr	r1, [pc, #68]	; (14c28 <mqtt_callback+0xbc>)
   14be2:	0020      	movs	r0, r4
   14be4:	47a8      	blx	r5
   14be6:	e7e4      	b.n	14bb2 <mqtt_callback+0x46>
            LogMessage(LOG_DEBUG_LVL, "MQTT disconnected\r\n");
   14be8:	4910      	ldr	r1, [pc, #64]	; (14c2c <mqtt_callback+0xc0>)
   14bea:	2001      	movs	r0, #1
   14bec:	4b01      	ldr	r3, [pc, #4]	; (14bf4 <mqtt_callback+0x88>)
   14bee:	4798      	blx	r3
}
   14bf0:	e7df      	b.n	14bb2 <mqtt_callback+0x46>
   14bf2:	46c0      	nop			; (mov r8, r8)
   14bf4:	000193d9 	.word	0x000193d9
   14bf8:	00028c7d 	.word	0x00028c7d
   14bfc:	00028c97 	.word	0x00028c97
   14c00:	000210f9 	.word	0x000210f9
   14c04:	00028ccd 	.word	0x00028ccd
   14c08:	00028ca5 	.word	0x00028ca5
   14c0c:	00028c6b 	.word	0x00028c6b
   14c10:	00028ce8 	.word	0x00028ce8
   14c14:	000210d1 	.word	0x000210d1
   14c18:	00014ac1 	.word	0x00014ac1
   14c1c:	00028d1e 	.word	0x00028d1e
   14c20:	000211ed 	.word	0x000211ed
   14c24:	00028d27 	.word	0x00028d27
   14c28:	00028d38 	.word	0x00028d38
   14c2c:	00028d69 	.word	0x00028d69

00014c30 <rename_to_unique.constprop.7>:
static bool rename_to_unique(FIL *fp, char *file_path_name, uint8_t max_len)
   14c30:	b5f0      	push	{r4, r5, r6, r7, lr}
   14c32:	b0c7      	sub	sp, #284	; 0x11c
    char name[MAIN_MAX_FILE_NAME_LENGTH + 1] = {0};
   14c34:	4c43      	ldr	r4, [pc, #268]	; (14d44 <rename_to_unique.constprop.7+0x114>)
   14c36:	22fb      	movs	r2, #251	; 0xfb
   14c38:	2100      	movs	r1, #0
   14c3a:	a807      	add	r0, sp, #28
   14c3c:	47a0      	blx	r4
    char ext[MAIN_MAX_FILE_EXT_LENGTH + 1] = {0};
   14c3e:	2209      	movs	r2, #9
   14c40:	2100      	movs	r1, #0
   14c42:	a804      	add	r0, sp, #16
   14c44:	47a0      	blx	r4
    char numbering[NUMBRING_MAX + 1] = {0};
   14c46:	2200      	movs	r2, #0
    FRESULT ret = f_open(&file_object, (char const *)file_path_name, FA_OPEN_EXISTING);
   14c48:	4c3f      	ldr	r4, [pc, #252]	; (14d48 <rename_to_unique.constprop.7+0x118>)
   14c4a:	4e40      	ldr	r6, [pc, #256]	; (14d4c <rename_to_unique.constprop.7+0x11c>)
   14c4c:	0020      	movs	r0, r4
   14c4e:	0031      	movs	r1, r6
   14c50:	4b3f      	ldr	r3, [pc, #252]	; (14d50 <rename_to_unique.constprop.7+0x120>)
    char numbering[NUMBRING_MAX + 1] = {0};
   14c52:	9203      	str	r2, [sp, #12]
    FRESULT ret = f_open(&file_object, (char const *)file_path_name, FA_OPEN_EXISTING);
   14c54:	4798      	blx	r3
    f_close(&file_object);
   14c56:	4b3f      	ldr	r3, [pc, #252]	; (14d54 <rename_to_unique.constprop.7+0x124>)
    FRESULT ret = f_open(&file_object, (char const *)file_path_name, FA_OPEN_EXISTING);
   14c58:	0005      	movs	r5, r0
    f_close(&file_object);
   14c5a:	0020      	movs	r0, r4
   14c5c:	4798      	blx	r3
        return true;
   14c5e:	2401      	movs	r4, #1
    if (!is_exist_file(fp, file_path_name)) {
   14c60:	2d00      	cmp	r5, #0
   14c62:	d105      	bne.n	14c70 <rename_to_unique.constprop.7+0x40>
    } else if (strlen(file_path_name) > MAIN_MAX_FILE_NAME_LENGTH) {
   14c64:	0030      	movs	r0, r6
   14c66:	4f3c      	ldr	r7, [pc, #240]	; (14d58 <rename_to_unique.constprop.7+0x128>)
   14c68:	47b8      	blx	r7
   14c6a:	28fa      	cmp	r0, #250	; 0xfa
   14c6c:	d903      	bls.n	14c76 <rename_to_unique.constprop.7+0x46>
        return false;
   14c6e:	2400      	movs	r4, #0
}
   14c70:	0020      	movs	r0, r4
   14c72:	b047      	add	sp, #284	; 0x11c
   14c74:	bdf0      	pop	{r4, r5, r6, r7, pc}
    p = strrchr(file_path_name, '.');
   14c76:	212e      	movs	r1, #46	; 0x2e
   14c78:	0030      	movs	r0, r6
   14c7a:	4b38      	ldr	r3, [pc, #224]	; (14d5c <rename_to_unique.constprop.7+0x12c>)
   14c7c:	4798      	blx	r3
   14c7e:	1e05      	subs	r5, r0, #0
    if (p != NULL) {
   14c80:	d051      	beq.n	14d26 <rename_to_unique.constprop.7+0xf6>
        ext_len = strlen(p);
   14c82:	47b8      	blx	r7
   14c84:	466b      	mov	r3, sp
   14c86:	9001      	str	r0, [sp, #4]
   14c88:	889b      	ldrh	r3, [r3, #4]
   14c8a:	9300      	str	r3, [sp, #0]
        if (ext_len < MAIN_MAX_FILE_EXT_LENGTH) {
   14c8c:	2b07      	cmp	r3, #7
   14c8e:	d84a      	bhi.n	14d26 <rename_to_unique.constprop.7+0xf6>
            strcpy(ext, p);
   14c90:	4b33      	ldr	r3, [pc, #204]	; (14d60 <rename_to_unique.constprop.7+0x130>)
   14c92:	0029      	movs	r1, r5
   14c94:	a804      	add	r0, sp, #16
   14c96:	4798      	blx	r3
            if (strlen(file_path_name) - ext_len > MAIN_MAX_FILE_NAME_LENGTH - ADDITION_SIZE) {
   14c98:	0030      	movs	r0, r6
   14c9a:	47b8      	blx	r7
   14c9c:	466b      	mov	r3, sp
   14c9e:	889b      	ldrh	r3, [r3, #4]
   14ca0:	1ac0      	subs	r0, r0, r3
   14ca2:	4b30      	ldr	r3, [pc, #192]	; (14d64 <rename_to_unique.constprop.7+0x134>)
   14ca4:	28f6      	cmp	r0, #246	; 0xf6
   14ca6:	d93b      	bls.n	14d20 <rename_to_unique.constprop.7+0xf0>
                name_len = MAIN_MAX_FILE_NAME_LENGTH - ADDITION_SIZE - ext_len;
   14ca8:	27f6      	movs	r7, #246	; 0xf6
   14caa:	9a00      	ldr	r2, [sp, #0]
   14cac:	1abf      	subs	r7, r7, r2
   14cae:	b2bf      	uxth	r7, r7
                strncpy(name, file_path_name, name_len);
   14cb0:	003a      	movs	r2, r7
   14cb2:	0031      	movs	r1, r6
   14cb4:	a807      	add	r0, sp, #28
   14cb6:	4798      	blx	r3
    name[name_len++] = '-';
   14cb8:	222d      	movs	r2, #45	; 0x2d
   14cba:	2501      	movs	r5, #1
   14cbc:	1c7b      	adds	r3, r7, #1
   14cbe:	b29b      	uxth	r3, r3
   14cc0:	9300      	str	r3, [sp, #0]
   14cc2:	ab07      	add	r3, sp, #28
   14cc4:	55da      	strb	r2, [r3, r7]
        sprintf(numbering, MAIN_ZERO_FMT(NUMBRING_MAX), i);
   14cc6:	002a      	movs	r2, r5
   14cc8:	4927      	ldr	r1, [pc, #156]	; (14d68 <rename_to_unique.constprop.7+0x138>)
   14cca:	4b28      	ldr	r3, [pc, #160]	; (14d6c <rename_to_unique.constprop.7+0x13c>)
   14ccc:	a803      	add	r0, sp, #12
   14cce:	4798      	blx	r3
        strncpy(&name[name_len], numbering, NUMBRING_MAX);
   14cd0:	9a00      	ldr	r2, [sp, #0]
   14cd2:	ab07      	add	r3, sp, #28
   14cd4:	1898      	adds	r0, r3, r2
   14cd6:	a903      	add	r1, sp, #12
   14cd8:	2203      	movs	r2, #3
   14cda:	4b22      	ldr	r3, [pc, #136]	; (14d64 <rename_to_unique.constprop.7+0x134>)
   14cdc:	4798      	blx	r3
        if (valid_ext) {
   14cde:	2c00      	cmp	r4, #0
   14ce0:	d006      	beq.n	14cf0 <rename_to_unique.constprop.7+0xc0>
            strcpy(&name[name_len + NUMBRING_MAX], ext);
   14ce2:	9b00      	ldr	r3, [sp, #0]
   14ce4:	a904      	add	r1, sp, #16
   14ce6:	1cd8      	adds	r0, r3, #3
   14ce8:	ab07      	add	r3, sp, #28
   14cea:	1818      	adds	r0, r3, r0
   14cec:	4b1c      	ldr	r3, [pc, #112]	; (14d60 <rename_to_unique.constprop.7+0x130>)
   14cee:	4798      	blx	r3
    FRESULT ret = f_open(&file_object, (char const *)file_path_name, FA_OPEN_EXISTING);
   14cf0:	4e15      	ldr	r6, [pc, #84]	; (14d48 <rename_to_unique.constprop.7+0x118>)
   14cf2:	4b17      	ldr	r3, [pc, #92]	; (14d50 <rename_to_unique.constprop.7+0x120>)
   14cf4:	2200      	movs	r2, #0
   14cf6:	a907      	add	r1, sp, #28
   14cf8:	0030      	movs	r0, r6
   14cfa:	4798      	blx	r3
    f_close(&file_object);
   14cfc:	4b15      	ldr	r3, [pc, #84]	; (14d54 <rename_to_unique.constprop.7+0x124>)
    FRESULT ret = f_open(&file_object, (char const *)file_path_name, FA_OPEN_EXISTING);
   14cfe:	0007      	movs	r7, r0
    f_close(&file_object);
   14d00:	0030      	movs	r0, r6
   14d02:	4798      	blx	r3
        if (!is_exist_file(fp, name)) {
   14d04:	2f00      	cmp	r7, #0
   14d06:	d016      	beq.n	14d36 <rename_to_unique.constprop.7+0x106>
            memset(file_path_name, 0, max_len);
   14d08:	4c10      	ldr	r4, [pc, #64]	; (14d4c <rename_to_unique.constprop.7+0x11c>)
   14d0a:	22fa      	movs	r2, #250	; 0xfa
   14d0c:	2100      	movs	r1, #0
   14d0e:	0020      	movs	r0, r4
   14d10:	4b0c      	ldr	r3, [pc, #48]	; (14d44 <rename_to_unique.constprop.7+0x114>)
   14d12:	4798      	blx	r3
            strcpy(file_path_name, name);
   14d14:	0020      	movs	r0, r4
   14d16:	a907      	add	r1, sp, #28
   14d18:	4b11      	ldr	r3, [pc, #68]	; (14d60 <rename_to_unique.constprop.7+0x130>)
   14d1a:	4798      	blx	r3
            return true;
   14d1c:	2401      	movs	r4, #1
   14d1e:	e7a7      	b.n	14c70 <rename_to_unique.constprop.7+0x40>
                name_len = (p - file_path_name);
   14d20:	1bad      	subs	r5, r5, r6
   14d22:	b2af      	uxth	r7, r5
   14d24:	e7c4      	b.n	14cb0 <rename_to_unique.constprop.7+0x80>
            strncpy(name, file_path_name, name_len);
   14d26:	22f6      	movs	r2, #246	; 0xf6
   14d28:	0031      	movs	r1, r6
   14d2a:	a807      	add	r0, sp, #28
   14d2c:	4b0d      	ldr	r3, [pc, #52]	; (14d64 <rename_to_unique.constprop.7+0x134>)
   14d2e:	4798      	blx	r3
    bool valid_ext = false;
   14d30:	2400      	movs	r4, #0
            name_len = MAIN_MAX_FILE_NAME_LENGTH - ADDITION_SIZE;
   14d32:	27f6      	movs	r7, #246	; 0xf6
   14d34:	e7c0      	b.n	14cb8 <rename_to_unique.constprop.7+0x88>
    for (i = 1; i < count; i++) {
   14d36:	23fa      	movs	r3, #250	; 0xfa
   14d38:	3501      	adds	r5, #1
   14d3a:	009b      	lsls	r3, r3, #2
   14d3c:	429d      	cmp	r5, r3
   14d3e:	d1c2      	bne.n	14cc6 <rename_to_unique.constprop.7+0x96>
   14d40:	e795      	b.n	14c6e <rename_to_unique.constprop.7+0x3e>
   14d42:	46c0      	nop			; (mov r8, r8)
   14d44:	00022c47 	.word	0x00022c47
   14d48:	20000724 	.word	0x20000724
   14d4c:	200000e0 	.word	0x200000e0
   14d50:	0002028d 	.word	0x0002028d
   14d54:	00020639 	.word	0x00020639
   14d58:	000238c3 	.word	0x000238c3
   14d5c:	0002391d 	.word	0x0002391d
   14d60:	00023879 	.word	0x00023879
   14d64:	000238f3 	.word	0x000238f3
   14d68:	00028d7d 	.word	0x00028d7d
   14d6c:	000237e5 	.word	0x000237e5

00014d70 <store_file_packet>:
{
   14d70:	b5f0      	push	{r4, r5, r6, r7, lr}
   14d72:	b085      	sub	sp, #20
   14d74:	9001      	str	r0, [sp, #4]
   14d76:	000f      	movs	r7, r1
    if ((data == NULL) || (length < 1)) {
   14d78:	2800      	cmp	r0, #0
   14d7a:	d001      	beq.n	14d80 <store_file_packet+0x10>
   14d7c:	2900      	cmp	r1, #0
   14d7e:	d105      	bne.n	14d8c <store_file_packet+0x1c>
        LogMessage(LOG_DEBUG_LVL, "store_file_packet: empty data.\r\n");
   14d80:	4935      	ldr	r1, [pc, #212]	; (14e58 <store_file_packet+0xe8>)
   14d82:	2001      	movs	r0, #1
   14d84:	4b35      	ldr	r3, [pc, #212]	; (14e5c <store_file_packet+0xec>)
   14d86:	4798      	blx	r3
}
   14d88:	b005      	add	sp, #20
   14d8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return ((down_state & mask) != 0);
   14d8c:	4b34      	ldr	r3, [pc, #208]	; (14e60 <store_file_packet+0xf0>)
   14d8e:	781b      	ldrb	r3, [r3, #0]
    if (!is_state_set(DOWNLOADING)) {
   14d90:	071b      	lsls	r3, r3, #28
   14d92:	d431      	bmi.n	14df8 <store_file_packet+0x88>
        save_file_name[0] = LUN_ID_SD_MMC_0_MEM + '0';
   14d94:	2330      	movs	r3, #48	; 0x30
   14d96:	4d33      	ldr	r5, [pc, #204]	; (14e64 <store_file_packet+0xf4>)
        cp = (char *)(MAIN_HTTP_FILE_URL + strlen(MAIN_HTTP_FILE_URL));
   14d98:	4c33      	ldr	r4, [pc, #204]	; (14e68 <store_file_packet+0xf8>)
        save_file_name[0] = LUN_ID_SD_MMC_0_MEM + '0';
   14d9a:	702b      	strb	r3, [r5, #0]
        save_file_name[1] = ':';
   14d9c:	330a      	adds	r3, #10
   14d9e:	706b      	strb	r3, [r5, #1]
        while (*cp != '/') {
   14da0:	7823      	ldrb	r3, [r4, #0]
   14da2:	2b2f      	cmp	r3, #47	; 0x2f
   14da4:	d11a      	bne.n	14ddc <store_file_packet+0x6c>
        if (strlen(cp) > 1) {
   14da6:	0020      	movs	r0, r4
   14da8:	4b30      	ldr	r3, [pc, #192]	; (14e6c <store_file_packet+0xfc>)
   14daa:	4798      	blx	r3
   14dac:	4e2b      	ldr	r6, [pc, #172]	; (14e5c <store_file_packet+0xec>)
   14dae:	2801      	cmp	r0, #1
   14db0:	d916      	bls.n	14de0 <store_file_packet+0x70>
            cp++;
   14db2:	1c61      	adds	r1, r4, #1
            strcpy(&save_file_name[2], cp);
   14db4:	4b2e      	ldr	r3, [pc, #184]	; (14e70 <store_file_packet+0x100>)
   14db6:	1ca8      	adds	r0, r5, #2
   14db8:	4798      	blx	r3
        rename_to_unique(&file_object, save_file_name, MAIN_MAX_FILE_NAME_LENGTH);
   14dba:	4b2e      	ldr	r3, [pc, #184]	; (14e74 <store_file_packet+0x104>)
   14dbc:	4798      	blx	r3
        LogMessage(LOG_DEBUG_LVL, "store_file_packet: creating file [%s]\r\n", save_file_name);
   14dbe:	002a      	movs	r2, r5
   14dc0:	492d      	ldr	r1, [pc, #180]	; (14e78 <store_file_packet+0x108>)
   14dc2:	2001      	movs	r0, #1
   14dc4:	47b0      	blx	r6
        ret = f_open(&file_object, (char const *)save_file_name, FA_CREATE_ALWAYS | FA_WRITE);
   14dc6:	220a      	movs	r2, #10
   14dc8:	0029      	movs	r1, r5
   14dca:	482c      	ldr	r0, [pc, #176]	; (14e7c <store_file_packet+0x10c>)
   14dcc:	4b2c      	ldr	r3, [pc, #176]	; (14e80 <store_file_packet+0x110>)
   14dce:	4798      	blx	r3
   14dd0:	1e02      	subs	r2, r0, #0
        if (ret != FR_OK) {
   14dd2:	d00c      	beq.n	14dee <store_file_packet+0x7e>
            LogMessage(LOG_DEBUG_LVL, "store_file_packet: file creation error! ret:%d\r\n", ret);
   14dd4:	492b      	ldr	r1, [pc, #172]	; (14e84 <store_file_packet+0x114>)
   14dd6:	2001      	movs	r0, #1
   14dd8:	47b0      	blx	r6
   14dda:	e7d5      	b.n	14d88 <store_file_packet+0x18>
            cp--;
   14ddc:	3c01      	subs	r4, #1
   14dde:	e7df      	b.n	14da0 <store_file_packet+0x30>
            LogMessage(LOG_DEBUG_LVL, "store_file_packet: file name is invalid. Download canceled.\r\n");
   14de0:	2001      	movs	r0, #1
   14de2:	4929      	ldr	r1, [pc, #164]	; (14e88 <store_file_packet+0x118>)
   14de4:	47b0      	blx	r6
            add_state(CANCELED);
   14de6:	2020      	movs	r0, #32
            add_state(COMPLETED);
   14de8:	4b28      	ldr	r3, [pc, #160]	; (14e8c <store_file_packet+0x11c>)
   14dea:	4798      	blx	r3
   14dec:	e7cc      	b.n	14d88 <store_file_packet+0x18>
        received_file_size = 0;
   14dee:	4b28      	ldr	r3, [pc, #160]	; (14e90 <store_file_packet+0x120>)
   14df0:	6018      	str	r0, [r3, #0]
        add_state(DOWNLOADING);
   14df2:	2008      	movs	r0, #8
   14df4:	4b25      	ldr	r3, [pc, #148]	; (14e8c <store_file_packet+0x11c>)
   14df6:	4798      	blx	r3
        UINT wsize = 0;
   14df8:	2300      	movs	r3, #0
        ret = f_write(&file_object, (const void *)data, length, &wsize);
   14dfa:	4d20      	ldr	r5, [pc, #128]	; (14e7c <store_file_packet+0x10c>)
        UINT wsize = 0;
   14dfc:	9303      	str	r3, [sp, #12]
        ret = f_write(&file_object, (const void *)data, length, &wsize);
   14dfe:	4c25      	ldr	r4, [pc, #148]	; (14e94 <store_file_packet+0x124>)
   14e00:	ab03      	add	r3, sp, #12
   14e02:	003a      	movs	r2, r7
   14e04:	9901      	ldr	r1, [sp, #4]
   14e06:	0028      	movs	r0, r5
   14e08:	47a0      	blx	r4
   14e0a:	4c14      	ldr	r4, [pc, #80]	; (14e5c <store_file_packet+0xec>)
        if (ret != FR_OK) {
   14e0c:	2800      	cmp	r0, #0
   14e0e:	d009      	beq.n	14e24 <store_file_packet+0xb4>
            f_close(&file_object);
   14e10:	0028      	movs	r0, r5
   14e12:	4b21      	ldr	r3, [pc, #132]	; (14e98 <store_file_packet+0x128>)
   14e14:	4798      	blx	r3
            add_state(CANCELED);
   14e16:	2020      	movs	r0, #32
   14e18:	4b1c      	ldr	r3, [pc, #112]	; (14e8c <store_file_packet+0x11c>)
   14e1a:	4798      	blx	r3
            LogMessage(LOG_DEBUG_LVL, "store_file_packet: file write error, download canceled.\r\n");
   14e1c:	491f      	ldr	r1, [pc, #124]	; (14e9c <store_file_packet+0x12c>)
   14e1e:	2001      	movs	r0, #1
   14e20:	47a0      	blx	r4
   14e22:	e7b1      	b.n	14d88 <store_file_packet+0x18>
        received_file_size += wsize;
   14e24:	4e1a      	ldr	r6, [pc, #104]	; (14e90 <store_file_packet+0x120>)
        LogMessage(LOG_DEBUG_LVL, "store_file_packet: received[%lu], file size[%lu]\r\n", (unsigned long)received_file_size, (unsigned long)http_file_size);
   14e26:	4f1e      	ldr	r7, [pc, #120]	; (14ea0 <store_file_packet+0x130>)
        received_file_size += wsize;
   14e28:	6833      	ldr	r3, [r6, #0]
   14e2a:	9a03      	ldr	r2, [sp, #12]
        LogMessage(LOG_DEBUG_LVL, "store_file_packet: received[%lu], file size[%lu]\r\n", (unsigned long)received_file_size, (unsigned long)http_file_size);
   14e2c:	491d      	ldr	r1, [pc, #116]	; (14ea4 <store_file_packet+0x134>)
        received_file_size += wsize;
   14e2e:	189a      	adds	r2, r3, r2
        LogMessage(LOG_DEBUG_LVL, "store_file_packet: received[%lu], file size[%lu]\r\n", (unsigned long)received_file_size, (unsigned long)http_file_size);
   14e30:	2001      	movs	r0, #1
   14e32:	683b      	ldr	r3, [r7, #0]
        received_file_size += wsize;
   14e34:	6032      	str	r2, [r6, #0]
        LogMessage(LOG_DEBUG_LVL, "store_file_packet: received[%lu], file size[%lu]\r\n", (unsigned long)received_file_size, (unsigned long)http_file_size);
   14e36:	47a0      	blx	r4
        if (received_file_size >= http_file_size) {
   14e38:	6832      	ldr	r2, [r6, #0]
   14e3a:	683b      	ldr	r3, [r7, #0]
   14e3c:	429a      	cmp	r2, r3
   14e3e:	d3a3      	bcc.n	14d88 <store_file_packet+0x18>
            f_close(&file_object);
   14e40:	4b15      	ldr	r3, [pc, #84]	; (14e98 <store_file_packet+0x128>)
   14e42:	0028      	movs	r0, r5
   14e44:	4798      	blx	r3
            LogMessage(LOG_DEBUG_LVL, "store_file_packet: file downloaded successfully.\r\n");
   14e46:	2001      	movs	r0, #1
   14e48:	4917      	ldr	r1, [pc, #92]	; (14ea8 <store_file_packet+0x138>)
   14e4a:	47a0      	blx	r4
   14e4c:	2280      	movs	r2, #128	; 0x80
   14e4e:	4b17      	ldr	r3, [pc, #92]	; (14eac <store_file_packet+0x13c>)
   14e50:	0412      	lsls	r2, r2, #16
   14e52:	615a      	str	r2, [r3, #20]
            add_state(COMPLETED);
   14e54:	2010      	movs	r0, #16
   14e56:	e7c7      	b.n	14de8 <store_file_packet+0x78>
   14e58:	00028ea8 	.word	0x00028ea8
   14e5c:	000193d9 	.word	0x000193d9
   14e60:	200004f1 	.word	0x200004f1
   14e64:	200000e0 	.word	0x200000e0
   14e68:	00028ea7 	.word	0x00028ea7
   14e6c:	000238c3 	.word	0x000238c3
   14e70:	00023879 	.word	0x00023879
   14e74:	00014c31 	.word	0x00014c31
   14e78:	00028ec9 	.word	0x00028ec9
   14e7c:	20000724 	.word	0x20000724
   14e80:	0002028d 	.word	0x0002028d
   14e84:	00028f2f 	.word	0x00028f2f
   14e88:	00028ef1 	.word	0x00028ef1
   14e8c:	000149bd 	.word	0x000149bd
   14e90:	20000b88 	.word	0x20000b88
   14e94:	000203ed 	.word	0x000203ed
   14e98:	00020639 	.word	0x00020639
   14e9c:	00028f60 	.word	0x00028f60
   14ea0:	20000748 	.word	0x20000748
   14ea4:	00028f9a 	.word	0x00028f9a
   14ea8:	00028fcd 	.word	0x00028fcd
   14eac:	41004400 	.word	0x41004400

00014eb0 <wifi_cb>:
{
   14eb0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    switch (u8MsgType) {
   14eb2:	282c      	cmp	r0, #44	; 0x2c
   14eb4:	d002      	beq.n	14ebc <wifi_cb+0xc>
   14eb6:	2832      	cmp	r0, #50	; 0x32
   14eb8:	d030      	beq.n	14f1c <wifi_cb+0x6c>
}
   14eba:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
            if (pstrWifiState->u8CurrState == M2M_WIFI_CONNECTED) {
   14ebc:	7808      	ldrb	r0, [r1, #0]
   14ebe:	2801      	cmp	r0, #1
   14ec0:	d105      	bne.n	14ece <wifi_cb+0x1e>
                LogMessage(LOG_DEBUG_LVL, "wifi_cb: M2M_WIFI_CONNECTED\r\n");
   14ec2:	4925      	ldr	r1, [pc, #148]	; (14f58 <wifi_cb+0xa8>)
   14ec4:	4b25      	ldr	r3, [pc, #148]	; (14f5c <wifi_cb+0xac>)
   14ec6:	4798      	blx	r3
                m2m_wifi_request_dhcp_client();
   14ec8:	4b25      	ldr	r3, [pc, #148]	; (14f60 <wifi_cb+0xb0>)
   14eca:	4798      	blx	r3
   14ecc:	e7f5      	b.n	14eba <wifi_cb+0xa>
            } else if (pstrWifiState->u8CurrState == M2M_WIFI_DISCONNECTED) {
   14ece:	2800      	cmp	r0, #0
   14ed0:	d1f3      	bne.n	14eba <wifi_cb+0xa>
                LogMessage(LOG_DEBUG_LVL, "wifi_cb: M2M_WIFI_DISCONNECTED\r\n");
   14ed2:	4b22      	ldr	r3, [pc, #136]	; (14f5c <wifi_cb+0xac>)
   14ed4:	4923      	ldr	r1, [pc, #140]	; (14f64 <wifi_cb+0xb4>)
   14ed6:	3001      	adds	r0, #1
   14ed8:	4798      	blx	r3
    down_state &= ~mask;
   14eda:	2202      	movs	r2, #2
    return ((down_state & mask) != 0);
   14edc:	2508      	movs	r5, #8
    down_state &= ~mask;
   14ede:	4c22      	ldr	r4, [pc, #136]	; (14f68 <wifi_cb+0xb8>)
   14ee0:	7823      	ldrb	r3, [r4, #0]
   14ee2:	4393      	bics	r3, r2
   14ee4:	7023      	strb	r3, [r4, #0]
                if (is_state_set(DOWNLOADING)) {
   14ee6:	422b      	tst	r3, r5
   14ee8:	d005      	beq.n	14ef6 <wifi_cb+0x46>
                    f_close(&file_object);
   14eea:	4b20      	ldr	r3, [pc, #128]	; (14f6c <wifi_cb+0xbc>)
   14eec:	4820      	ldr	r0, [pc, #128]	; (14f70 <wifi_cb+0xc0>)
   14eee:	4798      	blx	r3
    down_state &= ~mask;
   14ef0:	7823      	ldrb	r3, [r4, #0]
   14ef2:	43ab      	bics	r3, r5
   14ef4:	7023      	strb	r3, [r4, #0]
    return ((down_state & mask) != 0);
   14ef6:	2204      	movs	r2, #4
   14ef8:	7823      	ldrb	r3, [r4, #0]
                if (is_state_set(GET_REQUESTED)) {
   14efa:	4213      	tst	r3, r2
   14efc:	d001      	beq.n	14f02 <wifi_cb+0x52>
    down_state &= ~mask;
   14efe:	4393      	bics	r3, r2
   14f00:	7023      	strb	r3, [r4, #0]
                mqtt_disconnect(&mqtt_inst, 1);
   14f02:	2101      	movs	r1, #1
   14f04:	4b1b      	ldr	r3, [pc, #108]	; (14f74 <wifi_cb+0xc4>)
   14f06:	481c      	ldr	r0, [pc, #112]	; (14f78 <wifi_cb+0xc8>)
   14f08:	4798      	blx	r3
                m2m_wifi_connect((char *)MAIN_WLAN_SSID, sizeof(MAIN_WLAN_SSID), MAIN_WLAN_AUTH, (char *)MAIN_WLAN_PSK, M2M_WIFI_CH_ALL);
   14f0a:	23ff      	movs	r3, #255	; 0xff
   14f0c:	2202      	movs	r2, #2
   14f0e:	9300      	str	r3, [sp, #0]
   14f10:	2111      	movs	r1, #17
   14f12:	4b1a      	ldr	r3, [pc, #104]	; (14f7c <wifi_cb+0xcc>)
   14f14:	4c1a      	ldr	r4, [pc, #104]	; (14f80 <wifi_cb+0xd0>)
   14f16:	481b      	ldr	r0, [pc, #108]	; (14f84 <wifi_cb+0xd4>)
   14f18:	47a0      	blx	r4
   14f1a:	e7ce      	b.n	14eba <wifi_cb+0xa>
            LogMessage(LOG_DEBUG_LVL, "wifi_cb: IP address is %u.%u.%u.%u\r\n", pu8IPAddress[0], pu8IPAddress[1], pu8IPAddress[2], pu8IPAddress[3]);
   14f1c:	78c8      	ldrb	r0, [r1, #3]
   14f1e:	784b      	ldrb	r3, [r1, #1]
   14f20:	780a      	ldrb	r2, [r1, #0]
   14f22:	9001      	str	r0, [sp, #4]
   14f24:	7889      	ldrb	r1, [r1, #2]
   14f26:	2001      	movs	r0, #1
   14f28:	9100      	str	r1, [sp, #0]
   14f2a:	4c0c      	ldr	r4, [pc, #48]	; (14f5c <wifi_cb+0xac>)
   14f2c:	4916      	ldr	r1, [pc, #88]	; (14f88 <wifi_cb+0xd8>)
   14f2e:	47a0      	blx	r4
            add_state(WIFI_CONNECTED);
   14f30:	4b16      	ldr	r3, [pc, #88]	; (14f8c <wifi_cb+0xdc>)
   14f32:	2002      	movs	r0, #2
   14f34:	4798      	blx	r3
            if (do_download_flag == 1) {
   14f36:	4b16      	ldr	r3, [pc, #88]	; (14f90 <wifi_cb+0xe0>)
   14f38:	781b      	ldrb	r3, [r3, #0]
   14f3a:	2b01      	cmp	r3, #1
   14f3c:	d102      	bne.n	14f44 <wifi_cb+0x94>
                start_download();
   14f3e:	4b15      	ldr	r3, [pc, #84]	; (14f94 <wifi_cb+0xe4>)
   14f40:	4798      	blx	r3
   14f42:	e7ba      	b.n	14eba <wifi_cb+0xa>
                if (mqtt_connect(&mqtt_inst, main_mqtt_broker)) {
   14f44:	4914      	ldr	r1, [pc, #80]	; (14f98 <wifi_cb+0xe8>)
   14f46:	480c      	ldr	r0, [pc, #48]	; (14f78 <wifi_cb+0xc8>)
   14f48:	4b14      	ldr	r3, [pc, #80]	; (14f9c <wifi_cb+0xec>)
   14f4a:	4798      	blx	r3
   14f4c:	2800      	cmp	r0, #0
   14f4e:	d0b4      	beq.n	14eba <wifi_cb+0xa>
                    LogMessage(LOG_DEBUG_LVL, "Error connecting to MQTT Broker!\r\n");
   14f50:	4913      	ldr	r1, [pc, #76]	; (14fa0 <wifi_cb+0xf0>)
   14f52:	2001      	movs	r0, #1
   14f54:	47a0      	blx	r4
}
   14f56:	e7b0      	b.n	14eba <wifi_cb+0xa>
   14f58:	00029180 	.word	0x00029180
   14f5c:	000193d9 	.word	0x000193d9
   14f60:	0001b391 	.word	0x0001b391
   14f64:	0002919e 	.word	0x0002919e
   14f68:	200004f1 	.word	0x200004f1
   14f6c:	00020639 	.word	0x00020639
   14f70:	20000724 	.word	0x20000724
   14f74:	00021189 	.word	0x00021189
   14f78:	20000750 	.word	0x20000750
   14f7c:	000291bf 	.word	0x000291bf
   14f80:	0001b379 	.word	0x0001b379
   14f84:	000291cc 	.word	0x000291cc
   14f88:	000291dd 	.word	0x000291dd
   14f8c:	000149bd 	.word	0x000149bd
   14f90:	200004f0 	.word	0x200004f0
   14f94:	00014b01 	.word	0x00014b01
   14f98:	00028c6b 	.word	0x00028c6b
   14f9c:	000210d1 	.word	0x000210d1
   14fa0:	00029202 	.word	0x00029202

00014fa4 <http_client_callback>:
{
   14fa4:	b570      	push	{r4, r5, r6, lr}
   14fa6:	0014      	movs	r4, r2
    switch (type) {
   14fa8:	2904      	cmp	r1, #4
   14faa:	d809      	bhi.n	14fc0 <http_client_callback+0x1c>
   14fac:	0008      	movs	r0, r1
   14fae:	f010 fc7b 	bl	258a8 <__gnu_thumb1_case_uqi>
   14fb2:	0803      	.short	0x0803
   14fb4:	2a10      	.short	0x2a10
   14fb6:	32          	.byte	0x32
   14fb7:	00          	.byte	0x00
            LogMessage(LOG_DEBUG_LVL, "http_client_callback: HTTP client socket connected.\r\n");
   14fb8:	4925      	ldr	r1, [pc, #148]	; (15050 <http_client_callback+0xac>)
   14fba:	2001      	movs	r0, #1
   14fbc:	4b25      	ldr	r3, [pc, #148]	; (15054 <http_client_callback+0xb0>)
   14fbe:	4798      	blx	r3
}
   14fc0:	bd70      	pop	{r4, r5, r6, pc}
            LogMessage(LOG_DEBUG_LVL, "http_client_callback: request completed.\r\n");
   14fc2:	2001      	movs	r0, #1
   14fc4:	4924      	ldr	r1, [pc, #144]	; (15058 <http_client_callback+0xb4>)
   14fc6:	4b23      	ldr	r3, [pc, #140]	; (15054 <http_client_callback+0xb0>)
   14fc8:	4798      	blx	r3
            add_state(GET_REQUESTED);
   14fca:	2004      	movs	r0, #4
                add_state(CANCELED);
   14fcc:	4b23      	ldr	r3, [pc, #140]	; (1505c <http_client_callback+0xb8>)
   14fce:	4798      	blx	r3
                return;
   14fd0:	e7f6      	b.n	14fc0 <http_client_callback+0x1c>
            LogMessage(LOG_DEBUG_LVL, "http_client_callback: received response %u data size %u\r\n", (unsigned int)data->recv_response.response_code, (unsigned int)data->recv_response.content_length);
   14fd2:	6863      	ldr	r3, [r4, #4]
   14fd4:	8812      	ldrh	r2, [r2, #0]
   14fd6:	4922      	ldr	r1, [pc, #136]	; (15060 <http_client_callback+0xbc>)
   14fd8:	2001      	movs	r0, #1
   14fda:	4d1e      	ldr	r5, [pc, #120]	; (15054 <http_client_callback+0xb0>)
   14fdc:	47a8      	blx	r5
            if ((unsigned int)data->recv_response.response_code == 200) {
   14fde:	8823      	ldrh	r3, [r4, #0]
   14fe0:	2bc8      	cmp	r3, #200	; 0xc8
   14fe2:	d10e      	bne.n	15002 <http_client_callback+0x5e>
                received_file_size = 0;
   14fe4:	2200      	movs	r2, #0
                http_file_size = data->recv_response.content_length;
   14fe6:	4b1f      	ldr	r3, [pc, #124]	; (15064 <http_client_callback+0xc0>)
   14fe8:	6861      	ldr	r1, [r4, #4]
   14fea:	6019      	str	r1, [r3, #0]
                received_file_size = 0;
   14fec:	4b1e      	ldr	r3, [pc, #120]	; (15068 <http_client_callback+0xc4>)
   14fee:	601a      	str	r2, [r3, #0]
            if (data->recv_response.content_length <= MAIN_BUFFER_MAX_SIZE) {
   14ff0:	2380      	movs	r3, #128	; 0x80
   14ff2:	009b      	lsls	r3, r3, #2
   14ff4:	4299      	cmp	r1, r3
   14ff6:	d8e3      	bhi.n	14fc0 <http_client_callback+0x1c>
                store_file_packet(data->recv_response.content, data->recv_response.content_length);
   14ff8:	68a0      	ldr	r0, [r4, #8]
   14ffa:	4b1c      	ldr	r3, [pc, #112]	; (1506c <http_client_callback+0xc8>)
   14ffc:	4798      	blx	r3
                add_state(COMPLETED);
   14ffe:	2010      	movs	r0, #16
   15000:	e7e4      	b.n	14fcc <http_client_callback+0x28>
                add_state(CANCELED);
   15002:	2020      	movs	r0, #32
   15004:	e7e2      	b.n	14fcc <http_client_callback+0x28>
            store_file_packet(data->recv_chunked_data.data, data->recv_chunked_data.length);
   15006:	4b19      	ldr	r3, [pc, #100]	; (1506c <http_client_callback+0xc8>)
   15008:	6811      	ldr	r1, [r2, #0]
   1500a:	6850      	ldr	r0, [r2, #4]
   1500c:	4798      	blx	r3
            if (data->recv_chunked_data.is_complete) {
   1500e:	7a23      	ldrb	r3, [r4, #8]
   15010:	2b00      	cmp	r3, #0
   15012:	d0d5      	beq.n	14fc0 <http_client_callback+0x1c>
   15014:	e7f3      	b.n	14ffe <http_client_callback+0x5a>
            LogMessage(LOG_DEBUG_LVL, "http_client_callback: disconnection reason:%d\r\n", data->disconnected.reason);
   15016:	4b0f      	ldr	r3, [pc, #60]	; (15054 <http_client_callback+0xb0>)
   15018:	6812      	ldr	r2, [r2, #0]
   1501a:	4915      	ldr	r1, [pc, #84]	; (15070 <http_client_callback+0xcc>)
   1501c:	2001      	movs	r0, #1
   1501e:	4798      	blx	r3
            if (data->disconnected.reason == -EAGAIN) {
   15020:	6823      	ldr	r3, [r4, #0]
   15022:	330b      	adds	r3, #11
   15024:	d1cc      	bne.n	14fc0 <http_client_callback+0x1c>
    return ((down_state & mask) != 0);
   15026:	2508      	movs	r5, #8
   15028:	4c12      	ldr	r4, [pc, #72]	; (15074 <http_client_callback+0xd0>)
   1502a:	7823      	ldrb	r3, [r4, #0]
                if (is_state_set(DOWNLOADING)) {
   1502c:	422b      	tst	r3, r5
   1502e:	d005      	beq.n	1503c <http_client_callback+0x98>
                    f_close(&file_object);
   15030:	4b11      	ldr	r3, [pc, #68]	; (15078 <http_client_callback+0xd4>)
   15032:	4812      	ldr	r0, [pc, #72]	; (1507c <http_client_callback+0xd8>)
   15034:	4798      	blx	r3
    down_state &= ~mask;
   15036:	7823      	ldrb	r3, [r4, #0]
   15038:	43ab      	bics	r3, r5
   1503a:	7023      	strb	r3, [r4, #0]
    return ((down_state & mask) != 0);
   1503c:	2204      	movs	r2, #4
   1503e:	7823      	ldrb	r3, [r4, #0]
                if (is_state_set(GET_REQUESTED)) {
   15040:	4213      	tst	r3, r2
   15042:	d001      	beq.n	15048 <http_client_callback+0xa4>
    down_state &= ~mask;
   15044:	4393      	bics	r3, r2
   15046:	7023      	strb	r3, [r4, #0]
                start_download();
   15048:	4b0d      	ldr	r3, [pc, #52]	; (15080 <http_client_callback+0xdc>)
   1504a:	4798      	blx	r3
   1504c:	e7b8      	b.n	14fc0 <http_client_callback+0x1c>
   1504e:	46c0      	nop			; (mov r8, r8)
   15050:	00028a9c 	.word	0x00028a9c
   15054:	000193d9 	.word	0x000193d9
   15058:	00028ad2 	.word	0x00028ad2
   1505c:	000149bd 	.word	0x000149bd
   15060:	00028afd 	.word	0x00028afd
   15064:	20000748 	.word	0x20000748
   15068:	20000b88 	.word	0x20000b88
   1506c:	00014d71 	.word	0x00014d71
   15070:	00028b37 	.word	0x00028b37
   15074:	200004f1 	.word	0x200004f1
   15078:	00020639 	.word	0x00020639
   1507c:	20000724 	.word	0x20000724
   15080:	00014b01 	.word	0x00014b01

00015084 <init_storage>:
{
   15084:	b570      	push	{r4, r5, r6, lr}
    sd_mmc_init();
   15086:	4b1a      	ldr	r3, [pc, #104]	; (150f0 <init_storage+0x6c>)
   15088:	4798      	blx	r3
        LogMessage(LOG_DEBUG_LVL, "init_storage: please plug an SD/MMC card in slot...\r\n");
   1508a:	491a      	ldr	r1, [pc, #104]	; (150f4 <init_storage+0x70>)
   1508c:	2001      	movs	r0, #1
   1508e:	4c1a      	ldr	r4, [pc, #104]	; (150f8 <init_storage+0x74>)
   15090:	47a0      	blx	r4
            status = sd_mmc_test_unit_ready(0);
   15092:	2000      	movs	r0, #0
   15094:	4b19      	ldr	r3, [pc, #100]	; (150fc <init_storage+0x78>)
   15096:	4798      	blx	r3
   15098:	0005      	movs	r5, r0
            if (CTRL_FAIL == status) {
   1509a:	2801      	cmp	r0, #1
   1509c:	d10a      	bne.n	150b4 <init_storage+0x30>
                LogMessage(LOG_DEBUG_LVL, "init_storage: SD Card install failed.\r\n");
   1509e:	4918      	ldr	r1, [pc, #96]	; (15100 <init_storage+0x7c>)
   150a0:	47a0      	blx	r4
                LogMessage(LOG_DEBUG_LVL, "init_storage: try unplug and re-plug the card.\r\n");
   150a2:	4918      	ldr	r1, [pc, #96]	; (15104 <init_storage+0x80>)
   150a4:	0028      	movs	r0, r5
   150a6:	47a0      	blx	r4
                while (CTRL_NO_PRESENT != sd_mmc_check(0)) {
   150a8:	2000      	movs	r0, #0
   150aa:	4b17      	ldr	r3, [pc, #92]	; (15108 <init_storage+0x84>)
   150ac:	4798      	blx	r3
   150ae:	2802      	cmp	r0, #2
   150b0:	d1fa      	bne.n	150a8 <init_storage+0x24>
   150b2:	e7ee      	b.n	15092 <init_storage+0xe>
        } while (CTRL_GOOD != status);
   150b4:	2800      	cmp	r0, #0
   150b6:	d1ec      	bne.n	15092 <init_storage+0xe>
        LogMessage(LOG_DEBUG_LVL, "init_storage: mounting SD card...\r\n");
   150b8:	4914      	ldr	r1, [pc, #80]	; (1510c <init_storage+0x88>)
   150ba:	2001      	movs	r0, #1
   150bc:	47a0      	blx	r4
        memset(&fatfs, 0, sizeof(FATFS));
   150be:	228c      	movs	r2, #140	; 0x8c
   150c0:	4e13      	ldr	r6, [pc, #76]	; (15110 <init_storage+0x8c>)
   150c2:	0092      	lsls	r2, r2, #2
   150c4:	0029      	movs	r1, r5
   150c6:	4b13      	ldr	r3, [pc, #76]	; (15114 <init_storage+0x90>)
   150c8:	0030      	movs	r0, r6
   150ca:	4798      	blx	r3
        res = f_mount(LUN_ID_SD_MMC_0_MEM, &fatfs);
   150cc:	0031      	movs	r1, r6
   150ce:	0028      	movs	r0, r5
   150d0:	4b11      	ldr	r3, [pc, #68]	; (15118 <init_storage+0x94>)
   150d2:	4798      	blx	r3
   150d4:	0002      	movs	r2, r0
        if (FR_INVALID_DRIVE == res) {
   150d6:	280b      	cmp	r0, #11
   150d8:	d103      	bne.n	150e2 <init_storage+0x5e>
            LogMessage(LOG_DEBUG_LVL, "init_storage: SD card mount failed! (res %d)\r\n", res);
   150da:	4910      	ldr	r1, [pc, #64]	; (1511c <init_storage+0x98>)
   150dc:	2001      	movs	r0, #1
   150de:	47a0      	blx	r4
}
   150e0:	bd70      	pop	{r4, r5, r6, pc}
        LogMessage(LOG_DEBUG_LVL, "init_storage: SD card mount OK.\r\n");
   150e2:	490f      	ldr	r1, [pc, #60]	; (15120 <init_storage+0x9c>)
   150e4:	2001      	movs	r0, #1
   150e6:	47a0      	blx	r4
        add_state(STORAGE_READY);
   150e8:	2001      	movs	r0, #1
   150ea:	4b0e      	ldr	r3, [pc, #56]	; (15124 <init_storage+0xa0>)
   150ec:	4798      	blx	r3
        return;
   150ee:	e7f7      	b.n	150e0 <init_storage+0x5c>
   150f0:	00019585 	.word	0x00019585
   150f4:	00028b67 	.word	0x00028b67
   150f8:	000193d9 	.word	0x000193d9
   150fc:	00019bd9 	.word	0x00019bd9
   15100:	00028b9d 	.word	0x00028b9d
   15104:	00028bc5 	.word	0x00028bc5
   15108:	000195a5 	.word	0x000195a5
   1510c:	00028bf6 	.word	0x00028bf6
   15110:	200004f4 	.word	0x200004f4
   15114:	00022c47 	.word	0x00022c47
   15118:	00020265 	.word	0x00020265
   1511c:	00028c1a 	.word	0x00028c1a
   15120:	00028c49 	.word	0x00028c49
   15124:	000149bd 	.word	0x000149bd

00015128 <configure_extint_channel>:
{
   15128:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    extint_chan_get_config_defaults(&config_extint_chan);
   1512a:	ac01      	add	r4, sp, #4
   1512c:	0020      	movs	r0, r4
   1512e:	4b07      	ldr	r3, [pc, #28]	; (1514c <configure_extint_channel+0x24>)
   15130:	4798      	blx	r3
    config_extint_chan.gpio_pin_mux = DEBUG_EIC_MUX;
   15132:	2300      	movs	r3, #0
    config_extint_chan.gpio_pin = DEBUG_EIC_PIN;
   15134:	200a      	movs	r0, #10
    config_extint_chan.gpio_pin_mux = DEBUG_EIC_MUX;
   15136:	6063      	str	r3, [r4, #4]
    config_extint_chan.gpio_pin_pull = EXTINT_PULL_UP;
   15138:	3301      	adds	r3, #1
   1513a:	7223      	strb	r3, [r4, #8]
    config_extint_chan.detection_criteria = EXTINT_DETECT_FALLING;
   1513c:	3301      	adds	r3, #1
   1513e:	72e3      	strb	r3, [r4, #11]
    extint_chan_set_config(DEBUG_EIC_LINE, &config_extint_chan);
   15140:	0021      	movs	r1, r4
   15142:	4b03      	ldr	r3, [pc, #12]	; (15150 <configure_extint_channel+0x28>)
    config_extint_chan.gpio_pin = DEBUG_EIC_PIN;
   15144:	9001      	str	r0, [sp, #4]
    extint_chan_set_config(DEBUG_EIC_LINE, &config_extint_chan);
   15146:	4798      	blx	r3
}
   15148:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
   1514a:	46c0      	nop			; (mov r8, r8)
   1514c:	0001d059 	.word	0x0001d059
   15150:	0001d06d 	.word	0x0001d06d

00015154 <configure_extint_callbacks>:
{
   15154:	b510      	push	{r4, lr}
    extint_register_callback(extint_detection_callback, DEBUG_EIC_LINE, EXTINT_CALLBACK_TYPE_DETECT);
   15156:	2200      	movs	r2, #0
   15158:	210a      	movs	r1, #10
   1515a:	4b04      	ldr	r3, [pc, #16]	; (1516c <configure_extint_callbacks+0x18>)
   1515c:	4804      	ldr	r0, [pc, #16]	; (15170 <configure_extint_callbacks+0x1c>)
   1515e:	4798      	blx	r3
    extint_chan_enable_callback(DEBUG_EIC_LINE, EXTINT_CALLBACK_TYPE_DETECT);
   15160:	2100      	movs	r1, #0
   15162:	200a      	movs	r0, #10
   15164:	4b03      	ldr	r3, [pc, #12]	; (15174 <configure_extint_callbacks+0x20>)
   15166:	4798      	blx	r3
}
   15168:	bd10      	pop	{r4, pc}
   1516a:	46c0      	nop			; (mov r8, r8)
   1516c:	0001cf1d 	.word	0x0001cf1d
   15170:	000149cd 	.word	0x000149cd
   15174:	0001cf45 	.word	0x0001cf45

00015178 <vWifiTask>:
 * Application entry point.
 *
 * \return program return value.
 */
void vWifiTask(void *pvParameters)
{
   15178:	b5f0      	push	{r4, r5, r6, r7, lr}
    down_state = NOT_READY;
   1517a:	2400      	movs	r4, #0
{
   1517c:	b095      	sub	sp, #84	; 0x54
    tstrWifiInitParam param;
    int8_t ret;
    vTaskDelay(100);
   1517e:	2064      	movs	r0, #100	; 0x64
   15180:	4bd0      	ldr	r3, [pc, #832]	; (154c4 <vWifiTask+0x34c>)
   15182:	4798      	blx	r3
    down_state = NOT_READY;
   15184:	4bd0      	ldr	r3, [pc, #832]	; (154c8 <vWifiTask+0x350>)
    init_state();
	
    // Create buffers to send data
    xQueueWifiState = xQueueCreate(5, sizeof(uint32_t));
   15186:	4dd1      	ldr	r5, [pc, #836]	; (154cc <vWifiTask+0x354>)
   15188:	0022      	movs	r2, r4
   1518a:	2104      	movs	r1, #4
   1518c:	2005      	movs	r0, #5
    down_state = NOT_READY;
   1518e:	701c      	strb	r4, [r3, #0]
    xQueueWifiState = xQueueCreate(5, sizeof(uint32_t));
   15190:	47a8      	blx	r5
   15192:	4fcf      	ldr	r7, [pc, #828]	; (154d0 <vWifiTask+0x358>)
    xQueueImuBuffer = xQueueCreate(5, sizeof(struct ImuDataPacket_float));
   15194:	0022      	movs	r2, r4
    xQueueWifiState = xQueueCreate(5, sizeof(uint32_t));
   15196:	6038      	str	r0, [r7, #0]
    xQueueImuBuffer = xQueueCreate(5, sizeof(struct ImuDataPacket_float));
   15198:	210c      	movs	r1, #12
   1519a:	2005      	movs	r0, #5
   1519c:	47a8      	blx	r5
   1519e:	4bcd      	ldr	r3, [pc, #820]	; (154d4 <vWifiTask+0x35c>)
    xQueueAirBuffer = xQueueCreate(2, sizeof(float));
   151a0:	0022      	movs	r2, r4
    xQueueImuBuffer = xQueueCreate(5, sizeof(struct ImuDataPacket_float));
   151a2:	6018      	str	r0, [r3, #0]
    xQueueAirBuffer = xQueueCreate(2, sizeof(float));
   151a4:	2104      	movs	r1, #4
   151a6:	2002      	movs	r0, #2
   151a8:	47a8      	blx	r5
   151aa:	4ecb      	ldr	r6, [pc, #812]	; (154d8 <vWifiTask+0x360>)
    xQueueBmeBuffer = xQueueCreate(5, sizeof(struct bme68x_data));
   151ac:	0022      	movs	r2, r4
    xQueueAirBuffer = xQueueCreate(2, sizeof(float));
   151ae:	6030      	str	r0, [r6, #0]
    xQueueBmeBuffer = xQueueCreate(5, sizeof(struct bme68x_data));
   151b0:	2118      	movs	r1, #24
   151b2:	2005      	movs	r0, #5
   151b4:	47a8      	blx	r5
   151b6:	4bc9      	ldr	r3, [pc, #804]	; (154dc <vWifiTask+0x364>)
   151b8:	4cc9      	ldr	r4, [pc, #804]	; (154e0 <vWifiTask+0x368>)
   151ba:	6018      	str	r0, [r3, #0]

    if (xQueueWifiState == NULL || xQueueImuBuffer == NULL || xQueueAirBuffer == NULL || xQueueBmeBuffer == NULL) {
   151bc:	683b      	ldr	r3, [r7, #0]
   151be:	2b00      	cmp	r3, #0
   151c0:	d008      	beq.n	151d4 <vWifiTask+0x5c>
   151c2:	4bc4      	ldr	r3, [pc, #784]	; (154d4 <vWifiTask+0x35c>)
   151c4:	681b      	ldr	r3, [r3, #0]
   151c6:	2b00      	cmp	r3, #0
   151c8:	d004      	beq.n	151d4 <vWifiTask+0x5c>
   151ca:	6833      	ldr	r3, [r6, #0]
   151cc:	2b00      	cmp	r3, #0
   151ce:	d001      	beq.n	151d4 <vWifiTask+0x5c>
   151d0:	2800      	cmp	r0, #0
   151d2:	d101      	bne.n	151d8 <vWifiTask+0x60>
        SerialConsoleWriteString("ERROR Initializing Wifi Data queues!\r\n");
   151d4:	48c3      	ldr	r0, [pc, #780]	; (154e4 <vWifiTask+0x36c>)
   151d6:	47a0      	blx	r4
    }

    SerialConsoleWriteString("ESE516 - Wifi Init Code\r\n");
   151d8:	48c3      	ldr	r0, [pc, #780]	; (154e8 <vWifiTask+0x370>)
   151da:	47a0      	blx	r4
    sw_timer_get_config_defaults(&swt_conf);
   151dc:	a80d      	add	r0, sp, #52	; 0x34
   151de:	4bc3      	ldr	r3, [pc, #780]	; (154ec <vWifiTask+0x374>)
   151e0:	4798      	blx	r3
    sw_timer_init(&swt_module_inst, &swt_conf);
   151e2:	4cc3      	ldr	r4, [pc, #780]	; (154f0 <vWifiTask+0x378>)
   151e4:	a90d      	add	r1, sp, #52	; 0x34
   151e6:	0020      	movs	r0, r4
   151e8:	4bc2      	ldr	r3, [pc, #776]	; (154f4 <vWifiTask+0x37c>)
   151ea:	4798      	blx	r3
    sw_timer_enable(&swt_module_inst);
   151ec:	0020      	movs	r0, r4
   151ee:	4bc2      	ldr	r3, [pc, #776]	; (154f8 <vWifiTask+0x380>)
   151f0:	4798      	blx	r3
    http_client_get_config_defaults(&httpc_conf);
   151f2:	a80d      	add	r0, sp, #52	; 0x34
   151f4:	4bc1      	ldr	r3, [pc, #772]	; (154fc <vWifiTask+0x384>)
   151f6:	4798      	blx	r3
    httpc_conf.recv_buffer_size = MAIN_BUFFER_MAX_SIZE;
   151f8:	2380      	movs	r3, #128	; 0x80
    ret = http_client_init(&http_client_module_inst, &httpc_conf);
   151fa:	4ec1      	ldr	r6, [pc, #772]	; (15500 <vWifiTask+0x388>)
    httpc_conf.recv_buffer_size = MAIN_BUFFER_MAX_SIZE;
   151fc:	009b      	lsls	r3, r3, #2
   151fe:	9311      	str	r3, [sp, #68]	; 0x44
    ret = http_client_init(&http_client_module_inst, &httpc_conf);
   15200:	a90d      	add	r1, sp, #52	; 0x34
   15202:	0030      	movs	r0, r6
   15204:	4bbf      	ldr	r3, [pc, #764]	; (15504 <vWifiTask+0x38c>)
    httpc_conf.timer_inst = &swt_module_inst;
   15206:	940e      	str	r4, [sp, #56]	; 0x38
    ret = http_client_init(&http_client_module_inst, &httpc_conf);
   15208:	4798      	blx	r3
   1520a:	4dbf      	ldr	r5, [pc, #764]	; (15508 <vWifiTask+0x390>)
   1520c:	1e02      	subs	r2, r0, #0
    if (ret < 0) {
   1520e:	da03      	bge.n	15218 <vWifiTask+0xa0>
        LogMessage(LOG_DEBUG_LVL, "configure_http_client: HTTP client initialization failed! (res %d)\r\n", ret);
   15210:	49be      	ldr	r1, [pc, #760]	; (1550c <vWifiTask+0x394>)
   15212:	2001      	movs	r0, #1
   15214:	47a8      	blx	r5
   15216:	e7fe      	b.n	15216 <vWifiTask+0x9e>
    http_client_register_callback(&http_client_module_inst, http_client_callback);
   15218:	49bd      	ldr	r1, [pc, #756]	; (15510 <vWifiTask+0x398>)
   1521a:	4bbe      	ldr	r3, [pc, #760]	; (15514 <vWifiTask+0x39c>)
   1521c:	0030      	movs	r0, r6
   1521e:	4798      	blx	r3

    /* Initialize the HTTP client service. */
    configure_http_client();

    /* Initialize the MQTT service. */
    configure_mqtt();
   15220:	4bbd      	ldr	r3, [pc, #756]	; (15518 <vWifiTask+0x3a0>)
   15222:	4798      	blx	r3

    /* Initialize SD/MMC storage. */
    init_storage();
   15224:	4bbd      	ldr	r3, [pc, #756]	; (1551c <vWifiTask+0x3a4>)
   15226:	4798      	blx	r3

    /*Initialize BUTTON 0 as an external interrupt*/
    configure_extint_channel();
   15228:	4bbd      	ldr	r3, [pc, #756]	; (15520 <vWifiTask+0x3a8>)
   1522a:	4798      	blx	r3
    configure_extint_callbacks();
   1522c:	4bbd      	ldr	r3, [pc, #756]	; (15524 <vWifiTask+0x3ac>)
   1522e:	4798      	blx	r3

    /* Initialize Wi-Fi parameters structure. */
    memset((uint8_t *)&param, 0, sizeof(tstrWifiInitParam));
   15230:	2218      	movs	r2, #24
   15232:	2100      	movs	r1, #0
   15234:	4bbc      	ldr	r3, [pc, #752]	; (15528 <vWifiTask+0x3b0>)
   15236:	a807      	add	r0, sp, #28
   15238:	4798      	blx	r3

    nm_bsp_init();
   1523a:	4bbc      	ldr	r3, [pc, #752]	; (1552c <vWifiTask+0x3b4>)
   1523c:	4798      	blx	r3

    /* Initialize Wi-Fi driver with data and status callbacks. */
    param.pfAppWifiCb = wifi_cb;
   1523e:	4bbc      	ldr	r3, [pc, #752]	; (15530 <vWifiTask+0x3b8>)
    ret = m2m_wifi_init(&param);
   15240:	a807      	add	r0, sp, #28
    param.pfAppWifiCb = wifi_cb;
   15242:	9307      	str	r3, [sp, #28]
    ret = m2m_wifi_init(&param);
   15244:	4bbb      	ldr	r3, [pc, #748]	; (15534 <vWifiTask+0x3bc>)
   15246:	4798      	blx	r3
   15248:	1e02      	subs	r2, r0, #0
    if (M2M_SUCCESS != ret) {
   1524a:	d003      	beq.n	15254 <vWifiTask+0xdc>
        LogMessage(LOG_DEBUG_LVL, "main: m2m_wifi_init call error! (res %d)\r\n", ret);
   1524c:	49ba      	ldr	r1, [pc, #744]	; (15538 <vWifiTask+0x3c0>)
   1524e:	2001      	movs	r0, #1
   15250:	47a8      	blx	r5
   15252:	e7fe      	b.n	15252 <vWifiTask+0xda>
        while (1) {
        }
    }

    LogMessage(LOG_DEBUG_LVL, "main: connecting to WiFi AP %s...\r\n", (char *)MAIN_WLAN_SSID);
   15254:	4eb9      	ldr	r6, [pc, #740]	; (1553c <vWifiTask+0x3c4>)
   15256:	49ba      	ldr	r1, [pc, #744]	; (15540 <vWifiTask+0x3c8>)
   15258:	0032      	movs	r2, r6
   1525a:	2001      	movs	r0, #1
   1525c:	47a8      	blx	r5

    // Re-enable socket for MQTT Transfer
    socketInit();
   1525e:	4bb9      	ldr	r3, [pc, #740]	; (15544 <vWifiTask+0x3cc>)
   15260:	4798      	blx	r3
    registerSocketCallback(socket_event_handler, socket_resolve_handler);
   15262:	49b9      	ldr	r1, [pc, #740]	; (15548 <vWifiTask+0x3d0>)
   15264:	48b9      	ldr	r0, [pc, #740]	; (1554c <vWifiTask+0x3d4>)
   15266:	4bba      	ldr	r3, [pc, #744]	; (15550 <vWifiTask+0x3d8>)
   15268:	4798      	blx	r3

    m2m_wifi_connect((char *)MAIN_WLAN_SSID, sizeof(MAIN_WLAN_SSID), MAIN_WLAN_AUTH, (char *)MAIN_WLAN_PSK, M2M_WIFI_CH_ALL);
   1526a:	23ff      	movs	r3, #255	; 0xff
   1526c:	4db9      	ldr	r5, [pc, #740]	; (15554 <vWifiTask+0x3dc>)
   1526e:	9300      	str	r3, [sp, #0]
   15270:	2202      	movs	r2, #2
   15272:	4bb9      	ldr	r3, [pc, #740]	; (15558 <vWifiTask+0x3e0>)
   15274:	2111      	movs	r1, #17
   15276:	0030      	movs	r0, r6
   15278:	47a8      	blx	r5
    return ((down_state & mask) != 0);
   1527a:	2502      	movs	r5, #2
   1527c:	4b92      	ldr	r3, [pc, #584]	; (154c8 <vWifiTask+0x350>)
   1527e:	7818      	ldrb	r0, [r3, #0]

    while (!(is_state_set(WIFI_CONNECTED))) {
   15280:	4028      	ands	r0, r5
   15282:	d011      	beq.n	152a8 <vWifiTask+0x130>
        m2m_wifi_handle_events(NULL);
        /* Checks the timer timeout. */
        sw_timer_task(&swt_module_inst);
    }

    vTaskDelay(1000);
   15284:	20fa      	movs	r0, #250	; 0xfa
   15286:	4b8f      	ldr	r3, [pc, #572]	; (154c4 <vWifiTask+0x34c>)
   15288:	0080      	lsls	r0, r0, #2
   1528a:	4798      	blx	r3

    wifiStateMachine = WIFI_MQTT_HANDLE;
   1528c:	2201      	movs	r2, #1
                HTTP_DownloadFileTransaction();
                break;
            }

            default:
                wifiStateMachine = WIFI_MQTT_INIT;
   1528e:	2700      	movs	r7, #0
    wifiStateMachine = WIFI_MQTT_HANDLE;
   15290:	4bb2      	ldr	r3, [pc, #712]	; (1555c <vWifiTask+0x3e4>)
   15292:	701a      	strb	r2, [r3, #0]
        switch (wifiStateMachine) {
   15294:	2000      	movs	r0, #0
   15296:	4db1      	ldr	r5, [pc, #708]	; (1555c <vWifiTask+0x3e4>)
   15298:	5628      	ldrsb	r0, [r5, r0]
   1529a:	2803      	cmp	r0, #3
   1529c:	d900      	bls.n	152a0 <vWifiTask+0x128>
   1529e:	e10b      	b.n	154b8 <vWifiTask+0x340>
   152a0:	f010 fb02 	bl	258a8 <__gnu_thumb1_case_uqi>
   152a4:	e6bb2d08 	.word	0xe6bb2d08
        m2m_wifi_handle_events(NULL);
   152a8:	4bad      	ldr	r3, [pc, #692]	; (15560 <vWifiTask+0x3e8>)
   152aa:	4798      	blx	r3
        sw_timer_task(&swt_module_inst);
   152ac:	0020      	movs	r0, r4
   152ae:	4bad      	ldr	r3, [pc, #692]	; (15564 <vWifiTask+0x3ec>)
   152b0:	4798      	blx	r3
   152b2:	e7e3      	b.n	1527c <vWifiTask+0x104>
    socketDeinit();
   152b4:	4bac      	ldr	r3, [pc, #688]	; (15568 <vWifiTask+0x3f0>)
   152b6:	4798      	blx	r3
    configure_mqtt();
   152b8:	4b97      	ldr	r3, [pc, #604]	; (15518 <vWifiTask+0x3a0>)
   152ba:	4798      	blx	r3
    registerSocketCallback(socket_event_handler, socket_resolve_handler);
   152bc:	49a2      	ldr	r1, [pc, #648]	; (15548 <vWifiTask+0x3d0>)
   152be:	48a3      	ldr	r0, [pc, #652]	; (1554c <vWifiTask+0x3d4>)
   152c0:	4ba3      	ldr	r3, [pc, #652]	; (15550 <vWifiTask+0x3d8>)
   152c2:	4798      	blx	r3
    socketInit();
   152c4:	4b9f      	ldr	r3, [pc, #636]	; (15544 <vWifiTask+0x3cc>)
   152c6:	4798      	blx	r3
    if (!(mqtt_inst.isConnected)) {
   152c8:	4ca8      	ldr	r4, [pc, #672]	; (1556c <vWifiTask+0x3f4>)
   152ca:	0023      	movs	r3, r4
   152cc:	3334      	adds	r3, #52	; 0x34
   152ce:	781b      	ldrb	r3, [r3, #0]
   152d0:	2b00      	cmp	r3, #0
   152d2:	d10d      	bne.n	152f0 <vWifiTask+0x178>
        if (mqtt_connect(&mqtt_inst, main_mqtt_broker)) {
   152d4:	49a6      	ldr	r1, [pc, #664]	; (15570 <vWifiTask+0x3f8>)
   152d6:	0020      	movs	r0, r4
   152d8:	4ba6      	ldr	r3, [pc, #664]	; (15574 <vWifiTask+0x3fc>)
   152da:	4798      	blx	r3
   152dc:	2800      	cmp	r0, #0
   152de:	d003      	beq.n	152e8 <vWifiTask+0x170>
            LogMessage(LOG_DEBUG_LVL, "Error connecting to MQTT Broker!\r\n");
   152e0:	49a5      	ldr	r1, [pc, #660]	; (15578 <vWifiTask+0x400>)
   152e2:	2001      	movs	r0, #1
   152e4:	4b88      	ldr	r3, [pc, #544]	; (15508 <vWifiTask+0x390>)
   152e6:	4798      	blx	r3
    if (mqtt_inst.isConnected) {
   152e8:	3434      	adds	r4, #52	; 0x34
   152ea:	7823      	ldrb	r3, [r4, #0]
   152ec:	2b00      	cmp	r3, #0
   152ee:	d003      	beq.n	152f8 <vWifiTask+0x180>
        LogMessage(LOG_DEBUG_LVL, "Connected to MQTT Broker!\r\n");
   152f0:	49a2      	ldr	r1, [pc, #648]	; (1557c <vWifiTask+0x404>)
   152f2:	2001      	movs	r0, #1
   152f4:	4b84      	ldr	r3, [pc, #528]	; (15508 <vWifiTask+0x390>)
   152f6:	4798      	blx	r3
    wifiStateMachine = WIFI_MQTT_HANDLE;
   152f8:	2301      	movs	r3, #1
    wifiStateMachine = WIFI_DOWNLOAD_HANDLE;
   152fa:	702b      	strb	r3, [r5, #0]
   152fc:	e07c      	b.n	153f8 <vWifiTask+0x280>
    m2m_wifi_handle_events(NULL);
   152fe:	4b98      	ldr	r3, [pc, #608]	; (15560 <vWifiTask+0x3e8>)
   15300:	2000      	movs	r0, #0
   15302:	4798      	blx	r3
    sw_timer_task(&swt_module_inst);
   15304:	487a      	ldr	r0, [pc, #488]	; (154f0 <vWifiTask+0x378>)
   15306:	4b97      	ldr	r3, [pc, #604]	; (15564 <vWifiTask+0x3ec>)
   15308:	4798      	blx	r3
	if (pdPASS == xQueueReceive(xQueueBmeBuffer, &bme_data, 0)) {
   1530a:	4b74      	ldr	r3, [pc, #464]	; (154dc <vWifiTask+0x364>)
   1530c:	2200      	movs	r2, #0
   1530e:	6818      	ldr	r0, [r3, #0]
   15310:	a90d      	add	r1, sp, #52	; 0x34
   15312:	4b9b      	ldr	r3, [pc, #620]	; (15580 <vWifiTask+0x408>)
   15314:	4798      	blx	r3
   15316:	0006      	movs	r6, r0
   15318:	2801      	cmp	r0, #1
   1531a:	d11e      	bne.n	1535a <vWifiTask+0x1e2>
		sprintf(mqtt_msg,"{\"T\":%0.2f, \"H\":%0.2f, \"P\":%0.2f}", bme_data.temperature, bme_data.humidity, bme_data.pressure);
   1531c:	4d99      	ldr	r5, [pc, #612]	; (15584 <vWifiTask+0x40c>)
   1531e:	980f      	ldr	r0, [sp, #60]	; 0x3c
   15320:	47a8      	blx	r5
   15322:	9004      	str	r0, [sp, #16]
   15324:	9105      	str	r1, [sp, #20]
   15326:	9810      	ldr	r0, [sp, #64]	; 0x40
   15328:	47a8      	blx	r5
   1532a:	9002      	str	r0, [sp, #8]
   1532c:	9103      	str	r1, [sp, #12]
   1532e:	9811      	ldr	r0, [sp, #68]	; 0x44
   15330:	47a8      	blx	r5
   15332:	9a04      	ldr	r2, [sp, #16]
   15334:	9b05      	ldr	r3, [sp, #20]
   15336:	4c94      	ldr	r4, [pc, #592]	; (15588 <vWifiTask+0x410>)
   15338:	9000      	str	r0, [sp, #0]
   1533a:	9101      	str	r1, [sp, #4]
   1533c:	4d93      	ldr	r5, [pc, #588]	; (1558c <vWifiTask+0x414>)
   1533e:	4994      	ldr	r1, [pc, #592]	; (15590 <vWifiTask+0x418>)
   15340:	0020      	movs	r0, r4
   15342:	47a8      	blx	r5
		mqtt_publish(&mqtt_inst, BME_TOPIC, mqtt_msg, strlen(mqtt_msg), 1, 0);
   15344:	0020      	movs	r0, r4
   15346:	4b93      	ldr	r3, [pc, #588]	; (15594 <vWifiTask+0x41c>)
   15348:	4798      	blx	r3
   1534a:	0022      	movs	r2, r4
   1534c:	0003      	movs	r3, r0
   1534e:	9701      	str	r7, [sp, #4]
   15350:	9600      	str	r6, [sp, #0]
   15352:	4991      	ldr	r1, [pc, #580]	; (15598 <vWifiTask+0x420>)
   15354:	4885      	ldr	r0, [pc, #532]	; (1556c <vWifiTask+0x3f4>)
   15356:	4c91      	ldr	r4, [pc, #580]	; (1559c <vWifiTask+0x424>)
   15358:	47a0      	blx	r4
    if (pdPASS == xQueueReceive(xQueueImuBuffer, &imuDataVar, 0)) {
   1535a:	4b5e      	ldr	r3, [pc, #376]	; (154d4 <vWifiTask+0x35c>)
   1535c:	2200      	movs	r2, #0
   1535e:	6818      	ldr	r0, [r3, #0]
   15360:	a90d      	add	r1, sp, #52	; 0x34
   15362:	4b87      	ldr	r3, [pc, #540]	; (15580 <vWifiTask+0x408>)
   15364:	4798      	blx	r3
   15366:	0006      	movs	r6, r0
   15368:	2801      	cmp	r0, #1
   1536a:	d11e      	bne.n	153aa <vWifiTask+0x232>
        sprintf(mqtt_msg, "{\"X\":%f, \"Y\":%f, \"Z\": %f}", imuDataVar.xmg, imuDataVar.ymg, imuDataVar.zmg);
   1536c:	4d85      	ldr	r5, [pc, #532]	; (15584 <vWifiTask+0x40c>)
   1536e:	980d      	ldr	r0, [sp, #52]	; 0x34
   15370:	47a8      	blx	r5
   15372:	9004      	str	r0, [sp, #16]
   15374:	9105      	str	r1, [sp, #20]
   15376:	980f      	ldr	r0, [sp, #60]	; 0x3c
   15378:	47a8      	blx	r5
   1537a:	9002      	str	r0, [sp, #8]
   1537c:	9103      	str	r1, [sp, #12]
   1537e:	980e      	ldr	r0, [sp, #56]	; 0x38
   15380:	47a8      	blx	r5
   15382:	9a04      	ldr	r2, [sp, #16]
   15384:	9b05      	ldr	r3, [sp, #20]
   15386:	4c80      	ldr	r4, [pc, #512]	; (15588 <vWifiTask+0x410>)
   15388:	9000      	str	r0, [sp, #0]
   1538a:	9101      	str	r1, [sp, #4]
   1538c:	4d7f      	ldr	r5, [pc, #508]	; (1558c <vWifiTask+0x414>)
   1538e:	4984      	ldr	r1, [pc, #528]	; (155a0 <vWifiTask+0x428>)
   15390:	0020      	movs	r0, r4
   15392:	47a8      	blx	r5
        mqtt_publish(&mqtt_inst, IMU_TOPIC, mqtt_msg, strlen(mqtt_msg), 1, 0);
   15394:	0020      	movs	r0, r4
   15396:	4b7f      	ldr	r3, [pc, #508]	; (15594 <vWifiTask+0x41c>)
   15398:	4798      	blx	r3
   1539a:	0022      	movs	r2, r4
   1539c:	0003      	movs	r3, r0
   1539e:	9701      	str	r7, [sp, #4]
   153a0:	9600      	str	r6, [sp, #0]
   153a2:	4980      	ldr	r1, [pc, #512]	; (155a4 <vWifiTask+0x42c>)
   153a4:	4871      	ldr	r0, [pc, #452]	; (1556c <vWifiTask+0x3f4>)
   153a6:	4c7d      	ldr	r4, [pc, #500]	; (1559c <vWifiTask+0x424>)
   153a8:	47a0      	blx	r4
	if (pdPASS == xQueueReceive(xQueueAirBuffer, &air_data, 0)) {
   153aa:	4b4b      	ldr	r3, [pc, #300]	; (154d8 <vWifiTask+0x360>)
   153ac:	2200      	movs	r2, #0
   153ae:	6818      	ldr	r0, [r3, #0]
   153b0:	a90d      	add	r1, sp, #52	; 0x34
   153b2:	4b73      	ldr	r3, [pc, #460]	; (15580 <vWifiTask+0x408>)
   153b4:	4798      	blx	r3
   153b6:	0006      	movs	r6, r0
   153b8:	2801      	cmp	r0, #1
   153ba:	d114      	bne.n	153e6 <vWifiTask+0x26e>
		sprintf(mqtt_msg, "%0.2f", air_data);
   153bc:	4b71      	ldr	r3, [pc, #452]	; (15584 <vWifiTask+0x40c>)
   153be:	980d      	ldr	r0, [sp, #52]	; 0x34
   153c0:	4798      	blx	r3
   153c2:	4d71      	ldr	r5, [pc, #452]	; (15588 <vWifiTask+0x410>)
   153c4:	0002      	movs	r2, r0
   153c6:	000b      	movs	r3, r1
   153c8:	0028      	movs	r0, r5
   153ca:	4977      	ldr	r1, [pc, #476]	; (155a8 <vWifiTask+0x430>)
   153cc:	4c6f      	ldr	r4, [pc, #444]	; (1558c <vWifiTask+0x414>)
   153ce:	47a0      	blx	r4
		mqtt_publish(&mqtt_inst, AIR_TOPIC, mqtt_msg, strlen(mqtt_msg), 1, 0);
   153d0:	0028      	movs	r0, r5
   153d2:	4b70      	ldr	r3, [pc, #448]	; (15594 <vWifiTask+0x41c>)
   153d4:	4798      	blx	r3
   153d6:	002a      	movs	r2, r5
   153d8:	0003      	movs	r3, r0
   153da:	9701      	str	r7, [sp, #4]
   153dc:	9600      	str	r6, [sp, #0]
   153de:	4973      	ldr	r1, [pc, #460]	; (155ac <vWifiTask+0x434>)
   153e0:	4862      	ldr	r0, [pc, #392]	; (1556c <vWifiTask+0x3f4>)
   153e2:	4d6e      	ldr	r5, [pc, #440]	; (1559c <vWifiTask+0x424>)
   153e4:	47a8      	blx	r5
    if (mqtt_inst.isConnected) mqtt_yield(&mqtt_inst, 100);
   153e6:	4b61      	ldr	r3, [pc, #388]	; (1556c <vWifiTask+0x3f4>)
   153e8:	3334      	adds	r3, #52	; 0x34
   153ea:	781b      	ldrb	r3, [r3, #0]
   153ec:	2b00      	cmp	r3, #0
   153ee:	d003      	beq.n	153f8 <vWifiTask+0x280>
   153f0:	2164      	movs	r1, #100	; 0x64
   153f2:	485e      	ldr	r0, [pc, #376]	; (1556c <vWifiTask+0x3f4>)
   153f4:	4b6e      	ldr	r3, [pc, #440]	; (155b0 <vWifiTask+0x438>)
   153f6:	4798      	blx	r3
                break;
        }

        // Check if a new state was called
        uint8_t DataToReceive = 0;
        if (pdPASS == xQueueReceive(xQueueWifiState, &DataToReceive, 0)) {
   153f8:	4b35      	ldr	r3, [pc, #212]	; (154d0 <vWifiTask+0x358>)
        uint8_t DataToReceive = 0;
   153fa:	ac0d      	add	r4, sp, #52	; 0x34
        if (pdPASS == xQueueReceive(xQueueWifiState, &DataToReceive, 0)) {
   153fc:	6818      	ldr	r0, [r3, #0]
   153fe:	2200      	movs	r2, #0
   15400:	0021      	movs	r1, r4
   15402:	4b5f      	ldr	r3, [pc, #380]	; (15580 <vWifiTask+0x408>)
        uint8_t DataToReceive = 0;
   15404:	7027      	strb	r7, [r4, #0]
        if (pdPASS == xQueueReceive(xQueueWifiState, &DataToReceive, 0)) {
   15406:	4798      	blx	r3
   15408:	2801      	cmp	r0, #1
   1540a:	d102      	bne.n	15412 <vWifiTask+0x29a>
            wifiStateMachine = DataToReceive;  // Update new state
   1540c:	7822      	ldrb	r2, [r4, #0]
   1540e:	4b53      	ldr	r3, [pc, #332]	; (1555c <vWifiTask+0x3e4>)
   15410:	701a      	strb	r2, [r3, #0]
        }

        vTaskDelay(100);
   15412:	2064      	movs	r0, #100	; 0x64
   15414:	4b2b      	ldr	r3, [pc, #172]	; (154c4 <vWifiTask+0x34c>)
   15416:	4798      	blx	r3
    while (1) {
   15418:	e73c      	b.n	15294 <vWifiTask+0x11c>
    if (mqtt_disconnect(&mqtt_inst, main_mqtt_broker)) {
   1541a:	4c54      	ldr	r4, [pc, #336]	; (1556c <vWifiTask+0x3f4>)
   1541c:	4954      	ldr	r1, [pc, #336]	; (15570 <vWifiTask+0x3f8>)
   1541e:	0020      	movs	r0, r4
   15420:	4b64      	ldr	r3, [pc, #400]	; (155b4 <vWifiTask+0x43c>)
   15422:	4798      	blx	r3
   15424:	2800      	cmp	r0, #0
   15426:	d003      	beq.n	15430 <vWifiTask+0x2b8>
        LogMessage(LOG_DEBUG_LVL, "Error connecting to MQTT Broker!\r\n");
   15428:	4953      	ldr	r1, [pc, #332]	; (15578 <vWifiTask+0x400>)
   1542a:	2001      	movs	r0, #1
   1542c:	4b36      	ldr	r3, [pc, #216]	; (15508 <vWifiTask+0x390>)
   1542e:	4798      	blx	r3
    while ((mqtt_inst.isConnected)) {
   15430:	0023      	movs	r3, r4
   15432:	3334      	adds	r3, #52	; 0x34
   15434:	781b      	ldrb	r3, [r3, #0]
   15436:	2b00      	cmp	r3, #0
   15438:	d10e      	bne.n	15458 <vWifiTask+0x2e0>
    socketDeinit();
   1543a:	4b4b      	ldr	r3, [pc, #300]	; (15568 <vWifiTask+0x3f0>)
   1543c:	4798      	blx	r3
    do_download_flag = true;
   1543e:	2201      	movs	r2, #1
   15440:	4b5d      	ldr	r3, [pc, #372]	; (155b8 <vWifiTask+0x440>)
    registerSocketCallback(socket_cb, resolve_cb);
   15442:	495e      	ldr	r1, [pc, #376]	; (155bc <vWifiTask+0x444>)
    do_download_flag = true;
   15444:	701a      	strb	r2, [r3, #0]
    registerSocketCallback(socket_cb, resolve_cb);
   15446:	485e      	ldr	r0, [pc, #376]	; (155c0 <vWifiTask+0x448>)
   15448:	4b41      	ldr	r3, [pc, #260]	; (15550 <vWifiTask+0x3d8>)
   1544a:	4798      	blx	r3
    socketInit();
   1544c:	4b3d      	ldr	r3, [pc, #244]	; (15544 <vWifiTask+0x3cc>)
   1544e:	4798      	blx	r3
    start_download();
   15450:	4b5c      	ldr	r3, [pc, #368]	; (155c4 <vWifiTask+0x44c>)
   15452:	4798      	blx	r3
    wifiStateMachine = WIFI_DOWNLOAD_HANDLE;
   15454:	2303      	movs	r3, #3
   15456:	e750      	b.n	152fa <vWifiTask+0x182>
        m2m_wifi_handle_events(NULL);
   15458:	4b41      	ldr	r3, [pc, #260]	; (15560 <vWifiTask+0x3e8>)
   1545a:	2000      	movs	r0, #0
   1545c:	4798      	blx	r3
   1545e:	e7e7      	b.n	15430 <vWifiTask+0x2b8>
        m2m_wifi_handle_events(NULL);
   15460:	4b3f      	ldr	r3, [pc, #252]	; (15560 <vWifiTask+0x3e8>)
   15462:	2000      	movs	r0, #0
   15464:	4798      	blx	r3
        sw_timer_task(&swt_module_inst);
   15466:	4822      	ldr	r0, [pc, #136]	; (154f0 <vWifiTask+0x378>)
   15468:	4b3e      	ldr	r3, [pc, #248]	; (15564 <vWifiTask+0x3ec>)
   1546a:	4798      	blx	r3
        vTaskDelay(5);
   1546c:	2005      	movs	r0, #5
   1546e:	47b0      	blx	r6
    return ((down_state & mask) != 0);
   15470:	4b15      	ldr	r3, [pc, #84]	; (154c8 <vWifiTask+0x350>)
   15472:	4e14      	ldr	r6, [pc, #80]	; (154c4 <vWifiTask+0x34c>)
   15474:	781c      	ldrb	r4, [r3, #0]
    while (!(is_state_set(COMPLETED)) || is_state_set(CANCELED)) {
   15476:	2310      	movs	r3, #16
   15478:	421c      	tst	r4, r3
   1547a:	d0f1      	beq.n	15460 <vWifiTask+0x2e8>
   1547c:	18db      	adds	r3, r3, r3
   1547e:	401c      	ands	r4, r3
   15480:	d1ee      	bne.n	15460 <vWifiTask+0x2e8>
    socketDeinit();
   15482:	4b39      	ldr	r3, [pc, #228]	; (15568 <vWifiTask+0x3f0>)
   15484:	4798      	blx	r3
    vTaskDelay(1000);
   15486:	20fa      	movs	r0, #250	; 0xfa
   15488:	0080      	lsls	r0, r0, #2
   1548a:	47b0      	blx	r6
    do_download_flag = false;
   1548c:	4b4a      	ldr	r3, [pc, #296]	; (155b8 <vWifiTask+0x440>)
    char test_file_name[] = "0:FlagA.txt";
   1548e:	220c      	movs	r2, #12
    do_download_flag = false;
   15490:	701c      	strb	r4, [r3, #0]
    char test_file_name[] = "0:FlagA.txt";
   15492:	494d      	ldr	r1, [pc, #308]	; (155c8 <vWifiTask+0x450>)
   15494:	4b4d      	ldr	r3, [pc, #308]	; (155cc <vWifiTask+0x454>)
   15496:	a80d      	add	r0, sp, #52	; 0x34
   15498:	4798      	blx	r3
    FRESULT res = f_open(&file_object, (char const *)test_file_name, FA_CREATE_ALWAYS | FA_WRITE);
   1549a:	4e4d      	ldr	r6, [pc, #308]	; (155d0 <vWifiTask+0x458>)
   1549c:	220a      	movs	r2, #10
   1549e:	a90d      	add	r1, sp, #52	; 0x34
   154a0:	0030      	movs	r0, r6
   154a2:	4b4c      	ldr	r3, [pc, #304]	; (155d4 <vWifiTask+0x45c>)
   154a4:	4798      	blx	r3
   154a6:	1e02      	subs	r2, r0, #0
    if (res != FR_OK) {
   154a8:	d008      	beq.n	154bc <vWifiTask+0x344>
        LogMessage(LOG_INFO_LVL, "[FAIL] res %d\r\n", res);
   154aa:	494b      	ldr	r1, [pc, #300]	; (155d8 <vWifiTask+0x460>)
   154ac:	0020      	movs	r0, r4
   154ae:	4b16      	ldr	r3, [pc, #88]	; (15508 <vWifiTask+0x390>)
   154b0:	4798      	blx	r3
    f_close(&file_object);
   154b2:	0030      	movs	r0, r6
   154b4:	4b49      	ldr	r3, [pc, #292]	; (155dc <vWifiTask+0x464>)
   154b6:	4798      	blx	r3
                wifiStateMachine = WIFI_MQTT_INIT;
   154b8:	702f      	strb	r7, [r5, #0]
                break;
   154ba:	e79d      	b.n	153f8 <vWifiTask+0x280>
        SerialConsoleWriteString("FlagA.txt added!\r\n");
   154bc:	4848      	ldr	r0, [pc, #288]	; (155e0 <vWifiTask+0x468>)
   154be:	4b08      	ldr	r3, [pc, #32]	; (154e0 <vWifiTask+0x368>)
   154c0:	4798      	blx	r3
   154c2:	e7f6      	b.n	154b2 <vWifiTask+0x33a>
   154c4:	000185ad 	.word	0x000185ad
   154c8:	200004f1 	.word	0x200004f1
   154cc:	00017229 	.word	0x00017229
   154d0:	20000b9c 	.word	0x20000b9c
   154d4:	20000b98 	.word	0x20000b98
   154d8:	20000b90 	.word	0x20000b90
   154dc:	20000b94 	.word	0x20000b94
   154e0:	00019335 	.word	0x00019335
   154e4:	00029000 	.word	0x00029000
   154e8:	00029027 	.word	0x00029027
   154ec:	000227c1 	.word	0x000227c1
   154f0:	2000432c 	.word	0x2000432c
   154f4:	000227cd 	.word	0x000227cd
   154f8:	0002286d 	.word	0x0002286d
   154fc:	00021ab1 	.word	0x00021ab1
   15500:	20004384 	.word	0x20004384
   15504:	00021ad9 	.word	0x00021ad9
   15508:	000193d9 	.word	0x000193d9
   1550c:	00029041 	.word	0x00029041
   15510:	00014fa5 	.word	0x00014fa5
   15514:	00021b71 	.word	0x00021b71
   15518:	000149f1 	.word	0x000149f1
   1551c:	00015085 	.word	0x00015085
   15520:	00015129 	.word	0x00015129
   15524:	00015155 	.word	0x00015155
   15528:	00022c47 	.word	0x00022c47
   1552c:	0001a3f1 	.word	0x0001a3f1
   15530:	00014eb1 	.word	0x00014eb1
   15534:	0001b059 	.word	0x0001b059
   15538:	00029086 	.word	0x00029086
   1553c:	000291cc 	.word	0x000291cc
   15540:	000290b1 	.word	0x000290b1
   15544:	0001c915 	.word	0x0001c915
   15548:	000149d9 	.word	0x000149d9
   1554c:	000149e5 	.word	0x000149e5
   15550:	0001c991 	.word	0x0001c991
   15554:	0001b379 	.word	0x0001b379
   15558:	000291bf 	.word	0x000291bf
   1555c:	20000b8c 	.word	0x20000b8c
   15560:	0001b181 	.word	0x0001b181
   15564:	000228f5 	.word	0x000228f5
   15568:	0001c955 	.word	0x0001c955
   1556c:	20000750 	.word	0x20000750
   15570:	00028c6b 	.word	0x00028c6b
   15574:	000210d1 	.word	0x000210d1
   15578:	00029202 	.word	0x00029202
   1557c:	000290d5 	.word	0x000290d5
   15580:	00017905 	.word	0x00017905
   15584:	0002866d 	.word	0x0002866d
   15588:	200000a0 	.word	0x200000a0
   1558c:	000237e5 	.word	0x000237e5
   15590:	000290f1 	.word	0x000290f1
   15594:	000238c3 	.word	0x000238c3
   15598:	00029113 	.word	0x00029113
   1559c:	000211b5 	.word	0x000211b5
   155a0:	00029126 	.word	0x00029126
   155a4:	00029140 	.word	0x00029140
   155a8:	00029149 	.word	0x00029149
   155ac:	0002914f 	.word	0x0002914f
   155b0:	00021211 	.word	0x00021211
   155b4:	00021189 	.word	0x00021189
   155b8:	200004f0 	.word	0x200004f0
   155bc:	00014a79 	.word	0x00014a79
   155c0:	00014ab5 	.word	0x00014ab5
   155c4:	00014b01 	.word	0x00014b01
   155c8:	00029174 	.word	0x00029174
   155cc:	00022c11 	.word	0x00022c11
   155d0:	20000724 	.word	0x20000724
   155d4:	0002028d 	.word	0x0002028d
   155d8:	00028829 	.word	0x00028829
   155dc:	00020639 	.word	0x00020639
   155e0:	00029161 	.word	0x00029161

000155e4 <WifiHandlerSetState>:
    }
    return;
}

void WifiHandlerSetState(uint8_t state)
{
   155e4:	b513      	push	{r0, r1, r4, lr}
   155e6:	466b      	mov	r3, sp
   155e8:	1dd9      	adds	r1, r3, #7
   155ea:	7008      	strb	r0, [r1, #0]
    if (state <= WIFI_DOWNLOAD_HANDLE) {
   155ec:	2803      	cmp	r0, #3
   155ee:	d805      	bhi.n	155fc <WifiHandlerSetState+0x18>
        xQueueSend(xQueueWifiState, &state, (TickType_t)10);
   155f0:	4803      	ldr	r0, [pc, #12]	; (15600 <WifiHandlerSetState+0x1c>)
   155f2:	2300      	movs	r3, #0
   155f4:	220a      	movs	r2, #10
   155f6:	6800      	ldr	r0, [r0, #0]
   155f8:	4c02      	ldr	r4, [pc, #8]	; (15604 <WifiHandlerSetState+0x20>)
   155fa:	47a0      	blx	r4
    }
}
   155fc:	bd13      	pop	{r0, r1, r4, pc}
   155fe:	46c0      	nop			; (mov r8, r8)
   15600:	20000b9c 	.word	0x20000b9c
   15604:	0001735d 	.word	0x0001735d

00015608 <WifiAddImuDataToQueue>:
 * @return	Returns pdTrue if data can be added to queue, pdFalse if queue is full
 * @note

*/
int WifiAddImuDataToQueue(struct ImuDataPacket_float *imuPacket)
{
   15608:	b510      	push	{r4, lr}
   1560a:	0001      	movs	r1, r0
    int error = xQueueSend(xQueueImuBuffer, imuPacket, (TickType_t)10);
   1560c:	4803      	ldr	r0, [pc, #12]	; (1561c <WifiAddImuDataToQueue+0x14>)
   1560e:	2300      	movs	r3, #0
   15610:	220a      	movs	r2, #10
   15612:	4c03      	ldr	r4, [pc, #12]	; (15620 <WifiAddImuDataToQueue+0x18>)
   15614:	6800      	ldr	r0, [r0, #0]
   15616:	47a0      	blx	r4
    return error;
}
   15618:	bd10      	pop	{r4, pc}
   1561a:	46c0      	nop			; (mov r8, r8)
   1561c:	20000b98 	.word	0x20000b98
   15620:	0001735d 	.word	0x0001735d

00015624 <WifiAddAirDataToQueue>:
 * @return	Returns pdTrue if data can be added to queue, pdFalse if queue is full
 * @note

*/
int WifiAddAirDataToQueue(float *air_ms)
{
   15624:	b510      	push	{r4, lr}
   15626:	0001      	movs	r1, r0
    int error = xQueueSend(xQueueAirBuffer, air_ms, (TickType_t)10);
   15628:	4803      	ldr	r0, [pc, #12]	; (15638 <WifiAddAirDataToQueue+0x14>)
   1562a:	2300      	movs	r3, #0
   1562c:	220a      	movs	r2, #10
   1562e:	4c03      	ldr	r4, [pc, #12]	; (1563c <WifiAddAirDataToQueue+0x18>)
   15630:	6800      	ldr	r0, [r0, #0]
   15632:	47a0      	blx	r4
    return error;
}
   15634:	bd10      	pop	{r4, pc}
   15636:	46c0      	nop			; (mov r8, r8)
   15638:	20000b90 	.word	0x20000b90
   1563c:	0001735d 	.word	0x0001735d

00015640 <WifiAddBmeDataToQueue>:
 * @return	Returns pdTrue if data can be added to queue, pdFalse if queue is full
 * @note

*/
int WifiAddBmeDataToQueue(struct bme68x_data *bmePacket)
{
   15640:	b510      	push	{r4, lr}
   15642:	0001      	movs	r1, r0
    int error = xQueueSend(xQueueBmeBuffer, bmePacket, (TickType_t)10);
   15644:	4803      	ldr	r0, [pc, #12]	; (15654 <WifiAddBmeDataToQueue+0x14>)
   15646:	2300      	movs	r3, #0
   15648:	220a      	movs	r2, #10
   1564a:	4c03      	ldr	r4, [pc, #12]	; (15658 <WifiAddBmeDataToQueue+0x18>)
   1564c:	6800      	ldr	r0, [r0, #0]
   1564e:	47a0      	blx	r4
    return error;
   15650:	bd10      	pop	{r4, pc}
   15652:	46c0      	nop			; (mov r8, r8)
   15654:	20000b94 	.word	0x20000b94
   15658:	0001735d 	.word	0x0001735d

0001565c <_i2c_master_wait_for_sync>:
	return (i2c_hw->SYNCBUSY.reg & SERCOM_I2CM_SYNCBUSY_MASK);
   1565c:	2307      	movs	r3, #7
	SercomI2cm *const i2c_hw = &(module->hw->I2CM);
   1565e:	6801      	ldr	r1, [r0, #0]
	return (i2c_hw->SYNCBUSY.reg & SERCOM_I2CM_SYNCBUSY_MASK);
   15660:	69ca      	ldr	r2, [r1, #28]
	while (i2c_master_is_syncing(module)) {
   15662:	421a      	tst	r2, r3
   15664:	d1fc      	bne.n	15660 <_i2c_master_wait_for_sync+0x4>
}
   15666:	4770      	bx	lr

00015668 <i2c_master_init>:
 */
enum status_code i2c_master_init(
		struct i2c_master_module *const module,
		Sercom *const hw,
		const struct i2c_master_config *const config)
{
   15668:	b5f0      	push	{r4, r5, r6, r7, lr}
   1566a:	0007      	movs	r7, r0
   1566c:	b08b      	sub	sp, #44	; 0x2c
	Assert(module);
	Assert(hw);
	Assert(config);

	/* Initialize software module */
	module->hw = hw;
   1566e:	6039      	str	r1, [r7, #0]

	SercomI2cm *const i2c_module = &(module->hw->I2CM);

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
   15670:	0008      	movs	r0, r1
   15672:	4b9b      	ldr	r3, [pc, #620]	; (158e0 <i2c_master_init+0x278>)
{
   15674:	0014      	movs	r4, r2
   15676:	000e      	movs	r6, r1
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
   15678:	4798      	blx	r3
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBD, 1 << pm_index);
	} else {
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
	}
#else
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
   1567a:	2501      	movs	r5, #1
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
   1567c:	1c83      	adds	r3, r0, #2
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
   1567e:	409d      	lsls	r5, r3
   15680:	002b      	movs	r3, r5
   15682:	4a98      	ldr	r2, [pc, #608]	; (158e4 <i2c_master_init+0x27c>)
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
   15684:	3014      	adds	r0, #20
   15686:	6a11      	ldr	r1, [r2, #32]

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
   15688:	b2c5      	uxtb	r5, r0
   1568a:	430b      	orrs	r3, r1
   1568c:	6213      	str	r3, [r2, #32]
	gclk_chan_conf.source_generator = config->generator_source;
   1568e:	7b23      	ldrb	r3, [r4, #12]
   15690:	aa08      	add	r2, sp, #32
   15692:	7013      	strb	r3, [r2, #0]
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
   15694:	0011      	movs	r1, r2
   15696:	0028      	movs	r0, r5
   15698:	4b93      	ldr	r3, [pc, #588]	; (158e8 <i2c_master_init+0x280>)
   1569a:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
   1569c:	0028      	movs	r0, r5
   1569e:	4b93      	ldr	r3, [pc, #588]	; (158ec <i2c_master_init+0x284>)
   156a0:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
   156a2:	4b93      	ldr	r3, [pc, #588]	; (158f0 <i2c_master_init+0x288>)
   156a4:	7b20      	ldrb	r0, [r4, #12]
   156a6:	2100      	movs	r1, #0
   156a8:	4798      	blx	r3

	/* Check if module is enabled. */
	if (i2c_module->CTRLA.reg & SERCOM_I2CM_CTRLA_ENABLE) {
   156aa:	6833      	ldr	r3, [r6, #0]
		return STATUS_ERR_DENIED;
   156ac:	201c      	movs	r0, #28
	if (i2c_module->CTRLA.reg & SERCOM_I2CM_CTRLA_ENABLE) {
   156ae:	079b      	lsls	r3, r3, #30
   156b0:	d500      	bpl.n	156b4 <i2c_master_init+0x4c>
   156b2:	e109      	b.n	158c8 <i2c_master_init+0x260>
	}

	/* Check if reset is in progress. */
	if (i2c_module->CTRLA.reg & SERCOM_I2CM_CTRLA_SWRST) {
   156b4:	2301      	movs	r3, #1
   156b6:	6835      	ldr	r5, [r6, #0]
		return STATUS_BUSY;
   156b8:	3817      	subs	r0, #23
	if (i2c_module->CTRLA.reg & SERCOM_I2CM_CTRLA_SWRST) {
   156ba:	401d      	ands	r5, r3
   156bc:	d000      	beq.n	156c0 <i2c_master_init+0x58>
   156be:	e103      	b.n	158c8 <i2c_master_init+0x260>
	}

#if I2C_MASTER_CALLBACK_MODE == true
	/* Get sercom instance index and register callback. */
	uint8_t instance_index = _sercom_get_sercom_inst_index(module->hw);
   156c0:	4b87      	ldr	r3, [pc, #540]	; (158e0 <i2c_master_init+0x278>)
   156c2:	6838      	ldr	r0, [r7, #0]
   156c4:	4798      	blx	r3
	_sercom_set_handler(instance_index, _i2c_master_interrupt_handler);
   156c6:	498b      	ldr	r1, [pc, #556]	; (158f4 <i2c_master_init+0x28c>)
   156c8:	4b8b      	ldr	r3, [pc, #556]	; (158f8 <i2c_master_init+0x290>)
	uint8_t instance_index = _sercom_get_sercom_inst_index(module->hw);
   156ca:	9004      	str	r0, [sp, #16]
	_sercom_set_handler(instance_index, _i2c_master_interrupt_handler);
   156cc:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
   156ce:	9b04      	ldr	r3, [sp, #16]

	/* Initialize values in module. */
	module->registered_callback = 0;
   156d0:	763d      	strb	r5, [r7, #24]
	_sercom_instances[instance_index] = module;
   156d2:	009a      	lsls	r2, r3, #2
   156d4:	4b89      	ldr	r3, [pc, #548]	; (158fc <i2c_master_init+0x294>)
	module->enabled_callback = 0;
   156d6:	767d      	strb	r5, [r7, #25]
	_sercom_instances[instance_index] = module;
   156d8:	50d7      	str	r7, [r2, r3]
	module->buffer_length = 0;
	module->buffer_remaining = 0;

	module->status = STATUS_OK;
   156da:	1dbb      	adds	r3, r7, #6
	module->buffer_length = 0;
   156dc:	837d      	strh	r5, [r7, #26]
	module->buffer_remaining = 0;
   156de:	83bd      	strh	r5, [r7, #28]
	module->status = STATUS_OK;
   156e0:	77dd      	strb	r5, [r3, #31]
	module->buffer = NULL;
#endif

	/* Set sercom module to operate in I2C master mode. */
	i2c_module->CTRLA.reg = SERCOM_I2CM_CTRLA_MODE(0x5);
   156e2:	2314      	movs	r3, #20
	module->buffer = NULL;
   156e4:	623d      	str	r5, [r7, #32]
	i2c_module->CTRLA.reg = SERCOM_I2CM_CTRLA_MODE(0x5);
   156e6:	6033      	str	r3, [r6, #0]
	SercomI2cm *const i2c_module = &(module->hw->I2CM);
   156e8:	683b      	ldr	r3, [r7, #0]
	config->mux_position = SYSTEM_PINMUX_GPIO;
   156ea:	ae09      	add	r6, sp, #36	; 0x24
   156ec:	9304      	str	r3, [sp, #16]
	uint8_t sercom_index = _sercom_get_sercom_inst_index(sercom_hw);
   156ee:	0018      	movs	r0, r3
   156f0:	4b7b      	ldr	r3, [pc, #492]	; (158e0 <i2c_master_init+0x278>)
   156f2:	4798      	blx	r3
   156f4:	2380      	movs	r3, #128	; 0x80
   156f6:	9000      	str	r0, [sp, #0]
	uint32_t pad0 = config->pinmux_pad0;
   156f8:	69e0      	ldr	r0, [r4, #28]
   156fa:	7033      	strb	r3, [r6, #0]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
   156fc:	3b7f      	subs	r3, #127	; 0x7f
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
   156fe:	7075      	strb	r5, [r6, #1]
	config->powersave    = false;
   15700:	70f5      	strb	r5, [r6, #3]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
   15702:	70b3      	strb	r3, [r6, #2]
	uint32_t pad1 = config->pinmux_pad1;
   15704:	6a25      	ldr	r5, [r4, #32]
	if (pad0 == PINMUX_DEFAULT) {
   15706:	2800      	cmp	r0, #0
   15708:	d103      	bne.n	15712 <i2c_master_init+0xaa>
		pad0 = _sercom_get_default_pad(sercom_hw, 0);
   1570a:	0001      	movs	r1, r0
   1570c:	4b7c      	ldr	r3, [pc, #496]	; (15900 <i2c_master_init+0x298>)
   1570e:	9804      	ldr	r0, [sp, #16]
   15710:	4798      	blx	r3
	pin_conf.direction    = SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK;
   15712:	2302      	movs	r3, #2
	pin_conf.mux_position = pad0 & 0xFFFF;
   15714:	7030      	strb	r0, [r6, #0]
	system_pinmux_pin_set_config(pad0 >> 16, &pin_conf);
   15716:	0c00      	lsrs	r0, r0, #16
	pin_conf.direction    = SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK;
   15718:	7073      	strb	r3, [r6, #1]
	system_pinmux_pin_set_config(pad0 >> 16, &pin_conf);
   1571a:	b2c0      	uxtb	r0, r0
   1571c:	0031      	movs	r1, r6
   1571e:	4b79      	ldr	r3, [pc, #484]	; (15904 <i2c_master_init+0x29c>)
   15720:	4798      	blx	r3
	if (pad1 == PINMUX_DEFAULT) {
   15722:	2d00      	cmp	r5, #0
   15724:	d104      	bne.n	15730 <i2c_master_init+0xc8>
		pad1 = _sercom_get_default_pad(sercom_hw, 1);
   15726:	2101      	movs	r1, #1
   15728:	9804      	ldr	r0, [sp, #16]
   1572a:	4b75      	ldr	r3, [pc, #468]	; (15900 <i2c_master_init+0x298>)
   1572c:	4798      	blx	r3
   1572e:	0005      	movs	r5, r0
	pin_conf.direction    = SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK;
   15730:	2302      	movs	r3, #2
	pin_conf.mux_position = pad1 & 0xFFFF;
   15732:	7035      	strb	r5, [r6, #0]
	system_pinmux_pin_set_config(pad1 >> 16, &pin_conf);
   15734:	0c2d      	lsrs	r5, r5, #16
	pin_conf.direction    = SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK;
   15736:	7073      	strb	r3, [r6, #1]
	system_pinmux_pin_set_config(pad1 >> 16, &pin_conf);
   15738:	b2e8      	uxtb	r0, r5
   1573a:	4b72      	ldr	r3, [pc, #456]	; (15904 <i2c_master_init+0x29c>)
   1573c:	0031      	movs	r1, r6
   1573e:	4798      	blx	r3
	module->unknown_bus_state_timeout = config->unknown_bus_state_timeout;
   15740:	8aa3      	ldrh	r3, [r4, #20]
   15742:	80fb      	strh	r3, [r7, #6]
	module->buffer_timeout = config->buffer_timeout;
   15744:	8ae3      	ldrh	r3, [r4, #22]
   15746:	813b      	strh	r3, [r7, #8]
	if (config->run_in_standby || system_is_debugger_present()) {
   15748:	7e22      	ldrb	r2, [r4, #24]
		tmp_ctrla = SERCOM_I2CM_CTRLA_RUNSTDBY;
   1574a:	2380      	movs	r3, #128	; 0x80
	if (config->run_in_standby || system_is_debugger_present()) {
   1574c:	2a00      	cmp	r2, #0
   1574e:	d106      	bne.n	1575e <i2c_master_init+0xf6>
 * \retval false Debugger is not connected to the system
 *
 */
static inline bool system_is_debugger_present(void)
{
	return DSU->STATUSB.reg & DSU_STATUSB_DBGPRES;
   15750:	4b6d      	ldr	r3, [pc, #436]	; (15908 <i2c_master_init+0x2a0>)
   15752:	3202      	adds	r2, #2
   15754:	789b      	ldrb	r3, [r3, #2]
   15756:	4013      	ands	r3, r2
		tmp_ctrla = 0;
   15758:	1e5f      	subs	r7, r3, #1
   1575a:	41bb      	sbcs	r3, r7
   1575c:	01db      	lsls	r3, r3, #7
	tmp_ctrla |= config->transfer_speed;
   1575e:	68a2      	ldr	r2, [r4, #8]
   15760:	6927      	ldr	r7, [r4, #16]
   15762:	4317      	orrs	r7, r2
   15764:	431f      	orrs	r7, r3
	if (config->scl_low_timeout) {
   15766:	1d63      	adds	r3, r4, #5
   15768:	7fdb      	ldrb	r3, [r3, #31]
   1576a:	2b00      	cmp	r3, #0
   1576c:	d002      	beq.n	15774 <i2c_master_init+0x10c>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_LOWTOUTEN;
   1576e:	2380      	movs	r3, #128	; 0x80
   15770:	05db      	lsls	r3, r3, #23
   15772:	431f      	orrs	r7, r3
		tmp_ctrla |= config->inactive_timeout;
   15774:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   15776:	431f      	orrs	r7, r3
	if (config->scl_stretch_only_after_ack_bit || (config->transfer_speed == I2C_MASTER_SPEED_HIGH_SPEED)) {
   15778:	0023      	movs	r3, r4
   1577a:	332c      	adds	r3, #44	; 0x2c
   1577c:	781b      	ldrb	r3, [r3, #0]
   1577e:	2b00      	cmp	r3, #0
   15780:	d103      	bne.n	1578a <i2c_master_init+0x122>
   15782:	2380      	movs	r3, #128	; 0x80
   15784:	049b      	lsls	r3, r3, #18
   15786:	429a      	cmp	r2, r3
   15788:	d102      	bne.n	15790 <i2c_master_init+0x128>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_SCLSM;
   1578a:	2380      	movs	r3, #128	; 0x80
   1578c:	051b      	lsls	r3, r3, #20
   1578e:	431f      	orrs	r7, r3
	if (config->slave_scl_low_extend_timeout) {
   15790:	0023      	movs	r3, r4
   15792:	332d      	adds	r3, #45	; 0x2d
   15794:	781b      	ldrb	r3, [r3, #0]
   15796:	2b00      	cmp	r3, #0
   15798:	d002      	beq.n	157a0 <i2c_master_init+0x138>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_SEXTTOEN;
   1579a:	2380      	movs	r3, #128	; 0x80
   1579c:	041b      	lsls	r3, r3, #16
   1579e:	431f      	orrs	r7, r3
	if (config->master_scl_low_extend_timeout) {
   157a0:	0023      	movs	r3, r4
   157a2:	332e      	adds	r3, #46	; 0x2e
   157a4:	781b      	ldrb	r3, [r3, #0]
   157a6:	2b00      	cmp	r3, #0
   157a8:	d002      	beq.n	157b0 <i2c_master_init+0x148>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_MEXTTOEN;
   157aa:	2380      	movs	r3, #128	; 0x80
   157ac:	03db      	lsls	r3, r3, #15
   157ae:	431f      	orrs	r7, r3
	i2c_module->CTRLA.reg |= tmp_ctrla;
   157b0:	9b04      	ldr	r3, [sp, #16]
	uint32_t fgclk       = system_gclk_chan_get_hz(SERCOM0_GCLK_ID_CORE + sercom_index);
   157b2:	9800      	ldr	r0, [sp, #0]
	i2c_module->CTRLA.reg |= tmp_ctrla;
   157b4:	681b      	ldr	r3, [r3, #0]
	uint32_t fscl        = 1000 * config->baud_rate;
   157b6:	25fa      	movs	r5, #250	; 0xfa
	i2c_module->CTRLA.reg |= tmp_ctrla;
   157b8:	431f      	orrs	r7, r3
   157ba:	9b04      	ldr	r3, [sp, #16]
	i2c_module->CTRLB.reg = SERCOM_I2CM_CTRLB_SMEN;
   157bc:	9a04      	ldr	r2, [sp, #16]
	i2c_module->CTRLA.reg |= tmp_ctrla;
   157be:	601f      	str	r7, [r3, #0]
	i2c_module->CTRLB.reg = SERCOM_I2CM_CTRLB_SMEN;
   157c0:	2380      	movs	r3, #128	; 0x80
	uint32_t fgclk       = system_gclk_chan_get_hz(SERCOM0_GCLK_ID_CORE + sercom_index);
   157c2:	3014      	adds	r0, #20
	i2c_module->CTRLB.reg = SERCOM_I2CM_CTRLB_SMEN;
   157c4:	005b      	lsls	r3, r3, #1
   157c6:	6053      	str	r3, [r2, #4]
	uint32_t fgclk       = system_gclk_chan_get_hz(SERCOM0_GCLK_ID_CORE + sercom_index);
   157c8:	b2c0      	uxtb	r0, r0
   157ca:	4b50      	ldr	r3, [pc, #320]	; (1590c <i2c_master_init+0x2a4>)
   157cc:	4798      	blx	r3
	uint32_t fscl        = 1000 * config->baud_rate;
   157ce:	6823      	ldr	r3, [r4, #0]
   157d0:	00ad      	lsls	r5, r5, #2
   157d2:	435d      	muls	r5, r3
	uint32_t fscl_hs     = 1000 * config->baud_rate_high_speed;
   157d4:	6863      	ldr	r3, [r4, #4]
	uint32_t fgclk       = system_gclk_chan_get_hz(SERCOM0_GCLK_ID_CORE + sercom_index);
   157d6:	0007      	movs	r7, r0
	uint32_t fscl_hs     = 1000 * config->baud_rate_high_speed;
   157d8:	9305      	str	r3, [sp, #20]
	tmp_baud = (int32_t)(div_ceil(
   157da:	4b4d      	ldr	r3, [pc, #308]	; (15910 <i2c_master_init+0x2a8>)
   157dc:	4798      	blx	r3
   157de:	4b4c      	ldr	r3, [pc, #304]	; (15910 <i2c_master_init+0x2a8>)
   157e0:	9000      	str	r0, [sp, #0]
   157e2:	9101      	str	r1, [sp, #4]
   157e4:	0068      	lsls	r0, r5, #1
   157e6:	4798      	blx	r3
   157e8:	9002      	str	r0, [sp, #8]
   157ea:	9103      	str	r1, [sp, #12]
   157ec:	4b48      	ldr	r3, [pc, #288]	; (15910 <i2c_master_init+0x2a8>)
   157ee:	8e20      	ldrh	r0, [r4, #48]	; 0x30
   157f0:	4798      	blx	r3
   157f2:	4e48      	ldr	r6, [pc, #288]	; (15914 <i2c_master_init+0x2ac>)
   157f4:	9006      	str	r0, [sp, #24]
   157f6:	9107      	str	r1, [sp, #28]
   157f8:	9800      	ldr	r0, [sp, #0]
   157fa:	9901      	ldr	r1, [sp, #4]
   157fc:	4a46      	ldr	r2, [pc, #280]	; (15918 <i2c_master_init+0x2b0>)
   157fe:	4b47      	ldr	r3, [pc, #284]	; (1591c <i2c_master_init+0x2b4>)
   15800:	47b0      	blx	r6
   15802:	0002      	movs	r2, r0
   15804:	000b      	movs	r3, r1
   15806:	9806      	ldr	r0, [sp, #24]
   15808:	9907      	ldr	r1, [sp, #28]
   1580a:	47b0      	blx	r6
   1580c:	4e44      	ldr	r6, [pc, #272]	; (15920 <i2c_master_init+0x2b8>)
   1580e:	2200      	movs	r2, #0
   15810:	4b44      	ldr	r3, [pc, #272]	; (15924 <i2c_master_init+0x2bc>)
   15812:	47b0      	blx	r6
   15814:	4b3e      	ldr	r3, [pc, #248]	; (15910 <i2c_master_init+0x2a8>)
   15816:	9006      	str	r0, [sp, #24]
   15818:	9107      	str	r1, [sp, #28]
   1581a:	0028      	movs	r0, r5
   1581c:	4798      	blx	r3
   1581e:	4d3d      	ldr	r5, [pc, #244]	; (15914 <i2c_master_init+0x2ac>)
   15820:	0002      	movs	r2, r0
   15822:	000b      	movs	r3, r1
   15824:	9806      	ldr	r0, [sp, #24]
   15826:	9907      	ldr	r1, [sp, #28]
   15828:	47a8      	blx	r5
   1582a:	4d3f      	ldr	r5, [pc, #252]	; (15928 <i2c_master_init+0x2c0>)
   1582c:	0002      	movs	r2, r0
   1582e:	000b      	movs	r3, r1
   15830:	9800      	ldr	r0, [sp, #0]
   15832:	9901      	ldr	r1, [sp, #4]
   15834:	47a8      	blx	r5
   15836:	9a02      	ldr	r2, [sp, #8]
   15838:	9b03      	ldr	r3, [sp, #12]
   1583a:	47b0      	blx	r6
   1583c:	2200      	movs	r2, #0
   1583e:	4b3b      	ldr	r3, [pc, #236]	; (1592c <i2c_master_init+0x2c4>)
   15840:	47a8      	blx	r5
   15842:	9a02      	ldr	r2, [sp, #8]
   15844:	9b03      	ldr	r3, [sp, #12]
   15846:	4e3a      	ldr	r6, [pc, #232]	; (15930 <i2c_master_init+0x2c8>)
   15848:	47b0      	blx	r6
   1584a:	4b3a      	ldr	r3, [pc, #232]	; (15934 <i2c_master_init+0x2cc>)
   1584c:	4798      	blx	r3
	if (config->transfer_speed == I2C_MASTER_SPEED_HIGH_SPEED) {
   1584e:	2380      	movs	r3, #128	; 0x80
	tmp_baud = (int32_t)(div_ceil(
   15850:	9002      	str	r0, [sp, #8]
	if (config->transfer_speed == I2C_MASTER_SPEED_HIGH_SPEED) {
   15852:	68a2      	ldr	r2, [r4, #8]
   15854:	049b      	lsls	r3, r3, #18
   15856:	429a      	cmp	r2, r3
   15858:	d13e      	bne.n	158d8 <i2c_master_init+0x270>
	uint32_t fscl_hs     = 1000 * config->baud_rate_high_speed;
   1585a:	23fa      	movs	r3, #250	; 0xfa
   1585c:	9c05      	ldr	r4, [sp, #20]
   1585e:	009b      	lsls	r3, r3, #2
   15860:	435c      	muls	r4, r3
		tmp_baudlow_hs = (int32_t)((fgclk * 2.0) / (3.0 * fscl_hs) - 1);
   15862:	9a00      	ldr	r2, [sp, #0]
   15864:	9b01      	ldr	r3, [sp, #4]
   15866:	4e2e      	ldr	r6, [pc, #184]	; (15920 <i2c_master_init+0x2b8>)
   15868:	0010      	movs	r0, r2
   1586a:	0019      	movs	r1, r3
   1586c:	47b0      	blx	r6
   1586e:	4b28      	ldr	r3, [pc, #160]	; (15910 <i2c_master_init+0x2a8>)
   15870:	9000      	str	r0, [sp, #0]
   15872:	9101      	str	r1, [sp, #4]
   15874:	0020      	movs	r0, r4
   15876:	4798      	blx	r3
   15878:	2200      	movs	r2, #0
   1587a:	4b2f      	ldr	r3, [pc, #188]	; (15938 <i2c_master_init+0x2d0>)
   1587c:	4e25      	ldr	r6, [pc, #148]	; (15914 <i2c_master_init+0x2ac>)
   1587e:	47b0      	blx	r6
   15880:	4e2b      	ldr	r6, [pc, #172]	; (15930 <i2c_master_init+0x2c8>)
   15882:	0002      	movs	r2, r0
   15884:	000b      	movs	r3, r1
   15886:	9800      	ldr	r0, [sp, #0]
   15888:	9901      	ldr	r1, [sp, #4]
   1588a:	47b0      	blx	r6
   1588c:	2200      	movs	r2, #0
   1588e:	4b27      	ldr	r3, [pc, #156]	; (1592c <i2c_master_init+0x2c4>)
   15890:	47a8      	blx	r5
   15892:	4b28      	ldr	r3, [pc, #160]	; (15934 <i2c_master_init+0x2cc>)
   15894:	4798      	blx	r3
   15896:	4b29      	ldr	r3, [pc, #164]	; (1593c <i2c_master_init+0x2d4>)
   15898:	1e06      	subs	r6, r0, #0
		if (tmp_baudlow_hs) {
   1589a:	d017      	beq.n	158cc <i2c_master_init+0x264>
			tmp_baud_hs = (int32_t)(fgclk / fscl_hs) - 2 - tmp_baudlow_hs;
   1589c:	0021      	movs	r1, r4
   1589e:	0038      	movs	r0, r7
   158a0:	4798      	blx	r3
   158a2:	3802      	subs	r0, #2
   158a4:	1b83      	subs	r3, r0, r6
	if (tmp_baud > 255 || tmp_baud < 0 || tmp_baud_hs > 255 || tmp_baud_hs < 0) {
   158a6:	9a02      	ldr	r2, [sp, #8]
   158a8:	2040      	movs	r0, #64	; 0x40
   158aa:	2aff      	cmp	r2, #255	; 0xff
   158ac:	d80c      	bhi.n	158c8 <i2c_master_init+0x260>
   158ae:	2bff      	cmp	r3, #255	; 0xff
   158b0:	d80a      	bhi.n	158c8 <i2c_master_init+0x260>
			SERCOM_I2CM_BAUD_HSBAUD(tmp_baud_hs) | SERCOM_I2CM_BAUD_HSBAUDLOW(tmp_baudlow_hs);
   158b2:	20ff      	movs	r0, #255	; 0xff
   158b4:	0015      	movs	r5, r2
   158b6:	0400      	lsls	r0, r0, #16
   158b8:	041b      	lsls	r3, r3, #16
   158ba:	4003      	ands	r3, r0
	enum status_code tmp_status_code = STATUS_OK;
   158bc:	2000      	movs	r0, #0
			SERCOM_I2CM_BAUD_HSBAUD(tmp_baud_hs) | SERCOM_I2CM_BAUD_HSBAUDLOW(tmp_baudlow_hs);
   158be:	0636      	lsls	r6, r6, #24
   158c0:	4335      	orrs	r5, r6
		i2c_module->BAUD.reg = SERCOM_I2CM_BAUD_BAUD(tmp_baud) |
   158c2:	9a04      	ldr	r2, [sp, #16]
			SERCOM_I2CM_BAUD_HSBAUD(tmp_baud_hs) | SERCOM_I2CM_BAUD_HSBAUDLOW(tmp_baudlow_hs);
   158c4:	432b      	orrs	r3, r5
		i2c_module->BAUD.reg = SERCOM_I2CM_BAUD_BAUD(tmp_baud) |
   158c6:	60d3      	str	r3, [r2, #12]

	/* Set config and return status. */
	return _i2c_master_set_config(module, config);
}
   158c8:	b00b      	add	sp, #44	; 0x2c
   158ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
			tmp_baud_hs = (int32_t)(div_ceil(fgclk, 2 * fscl_hs)) - 1;
   158cc:	0061      	lsls	r1, r4, #1
   158ce:	1e48      	subs	r0, r1, #1
   158d0:	19c0      	adds	r0, r0, r7
   158d2:	4798      	blx	r3
   158d4:	1e43      	subs	r3, r0, #1
   158d6:	e7e6      	b.n	158a6 <i2c_master_init+0x23e>
	int32_t tmp_baudlow_hs = 0;
   158d8:	2600      	movs	r6, #0
	int32_t tmp_baud_hs = 0;
   158da:	0033      	movs	r3, r6
   158dc:	e7e3      	b.n	158a6 <i2c_master_init+0x23e>
   158de:	46c0      	nop			; (mov r8, r8)
   158e0:	0001d62d 	.word	0x0001d62d
   158e4:	40000400 	.word	0x40000400
   158e8:	0001e839 	.word	0x0001e839
   158ec:	0001e7b1 	.word	0x0001e7b1
   158f0:	0001d48d 	.word	0x0001d48d
   158f4:	00012575 	.word	0x00012575
   158f8:	0001d661 	.word	0x0001d661
   158fc:	20005680 	.word	0x20005680
   15900:	0001d4d1 	.word	0x0001d4d1
   15904:	0001e93d 	.word	0x0001e93d
   15908:	41002000 	.word	0x41002000
   1590c:	0001e855 	.word	0x0001e855
   15910:	000285fd 	.word	0x000285fd
   15914:	000279a5 	.word	0x000279a5
   15918:	e826d695 	.word	0xe826d695
   1591c:	3e112e0b 	.word	0x3e112e0b
   15920:	00026b1d 	.word	0x00026b1d
   15924:	40240000 	.word	0x40240000
   15928:	00027ea5 	.word	0x00027ea5
   1592c:	3ff00000 	.word	0x3ff00000
   15930:	0002713d 	.word	0x0002713d
   15934:	00028511 	.word	0x00028511
   15938:	40080000 	.word	0x40080000
   1593c:	000258bd 	.word	0x000258bd

00015940 <i2c_master_reset>:
 * Reset the module to hardware defaults.
 *
 * \param[in,out] module Pointer to software module structure
 */
void i2c_master_reset(struct i2c_master_module *const module)
{
   15940:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   15942:	0004      	movs	r4, r0
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
   15944:	6803      	ldr	r3, [r0, #0]

	/* Wait for sync */
	_i2c_master_wait_for_sync(module);
   15946:	4e12      	ldr	r6, [pc, #72]	; (15990 <i2c_master_reset+0x50>)
	SercomI2cm *const i2c_module = &(module->hw->I2CM);
   15948:	9301      	str	r3, [sp, #4]
	_i2c_master_wait_for_sync(module);
   1594a:	47b0      	blx	r6
{
	/* Sanity check of arguments */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
   1594c:	6825      	ldr	r5, [r4, #0]

#if I2C_MASTER_CALLBACK_MODE == true
		/* Disable module interrupts */
		system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
   1594e:	4f11      	ldr	r7, [pc, #68]	; (15994 <i2c_master_reset+0x54>)
   15950:	0028      	movs	r0, r5
   15952:	47b8      	blx	r7
 * \param[in] vector  Interrupt vector to disable
 */
static inline void system_interrupt_disable(
		const enum system_interrupt_vector vector)
{
	NVIC->ICER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
   15954:	231f      	movs	r3, #31
   15956:	2201      	movs	r2, #1
   15958:	4018      	ands	r0, r3
   1595a:	4082      	lsls	r2, r0
   1595c:	4b0e      	ldr	r3, [pc, #56]	; (15998 <i2c_master_reset+0x58>)
#endif

	/* Wait for module to sync */
	_i2c_master_wait_for_sync(module);
   1595e:	0020      	movs	r0, r4
   15960:	67da      	str	r2, [r3, #124]	; 0x7c
   15962:	47b0      	blx	r6

	/* Disbale interrupt */
	i2c_module->INTENCLR.reg = SERCOM_I2CM_INTENCLR_MASK;
   15964:	2383      	movs	r3, #131	; 0x83
	/* Clear interrupt flag */
	i2c_module->INTFLAG.reg = SERCOM_I2CM_INTFLAG_MASK;

	/* Disable module */
	i2c_module->CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
   15966:	2202      	movs	r2, #2
	i2c_module->INTENCLR.reg = SERCOM_I2CM_INTENCLR_MASK;
   15968:	752b      	strb	r3, [r5, #20]
	i2c_module->INTFLAG.reg = SERCOM_I2CM_INTFLAG_MASK;
   1596a:	762b      	strb	r3, [r5, #24]
	i2c_module->CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
   1596c:	682b      	ldr	r3, [r5, #0]
   1596e:	4393      	bics	r3, r2
   15970:	602b      	str	r3, [r5, #0]
	cpu_irq_enter_critical();
   15972:	4b0a      	ldr	r3, [pc, #40]	; (1599c <i2c_master_reset+0x5c>)
   15974:	4798      	blx	r3
	i2c_master_disable(module);

#if I2C_MASTER_CALLBACK_MODE == true
	/* Clear all pending interrupts */
	system_interrupt_enter_critical_section();
	system_interrupt_clear_pending(_sercom_get_interrupt_vector(module->hw));
   15976:	6820      	ldr	r0, [r4, #0]
   15978:	47b8      	blx	r7
   1597a:	4b09      	ldr	r3, [pc, #36]	; (159a0 <i2c_master_reset+0x60>)
   1597c:	4798      	blx	r3
	cpu_irq_leave_critical();
   1597e:	4b09      	ldr	r3, [pc, #36]	; (159a4 <i2c_master_reset+0x64>)
   15980:	4798      	blx	r3
	system_interrupt_leave_critical_section();
#endif

	/* Wait for sync */
	_i2c_master_wait_for_sync(module);
   15982:	0020      	movs	r0, r4
   15984:	47b0      	blx	r6

	/* Reset module */
	i2c_module->CTRLA.reg = SERCOM_I2CM_CTRLA_SWRST;
   15986:	2201      	movs	r2, #1
   15988:	9b01      	ldr	r3, [sp, #4]
   1598a:	601a      	str	r2, [r3, #0]
}
   1598c:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   1598e:	46c0      	nop			; (mov r8, r8)
   15990:	0001565d 	.word	0x0001565d
   15994:	0001d699 	.word	0x0001d699
   15998:	e000e104 	.word	0xe000e104
   1599c:	0001ce85 	.word	0x0001ce85
   159a0:	0001e889 	.word	0x0001e889
   159a4:	0001ceb9 	.word	0x0001ceb9

000159a8 <_i2c_master_address_response>:

	SercomI2cm *const i2c_module = &(module->hw->I2CM);

	/* Check for error and ignore bus-error; workaround for BUSSTATE stuck in
	 * BUSY */
	if (i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB) {
   159a8:	2202      	movs	r2, #2
	SercomI2cm *const i2c_module = &(module->hw->I2CM);
   159aa:	6803      	ldr	r3, [r0, #0]
	if (i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB) {
   159ac:	7e19      	ldrb	r1, [r3, #24]
   159ae:	4211      	tst	r1, r2
   159b0:	d006      	beq.n	159c0 <_i2c_master_address_response+0x18>

		/* Clear write interrupt flag */
		i2c_module->INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
   159b2:	761a      	strb	r2, [r3, #24]

		/* Check arbitration. */
		if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_ARBLOST) {
   159b4:	8b5b      	ldrh	r3, [r3, #26]
			/* Return packet collision. */
			return STATUS_ERR_PACKET_COLLISION;
   159b6:	2041      	movs	r0, #65	; 0x41
		if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_ARBLOST) {
   159b8:	4213      	tst	r3, r2
   159ba:	d10a      	bne.n	159d2 <_i2c_master_address_response+0x2a>

		/* Return bad address value. */
		return STATUS_ERR_BAD_ADDRESS;
	}

	return STATUS_OK;
   159bc:	2000      	movs	r0, #0
   159be:	e008      	b.n	159d2 <_i2c_master_address_response+0x2a>
	} else if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_RXNACK) {
   159c0:	8b5a      	ldrh	r2, [r3, #26]
   159c2:	0752      	lsls	r2, r2, #29
   159c4:	d5fa      	bpl.n	159bc <_i2c_master_address_response+0x14>
		i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
   159c6:	22c0      	movs	r2, #192	; 0xc0
		return STATUS_ERR_BAD_ADDRESS;
   159c8:	2018      	movs	r0, #24
		i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
   159ca:	6859      	ldr	r1, [r3, #4]
   159cc:	0292      	lsls	r2, r2, #10
   159ce:	430a      	orrs	r2, r1
   159d0:	605a      	str	r2, [r3, #4]
}
   159d2:	4770      	bx	lr

000159d4 <_i2c_master_wait_for_bus>:
 * \retval STATUS_ERR_TIMEOUT  If no response was given within specified timeout
 *                             period
 */
enum status_code _i2c_master_wait_for_bus(
		struct i2c_master_module *const module)
{
   159d4:	b570      	push	{r4, r5, r6, lr}
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);

	/* Wait for reply. */
	uint16_t timeout_counter = 0;
   159d6:	2200      	movs	r2, #0
	while (!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB) &&
   159d8:	2601      	movs	r6, #1
   159da:	2402      	movs	r4, #2
	SercomI2cm *const i2c_module = &(module->hw->I2CM);
   159dc:	6801      	ldr	r1, [r0, #0]
	while (!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB) &&
   159de:	7e0b      	ldrb	r3, [r1, #24]
   159e0:	4033      	ands	r3, r6
   159e2:	d102      	bne.n	159ea <_i2c_master_wait_for_bus+0x16>
			!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB)) {
   159e4:	7e0d      	ldrb	r5, [r1, #24]
	while (!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB) &&
   159e6:	4225      	tst	r5, r4
   159e8:	d001      	beq.n	159ee <_i2c_master_wait_for_bus+0x1a>
		/* Check timeout condition. */
		if (++timeout_counter >= module->buffer_timeout) {
			return STATUS_ERR_TIMEOUT;
		}
	}
	return STATUS_OK;
   159ea:	2000      	movs	r0, #0
   159ec:	e005      	b.n	159fa <_i2c_master_wait_for_bus+0x26>
		if (++timeout_counter >= module->buffer_timeout) {
   159ee:	3201      	adds	r2, #1
   159f0:	8903      	ldrh	r3, [r0, #8]
   159f2:	b292      	uxth	r2, r2
   159f4:	4293      	cmp	r3, r2
   159f6:	d8f2      	bhi.n	159de <_i2c_master_wait_for_bus+0xa>
			return STATUS_ERR_TIMEOUT;
   159f8:	2012      	movs	r0, #18
}
   159fa:	bd70      	pop	{r4, r5, r6, pc}

000159fc <_i2c_master_send_hs_master_code>:
	SercomI2cm *const i2c_module = &(module->hw->I2CM);
	/* Return value. */
	enum status_code tmp_status;

	/* Set NACK for high speed code */
	i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
   159fc:	2380      	movs	r3, #128	; 0x80
{
   159fe:	b510      	push	{r4, lr}
	SercomI2cm *const i2c_module = &(module->hw->I2CM);
   15a00:	6804      	ldr	r4, [r0, #0]
	i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
   15a02:	02db      	lsls	r3, r3, #11
   15a04:	6862      	ldr	r2, [r4, #4]
   15a06:	4313      	orrs	r3, r2
   15a08:	6063      	str	r3, [r4, #4]
	/* Send high speed code */
	i2c_module->ADDR.reg = hs_master_code;
   15a0a:	6261      	str	r1, [r4, #36]	; 0x24
	/* Wait for response on bus. */
	tmp_status = _i2c_master_wait_for_bus(module);
   15a0c:	4b02      	ldr	r3, [pc, #8]	; (15a18 <_i2c_master_send_hs_master_code+0x1c>)
   15a0e:	4798      	blx	r3
	/* Clear write interrupt flag */
	i2c_module->INTFLAG.reg = SERCOM_I2CM_INTENCLR_MB;
   15a10:	2301      	movs	r3, #1
   15a12:	7623      	strb	r3, [r4, #24]

	return tmp_status;
}
   15a14:	bd10      	pop	{r4, pc}
   15a16:	46c0      	nop			; (mov r8, r8)
   15a18:	000159d5 	.word	0x000159d5

00015a1c <_tc_interrupt_handler>:
 * \param[in]  instance  ID of the TC instance calling the interrupt
 *                       handler
 */
void _tc_interrupt_handler(
		uint8_t instance)
{
   15a1c:	b570      	push	{r4, r5, r6, lr}
	interrupt_and_callback_status_mask = module->hw->COUNT8.INTFLAG.reg &
			module->register_callback_mask &
			module->enable_callback_mask;

	/* Check if an Overflow interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_OVF) {
   15a1e:	2601      	movs	r6, #1
	struct tc_module *module
   15a20:	4b14      	ldr	r3, [pc, #80]	; (15a74 <_tc_interrupt_handler+0x58>)
   15a22:	0080      	lsls	r0, r0, #2
   15a24:	58c4      	ldr	r4, [r0, r3]
	interrupt_and_callback_status_mask = module->hw->COUNT8.INTFLAG.reg &
   15a26:	6823      	ldr	r3, [r4, #0]
   15a28:	7e22      	ldrb	r2, [r4, #24]
   15a2a:	7e65      	ldrb	r5, [r4, #25]
   15a2c:	7b9b      	ldrb	r3, [r3, #14]
   15a2e:	4015      	ands	r5, r2
   15a30:	401d      	ands	r5, r3
	if (interrupt_and_callback_status_mask & TC_INTFLAG_OVF) {
   15a32:	4235      	tst	r5, r6
   15a34:	d004      	beq.n	15a40 <_tc_interrupt_handler+0x24>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_OVERFLOW])(module);
   15a36:	68a3      	ldr	r3, [r4, #8]
   15a38:	0020      	movs	r0, r4
   15a3a:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_OVF;
   15a3c:	6823      	ldr	r3, [r4, #0]
   15a3e:	739e      	strb	r6, [r3, #14]
	}

	/* Check if an Error interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_ERR) {
   15a40:	2602      	movs	r6, #2
   15a42:	4235      	tst	r5, r6
   15a44:	d004      	beq.n	15a50 <_tc_interrupt_handler+0x34>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_ERROR])(module);
   15a46:	68e3      	ldr	r3, [r4, #12]
   15a48:	0020      	movs	r0, r4
   15a4a:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_ERR;
   15a4c:	6823      	ldr	r3, [r4, #0]
   15a4e:	739e      	strb	r6, [r3, #14]
	}

	/* Check if an Match/Capture Channel 0 interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_MC(1)) {
   15a50:	2610      	movs	r6, #16
   15a52:	4235      	tst	r5, r6
   15a54:	d004      	beq.n	15a60 <_tc_interrupt_handler+0x44>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_CC_CHANNEL0])(module);
   15a56:	6923      	ldr	r3, [r4, #16]
   15a58:	0020      	movs	r0, r4
   15a5a:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_MC(1);
   15a5c:	6823      	ldr	r3, [r4, #0]
   15a5e:	739e      	strb	r6, [r3, #14]
	}

	/* Check if an Match/Capture Channel 1 interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_MC(2)) {
   15a60:	2620      	movs	r6, #32
   15a62:	4235      	tst	r5, r6
   15a64:	d004      	beq.n	15a70 <_tc_interrupt_handler+0x54>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_CC_CHANNEL1])(module);
   15a66:	6963      	ldr	r3, [r4, #20]
   15a68:	0020      	movs	r0, r4
   15a6a:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_MC(2);
   15a6c:	6823      	ldr	r3, [r4, #0]
   15a6e:	739e      	strb	r6, [r3, #14]
	}
}
   15a70:	bd70      	pop	{r4, r5, r6, pc}
   15a72:	46c0      	nop			; (mov r8, r8)
   15a74:	2000446c 	.word	0x2000446c

00015a78 <TC3_Handler>:
	MRECURSION(TC_INST_NUM, _TC_INTERRUPT_HANDLER, TC_INST_MAX_ID)
   15a78:	b510      	push	{r4, lr}
   15a7a:	2000      	movs	r0, #0
   15a7c:	4b01      	ldr	r3, [pc, #4]	; (15a84 <TC3_Handler+0xc>)
   15a7e:	4798      	blx	r3
   15a80:	bd10      	pop	{r4, pc}
   15a82:	46c0      	nop			; (mov r8, r8)
   15a84:	00015a1d 	.word	0x00015a1d

00015a88 <TC4_Handler>:
   15a88:	b510      	push	{r4, lr}
   15a8a:	2001      	movs	r0, #1
   15a8c:	4b01      	ldr	r3, [pc, #4]	; (15a94 <TC4_Handler+0xc>)
   15a8e:	4798      	blx	r3
   15a90:	bd10      	pop	{r4, pc}
   15a92:	46c0      	nop			; (mov r8, r8)
   15a94:	00015a1d 	.word	0x00015a1d

00015a98 <TC5_Handler>:
   15a98:	b510      	push	{r4, lr}
   15a9a:	2002      	movs	r0, #2
   15a9c:	4b01      	ldr	r3, [pc, #4]	; (15aa4 <TC5_Handler+0xc>)
   15a9e:	4798      	blx	r3
   15aa0:	bd10      	pop	{r4, pc}
   15aa2:	46c0      	nop			; (mov r8, r8)
   15aa4:	00015a1d 	.word	0x00015a1d

00015aa8 <prvHelpCommand>:
	return pcReturn;
}
/*-----------------------------------------------------------*/

static BaseType_t prvHelpCommand( char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString )
{
   15aa8:	b570      	push	{r4, r5, r6, lr}
static const CLI_Definition_List_Item_t * pxCommand = NULL;
BaseType_t xReturn;

	( void ) pcCommandString;

	if( pxCommand == NULL )
   15aaa:	4c08      	ldr	r4, [pc, #32]	; (15acc <prvHelpCommand+0x24>)
{
   15aac:	000a      	movs	r2, r1
	if( pxCommand == NULL )
   15aae:	6823      	ldr	r3, [r4, #0]
   15ab0:	2b00      	cmp	r3, #0
   15ab2:	d101      	bne.n	15ab8 <prvHelpCommand+0x10>
	{
		/* Reset the pxCommand pointer back to the start of the list. */
		pxCommand = &xRegisteredCommands;
   15ab4:	4b06      	ldr	r3, [pc, #24]	; (15ad0 <prvHelpCommand+0x28>)
   15ab6:	6023      	str	r3, [r4, #0]
	}

	/* Return the next command help string, before moving the pointer on to
	the next command in the list. */
	strncpy( pcWriteBuffer, pxCommand->pxCommandLineDefinition->pcHelpString, xWriteBufferLen );
   15ab8:	6825      	ldr	r5, [r4, #0]
   15aba:	682b      	ldr	r3, [r5, #0]
   15abc:	6859      	ldr	r1, [r3, #4]
   15abe:	4b05      	ldr	r3, [pc, #20]	; (15ad4 <prvHelpCommand+0x2c>)
   15ac0:	4798      	blx	r3
	pxCommand = pxCommand->pxNext;
   15ac2:	6868      	ldr	r0, [r5, #4]
   15ac4:	6020      	str	r0, [r4, #0]

	if( pxCommand == NULL )
   15ac6:	1e43      	subs	r3, r0, #1
   15ac8:	4198      	sbcs	r0, r3
	{
		xReturn = pdTRUE;
	}

	return xReturn;
}
   15aca:	bd70      	pop	{r4, r5, r6, pc}
   15acc:	20000ba4 	.word	0x20000ba4
   15ad0:	200001e0 	.word	0x200001e0
   15ad4:	000238f3 	.word	0x000238f3

00015ad8 <FreeRTOS_CLIRegisterCommand>:
{
   15ad8:	b570      	push	{r4, r5, r6, lr}
   15ada:	1e05      	subs	r5, r0, #0
	configASSERT( pxCommandToRegister );
   15adc:	d101      	bne.n	15ae2 <FreeRTOS_CLIRegisterCommand+0xa>
   15ade:	b672      	cpsid	i
   15ae0:	e7fe      	b.n	15ae0 <FreeRTOS_CLIRegisterCommand+0x8>
	pxNewListItem = ( CLI_Definition_List_Item_t * ) pvPortMalloc( sizeof( CLI_Definition_List_Item_t ) );
   15ae2:	2008      	movs	r0, #8
   15ae4:	4b09      	ldr	r3, [pc, #36]	; (15b0c <FreeRTOS_CLIRegisterCommand+0x34>)
   15ae6:	4798      	blx	r3
   15ae8:	1e04      	subs	r4, r0, #0
	configASSERT( pxNewListItem );
   15aea:	d101      	bne.n	15af0 <FreeRTOS_CLIRegisterCommand+0x18>
   15aec:	b672      	cpsid	i
   15aee:	e7fe      	b.n	15aee <FreeRTOS_CLIRegisterCommand+0x16>
		taskENTER_CRITICAL();
   15af0:	4b07      	ldr	r3, [pc, #28]	; (15b10 <FreeRTOS_CLIRegisterCommand+0x38>)
   15af2:	4798      	blx	r3
			pxNewListItem->pxNext = NULL;
   15af4:	2300      	movs	r3, #0
   15af6:	6063      	str	r3, [r4, #4]
			pxLastCommandInList->pxNext = pxNewListItem;
   15af8:	4b06      	ldr	r3, [pc, #24]	; (15b14 <FreeRTOS_CLIRegisterCommand+0x3c>)
			pxNewListItem->pxCommandLineDefinition = pxCommandToRegister;
   15afa:	6025      	str	r5, [r4, #0]
			pxLastCommandInList->pxNext = pxNewListItem;
   15afc:	681a      	ldr	r2, [r3, #0]
			pxLastCommandInList = pxNewListItem;
   15afe:	601c      	str	r4, [r3, #0]
			pxLastCommandInList->pxNext = pxNewListItem;
   15b00:	6054      	str	r4, [r2, #4]
		taskEXIT_CRITICAL();
   15b02:	4b05      	ldr	r3, [pc, #20]	; (15b18 <FreeRTOS_CLIRegisterCommand+0x40>)
   15b04:	4798      	blx	r3
}
   15b06:	2001      	movs	r0, #1
   15b08:	bd70      	pop	{r4, r5, r6, pc}
   15b0a:	46c0      	nop			; (mov r8, r8)
   15b0c:	00016eb5 	.word	0x00016eb5
   15b10:	00016df1 	.word	0x00016df1
   15b14:	200001dc 	.word	0x200001dc
   15b18:	00016e09 	.word	0x00016e09

00015b1c <FreeRTOS_CLIProcessCommand>:
{
   15b1c:	b5f0      	push	{r4, r5, r6, r7, lr}
	if( pxCommand == NULL )
   15b1e:	4b32      	ldr	r3, [pc, #200]	; (15be8 <FreeRTOS_CLIProcessCommand+0xcc>)
{
   15b20:	b085      	sub	sp, #20
   15b22:	9202      	str	r2, [sp, #8]
	if( pxCommand == NULL )
   15b24:	681a      	ldr	r2, [r3, #0]
{
   15b26:	0006      	movs	r6, r0
   15b28:	9101      	str	r1, [sp, #4]
	if( pxCommand == NULL )
   15b2a:	2a00      	cmp	r2, #0
   15b2c:	d00f      	beq.n	15b4e <FreeRTOS_CLIProcessCommand+0x32>
BaseType_t xReturn = pdTRUE;
   15b2e:	2301      	movs	r3, #1
   15b30:	001c      	movs	r4, r3
	if( ( pxCommand != NULL ) && ( xReturn == pdFALSE ) )
   15b32:	4f2d      	ldr	r7, [pc, #180]	; (15be8 <FreeRTOS_CLIProcessCommand+0xcc>)
   15b34:	683d      	ldr	r5, [r7, #0]
   15b36:	2d00      	cmp	r5, #0
   15b38:	d04e      	beq.n	15bd8 <FreeRTOS_CLIProcessCommand+0xbc>
   15b3a:	2c00      	cmp	r4, #0
   15b3c:	d140      	bne.n	15bc0 <FreeRTOS_CLIProcessCommand+0xa4>
		strncpy( pcWriteBuffer, "Incorrect command parameter(s).  Enter \"help\" to view a list of available commands.\r\n\r\n", xWriteBufferLen );
   15b3e:	4b2b      	ldr	r3, [pc, #172]	; (15bec <FreeRTOS_CLIProcessCommand+0xd0>)
   15b40:	9a02      	ldr	r2, [sp, #8]
   15b42:	492b      	ldr	r1, [pc, #172]	; (15bf0 <FreeRTOS_CLIProcessCommand+0xd4>)
   15b44:	9801      	ldr	r0, [sp, #4]
   15b46:	4798      	blx	r3
		pxCommand = NULL;
   15b48:	0023      	movs	r3, r4
			pxCommand = NULL;
   15b4a:	603b      	str	r3, [r7, #0]
   15b4c:	e041      	b.n	15bd2 <FreeRTOS_CLIProcessCommand+0xb6>
		for( pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand = pxCommand->pxNext )
   15b4e:	4a29      	ldr	r2, [pc, #164]	; (15bf4 <FreeRTOS_CLIProcessCommand+0xd8>)
   15b50:	9303      	str	r3, [sp, #12]
   15b52:	601a      	str	r2, [r3, #0]
   15b54:	9b03      	ldr	r3, [sp, #12]
   15b56:	681c      	ldr	r4, [r3, #0]
   15b58:	2c00      	cmp	r4, #0
   15b5a:	d0e8      	beq.n	15b2e <FreeRTOS_CLIProcessCommand+0x12>
			pcRegisteredCommandString = pxCommand->pxCommandLineDefinition->pcCommand;
   15b5c:	6827      	ldr	r7, [r4, #0]
			xCommandStringLength = strlen( pcRegisteredCommandString );
   15b5e:	4b26      	ldr	r3, [pc, #152]	; (15bf8 <FreeRTOS_CLIProcessCommand+0xdc>)
			pcRegisteredCommandString = pxCommand->pxCommandLineDefinition->pcCommand;
   15b60:	683d      	ldr	r5, [r7, #0]
			xCommandStringLength = strlen( pcRegisteredCommandString );
   15b62:	0028      	movs	r0, r5
   15b64:	4798      	blx	r3
			if( ( pcCommandInput[ xCommandStringLength ] == ' ' ) || ( pcCommandInput[ xCommandStringLength ] == 0x00 ) )
   15b66:	2120      	movs	r1, #32
   15b68:	5c33      	ldrb	r3, [r6, r0]
			xCommandStringLength = strlen( pcRegisteredCommandString );
   15b6a:	0002      	movs	r2, r0
			if( ( pcCommandInput[ xCommandStringLength ] == ' ' ) || ( pcCommandInput[ xCommandStringLength ] == 0x00 ) )
   15b6c:	438b      	bics	r3, r1
   15b6e:	d123      	bne.n	15bb8 <FreeRTOS_CLIProcessCommand+0x9c>
				if( strncmp( pcCommandInput, pcRegisteredCommandString, xCommandStringLength ) == 0 )
   15b70:	0029      	movs	r1, r5
   15b72:	0030      	movs	r0, r6
   15b74:	4b21      	ldr	r3, [pc, #132]	; (15bfc <FreeRTOS_CLIProcessCommand+0xe0>)
   15b76:	4798      	blx	r3
   15b78:	2800      	cmp	r0, #0
   15b7a:	d11d      	bne.n	15bb8 <FreeRTOS_CLIProcessCommand+0x9c>
					if( pxCommand->pxCommandLineDefinition->cExpectedNumberOfParameters >= 0 )
   15b7c:	230c      	movs	r3, #12
   15b7e:	56fb      	ldrsb	r3, [r7, r3]
   15b80:	2b00      	cmp	r3, #0
   15b82:	dbd4      	blt.n	15b2e <FreeRTOS_CLIProcessCommand+0x12>
   15b84:	0032      	movs	r2, r6
   15b86:	0004      	movs	r4, r0
		if( ( *pcCommandString ) == ' ' )
		{
			if( xLastCharacterWasSpace != pdTRUE )
			{
				cParameters++;
				xLastCharacterWasSpace = pdTRUE;
   15b88:	2101      	movs	r1, #1
	while( *pcCommandString != 0x00 )
   15b8a:	7815      	ldrb	r5, [r2, #0]
   15b8c:	2d00      	cmp	r5, #0
   15b8e:	d108      	bne.n	15ba2 <FreeRTOS_CLIProcessCommand+0x86>
		pcCommandString++;
	}

	/* If the command string ended with spaces, then there will have been too
	many parameters counted. */
	if( xLastCharacterWasSpace == pdTRUE )
   15b90:	2801      	cmp	r0, #1
   15b92:	d101      	bne.n	15b98 <FreeRTOS_CLIProcessCommand+0x7c>
	{
		cParameters--;
   15b94:	3c01      	subs	r4, #1
   15b96:	b264      	sxtb	r4, r4
						if( prvGetNumberOfParameters( pcCommandInput ) != pxCommand->pxCommandLineDefinition->cExpectedNumberOfParameters )
   15b98:	1b1c      	subs	r4, r3, r4
BaseType_t xReturn = pdTRUE;
   15b9a:	4262      	negs	r2, r4
   15b9c:	4162      	adcs	r2, r4
   15b9e:	0014      	movs	r4, r2
   15ba0:	e7c7      	b.n	15b32 <FreeRTOS_CLIProcessCommand+0x16>
		if( ( *pcCommandString ) == ' ' )
   15ba2:	2d20      	cmp	r5, #32
   15ba4:	d106      	bne.n	15bb4 <FreeRTOS_CLIProcessCommand+0x98>
			if( xLastCharacterWasSpace != pdTRUE )
   15ba6:	2801      	cmp	r0, #1
   15ba8:	d002      	beq.n	15bb0 <FreeRTOS_CLIProcessCommand+0x94>
				xLastCharacterWasSpace = pdTRUE;
   15baa:	0008      	movs	r0, r1
				cParameters++;
   15bac:	3401      	adds	r4, #1
   15bae:	b264      	sxtb	r4, r4
		pcCommandString++;
   15bb0:	3201      	adds	r2, #1
   15bb2:	e7ea      	b.n	15b8a <FreeRTOS_CLIProcessCommand+0x6e>
			xLastCharacterWasSpace = pdFALSE;
   15bb4:	2000      	movs	r0, #0
   15bb6:	e7fb      	b.n	15bb0 <FreeRTOS_CLIProcessCommand+0x94>
		for( pxCommand = &xRegisteredCommands; pxCommand != NULL; pxCommand = pxCommand->pxNext )
   15bb8:	6862      	ldr	r2, [r4, #4]
   15bba:	4b0b      	ldr	r3, [pc, #44]	; (15be8 <FreeRTOS_CLIProcessCommand+0xcc>)
   15bbc:	601a      	str	r2, [r3, #0]
   15bbe:	e7c9      	b.n	15b54 <FreeRTOS_CLIProcessCommand+0x38>
		xReturn = pxCommand->pxCommandLineDefinition->pxCommandInterpreter( pcWriteBuffer, xWriteBufferLen, pcCommandInput );
   15bc0:	682b      	ldr	r3, [r5, #0]
   15bc2:	0032      	movs	r2, r6
   15bc4:	689b      	ldr	r3, [r3, #8]
   15bc6:	9902      	ldr	r1, [sp, #8]
   15bc8:	9801      	ldr	r0, [sp, #4]
   15bca:	4798      	blx	r3
   15bcc:	0004      	movs	r4, r0
		if( xReturn == pdFALSE )
   15bce:	1e03      	subs	r3, r0, #0
   15bd0:	d0bb      	beq.n	15b4a <FreeRTOS_CLIProcessCommand+0x2e>
}
   15bd2:	0020      	movs	r0, r4
   15bd4:	b005      	add	sp, #20
   15bd6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		strncpy( pcWriteBuffer, "Command not recognised.  Enter 'help' to view a list of available commands.\r\n\r\n", xWriteBufferLen );
   15bd8:	9a02      	ldr	r2, [sp, #8]
   15bda:	4909      	ldr	r1, [pc, #36]	; (15c00 <FreeRTOS_CLIProcessCommand+0xe4>)
   15bdc:	9801      	ldr	r0, [sp, #4]
   15bde:	4b03      	ldr	r3, [pc, #12]	; (15bec <FreeRTOS_CLIProcessCommand+0xd0>)
   15be0:	4798      	blx	r3
		xReturn = pdFALSE;
   15be2:	002c      	movs	r4, r5
	return xReturn;
   15be4:	e7f5      	b.n	15bd2 <FreeRTOS_CLIProcessCommand+0xb6>
   15be6:	46c0      	nop			; (mov r8, r8)
   15be8:	20000ba0 	.word	0x20000ba0
   15bec:	000238f3 	.word	0x000238f3
   15bf0:	00029225 	.word	0x00029225
   15bf4:	200001e0 	.word	0x200001e0
   15bf8:	000238c3 	.word	0x000238c3
   15bfc:	000238d1 	.word	0x000238d1
   15c00:	0002927d 	.word	0x0002927d

00015c04 <prvTraceGetQueueType>:
	return (uint32_t)uxQueueGetQueueNumber(handle);
}
#endif /* (TRC_CFG_FREERTOS_VERSION < TRC_FREERTOS_VERSION_8_X) */

uint8_t prvTraceGetQueueType(void* handle)
{
   15c04:	b510      	push	{r4, lr}
	// This is either declared in header file in FreeRTOS 8 and later, or as extern above
	return ucQueueGetQueueType(handle);
   15c06:	4b01      	ldr	r3, [pc, #4]	; (15c0c <prvTraceGetQueueType+0x8>)
   15c08:	4798      	blx	r3
}
   15c0a:	bd10      	pop	{r4, pc}
   15c0c:	00017ec1 	.word	0x00017ec1

00015c10 <prvTraceGetTaskNumberLow16>:

/* Tasks */
uint16_t prvTraceGetTaskNumberLow16(void* handle)
{
   15c10:	b510      	push	{r4, lr}
	return TRACE_GET_LOW16(uxTaskGetTaskNumber(handle));
   15c12:	4b02      	ldr	r3, [pc, #8]	; (15c1c <prvTraceGetTaskNumberLow16+0xc>)
   15c14:	4798      	blx	r3
   15c16:	b280      	uxth	r0, r0
}
   15c18:	bd10      	pop	{r4, pc}
   15c1a:	46c0      	nop			; (mov r8, r8)
   15c1c:	00018a3d 	.word	0x00018a3d

00015c20 <prvTraceGetTaskNumberHigh16>:

uint16_t prvTraceGetTaskNumberHigh16(void* handle)
{
   15c20:	b510      	push	{r4, lr}
	return TRACE_GET_HIGH16(uxTaskGetTaskNumber(handle));
   15c22:	4b02      	ldr	r3, [pc, #8]	; (15c2c <prvTraceGetTaskNumberHigh16+0xc>)
   15c24:	4798      	blx	r3
   15c26:	0c00      	lsrs	r0, r0, #16
}
   15c28:	bd10      	pop	{r4, pc}
   15c2a:	46c0      	nop			; (mov r8, r8)
   15c2c:	00018a3d 	.word	0x00018a3d

00015c30 <prvTraceSetTaskNumberLow16>:

void prvTraceSetTaskNumberLow16(void* handle, uint16_t value)
{
   15c30:	b570      	push	{r4, r5, r6, lr}
	vTaskSetTaskNumber(handle, TRACE_SET_LOW16(uxTaskGetTaskNumber(handle), value));
   15c32:	4b05      	ldr	r3, [pc, #20]	; (15c48 <prvTraceSetTaskNumberLow16+0x18>)
{
   15c34:	000d      	movs	r5, r1
   15c36:	0004      	movs	r4, r0
	vTaskSetTaskNumber(handle, TRACE_SET_LOW16(uxTaskGetTaskNumber(handle), value));
   15c38:	4798      	blx	r3
   15c3a:	0c01      	lsrs	r1, r0, #16
   15c3c:	0409      	lsls	r1, r1, #16
   15c3e:	4329      	orrs	r1, r5
   15c40:	0020      	movs	r0, r4
   15c42:	4b02      	ldr	r3, [pc, #8]	; (15c4c <prvTraceSetTaskNumberLow16+0x1c>)
   15c44:	4798      	blx	r3
}
   15c46:	bd70      	pop	{r4, r5, r6, pc}
   15c48:	00018a3d 	.word	0x00018a3d
   15c4c:	00018a45 	.word	0x00018a45

00015c50 <prvTraceSetTaskNumberHigh16>:

void prvTraceSetTaskNumberHigh16(void* handle, uint16_t value)
{
   15c50:	b570      	push	{r4, r5, r6, lr}
	vTaskSetTaskNumber(handle, TRACE_SET_HIGH16(uxTaskGetTaskNumber(handle), value));
   15c52:	4b05      	ldr	r3, [pc, #20]	; (15c68 <prvTraceSetTaskNumberHigh16+0x18>)
{
   15c54:	0004      	movs	r4, r0
   15c56:	000d      	movs	r5, r1
	vTaskSetTaskNumber(handle, TRACE_SET_HIGH16(uxTaskGetTaskNumber(handle), value));
   15c58:	4798      	blx	r3
   15c5a:	042d      	lsls	r5, r5, #16
   15c5c:	b281      	uxth	r1, r0
   15c5e:	4329      	orrs	r1, r5
   15c60:	0020      	movs	r0, r4
   15c62:	4b02      	ldr	r3, [pc, #8]	; (15c6c <prvTraceSetTaskNumberHigh16+0x1c>)
   15c64:	4798      	blx	r3
}
   15c66:	bd70      	pop	{r4, r5, r6, pc}
   15c68:	00018a3d 	.word	0x00018a3d
   15c6c:	00018a45 	.word	0x00018a45

00015c70 <prvTraceGetQueueNumberLow16>:

uint16_t prvTraceGetQueueNumberLow16(void* handle)
{
   15c70:	b510      	push	{r4, lr}
	return (uint32_t)uxQueueGetQueueNumber(handle);
   15c72:	4b02      	ldr	r3, [pc, #8]	; (15c7c <prvTraceGetQueueNumberLow16+0xc>)
   15c74:	4798      	blx	r3
	return TRACE_GET_LOW16(prvTraceGetQueueNumber(handle));
   15c76:	b280      	uxth	r0, r0
}
   15c78:	bd10      	pop	{r4, pc}
   15c7a:	46c0      	nop			; (mov r8, r8)
   15c7c:	00017eb9 	.word	0x00017eb9

00015c80 <prvTraceGetQueueNumberHigh16>:

uint16_t prvTraceGetQueueNumberHigh16(void* handle)
{
   15c80:	b510      	push	{r4, lr}
	return (uint32_t)uxQueueGetQueueNumber(handle);
   15c82:	4b02      	ldr	r3, [pc, #8]	; (15c8c <prvTraceGetQueueNumberHigh16+0xc>)
   15c84:	4798      	blx	r3
	return TRACE_GET_HIGH16(prvTraceGetQueueNumber(handle));
   15c86:	0c00      	lsrs	r0, r0, #16
}
   15c88:	bd10      	pop	{r4, pc}
   15c8a:	46c0      	nop			; (mov r8, r8)
   15c8c:	00017eb9 	.word	0x00017eb9

00015c90 <prvTraceSetQueueNumberLow16>:

void prvTraceSetQueueNumberLow16(void* handle, uint16_t value)
{
   15c90:	b570      	push	{r4, r5, r6, lr}
	return (uint32_t)uxQueueGetQueueNumber(handle);
   15c92:	4b05      	ldr	r3, [pc, #20]	; (15ca8 <prvTraceSetQueueNumberLow16+0x18>)
{
   15c94:	000d      	movs	r5, r1
   15c96:	0004      	movs	r4, r0
	return (uint32_t)uxQueueGetQueueNumber(handle);
   15c98:	4798      	blx	r3
	vQueueSetQueueNumber(handle, TRACE_SET_LOW16(prvTraceGetQueueNumber(handle), value));
   15c9a:	0c01      	lsrs	r1, r0, #16
   15c9c:	0409      	lsls	r1, r1, #16
   15c9e:	4329      	orrs	r1, r5
   15ca0:	0020      	movs	r0, r4
   15ca2:	4b02      	ldr	r3, [pc, #8]	; (15cac <prvTraceSetQueueNumberLow16+0x1c>)
   15ca4:	4798      	blx	r3
}
   15ca6:	bd70      	pop	{r4, r5, r6, pc}
   15ca8:	00017eb9 	.word	0x00017eb9
   15cac:	00017ebd 	.word	0x00017ebd

00015cb0 <prvTraceSetQueueNumberHigh16>:

void prvTraceSetQueueNumberHigh16(void* handle, uint16_t value)
{
   15cb0:	b570      	push	{r4, r5, r6, lr}
	return (uint32_t)uxQueueGetQueueNumber(handle);
   15cb2:	4b05      	ldr	r3, [pc, #20]	; (15cc8 <prvTraceSetQueueNumberHigh16+0x18>)
{
   15cb4:	0004      	movs	r4, r0
   15cb6:	000d      	movs	r5, r1
	return (uint32_t)uxQueueGetQueueNumber(handle);
   15cb8:	4798      	blx	r3
	vQueueSetQueueNumber(handle, TRACE_SET_HIGH16(prvTraceGetQueueNumber(handle), value));
   15cba:	042d      	lsls	r5, r5, #16
   15cbc:	b281      	uxth	r1, r0
   15cbe:	4329      	orrs	r1, r5
   15cc0:	0020      	movs	r0, r4
   15cc2:	4b02      	ldr	r3, [pc, #8]	; (15ccc <prvTraceSetQueueNumberHigh16+0x1c>)
   15cc4:	4798      	blx	r3
}
   15cc6:	bd70      	pop	{r4, r5, r6, pc}
   15cc8:	00017eb9 	.word	0x00017eb9
   15ccc:	00017ebd 	.word	0x00017ebd

00015cd0 <prvAddTaskToStackMonitor>:
void prvAddTaskToStackMonitor(void* task)
{
	int foundEmptySlot = 0;

	// find an empty slot
	for (int i = 0; i < TRC_CFG_STACK_MONITOR_MAX_TASKS; i++)
   15cd0:	2200      	movs	r2, #0
{
   15cd2:	b510      	push	{r4, lr}
	{
		if (tasksInStackMonitor[i].tcb == NULL)
   15cd4:	4b09      	ldr	r3, [pc, #36]	; (15cfc <prvAddTaskToStackMonitor+0x2c>)
   15cd6:	00d1      	lsls	r1, r2, #3
   15cd8:	58cc      	ldr	r4, [r1, r3]
   15cda:	2c00      	cmp	r4, #0
   15cdc:	d105      	bne.n	15cea <prvAddTaskToStackMonitor+0x1a>
		{
			tasksInStackMonitor[i].tcb = task;
			tasksInStackMonitor[i].uiPreviousLowMark = 0xFFFFFFFF;
   15cde:	2201      	movs	r2, #1
			tasksInStackMonitor[i].tcb = task;
   15ce0:	50c8      	str	r0, [r1, r3]
			tasksInStackMonitor[i].uiPreviousLowMark = 0xFFFFFFFF;
   15ce2:	4252      	negs	r2, r2
   15ce4:	185b      	adds	r3, r3, r1
   15ce6:	605a      	str	r2, [r3, #4]

	if (foundEmptySlot == 0)
	{
		tasksNotIncluded++;
	}
}
   15ce8:	bd10      	pop	{r4, pc}
	for (int i = 0; i < TRC_CFG_STACK_MONITOR_MAX_TASKS; i++)
   15cea:	3201      	adds	r2, #1
   15cec:	2a0a      	cmp	r2, #10
   15cee:	d1f2      	bne.n	15cd6 <prvAddTaskToStackMonitor+0x6>
		tasksNotIncluded++;
   15cf0:	4a03      	ldr	r2, [pc, #12]	; (15d00 <prvAddTaskToStackMonitor+0x30>)
   15cf2:	6813      	ldr	r3, [r2, #0]
   15cf4:	3301      	adds	r3, #1
   15cf6:	6013      	str	r3, [r2, #0]
   15cf8:	e7f6      	b.n	15ce8 <prvAddTaskToStackMonitor+0x18>
   15cfa:	46c0      	nop			; (mov r8, r8)
   15cfc:	20000bb0 	.word	0x20000bb0
   15d00:	20000c00 	.word	0x20000c00

00015d04 <prvReportStackUsage>:
		}
	}
}

void prvReportStackUsage()
{
   15d04:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
			prvTraceStoreKernelCallWithParam(TRACE_UNUSED_STACK, TRACE_CLASS_TASK, TRACE_GET_TASK_NUMBER(tasksInStackMonitor[i].tcb), tasksInStackMonitor[i].uiPreviousLowMark);
#else /* TRC_CFG_RECORDER_MODE == TRC_RECORDER_MODE_SNAPSHOT */
			prvTraceStoreEvent2(PSF_EVENT_UNUSED_STACK, (uint32_t)tasksInStackMonitor[i].tcb, tasksInStackMonitor[i].uiPreviousLowMark);
#endif /* TRC_CFG_RECORDER_MODE == TRC_RECORDER_MODE_SNAPSHOT */

			count++;
   15d06:	2701      	movs	r7, #1
	int initial = i;	/* Used to make sure we break if we are back at the inital value */
   15d08:	4c15      	ldr	r4, [pc, #84]	; (15d60 <prvReportStackUsage+0x5c>)
   15d0a:	6823      	ldr	r3, [r4, #0]
   15d0c:	9301      	str	r3, [sp, #4]
		if (tasksInStackMonitor[i].tcb != NULL)
   15d0e:	6823      	ldr	r3, [r4, #0]
   15d10:	4d14      	ldr	r5, [pc, #80]	; (15d64 <prvReportStackUsage+0x60>)
   15d12:	00db      	lsls	r3, r3, #3
   15d14:	5958      	ldr	r0, [r3, r5]
   15d16:	1e06      	subs	r6, r0, #0
   15d18:	d016      	beq.n	15d48 <prvReportStackUsage+0x44>
			uint32_t unusedStackSpace = uxTaskGetStackHighWaterMark((TaskType)tasksInStackMonitor[i].tcb);
   15d1a:	4b13      	ldr	r3, [pc, #76]	; (15d68 <prvReportStackUsage+0x64>)
   15d1c:	4798      	blx	r3
			if (tasksInStackMonitor[i].uiPreviousLowMark > unusedStackSpace)
   15d1e:	6823      	ldr	r3, [r4, #0]
   15d20:	00db      	lsls	r3, r3, #3
   15d22:	18ea      	adds	r2, r5, r3
   15d24:	6851      	ldr	r1, [r2, #4]
   15d26:	4288      	cmp	r0, r1
   15d28:	d200      	bcs.n	15d2c <prvReportStackUsage+0x28>
				tasksInStackMonitor[i].uiPreviousLowMark = unusedStackSpace;
   15d2a:	6050      	str	r0, [r2, #4]
	return TRACE_GET_LOW16(uxTaskGetTaskNumber(handle));
   15d2c:	58e8      	ldr	r0, [r5, r3]
   15d2e:	4b0f      	ldr	r3, [pc, #60]	; (15d6c <prvReportStackUsage+0x68>)
   15d30:	4798      	blx	r3
			prvTraceStoreKernelCallWithParam(TRACE_UNUSED_STACK, TRACE_CLASS_TASK, TRACE_GET_TASK_NUMBER(tasksInStackMonitor[i].tcb), tasksInStackMonitor[i].uiPreviousLowMark);
   15d32:	22ff      	movs	r2, #255	; 0xff
   15d34:	6823      	ldr	r3, [r4, #0]
   15d36:	4002      	ands	r2, r0
   15d38:	00db      	lsls	r3, r3, #3
   15d3a:	18ed      	adds	r5, r5, r3
   15d3c:	686b      	ldr	r3, [r5, #4]
   15d3e:	2103      	movs	r1, #3
   15d40:	20ea      	movs	r0, #234	; 0xea
   15d42:	4d0b      	ldr	r5, [pc, #44]	; (15d70 <prvReportStackUsage+0x6c>)
   15d44:	47a8      	blx	r5
			count++;
   15d46:	003e      	movs	r6, r7
		}

		i = (i + 1) % TRC_CFG_STACK_MONITOR_MAX_TASKS; // Move i beyond this task
   15d48:	6823      	ldr	r3, [r4, #0]
   15d4a:	210a      	movs	r1, #10
   15d4c:	1c58      	adds	r0, r3, #1
   15d4e:	4b09      	ldr	r3, [pc, #36]	; (15d74 <prvReportStackUsage+0x70>)
   15d50:	4798      	blx	r3
   15d52:	6021      	str	r1, [r4, #0]
	} while (count < TRC_CFG_STACK_MONITOR_MAX_REPORTS && i != initial);
   15d54:	2e00      	cmp	r6, #0
   15d56:	d102      	bne.n	15d5e <prvReportStackUsage+0x5a>
   15d58:	9b01      	ldr	r3, [sp, #4]
   15d5a:	428b      	cmp	r3, r1
   15d5c:	d1d7      	bne.n	15d0e <prvReportStackUsage+0xa>
}
   15d5e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   15d60:	20000bac 	.word	0x20000bac
   15d64:	20000bb0 	.word	0x20000bb0
   15d68:	00018a4d 	.word	0x00018a4d
   15d6c:	00018a3d 	.word	0x00018a3d
   15d70:	00016965 	.word	0x00016965
   15d74:	00025b9d 	.word	0x00025b9d

00015d78 <TzCtrl>:
* interface (assuming TRC_STREAM_PORT_USE_INTERNAL_BUFFER == 1) and for
* receiving commands from Tracealyzer. Also does some diagnostics.
******************************************************************************/
#if defined(TRC_CFG_ENABLE_STACK_MONITOR) && (TRC_CFG_ENABLE_STACK_MONITOR == 1) && (TRC_CFG_SCHEDULING_ONLY == 0)
static portTASK_FUNCTION(TzCtrl, pvParameters)
{
   15d78:	b510      	push	{r4, lr}
	(void)pvParameters;

	while (1)
	{
		if (xTraceIsRecordingEnabled())
   15d7a:	4b05      	ldr	r3, [pc, #20]	; (15d90 <TzCtrl+0x18>)
   15d7c:	4798      	blx	r3
   15d7e:	2800      	cmp	r0, #0
   15d80:	d001      	beq.n	15d86 <TzCtrl+0xe>
		{
			prvReportStackUsage();
   15d82:	4b04      	ldr	r3, [pc, #16]	; (15d94 <TzCtrl+0x1c>)
   15d84:	4798      	blx	r3
		}

		vTaskDelay(TRC_CFG_CTRL_TASK_DELAY);
   15d86:	2004      	movs	r0, #4
   15d88:	4b03      	ldr	r3, [pc, #12]	; (15d98 <TzCtrl+0x20>)
   15d8a:	4798      	blx	r3
		if (xTraceIsRecordingEnabled())
   15d8c:	e7f5      	b.n	15d7a <TzCtrl+0x2>
   15d8e:	46c0      	nop			; (mov r8, r8)
   15d90:	00015f69 	.word	0x00015f69
   15d94:	00015d05 	.word	0x00015d05
   15d98:	000185ad 	.word	0x000185ad

00015d9c <prvTraceGetCurrentTaskHandle>:
{
   15d9c:	b510      	push	{r4, lr}
	return xTaskGetCurrentTaskHandle();
   15d9e:	4b01      	ldr	r3, [pc, #4]	; (15da4 <prvTraceGetCurrentTaskHandle+0x8>)
   15da0:	4798      	blx	r3
}
   15da2:	bd10      	pop	{r4, pc}
   15da4:	00018a71 	.word	0x00018a71

00015da8 <vTraceEnable>:
{
   15da8:	b513      	push	{r0, r1, r4, lr}
	prvTraceInitTraceData();
   15daa:	4b0e      	ldr	r3, [pc, #56]	; (15de4 <vTraceEnable+0x3c>)
{
   15dac:	0004      	movs	r4, r0
	prvTraceInitTraceData();
   15dae:	4798      	blx	r3
	if (startOption == TRC_START)
   15db0:	2c01      	cmp	r4, #1
   15db2:	d10e      	bne.n	15dd2 <vTraceEnable+0x2a>
		vTraceStart();
   15db4:	4b0c      	ldr	r3, [pc, #48]	; (15de8 <vTraceEnable+0x40>)
   15db6:	4798      	blx	r3
	if (HandleTzCtrl == NULL)
   15db8:	4a0c      	ldr	r2, [pc, #48]	; (15dec <vTraceEnable+0x44>)
   15dba:	6813      	ldr	r3, [r2, #0]
   15dbc:	2b00      	cmp	r3, #0
   15dbe:	d107      	bne.n	15dd0 <vTraceEnable+0x28>
		xTaskCreate(TzCtrl, STRING_CAST("TzCtrl"), TRC_CFG_CTRL_TASK_STACK_SIZE, NULL, TRC_CFG_CTRL_TASK_PRIORITY, &HandleTzCtrl);
   15dc0:	9201      	str	r2, [sp, #4]
   15dc2:	2204      	movs	r2, #4
   15dc4:	490a      	ldr	r1, [pc, #40]	; (15df0 <vTraceEnable+0x48>)
   15dc6:	9200      	str	r2, [sp, #0]
   15dc8:	480a      	ldr	r0, [pc, #40]	; (15df4 <vTraceEnable+0x4c>)
   15dca:	32c4      	adds	r2, #196	; 0xc4
   15dcc:	4c0a      	ldr	r4, [pc, #40]	; (15df8 <vTraceEnable+0x50>)
   15dce:	47a0      	blx	r4
}
   15dd0:	bd13      	pop	{r0, r1, r4, pc}
		prvTraceError("vTraceEnable(TRC_START_AWAIT_HOST) not allowed in Snapshot mode");
   15dd2:	480a      	ldr	r0, [pc, #40]	; (15dfc <vTraceEnable+0x54>)
	else if (startOption == TRC_START_AWAIT_HOST)
   15dd4:	2c02      	cmp	r4, #2
   15dd6:	d002      	beq.n	15dde <vTraceEnable+0x36>
	else if (startOption != TRC_INIT)
   15dd8:	2c00      	cmp	r4, #0
   15dda:	d0ed      	beq.n	15db8 <vTraceEnable+0x10>
		prvTraceError("Unexpected argument to vTraceEnable (snapshot mode)");
   15ddc:	4808      	ldr	r0, [pc, #32]	; (15e00 <vTraceEnable+0x58>)
   15dde:	4b09      	ldr	r3, [pc, #36]	; (15e04 <vTraceEnable+0x5c>)
   15de0:	4798      	blx	r3
   15de2:	e7e9      	b.n	15db8 <vTraceEnable+0x10>
   15de4:	00015f79 	.word	0x00015f79
   15de8:	00016c59 	.word	0x00016c59
   15dec:	20000ba8 	.word	0x20000ba8
   15df0:	0002969e 	.word	0x0002969e
   15df4:	00015d79 	.word	0x00015d79
   15df8:	00018031 	.word	0x00018031
   15dfc:	0002962a 	.word	0x0002962a
   15e00:	0002966a 	.word	0x0002966a
   15e04:	00016121 	.word	0x00016121

00015e08 <vTraceInitObjectPropertyTable>:
}
#endif

/* Initialization of the object property table */
void vTraceInitObjectPropertyTable()
{
   15e08:	b510      	push	{r4, lr}
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectClasses = TRACE_NCLASSES;
   15e0a:	4b23      	ldr	r3, [pc, #140]	; (15e98 <vTraceInitObjectPropertyTable+0x90>)
   15e0c:	2209      	movs	r2, #9
   15e0e:	681b      	ldr	r3, [r3, #0]
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[8] = TRC_CFG_NAME_LEN_MESSAGEBUFFER;
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[0] = PropertyTableSizeQueue;
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[1] = PropertyTableSizeSemaphore;
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[2] = PropertyTableSizeMutex;
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[3] = PropertyTableSizeTask;
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[4] = PropertyTableSizeISR;
   15e10:	2411      	movs	r4, #17
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[0] = TRC_CFG_NQUEUE;
   15e12:	0019      	movs	r1, r3
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectClasses = TRACE_NCLASSES;
   15e14:	65da      	str	r2, [r3, #92]	; 0x5c
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[0] = TRC_CFG_NQUEUE;
   15e16:	3164      	adds	r1, #100	; 0x64
   15e18:	3201      	adds	r2, #1
   15e1a:	700a      	strb	r2, [r1, #0]
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[1] = TRC_CFG_NSEMAPHORE;
   15e1c:	704a      	strb	r2, [r1, #1]
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[2] = TRC_CFG_NMUTEX;
   15e1e:	708a      	strb	r2, [r1, #2]
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[4] = TRC_CFG_NISR;
   15e20:	0018      	movs	r0, r3
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[3] = TRC_CFG_NTASK;
   15e22:	3205      	adds	r2, #5
   15e24:	70ca      	strb	r2, [r1, #3]
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[4] = TRC_CFG_NISR;
   15e26:	2105      	movs	r1, #5
   15e28:	3068      	adds	r0, #104	; 0x68
   15e2a:	7001      	strb	r1, [r0, #0]
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[5] = TRC_CFG_NTIMER;
   15e2c:	7041      	strb	r1, [r0, #1]
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[6] = TRC_CFG_NEVENTGROUP;
   15e2e:	7081      	strb	r1, [r0, #2]
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[7] = TRC_CFG_NSTREAMBUFFER;
   15e30:	70c1      	strb	r1, [r0, #3]
	RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[8] = TRC_CFG_NMESSAGEBUFFER;
   15e32:	7101      	strb	r1, [r0, #4]
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[0] = TRC_CFG_NAME_LEN_QUEUE;
   15e34:	0019      	movs	r1, r3
   15e36:	3170      	adds	r1, #112	; 0x70
   15e38:	700a      	strb	r2, [r1, #0]
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[1] = TRC_CFG_NAME_LEN_SEMAPHORE;
   15e3a:	704a      	strb	r2, [r1, #1]
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[2] = TRC_CFG_NAME_LEN_MUTEX;
   15e3c:	708a      	strb	r2, [r1, #2]
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[3] = TRC_CFG_NAME_LEN_TASK;
   15e3e:	70ca      	strb	r2, [r1, #3]
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[4] = TRC_CFG_NAME_LEN_ISR;
   15e40:	710a      	strb	r2, [r1, #4]
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[5] = TRC_CFG_NAME_LEN_TIMER;
   15e42:	714a      	strb	r2, [r1, #5]
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[6] = TRC_CFG_NAME_LEN_EVENTGROUP;
   15e44:	718a      	strb	r2, [r1, #6]
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[7] = TRC_CFG_NAME_LEN_STREAMBUFFER;
   15e46:	71ca      	strb	r2, [r1, #7]
	RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[8] = TRC_CFG_NAME_LEN_MESSAGEBUFFER;
   15e48:	720a      	strb	r2, [r1, #8]
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[0] = PropertyTableSizeQueue;
   15e4a:	001a      	movs	r2, r3
   15e4c:	2110      	movs	r1, #16
   15e4e:	327c      	adds	r2, #124	; 0x7c
   15e50:	7011      	strb	r1, [r2, #0]
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[1] = PropertyTableSizeSemaphore;
   15e52:	7051      	strb	r1, [r2, #1]
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[2] = PropertyTableSizeMutex;
   15e54:	7091      	strb	r1, [r2, #2]
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[5] = PropertyTableSizeTimer;
   15e56:	7641      	strb	r1, [r0, #25]
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[6] = PropertyTableSizeEventGroup;
   15e58:	0019      	movs	r1, r3
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[3] = PropertyTableSizeTask;
   15e5a:	2213      	movs	r2, #19
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[6] = PropertyTableSizeEventGroup;
   15e5c:	3182      	adds	r1, #130	; 0x82
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[3] = PropertyTableSizeTask;
   15e5e:	75c2      	strb	r2, [r0, #23]
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[4] = PropertyTableSizeISR;
   15e60:	7604      	strb	r4, [r0, #24]
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[6] = PropertyTableSizeEventGroup;
   15e62:	700a      	strb	r2, [r1, #0]
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[7] = PropertyTableSizeStreamBuffer;
   15e64:	704a      	strb	r2, [r1, #1]
	RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[8] = PropertyTableSizeMessageBuffer;
   15e66:	708a      	strb	r2, [r1, #2]
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[0] = StartIndexQueue;
   15e68:	001a      	movs	r2, r3
   15e6a:	2100      	movs	r1, #0
   15e6c:	3288      	adds	r2, #136	; 0x88
   15e6e:	8011      	strh	r1, [r2, #0]
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[1] = StartIndexSemaphore;
   15e70:	31a0      	adds	r1, #160	; 0xa0
   15e72:	8051      	strh	r1, [r2, #2]
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[2] = StartIndexMutex;
   15e74:	31a0      	adds	r1, #160	; 0xa0
   15e76:	8091      	strh	r1, [r2, #4]
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[3] = StartIndexTask;
   15e78:	31a0      	adds	r1, #160	; 0xa0
   15e7a:	80d1      	strh	r1, [r2, #6]
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[4] = StartIndexISR;
   15e7c:	4907      	ldr	r1, [pc, #28]	; (15e9c <vTraceInitObjectPropertyTable+0x94>)
   15e7e:	8111      	strh	r1, [r2, #8]
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[5] = StartIndexTimer;
   15e80:	4907      	ldr	r1, [pc, #28]	; (15ea0 <vTraceInitObjectPropertyTable+0x98>)
   15e82:	8151      	strh	r1, [r2, #10]
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[6] = StartIndexEventGroup;
   15e84:	4907      	ldr	r1, [pc, #28]	; (15ea4 <vTraceInitObjectPropertyTable+0x9c>)
   15e86:	8191      	strh	r1, [r2, #12]
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[7] = StartIndexStreamBuffer;
   15e88:	4907      	ldr	r1, [pc, #28]	; (15ea8 <vTraceInitObjectPropertyTable+0xa0>)
   15e8a:	81d1      	strh	r1, [r2, #14]
	RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[8] = StartIndexMessageBuffer;
   15e8c:	315f      	adds	r1, #95	; 0x5f
   15e8e:	8211      	strh	r1, [r2, #16]
	RecorderDataPtr->ObjectPropertyTable.ObjectPropertyTableSizeInBytes = TRACE_OBJECT_TABLE_SIZE;
   15e90:	4a06      	ldr	r2, [pc, #24]	; (15eac <vTraceInitObjectPropertyTable+0xa4>)
   15e92:	661a      	str	r2, [r3, #96]	; 0x60
}
   15e94:	bd10      	pop	{r4, pc}
   15e96:	46c0      	nop			; (mov r8, r8)
   15e98:	20000c04 	.word	0x20000c04
   15e9c:	000002fd 	.word	0x000002fd
   15ea0:	00000352 	.word	0x00000352
   15ea4:	000003a2 	.word	0x000003a2
   15ea8:	00000401 	.word	0x00000401
   15eac:	000004bf 	.word	0x000004bf

00015eb0 <vTraceInitObjectHandleStack>:

/* Initialization of the handle mechanism, see e.g, prvTraceGetObjectHandle */
void vTraceInitObjectHandleStack()
{
	objectHandleStacks.indexOfNextAvailableHandle[0] = objectHandleStacks.lowestIndexOfClass[0] = 0;
   15eb0:	2200      	movs	r2, #0
   15eb2:	4b17      	ldr	r3, [pc, #92]	; (15f10 <vTraceInitObjectHandleStack+0x60>)
   15eb4:	825a      	strh	r2, [r3, #18]
   15eb6:	801a      	strh	r2, [r3, #0]
	objectHandleStacks.indexOfNextAvailableHandle[1] = objectHandleStacks.lowestIndexOfClass[1] = (TRC_CFG_NQUEUE);
   15eb8:	320a      	adds	r2, #10
   15eba:	829a      	strh	r2, [r3, #20]
   15ebc:	805a      	strh	r2, [r3, #2]
	objectHandleStacks.indexOfNextAvailableHandle[2] = objectHandleStacks.lowestIndexOfClass[2] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE);
   15ebe:	320a      	adds	r2, #10
   15ec0:	82da      	strh	r2, [r3, #22]
   15ec2:	809a      	strh	r2, [r3, #4]
	objectHandleStacks.indexOfNextAvailableHandle[3] = objectHandleStacks.lowestIndexOfClass[3] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX);
   15ec4:	320a      	adds	r2, #10
   15ec6:	831a      	strh	r2, [r3, #24]
   15ec8:	80da      	strh	r2, [r3, #6]
	objectHandleStacks.indexOfNextAvailableHandle[4] = objectHandleStacks.lowestIndexOfClass[4] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK);
   15eca:	320f      	adds	r2, #15
   15ecc:	835a      	strh	r2, [r3, #26]
   15ece:	811a      	strh	r2, [r3, #8]
	objectHandleStacks.indexOfNextAvailableHandle[5] = objectHandleStacks.lowestIndexOfClass[5] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK) + (TRC_CFG_NISR);
   15ed0:	3205      	adds	r2, #5
   15ed2:	839a      	strh	r2, [r3, #28]
   15ed4:	815a      	strh	r2, [r3, #10]
	objectHandleStacks.indexOfNextAvailableHandle[6] = objectHandleStacks.lowestIndexOfClass[6] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK) + (TRC_CFG_NISR) + (TRC_CFG_NTIMER);
   15ed6:	3205      	adds	r2, #5
   15ed8:	83da      	strh	r2, [r3, #30]
   15eda:	819a      	strh	r2, [r3, #12]
	objectHandleStacks.indexOfNextAvailableHandle[7] = objectHandleStacks.lowestIndexOfClass[7] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK) + (TRC_CFG_NISR) + (TRC_CFG_NTIMER) + (TRC_CFG_NEVENTGROUP);
   15edc:	3205      	adds	r2, #5
   15ede:	841a      	strh	r2, [r3, #32]
   15ee0:	81da      	strh	r2, [r3, #14]
	objectHandleStacks.indexOfNextAvailableHandle[8] = objectHandleStacks.lowestIndexOfClass[8] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK) + (TRC_CFG_NISR) + (TRC_CFG_NTIMER) + (TRC_CFG_NEVENTGROUP) + (TRC_CFG_NSTREAMBUFFER);
   15ee2:	3205      	adds	r2, #5
   15ee4:	845a      	strh	r2, [r3, #34]	; 0x22
   15ee6:	821a      	strh	r2, [r3, #16]

	objectHandleStacks.highestIndexOfClass[0] = (TRC_CFG_NQUEUE) - 1;
   15ee8:	3a38      	subs	r2, #56	; 0x38
   15eea:	849a      	strh	r2, [r3, #36]	; 0x24
	objectHandleStacks.highestIndexOfClass[1] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) - 1;
   15eec:	320a      	adds	r2, #10
   15eee:	84da      	strh	r2, [r3, #38]	; 0x26
	objectHandleStacks.highestIndexOfClass[2] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) - 1;
   15ef0:	320a      	adds	r2, #10
   15ef2:	851a      	strh	r2, [r3, #40]	; 0x28
	objectHandleStacks.highestIndexOfClass[3] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK) - 1;
   15ef4:	320f      	adds	r2, #15
   15ef6:	855a      	strh	r2, [r3, #42]	; 0x2a
	objectHandleStacks.highestIndexOfClass[4] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK) + (TRC_CFG_NISR) - 1;
   15ef8:	3205      	adds	r2, #5
   15efa:	859a      	strh	r2, [r3, #44]	; 0x2c
	objectHandleStacks.highestIndexOfClass[5] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK) + (TRC_CFG_NISR) + (TRC_CFG_NTIMER) - 1;
   15efc:	3205      	adds	r2, #5
   15efe:	85da      	strh	r2, [r3, #46]	; 0x2e
	objectHandleStacks.highestIndexOfClass[6] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK) + (TRC_CFG_NISR) + (TRC_CFG_NTIMER) + (TRC_CFG_NEVENTGROUP) - 1;
   15f00:	3205      	adds	r2, #5
   15f02:	861a      	strh	r2, [r3, #48]	; 0x30
	objectHandleStacks.highestIndexOfClass[7] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK) + (TRC_CFG_NISR) + (TRC_CFG_NTIMER) + (TRC_CFG_NEVENTGROUP) + (TRC_CFG_NSTREAMBUFFER) - 1;
   15f04:	3205      	adds	r2, #5
   15f06:	865a      	strh	r2, [r3, #50]	; 0x32
	objectHandleStacks.highestIndexOfClass[8] = (TRC_CFG_NQUEUE) + (TRC_CFG_NSEMAPHORE) + (TRC_CFG_NMUTEX) + (TRC_CFG_NTASK) + (TRC_CFG_NISR) + (TRC_CFG_NTIMER) + (TRC_CFG_NEVENTGROUP) + (TRC_CFG_NSTREAMBUFFER) + (TRC_CFG_NMESSAGEBUFFER) - 1;
   15f08:	3205      	adds	r2, #5
   15f0a:	869a      	strh	r2, [r3, #52]	; 0x34
}
   15f0c:	4770      	bx	lr
   15f0e:	46c0      	nop			; (mov r8, r8)
   15f10:	20000c20 	.word	0x20000c20

00015f14 <pszTraceGetErrorNotEnoughHandles>:

/* Returns the "Not enough handles" error message for this object class */
const char* pszTraceGetErrorNotEnoughHandles(traceObjectClass objectclass)
{
   15f14:	4b03      	ldr	r3, [pc, #12]	; (15f24 <pszTraceGetErrorNotEnoughHandles+0x10>)
   15f16:	2808      	cmp	r0, #8
   15f18:	d802      	bhi.n	15f20 <pszTraceGetErrorNotEnoughHandles+0xc>
   15f1a:	4b03      	ldr	r3, [pc, #12]	; (15f28 <pszTraceGetErrorNotEnoughHandles+0x14>)
   15f1c:	0080      	lsls	r0, r0, #2
   15f1e:	58c3      	ldr	r3, [r0, r3]
	case TRACE_CLASS_MESSAGEBUFFER:
		return "Not enough MESSAGEBUFFER handles - increase TRC_CFG_NMESSAGEBUFFER in trcSnapshotConfig.h";
	default:
		return "pszTraceGetErrorHandles: Invalid objectclass!";
	}
}
   15f20:	0018      	movs	r0, r3
   15f22:	4770      	bx	lr
   15f24:	00029338 	.word	0x00029338
   15f28:	00029314 	.word	0x00029314

00015f2c <prvStrncpy>:
 * Private string copy function, to improve portability between compilers.
 ******************************************************************************/
static void prvStrncpy(char* dst, const char* src, uint32_t maxLength)
{
	uint32_t i;
	for (i = 0; i < maxLength; i++)
   15f2c:	2300      	movs	r3, #0
{
   15f2e:	b510      	push	{r4, lr}
	for (i = 0; i < maxLength; i++)
   15f30:	4293      	cmp	r3, r2
   15f32:	d100      	bne.n	15f36 <prvStrncpy+0xa>
	{
		dst[i] = src[i];
		if (src[i] == 0)
			break;
	}
}
   15f34:	bd10      	pop	{r4, pc}
		dst[i] = src[i];
   15f36:	5ccc      	ldrb	r4, [r1, r3]
   15f38:	54c4      	strb	r4, [r0, r3]
		if (src[i] == 0)
   15f3a:	5ccc      	ldrb	r4, [r1, r3]
   15f3c:	2c00      	cmp	r4, #0
   15f3e:	d0f9      	beq.n	15f34 <prvStrncpy+0x8>
	for (i = 0; i < maxLength; i++)
   15f40:	3301      	adds	r3, #1
   15f42:	e7f5      	b.n	15f30 <prvStrncpy+0x4>

00015f44 <vTraceStop>:
{
   15f44:	b510      	push	{r4, lr}
	if (RecorderDataPtr != NULL)
   15f46:	4b06      	ldr	r3, [pc, #24]	; (15f60 <vTraceStop+0x1c>)
   15f48:	681b      	ldr	r3, [r3, #0]
   15f4a:	2b00      	cmp	r3, #0
   15f4c:	d001      	beq.n	15f52 <vTraceStop+0xe>
		RecorderDataPtr->recorderActive = 0;
   15f4e:	2200      	movs	r2, #0
   15f50:	631a      	str	r2, [r3, #48]	; 0x30
	if (vTraceStopHookPtr != (TRACE_STOP_HOOK)0)
   15f52:	4b04      	ldr	r3, [pc, #16]	; (15f64 <vTraceStop+0x20>)
   15f54:	681b      	ldr	r3, [r3, #0]
   15f56:	2b00      	cmp	r3, #0
   15f58:	d000      	beq.n	15f5c <vTraceStop+0x18>
		(*vTraceStopHookPtr)();			/* An application call-back function. */
   15f5a:	4798      	blx	r3
}
   15f5c:	bd10      	pop	{r4, pc}
   15f5e:	46c0      	nop			; (mov r8, r8)
   15f60:	20000c04 	.word	0x20000c04
   15f64:	20000ccc 	.word	0x20000ccc

00015f68 <xTraceIsRecordingEnabled>:
	if (RecorderDataPtr != NULL)
   15f68:	4b02      	ldr	r3, [pc, #8]	; (15f74 <xTraceIsRecordingEnabled+0xc>)
   15f6a:	681b      	ldr	r3, [r3, #0]
   15f6c:	1e18      	subs	r0, r3, #0
   15f6e:	d000      	beq.n	15f72 <xTraceIsRecordingEnabled+0xa>
		return (int)RecorderDataPtr->recorderActive;
   15f70:	6b18      	ldr	r0, [r3, #48]	; 0x30
}
   15f72:	4770      	bx	lr
   15f74:	20000c04 	.word	0x20000c04

00015f78 <prvTraceInitTraceData>:
{	
   15f78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (RecorderDataPtr == NULL)
   15f7a:	4a48      	ldr	r2, [pc, #288]	; (1609c <prvTraceInitTraceData+0x124>)
   15f7c:	6813      	ldr	r3, [r2, #0]
   15f7e:	2b00      	cmp	r3, #0
   15f80:	d000      	beq.n	15f84 <prvTraceInitTraceData+0xc>
   15f82:	e085      	b.n	16090 <prvTraceInitTraceData+0x118>
	RecorderDataPtr = &RecorderData;
   15f84:	4b46      	ldr	r3, [pc, #280]	; (160a0 <prvTraceInitTraceData+0x128>)
   15f86:	6013      	str	r3, [r2, #0]
	(void)memset(RecorderDataPtr, 0, sizeof(RecorderDataType));
   15f88:	25bd      	movs	r5, #189	; 0xbd
	init_hwtc_count = TRC_HWTC_COUNT;
   15f8a:	4b46      	ldr	r3, [pc, #280]	; (160a4 <prvTraceInitTraceData+0x12c>)
	(void)memset(RecorderDataPtr, 0, sizeof(RecorderDataType));
   15f8c:	4c43      	ldr	r4, [pc, #268]	; (1609c <prvTraceInitTraceData+0x124>)
	init_hwtc_count = TRC_HWTC_COUNT;
   15f8e:	681a      	ldr	r2, [r3, #0]
   15f90:	4b45      	ldr	r3, [pc, #276]	; (160a8 <prvTraceInitTraceData+0x130>)
	(void)memset(RecorderDataPtr, 0, sizeof(RecorderDataType));
   15f92:	012d      	lsls	r5, r5, #4
	init_hwtc_count = TRC_HWTC_COUNT;
   15f94:	601a      	str	r2, [r3, #0]
	(void)memset(RecorderDataPtr, 0, sizeof(RecorderDataType));
   15f96:	2100      	movs	r1, #0
   15f98:	002a      	movs	r2, r5
   15f9a:	4b44      	ldr	r3, [pc, #272]	; (160ac <prvTraceInitTraceData+0x134>)
   15f9c:	6820      	ldr	r0, [r4, #0]
   15f9e:	4798      	blx	r3
	RecorderDataPtr->version = TRACE_KERNEL_VERSION;
   15fa0:	6823      	ldr	r3, [r4, #0]
   15fa2:	4a43      	ldr	r2, [pc, #268]	; (160b0 <prvTraceInitTraceData+0x138>)
	RecorderDataPtr->maxEvents = (TRC_CFG_EVENT_BUFFER_SIZE);
   15fa4:	2196      	movs	r1, #150	; 0x96
	RecorderDataPtr->version = TRACE_KERNEL_VERSION;
   15fa6:	819a      	strh	r2, [r3, #12]
	RecorderDataPtr->minor_version = TRACE_MINOR_VERSION;
   15fa8:	2205      	movs	r2, #5
   15faa:	739a      	strb	r2, [r3, #14]
	RecorderDataPtr->irq_priority_order = TRC_IRQ_PRIORITY_ORDER;
   15fac:	2200      	movs	r2, #0
	RecorderDataPtr->maxEvents = (TRC_CFG_EVENT_BUFFER_SIZE);
   15fae:	0049      	lsls	r1, r1, #1
   15fb0:	6199      	str	r1, [r3, #24]
	RecorderDataPtr->debugMarker0 = (int32_t) 0xF0F0F0F0;
   15fb2:	4940      	ldr	r1, [pc, #256]	; (160b4 <prvTraceInitTraceData+0x13c>)
	RecorderDataPtr->irq_priority_order = TRC_IRQ_PRIORITY_ORDER;
   15fb4:	73da      	strb	r2, [r3, #15]
	RecorderDataPtr->filesize = sizeof(RecorderDataType);
   15fb6:	611d      	str	r5, [r3, #16]
	RecorderDataPtr->debugMarker0 = (int32_t) 0xF0F0F0F0;
   15fb8:	6559      	str	r1, [r3, #84]	; 0x54
	RecorderDataPtr->isUsing16bitHandles = TRC_CFG_USE_16BIT_OBJECT_HANDLES;
   15fba:	659a      	str	r2, [r3, #88]	; 0x58
	RecorderDataPtr->isrTailchainingThreshold = TRC_CFG_ISR_TAILCHAINING_THRESHOLD;
   15fbc:	635a      	str	r2, [r3, #52]	; 0x34
	vTraceInitObjectPropertyTable();
   15fbe:	4b3e      	ldr	r3, [pc, #248]	; (160b8 <prvTraceInitTraceData+0x140>)
   15fc0:	4798      	blx	r3
	RecorderDataPtr->debugMarker1 = (int32_t)0xF1F1F1F1;
   15fc2:	6820      	ldr	r0, [r4, #0]
   15fc4:	4a3d      	ldr	r2, [pc, #244]	; (160bc <prvTraceInitTraceData+0x144>)
   15fc6:	4b3e      	ldr	r3, [pc, #248]	; (160c0 <prvTraceInitTraceData+0x148>)
	RecorderDataPtr->SymbolTable.nextFreeSymbolIndex = 1;
   15fc8:	2501      	movs	r5, #1
	RecorderDataPtr->debugMarker1 = (int32_t)0xF1F1F1F1;
   15fca:	50c2      	str	r2, [r0, r3]
	RecorderDataPtr->SymbolTable.symTableSize = (TRC_CFG_SYMBOL_TABLE_SIZE);
   15fcc:	22c8      	movs	r2, #200	; 0xc8
   15fce:	3304      	adds	r3, #4
   15fd0:	50c2      	str	r2, [r0, r3]
	RecorderDataPtr->SymbolTable.nextFreeSymbolIndex = 1;
   15fd2:	4b3c      	ldr	r3, [pc, #240]	; (160c4 <prvTraceInitTraceData+0x14c>)
	RecorderDataPtr->debugMarker2 = (int32_t)0xF2F2F2F2;
   15fd4:	4a3c      	ldr	r2, [pc, #240]	; (160c8 <prvTraceInitTraceData+0x150>)
	RecorderDataPtr->SymbolTable.nextFreeSymbolIndex = 1;
   15fd6:	50c5      	str	r5, [r0, r3]
	RecorderDataPtr->debugMarker2 = (int32_t)0xF2F2F2F2;
   15fd8:	3355      	adds	r3, #85	; 0x55
   15fda:	33ff      	adds	r3, #255	; 0xff
   15fdc:	50c2      	str	r2, [r0, r3]
	prvStrncpy(RecorderDataPtr->systemInfo, "Trace Recorder Demo", 80);
   15fde:	4b3b      	ldr	r3, [pc, #236]	; (160cc <prvTraceInitTraceData+0x154>)
   15fe0:	2250      	movs	r2, #80	; 0x50
   15fe2:	18c0      	adds	r0, r0, r3
   15fe4:	493a      	ldr	r1, [pc, #232]	; (160d0 <prvTraceInitTraceData+0x158>)
   15fe6:	4b3b      	ldr	r3, [pc, #236]	; (160d4 <prvTraceInitTraceData+0x15c>)
   15fe8:	4798      	blx	r3
	RecorderDataPtr->debugMarker3 = (int32_t)0xF3F3F3F3;
   15fea:	6823      	ldr	r3, [r4, #0]
   15fec:	493a      	ldr	r1, [pc, #232]	; (160d8 <prvTraceInitTraceData+0x160>)
   15fee:	4a3b      	ldr	r2, [pc, #236]	; (160dc <prvTraceInitTraceData+0x164>)
	RecorderDataPtr->endmarker10 = 0xF3;
   15ff0:	26f3      	movs	r6, #243	; 0xf3
	RecorderDataPtr->debugMarker3 = (int32_t)0xF3F3F3F3;
   15ff2:	5099      	str	r1, [r3, r2]
	RecorderDataPtr->endmarker0 = 0x0A;
   15ff4:	210a      	movs	r1, #10
   15ff6:	4a3a      	ldr	r2, [pc, #232]	; (160e0 <prvTraceInitTraceData+0x168>)
	RecorderDataPtr->endmarker11 = 0xF4;
   15ff8:	27f4      	movs	r7, #244	; 0xf4
	RecorderDataPtr->endmarker0 = 0x0A;
   15ffa:	5499      	strb	r1, [r3, r2]
	RecorderDataPtr->endmarker1 = 0x0B;
   15ffc:	4a39      	ldr	r2, [pc, #228]	; (160e4 <prvTraceInitTraceData+0x16c>)
   15ffe:	1949      	adds	r1, r1, r5
   16000:	5499      	strb	r1, [r3, r2]
	RecorderDataPtr->endmarker2 = 0x0C;
   16002:	4a39      	ldr	r2, [pc, #228]	; (160e8 <prvTraceInitTraceData+0x170>)
   16004:	1949      	adds	r1, r1, r5
   16006:	5499      	strb	r1, [r3, r2]
	RecorderDataPtr->endmarker3 = 0x0D;
   16008:	4a38      	ldr	r2, [pc, #224]	; (160ec <prvTraceInitTraceData+0x174>)
   1600a:	1949      	adds	r1, r1, r5
   1600c:	5499      	strb	r1, [r3, r2]
	RecorderDataPtr->endmarker4 = 0x71;
   1600e:	4a38      	ldr	r2, [pc, #224]	; (160f0 <prvTraceInitTraceData+0x178>)
   16010:	3164      	adds	r1, #100	; 0x64
   16012:	5499      	strb	r1, [r3, r2]
	RecorderDataPtr->endmarker5 = 0x72;
   16014:	2172      	movs	r1, #114	; 0x72
   16016:	4a37      	ldr	r2, [pc, #220]	; (160f4 <prvTraceInitTraceData+0x17c>)
   16018:	5499      	strb	r1, [r3, r2]
	RecorderDataPtr->endmarker6 = 0x73;
   1601a:	2173      	movs	r1, #115	; 0x73
   1601c:	4a36      	ldr	r2, [pc, #216]	; (160f8 <prvTraceInitTraceData+0x180>)
   1601e:	5499      	strb	r1, [r3, r2]
	RecorderDataPtr->endmarker7 = 0x74;
   16020:	2174      	movs	r1, #116	; 0x74
   16022:	4a36      	ldr	r2, [pc, #216]	; (160fc <prvTraceInitTraceData+0x184>)
   16024:	5499      	strb	r1, [r3, r2]
	RecorderDataPtr->endmarker8 = 0xF1;
   16026:	21f1      	movs	r1, #241	; 0xf1
   16028:	4a35      	ldr	r2, [pc, #212]	; (16100 <prvTraceInitTraceData+0x188>)
   1602a:	5499      	strb	r1, [r3, r2]
	RecorderDataPtr->endmarker9 = 0xF2;
   1602c:	21f2      	movs	r1, #242	; 0xf2
   1602e:	4a35      	ldr	r2, [pc, #212]	; (16104 <prvTraceInitTraceData+0x18c>)
   16030:	5499      	strb	r1, [r3, r2]
	RecorderDataPtr->endmarker10 = 0xF3;
   16032:	4a35      	ldr	r2, [pc, #212]	; (16108 <prvTraceInitTraceData+0x190>)
   16034:	549e      	strb	r6, [r3, r2]
	RecorderDataPtr->endmarker11 = 0xF4;
   16036:	4a35      	ldr	r2, [pc, #212]	; (1610c <prvTraceInitTraceData+0x194>)
   16038:	549f      	strb	r7, [r3, r2]
	vTraceInitObjectHandleStack();
   1603a:	4b35      	ldr	r3, [pc, #212]	; (16110 <prvTraceInitTraceData+0x198>)
   1603c:	4798      	blx	r3
	RecorderDataPtr->startmarker9 = 0xF2;
   1603e:	22f2      	movs	r2, #242	; 0xf2
	RecorderDataPtr->startmarker11 = 0xF4;
   16040:	6823      	ldr	r3, [r4, #0]
   16042:	72df      	strb	r7, [r3, #11]
	RecorderDataPtr->startmarker10 = 0xF3;
   16044:	729e      	strb	r6, [r3, #10]
	RecorderDataPtr->startmarker9 = 0xF2;
   16046:	725a      	strb	r2, [r3, #9]
	RecorderDataPtr->startmarker8 = 0xF1;
   16048:	22f1      	movs	r2, #241	; 0xf1
   1604a:	721a      	strb	r2, [r3, #8]
	RecorderDataPtr->startmarker7 = 0x74;
   1604c:	2274      	movs	r2, #116	; 0x74
   1604e:	71da      	strb	r2, [r3, #7]
	RecorderDataPtr->startmarker6 = 0x73;
   16050:	2273      	movs	r2, #115	; 0x73
   16052:	719a      	strb	r2, [r3, #6]
	RecorderDataPtr->startmarker5 = 0x72;
   16054:	2272      	movs	r2, #114	; 0x72
   16056:	715a      	strb	r2, [r3, #5]
	RecorderDataPtr->startmarker4 = 0x71;
   16058:	2271      	movs	r2, #113	; 0x71
   1605a:	711a      	strb	r2, [r3, #4]
	RecorderDataPtr->startmarker3 = 0x04;
   1605c:	2204      	movs	r2, #4
   1605e:	70da      	strb	r2, [r3, #3]
	RecorderDataPtr->startmarker2 = 0x03;
   16060:	2303      	movs	r3, #3
   16062:	6822      	ldr	r2, [r4, #0]
   16064:	7093      	strb	r3, [r2, #2]
	RecorderDataPtr->startmarker1 = 0x02;	
   16066:	6822      	ldr	r2, [r4, #0]
   16068:	3b01      	subs	r3, #1
   1606a:	7053      	strb	r3, [r2, #1]
	RecorderDataPtr->startmarker0 = 0x01; 
   1606c:	6823      	ldr	r3, [r4, #0]
   1606e:	701d      	strb	r5, [r3, #0]
	if (traceErrorMessage != NULL)
   16070:	4b28      	ldr	r3, [pc, #160]	; (16114 <prvTraceInitTraceData+0x19c>)
   16072:	6819      	ldr	r1, [r3, #0]
   16074:	2900      	cmp	r1, #0
   16076:	d00f      	beq.n	16098 <prvTraceInitTraceData+0x120>
		prvStrncpy(RecorderDataPtr->systemInfo, traceErrorMessage, 80);
   16078:	6823      	ldr	r3, [r4, #0]
   1607a:	4a14      	ldr	r2, [pc, #80]	; (160cc <prvTraceInitTraceData+0x154>)
   1607c:	1898      	adds	r0, r3, r2
   1607e:	2250      	movs	r2, #80	; 0x50
   16080:	4b14      	ldr	r3, [pc, #80]	; (160d4 <prvTraceInitTraceData+0x15c>)
   16082:	4798      	blx	r3
		RecorderDataPtr->internalErrorOccured = 1;
   16084:	6822      	ldr	r2, [r4, #0]
   16086:	4b24      	ldr	r3, [pc, #144]	; (16118 <prvTraceInitTraceData+0x1a0>)
   16088:	50d5      	str	r5, [r2, r3]
		vTraceStop();
   1608a:	4b24      	ldr	r3, [pc, #144]	; (1611c <prvTraceInitTraceData+0x1a4>)
   1608c:	4798      	blx	r3
   1608e:	e003      	b.n	16098 <prvTraceInitTraceData+0x120>
		if (RecorderDataPtr->startmarker0 == 1)
   16090:	781b      	ldrb	r3, [r3, #0]
   16092:	2b01      	cmp	r3, #1
   16094:	d000      	beq.n	16098 <prvTraceInitTraceData+0x120>
   16096:	e777      	b.n	15f88 <prvTraceInitTraceData+0x10>
}
   16098:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1609a:	46c0      	nop			; (mov r8, r8)
   1609c:	20000c04 	.word	0x20000c04
   160a0:	20004478 	.word	0x20004478
   160a4:	e000e018 	.word	0xe000e018
   160a8:	20005048 	.word	0x20005048
   160ac:	00022c47 	.word	0x00022c47
   160b0:	00001aa1 	.word	0x00001aa1
   160b4:	f0f0f0f0 	.word	0xf0f0f0f0
   160b8:	00015e09 	.word	0x00015e09
   160bc:	f1f1f1f1 	.word	0xf1f1f1f1
   160c0:	0000055c 	.word	0x0000055c
   160c4:	00000564 	.word	0x00000564
   160c8:	f2f2f2f2 	.word	0xf2f2f2f2
   160cc:	000006bc 	.word	0x000006bc
   160d0:	00029828 	.word	0x00029828
   160d4:	00015f2d 	.word	0x00015f2d
   160d8:	f3f3f3f3 	.word	0xf3f3f3f3
   160dc:	0000070c 	.word	0x0000070c
   160e0:	00000bc4 	.word	0x00000bc4
   160e4:	00000bc5 	.word	0x00000bc5
   160e8:	00000bc6 	.word	0x00000bc6
   160ec:	00000bc7 	.word	0x00000bc7
   160f0:	00000bc8 	.word	0x00000bc8
   160f4:	00000bc9 	.word	0x00000bc9
   160f8:	00000bca 	.word	0x00000bca
   160fc:	00000bcb 	.word	0x00000bcb
   16100:	00000bcc 	.word	0x00000bcc
   16104:	00000bcd 	.word	0x00000bcd
   16108:	00000bce 	.word	0x00000bce
   1610c:	00000bcf 	.word	0x00000bcf
   16110:	00015eb1 	.word	0x00015eb1
   16114:	20000cbc 	.word	0x20000cbc
   16118:	000006b4 	.word	0x000006b4
   1611c:	00015f45 	.word	0x00015f45

00016120 <prvTraceError>:
 * Note: If a recorder error is registered before vTraceStart is called, the
 * trace start will be aborted. This can occur if any of the Nxxxx constants
 * (e.g., TRC_CFG_NTASK) in trcConfig.h is too small.
 ******************************************************************************/
void prvTraceError(const char* msg)
{
   16120:	b570      	push	{r4, r5, r6, lr}
	/* Stop the recorder */
	if (RecorderDataPtr != NULL)
   16122:	4c0d      	ldr	r4, [pc, #52]	; (16158 <prvTraceError+0x38>)
{
   16124:	0005      	movs	r5, r0
	if (RecorderDataPtr != NULL)
   16126:	6823      	ldr	r3, [r4, #0]
   16128:	2b00      	cmp	r3, #0
   1612a:	d001      	beq.n	16130 <prvTraceError+0x10>
	{
		vTraceStop();
   1612c:	4b0b      	ldr	r3, [pc, #44]	; (1615c <prvTraceError+0x3c>)
   1612e:	4798      	blx	r3
	}

	/* If first error only... */
	if (traceErrorMessage == NULL)
   16130:	4b0b      	ldr	r3, [pc, #44]	; (16160 <prvTraceError+0x40>)
   16132:	681a      	ldr	r2, [r3, #0]
   16134:	2a00      	cmp	r2, #0
   16136:	d10d      	bne.n	16154 <prvTraceError+0x34>
	{
		traceErrorMessage = (char*)(intptr_t) msg;
		if (RecorderDataPtr != NULL)
   16138:	6820      	ldr	r0, [r4, #0]
		traceErrorMessage = (char*)(intptr_t) msg;
   1613a:	601d      	str	r5, [r3, #0]
		if (RecorderDataPtr != NULL)
   1613c:	2800      	cmp	r0, #0
   1613e:	d009      	beq.n	16154 <prvTraceError+0x34>
		{
			prvStrncpy(RecorderDataPtr->systemInfo, traceErrorMessage, 80);
   16140:	4b08      	ldr	r3, [pc, #32]	; (16164 <prvTraceError+0x44>)
   16142:	3250      	adds	r2, #80	; 0x50
   16144:	18c0      	adds	r0, r0, r3
   16146:	0029      	movs	r1, r5
   16148:	4b07      	ldr	r3, [pc, #28]	; (16168 <prvTraceError+0x48>)
   1614a:	4798      	blx	r3
			RecorderDataPtr->internalErrorOccured = 1;
   1614c:	2101      	movs	r1, #1
   1614e:	6822      	ldr	r2, [r4, #0]
   16150:	4b06      	ldr	r3, [pc, #24]	; (1616c <prvTraceError+0x4c>)
   16152:	50d1      	str	r1, [r2, r3]
		}
	}
}
   16154:	bd70      	pop	{r4, r5, r6, pc}
   16156:	46c0      	nop			; (mov r8, r8)
   16158:	20000c04 	.word	0x20000c04
   1615c:	00015f45 	.word	0x00015f45
   16160:	20000cbc 	.word	0x20000cbc
   16164:	000006bc 	.word	0x000006bc
   16168:	00015f2d 	.word	0x00015f2d
   1616c:	000006b4 	.word	0x000006b4

00016170 <prvTraceNextFreeEventBufferSlot>:
{
   16170:	b510      	push	{r4, lr}
	if (! RecorderDataPtr->recorderActive)
   16172:	4b0a      	ldr	r3, [pc, #40]	; (1619c <prvTraceNextFreeEventBufferSlot+0x2c>)
   16174:	681b      	ldr	r3, [r3, #0]
		return NULL;
   16176:	6b18      	ldr	r0, [r3, #48]	; 0x30
	if (! RecorderDataPtr->recorderActive)
   16178:	2800      	cmp	r0, #0
   1617a:	d008      	beq.n	1618e <prvTraceNextFreeEventBufferSlot+0x1e>
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
   1617c:	222c      	movs	r2, #44	; 0x2c
   1617e:	69d8      	ldr	r0, [r3, #28]
   16180:	32ff      	adds	r2, #255	; 0xff
   16182:	4290      	cmp	r0, r2
   16184:	d904      	bls.n	16190 <prvTraceNextFreeEventBufferSlot+0x20>
		prvTraceError("Attempt to index outside event buffer!");
   16186:	4806      	ldr	r0, [pc, #24]	; (161a0 <prvTraceNextFreeEventBufferSlot+0x30>)
   16188:	4b06      	ldr	r3, [pc, #24]	; (161a4 <prvTraceNextFreeEventBufferSlot+0x34>)
   1618a:	4798      	blx	r3
		return NULL;
   1618c:	2000      	movs	r0, #0
}
   1618e:	bd10      	pop	{r4, pc}
	return (void*)(&RecorderDataPtr->eventData[RecorderDataPtr->nextFreeIndex*4]);
   16190:	22e2      	movs	r2, #226	; 0xe2
   16192:	0080      	lsls	r0, r0, #2
   16194:	00d2      	lsls	r2, r2, #3
   16196:	1880      	adds	r0, r0, r2
   16198:	1818      	adds	r0, r3, r0
   1619a:	e7f8      	b.n	1618e <prvTraceNextFreeEventBufferSlot+0x1e>
   1619c:	20000c04 	.word	0x20000c04
   161a0:	0002983c 	.word	0x0002983c
   161a4:	00016121 	.word	0x00016121

000161a8 <prvCheckDataToBeOverwrittenForMultiEntryEvents>:
 * This is assumed to execute within a critical section...
 *****************************************************************************/

#if (TRC_CFG_SNAPSHOT_MODE == TRC_SNAPSHOT_MODE_RING_BUFFER)
void prvCheckDataToBeOverwrittenForMultiEntryEvents(uint8_t nofEntriesToCheck)
{
   161a8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   161aa:	2600      	movs	r6, #0
   161ac:	9001      	str	r0, [sp, #4]
	/* Generic "int" type is desired - should be 16 bit variable on 16 bit HW */
	unsigned int i = 0;
	unsigned int e = 0;

	TRACE_ASSERT(nofEntriesToCheck != 0, 
   161ae:	2800      	cmp	r0, #0
   161b0:	d122      	bne.n	161f8 <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x50>
   161b2:	481f      	ldr	r0, [pc, #124]	; (16230 <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x88>)
   161b4:	4b1f      	ldr	r3, [pc, #124]	; (16234 <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x8c>)
   161b6:	4798      	blx	r3
				(void)memset(& RecorderDataPtr->eventData[e*4], 0, 4);
			}
		}
		i++;
	}
}
   161b8:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
		if ((RecorderDataPtr->eventData[e*4] > USER_EVENT) &&
   161ba:	21e2      	movs	r1, #226	; 0xe2
		e = RecorderDataPtr->nextFreeIndex + i;
   161bc:	4b1e      	ldr	r3, [pc, #120]	; (16238 <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x90>)
		if ((RecorderDataPtr->eventData[e*4] > USER_EVENT) &&
   161be:	00c9      	lsls	r1, r1, #3
		e = RecorderDataPtr->nextFreeIndex + i;
   161c0:	681c      	ldr	r4, [r3, #0]
   161c2:	69e3      	ldr	r3, [r4, #28]
   161c4:	18f3      	adds	r3, r6, r3
		if ((RecorderDataPtr->eventData[e*4] > USER_EVENT) &&
   161c6:	009d      	lsls	r5, r3, #2
   161c8:	1962      	adds	r2, r4, r5
   161ca:	1852      	adds	r2, r2, r1
   161cc:	7812      	ldrb	r2, [r2, #0]
   161ce:	0011      	movs	r1, r2
   161d0:	3167      	adds	r1, #103	; 0x67
   161d2:	b2c9      	uxtb	r1, r1
   161d4:	290e      	cmp	r1, #14
   161d6:	d813      	bhi.n	16200 <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x58>
			uint8_t nDataEvents = (uint8_t)(RecorderDataPtr->eventData[e*4] - USER_EVENT);
   161d8:	3268      	adds	r2, #104	; 0x68
   161da:	b2d2      	uxtb	r2, r2
			if ((e + nDataEvents) < RecorderDataPtr->maxEvents)
   161dc:	69a1      	ldr	r1, [r4, #24]
   161de:	18d3      	adds	r3, r2, r3
   161e0:	428b      	cmp	r3, r1
   161e2:	d208      	bcs.n	161f6 <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x4e>
				(void)memset(& RecorderDataPtr->eventData[e*4], 0, (size_t) (4 + 4 * nDataEvents));
   161e4:	23e2      	movs	r3, #226	; 0xe2
   161e6:	00db      	lsls	r3, r3, #3
   161e8:	18ed      	adds	r5, r5, r3
   161ea:	3201      	adds	r2, #1
   161ec:	0092      	lsls	r2, r2, #2
   161ee:	1960      	adds	r0, r4, r5
   161f0:	2100      	movs	r1, #0
   161f2:	4b12      	ldr	r3, [pc, #72]	; (1623c <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x94>)
   161f4:	4798      	blx	r3
		i++;
   161f6:	3601      	adds	r6, #1
	while (i < nofEntriesToCheck)
   161f8:	9b01      	ldr	r3, [sp, #4]
   161fa:	429e      	cmp	r6, r3
   161fc:	d3dd      	bcc.n	161ba <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x12>
   161fe:	e7db      	b.n	161b8 <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x10>
		else if (RecorderDataPtr->eventData[e*4] == DIV_XPS)
   16200:	2a01      	cmp	r2, #1
   16202:	d1f8      	bne.n	161f6 <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x4e>
   16204:	22e2      	movs	r2, #226	; 0xe2
   16206:	00d2      	lsls	r2, r2, #3
   16208:	18ad      	adds	r5, r5, r2
			if ((e + 1) < RecorderDataPtr->maxEvents)
   1620a:	69a2      	ldr	r2, [r4, #24]
   1620c:	3301      	adds	r3, #1
   1620e:	4f0b      	ldr	r7, [pc, #44]	; (1623c <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x94>)
   16210:	4293      	cmp	r3, r2
   16212:	d204      	bcs.n	1621e <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x76>
				(void)memset(& RecorderDataPtr->eventData[e*4], 0, 4 + 4);
   16214:	2208      	movs	r2, #8
   16216:	1960      	adds	r0, r4, r5
				(void)memset(& RecorderDataPtr->eventData[e*4], 0, 4);
   16218:	2100      	movs	r1, #0
   1621a:	47b8      	blx	r7
   1621c:	e7eb      	b.n	161f6 <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x4e>
				(void)memset(& RecorderDataPtr->eventData[0], 0, 4);
   1621e:	23e2      	movs	r3, #226	; 0xe2
   16220:	00db      	lsls	r3, r3, #3
   16222:	2204      	movs	r2, #4
   16224:	18e0      	adds	r0, r4, r3
   16226:	2100      	movs	r1, #0
   16228:	47b8      	blx	r7
				(void)memset(& RecorderDataPtr->eventData[e*4], 0, 4);
   1622a:	1960      	adds	r0, r4, r5
   1622c:	2204      	movs	r2, #4
   1622e:	e7f3      	b.n	16218 <prvCheckDataToBeOverwrittenForMultiEntryEvents+0x70>
   16230:	000296a5 	.word	0x000296a5
   16234:	00016121 	.word	0x00016121
   16238:	20000c04 	.word	0x20000c04
   1623c:	00022c47 	.word	0x00022c47

00016240 <prvTraceUpdateCounters>:
 * prvTraceUpdateCounters
 *
 * Updates the index of the event buffer.
 ******************************************************************************/
void prvTraceUpdateCounters(void)
{	
   16240:	b510      	push	{r4, lr}
	if (RecorderDataPtr->recorderActive == 0)
   16242:	4b0b      	ldr	r3, [pc, #44]	; (16270 <prvTraceUpdateCounters+0x30>)
   16244:	681b      	ldr	r3, [r3, #0]
   16246:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   16248:	2a00      	cmp	r2, #0
   1624a:	d010      	beq.n	1626e <prvTraceUpdateCounters+0x2e>
	
	RecorderDataPtr->numEvents++;

	RecorderDataPtr->nextFreeIndex++;

	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
   1624c:	212c      	movs	r1, #44	; 0x2c
	RecorderDataPtr->numEvents++;
   1624e:	695a      	ldr	r2, [r3, #20]
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
   16250:	31ff      	adds	r1, #255	; 0xff
	RecorderDataPtr->numEvents++;
   16252:	3201      	adds	r2, #1
   16254:	615a      	str	r2, [r3, #20]
	RecorderDataPtr->nextFreeIndex++;
   16256:	69da      	ldr	r2, [r3, #28]
   16258:	3201      	adds	r2, #1
   1625a:	61da      	str	r2, [r3, #28]
	if (RecorderDataPtr->nextFreeIndex >= (TRC_CFG_EVENT_BUFFER_SIZE))
   1625c:	428a      	cmp	r2, r1
   1625e:	d903      	bls.n	16268 <prvTraceUpdateCounters+0x28>
	{
#if (TRC_CFG_SNAPSHOT_MODE == TRC_SNAPSHOT_MODE_RING_BUFFER)
		RecorderDataPtr->bufferIsFull = 1;
   16260:	2201      	movs	r2, #1
   16262:	621a      	str	r2, [r3, #32]
		RecorderDataPtr->nextFreeIndex = 0;
   16264:	2200      	movs	r2, #0
   16266:	61da      	str	r2, [r3, #28]
		vTraceStop();
#endif
	}

#if (TRC_CFG_SNAPSHOT_MODE == TRC_SNAPSHOT_MODE_RING_BUFFER)
	prvCheckDataToBeOverwrittenForMultiEntryEvents(1);
   16268:	2001      	movs	r0, #1
   1626a:	4b02      	ldr	r3, [pc, #8]	; (16274 <prvTraceUpdateCounters+0x34>)
   1626c:	4798      	blx	r3
#endif
}
   1626e:	bd10      	pop	{r4, pc}
   16270:	20000c04 	.word	0x20000c04
   16274:	000161a9 	.word	0x000161a9

00016278 <prvTraceGetParam.part.1>:
static uint32_t prvTraceGetParam(uint32_t param_max, uint32_t param)
   16278:	b570      	push	{r4, r5, r6, lr}
		xps = (XPSEvent*) prvTraceNextFreeEventBufferSlot();
   1627a:	4b09      	ldr	r3, [pc, #36]	; (162a0 <prvTraceGetParam.part.1+0x28>)
static uint32_t prvTraceGetParam(uint32_t param_max, uint32_t param)
   1627c:	0005      	movs	r5, r0
   1627e:	000c      	movs	r4, r1
		xps = (XPSEvent*) prvTraceNextFreeEventBufferSlot();
   16280:	4798      	blx	r3
		if (xps != NULL)
   16282:	2800      	cmp	r0, #0
   16284:	d009      	beq.n	1629a <prvTraceGetParam.part.1+0x22>
			xps->type = DIV_XPS;
   16286:	2301      	movs	r3, #1
   16288:	7003      	strb	r3, [r0, #0]
			xps->xps_8 = (uint8_t)((param & (0xFF00 & ~param_max)) >> 8);
   1628a:	0023      	movs	r3, r4
   1628c:	43ab      	bics	r3, r5
   1628e:	0a1a      	lsrs	r2, r3, #8
			xps->xps_16 = (uint16_t)((param & (0xFFFF0000 & ~param_max)) >> 16);
   16290:	0c1b      	lsrs	r3, r3, #16
   16292:	8043      	strh	r3, [r0, #2]
			xps->xps_8 = (uint8_t)((param & (0xFF00 & ~param_max)) >> 8);
   16294:	7042      	strb	r2, [r0, #1]
			prvTraceUpdateCounters();
   16296:	4b03      	ldr	r3, [pc, #12]	; (162a4 <prvTraceGetParam.part.1+0x2c>)
   16298:	4798      	blx	r3
		return param & param_max;
   1629a:	0020      	movs	r0, r4
   1629c:	4028      	ands	r0, r5
}
   1629e:	bd70      	pop	{r4, r5, r6, pc}
   162a0:	00016171 	.word	0x00016171
   162a4:	00016241 	.word	0x00016241

000162a8 <uiIndexOfObject>:
{
   162a8:	b510      	push	{r4, lr}
	TRACE_ASSERT(objectclass < TRACE_NCLASSES, 
   162aa:	2908      	cmp	r1, #8
   162ac:	d904      	bls.n	162b8 <uiIndexOfObject+0x10>
   162ae:	480e      	ldr	r0, [pc, #56]	; (162e8 <uiIndexOfObject+0x40>)
	TRACE_ASSERT(objecthandle > 0 && objecthandle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass], 
   162b0:	4b0e      	ldr	r3, [pc, #56]	; (162ec <uiIndexOfObject+0x44>)
   162b2:	4798      	blx	r3
   162b4:	2000      	movs	r0, #0
}
   162b6:	bd10      	pop	{r4, pc}
	TRACE_ASSERT(objecthandle > 0 && objecthandle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass], 
   162b8:	2800      	cmp	r0, #0
   162ba:	d007      	beq.n	162cc <uiIndexOfObject+0x24>
   162bc:	4b0c      	ldr	r3, [pc, #48]	; (162f0 <uiIndexOfObject+0x48>)
   162be:	681a      	ldr	r2, [r3, #0]
   162c0:	1853      	adds	r3, r2, r1
   162c2:	001c      	movs	r4, r3
   162c4:	3464      	adds	r4, #100	; 0x64
   162c6:	7824      	ldrb	r4, [r4, #0]
   162c8:	4284      	cmp	r4, r0
   162ca:	d201      	bcs.n	162d0 <uiIndexOfObject+0x28>
   162cc:	4809      	ldr	r0, [pc, #36]	; (162f4 <uiIndexOfObject+0x4c>)
   162ce:	e7ef      	b.n	162b0 <uiIndexOfObject+0x8>
			(RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[objectclass] * (objecthandle-1)));
   162d0:	337c      	adds	r3, #124	; 0x7c
		return (uint16_t)(RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[objectclass] + 
   162d2:	781b      	ldrb	r3, [r3, #0]
			(RecorderDataPtr->ObjectPropertyTable.TotalPropertyBytesPerClass[objectclass] * (objecthandle-1)));
   162d4:	3801      	subs	r0, #1
		return (uint16_t)(RecorderDataPtr->ObjectPropertyTable.StartIndexOfClass[objectclass] + 
   162d6:	3140      	adds	r1, #64	; 0x40
   162d8:	4358      	muls	r0, r3
   162da:	0049      	lsls	r1, r1, #1
   162dc:	1851      	adds	r1, r2, r1
   162de:	890b      	ldrh	r3, [r1, #8]
   162e0:	18c0      	adds	r0, r0, r3
   162e2:	b280      	uxth	r0, r0
   162e4:	e7e7      	b.n	162b6 <uiIndexOfObject+0xe>
   162e6:	46c0      	nop			; (mov r8, r8)
   162e8:	00029dc5 	.word	0x00029dc5
   162ec:	00016121 	.word	0x00016121
   162f0:	20000c04 	.word	0x20000c04
   162f4:	00029e02 	.word	0x00029e02

000162f8 <prvMarkObjectAsUsed>:
{
   162f8:	000b      	movs	r3, r1
   162fa:	b510      	push	{r4, lr}
	uint16_t idx = uiIndexOfObject(handle, objectclass);
   162fc:	0001      	movs	r1, r0
   162fe:	0018      	movs	r0, r3
   16300:	4b04      	ldr	r3, [pc, #16]	; (16314 <prvMarkObjectAsUsed+0x1c>)
   16302:	4798      	blx	r3
	RecorderDataPtr->ObjectPropertyTable.objbytes[idx] = 1;
   16304:	4b04      	ldr	r3, [pc, #16]	; (16318 <prvMarkObjectAsUsed+0x20>)
   16306:	681b      	ldr	r3, [r3, #0]
   16308:	1818      	adds	r0, r3, r0
   1630a:	2301      	movs	r3, #1
   1630c:	309c      	adds	r0, #156	; 0x9c
   1630e:	7003      	strb	r3, [r0, #0]
}
   16310:	bd10      	pop	{r4, pc}
   16312:	46c0      	nop			; (mov r8, r8)
   16314:	000162a9 	.word	0x000162a9
   16318:	20000c04 	.word	0x20000c04

0001631c <prvTraceSetPriorityProperty>:
{
   1631c:	b570      	push	{r4, r5, r6, lr}
   1631e:	0005      	movs	r5, r0
   16320:	0014      	movs	r4, r2
   16322:	0008      	movs	r0, r1
	TRACE_ASSERT(objectclass < TRACE_NCLASSES,
   16324:	2d08      	cmp	r5, #8
   16326:	d903      	bls.n	16330 <prvTraceSetPriorityProperty+0x14>
   16328:	480c      	ldr	r0, [pc, #48]	; (1635c <prvTraceSetPriorityProperty+0x40>)
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
   1632a:	4b0d      	ldr	r3, [pc, #52]	; (16360 <prvTraceSetPriorityProperty+0x44>)
   1632c:	4798      	blx	r3
}
   1632e:	bd70      	pop	{r4, r5, r6, pc}
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
   16330:	4e0c      	ldr	r6, [pc, #48]	; (16364 <prvTraceSetPriorityProperty+0x48>)
   16332:	6833      	ldr	r3, [r6, #0]
   16334:	195b      	adds	r3, r3, r5
   16336:	3364      	adds	r3, #100	; 0x64
   16338:	781b      	ldrb	r3, [r3, #0]
   1633a:	428b      	cmp	r3, r1
   1633c:	d201      	bcs.n	16342 <prvTraceSetPriorityProperty+0x26>
   1633e:	480a      	ldr	r0, [pc, #40]	; (16368 <prvTraceSetPriorityProperty+0x4c>)
   16340:	e7f3      	b.n	1632a <prvTraceSetPriorityProperty+0xe>
	TRACE_PROPERTY_ACTOR_PRIORITY(objectclass, id) = value;
   16342:	0029      	movs	r1, r5
   16344:	4b09      	ldr	r3, [pc, #36]	; (1636c <prvTraceSetPriorityProperty+0x50>)
   16346:	4798      	blx	r3
   16348:	6833      	ldr	r3, [r6, #0]
   1634a:	195d      	adds	r5, r3, r5
   1634c:	3570      	adds	r5, #112	; 0x70
   1634e:	782a      	ldrb	r2, [r5, #0]
   16350:	181b      	adds	r3, r3, r0
   16352:	189b      	adds	r3, r3, r2
   16354:	339d      	adds	r3, #157	; 0x9d
   16356:	701c      	strb	r4, [r3, #0]
   16358:	e7e9      	b.n	1632e <prvTraceSetPriorityProperty+0x12>
   1635a:	46c0      	nop			; (mov r8, r8)
   1635c:	0002996f 	.word	0x0002996f
   16360:	00016121 	.word	0x00016121
   16364:	20000c04 	.word	0x20000c04
   16368:	000299b8 	.word	0x000299b8
   1636c:	000162a9 	.word	0x000162a9

00016370 <prvTraceGetPriorityProperty>:
{
   16370:	b570      	push	{r4, r5, r6, lr}
   16372:	0004      	movs	r4, r0
   16374:	0008      	movs	r0, r1
	TRACE_ASSERT(objectclass < TRACE_NCLASSES,
   16376:	2c08      	cmp	r4, #8
   16378:	d904      	bls.n	16384 <prvTraceGetPriorityProperty+0x14>
   1637a:	480d      	ldr	r0, [pc, #52]	; (163b0 <prvTraceGetPriorityProperty+0x40>)
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
   1637c:	4b0d      	ldr	r3, [pc, #52]	; (163b4 <prvTraceGetPriorityProperty+0x44>)
   1637e:	4798      	blx	r3
   16380:	2000      	movs	r0, #0
}
   16382:	bd70      	pop	{r4, r5, r6, pc}
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
   16384:	4d0c      	ldr	r5, [pc, #48]	; (163b8 <prvTraceGetPriorityProperty+0x48>)
   16386:	682b      	ldr	r3, [r5, #0]
   16388:	191b      	adds	r3, r3, r4
   1638a:	3364      	adds	r3, #100	; 0x64
   1638c:	781b      	ldrb	r3, [r3, #0]
   1638e:	428b      	cmp	r3, r1
   16390:	d201      	bcs.n	16396 <prvTraceGetPriorityProperty+0x26>
   16392:	480a      	ldr	r0, [pc, #40]	; (163bc <prvTraceGetPriorityProperty+0x4c>)
   16394:	e7f2      	b.n	1637c <prvTraceGetPriorityProperty+0xc>
	return TRACE_PROPERTY_ACTOR_PRIORITY(objectclass, id);
   16396:	0021      	movs	r1, r4
   16398:	4b09      	ldr	r3, [pc, #36]	; (163c0 <prvTraceGetPriorityProperty+0x50>)
   1639a:	4798      	blx	r3
   1639c:	682b      	ldr	r3, [r5, #0]
   1639e:	191c      	adds	r4, r3, r4
   163a0:	3470      	adds	r4, #112	; 0x70
   163a2:	7822      	ldrb	r2, [r4, #0]
   163a4:	181b      	adds	r3, r3, r0
   163a6:	189b      	adds	r3, r3, r2
   163a8:	339d      	adds	r3, #157	; 0x9d
   163aa:	7818      	ldrb	r0, [r3, #0]
   163ac:	e7e9      	b.n	16382 <prvTraceGetPriorityProperty+0x12>
   163ae:	46c0      	nop			; (mov r8, r8)
   163b0:	0002979f 	.word	0x0002979f
   163b4:	00016121 	.word	0x00016121
   163b8:	20000c04 	.word	0x20000c04
   163bc:	000297e8 	.word	0x000297e8
   163c0:	000162a9 	.word	0x000162a9

000163c4 <prvTraceSetObjectState>:
{
   163c4:	b570      	push	{r4, r5, r6, lr}
   163c6:	0005      	movs	r5, r0
   163c8:	0014      	movs	r4, r2
   163ca:	0008      	movs	r0, r1
	TRACE_ASSERT(objectclass < TRACE_NCLASSES,
   163cc:	2d08      	cmp	r5, #8
   163ce:	d903      	bls.n	163d8 <prvTraceSetObjectState+0x14>
   163d0:	480c      	ldr	r0, [pc, #48]	; (16404 <prvTraceSetObjectState+0x40>)
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
   163d2:	4b0d      	ldr	r3, [pc, #52]	; (16408 <prvTraceSetObjectState+0x44>)
   163d4:	4798      	blx	r3
}
   163d6:	bd70      	pop	{r4, r5, r6, pc}
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
   163d8:	4e0c      	ldr	r6, [pc, #48]	; (1640c <prvTraceSetObjectState+0x48>)
   163da:	6833      	ldr	r3, [r6, #0]
   163dc:	195b      	adds	r3, r3, r5
   163de:	3364      	adds	r3, #100	; 0x64
   163e0:	781b      	ldrb	r3, [r3, #0]
   163e2:	428b      	cmp	r3, r1
   163e4:	d201      	bcs.n	163ea <prvTraceSetObjectState+0x26>
   163e6:	480a      	ldr	r0, [pc, #40]	; (16410 <prvTraceSetObjectState+0x4c>)
   163e8:	e7f3      	b.n	163d2 <prvTraceSetObjectState+0xe>
	TRACE_PROPERTY_OBJECT_STATE(objectclass, id) = value;
   163ea:	0029      	movs	r1, r5
   163ec:	4b09      	ldr	r3, [pc, #36]	; (16414 <prvTraceSetObjectState+0x50>)
   163ee:	4798      	blx	r3
   163f0:	6833      	ldr	r3, [r6, #0]
   163f2:	195d      	adds	r5, r3, r5
   163f4:	3570      	adds	r5, #112	; 0x70
   163f6:	782a      	ldrb	r2, [r5, #0]
   163f8:	181b      	adds	r3, r3, r0
   163fa:	189b      	adds	r3, r3, r2
   163fc:	339c      	adds	r3, #156	; 0x9c
   163fe:	701c      	strb	r4, [r3, #0]
   16400:	e7e9      	b.n	163d6 <prvTraceSetObjectState+0x12>
   16402:	46c0      	nop			; (mov r8, r8)
   16404:	000298f0 	.word	0x000298f0
   16408:	00016121 	.word	0x00016121
   1640c:	20000c04 	.word	0x20000c04
   16410:	00029934 	.word	0x00029934
   16414:	000162a9 	.word	0x000162a9

00016418 <prvTraceSetTaskInstanceFinished>:
{
   16418:	b510      	push	{r4, lr}
	TRACE_ASSERT(handle <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[TRACE_CLASS_TASK],
   1641a:	4c0b      	ldr	r4, [pc, #44]	; (16448 <prvTraceSetTaskInstanceFinished+0x30>)
   1641c:	6823      	ldr	r3, [r4, #0]
   1641e:	3367      	adds	r3, #103	; 0x67
   16420:	781b      	ldrb	r3, [r3, #0]
   16422:	4283      	cmp	r3, r0
   16424:	d203      	bcs.n	1642e <prvTraceSetTaskInstanceFinished+0x16>
   16426:	4809      	ldr	r0, [pc, #36]	; (1644c <prvTraceSetTaskInstanceFinished+0x34>)
   16428:	4b09      	ldr	r3, [pc, #36]	; (16450 <prvTraceSetTaskInstanceFinished+0x38>)
   1642a:	4798      	blx	r3
}
   1642c:	bd10      	pop	{r4, pc}
	TRACE_PROPERTY_OBJECT_STATE(TRACE_CLASS_TASK, handle) = 0;
   1642e:	4b09      	ldr	r3, [pc, #36]	; (16454 <prvTraceSetTaskInstanceFinished+0x3c>)
   16430:	2103      	movs	r1, #3
   16432:	4798      	blx	r3
   16434:	6823      	ldr	r3, [r4, #0]
   16436:	001a      	movs	r2, r3
   16438:	3273      	adds	r2, #115	; 0x73
   1643a:	7812      	ldrb	r2, [r2, #0]
   1643c:	181b      	adds	r3, r3, r0
   1643e:	189b      	adds	r3, r3, r2
   16440:	2200      	movs	r2, #0
   16442:	339c      	adds	r3, #156	; 0x9c
   16444:	701a      	strb	r2, [r3, #0]
   16446:	e7f1      	b.n	1642c <prvTraceSetTaskInstanceFinished+0x14>
   16448:	20000c04 	.word	0x20000c04
   1644c:	000299f8 	.word	0x000299f8
   16450:	00016121 	.word	0x00016121
   16454:	000162a9 	.word	0x000162a9

00016458 <prvTraceGetObjectHandle>:
{
   16458:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	TRACE_ASSERT(RecorderDataPtr != NULL, "Recorder not initialized, call vTraceEnable() first!", (traceHandle)0);
   1645a:	4b2a      	ldr	r3, [pc, #168]	; (16504 <prvTraceGetObjectHandle+0xac>)
   1645c:	681c      	ldr	r4, [r3, #0]
   1645e:	2c00      	cmp	r4, #0
   16460:	d105      	bne.n	1646e <prvTraceGetObjectHandle+0x16>
   16462:	4829      	ldr	r0, [pc, #164]	; (16508 <prvTraceGetObjectHandle+0xb0>)
	TRACE_ASSERT(objectclass < TRACE_NCLASSES, 
   16464:	4b29      	ldr	r3, [pc, #164]	; (1650c <prvTraceGetObjectHandle+0xb4>)
   16466:	4798      	blx	r3
   16468:	2100      	movs	r1, #0
}
   1646a:	0008      	movs	r0, r1
   1646c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	TRACE_ASSERT(objectclass < TRACE_NCLASSES, 
   1646e:	2808      	cmp	r0, #8
   16470:	d901      	bls.n	16476 <prvTraceGetObjectHandle+0x1e>
   16472:	4827      	ldr	r0, [pc, #156]	; (16510 <prvTraceGetObjectHandle+0xb8>)
   16474:	e7f6      	b.n	16464 <prvTraceGetObjectHandle+0xc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   16476:	f3ef 8310 	mrs	r3, PRIMASK
   1647a:	9301      	str	r3, [sp, #4]

    \param [in]    priMask  Priority Mask
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
   1647c:	2301      	movs	r3, #1
   1647e:	f383 8810 	msr	PRIMASK, r3
	trcCRITICAL_SECTION_BEGIN();
   16482:	4c24      	ldr	r4, [pc, #144]	; (16514 <prvTraceGetObjectHandle+0xbc>)
	indexOfHandle = objectHandleStacks.indexOfNextAvailableHandle[objectclass];
   16484:	0046      	lsls	r6, r0, #1
	trcCRITICAL_SECTION_BEGIN();
   16486:	6823      	ldr	r3, [r4, #0]
   16488:	3301      	adds	r3, #1
   1648a:	6023      	str	r3, [r4, #0]
	indexOfHandle = objectHandleStacks.indexOfNextAvailableHandle[objectclass];
   1648c:	4b22      	ldr	r3, [pc, #136]	; (16518 <prvTraceGetObjectHandle+0xc0>)
   1648e:	5af2      	ldrh	r2, [r6, r3]
	if (objectHandleStacks.objectHandles[indexOfHandle] == 0)
   16490:	189f      	adds	r7, r3, r2
   16492:	3748      	adds	r7, #72	; 0x48
   16494:	7839      	ldrb	r1, [r7, #0]
   16496:	2900      	cmp	r1, #0
   16498:	d10b      	bne.n	164b2 <prvTraceGetObjectHandle+0x5a>
			objectHandleStacks.lowestIndexOfClass[objectclass]);
   1649a:	2508      	movs	r5, #8
   1649c:	46ac      	mov	ip, r5
   1649e:	4484      	add	ip, r0
   164a0:	4665      	mov	r5, ip
   164a2:	006d      	lsls	r5, r5, #1
   164a4:	46ac      	mov	ip, r5
   164a6:	449c      	add	ip, r3
			(traceHandle)(1 + indexOfHandle -
   164a8:	4665      	mov	r5, ip
   164aa:	886d      	ldrh	r5, [r5, #2]
   164ac:	1c51      	adds	r1, r2, #1
   164ae:	1b49      	subs	r1, r1, r5
		objectHandleStacks.objectHandles[indexOfHandle] =
   164b0:	7039      	strb	r1, [r7, #0]
		> objectHandleStacks.highestIndexOfClass[objectclass])
   164b2:	0001      	movs	r1, r0
   164b4:	3110      	adds	r1, #16
   164b6:	0049      	lsls	r1, r1, #1
   164b8:	1859      	adds	r1, r3, r1
	if (objectHandleStacks.indexOfNextAvailableHandle[objectclass]
   164ba:	8889      	ldrh	r1, [r1, #4]
   164bc:	4291      	cmp	r1, r2
   164be:	d20b      	bcs.n	164d8 <prvTraceGetObjectHandle+0x80>
		prvTraceError(pszTraceGetErrorNotEnoughHandles(objectclass));
   164c0:	4b16      	ldr	r3, [pc, #88]	; (1651c <prvTraceGetObjectHandle+0xc4>)
   164c2:	4798      	blx	r3
   164c4:	4b11      	ldr	r3, [pc, #68]	; (1650c <prvTraceGetObjectHandle+0xb4>)
   164c6:	4798      	blx	r3
		handle = 0;
   164c8:	2100      	movs	r1, #0
	trcCRITICAL_SECTION_END();
   164ca:	6823      	ldr	r3, [r4, #0]
   164cc:	3b01      	subs	r3, #1
   164ce:	6023      	str	r3, [r4, #0]
   164d0:	9b01      	ldr	r3, [sp, #4]
   164d2:	f383 8810 	msr	PRIMASK, r3
	return handle;
   164d6:	e7c8      	b.n	1646a <prvTraceGetObjectHandle+0x12>
	handle = objectHandleStacks.objectHandles[indexOfHandle];
   164d8:	1899      	adds	r1, r3, r2
		objectHandleStacks.indexOfNextAvailableHandle[objectclass]++;
   164da:	3201      	adds	r2, #1
   164dc:	b292      	uxth	r2, r2
	handle = objectHandleStacks.objectHandles[indexOfHandle];
   164de:	3148      	adds	r1, #72	; 0x48
   164e0:	7809      	ldrb	r1, [r1, #0]
		objectHandleStacks.indexOfNextAvailableHandle[objectclass]++;
   164e2:	539a      	strh	r2, [r3, r6]
			objectHandleStacks.lowestIndexOfClass[objectclass];
   164e4:	0006      	movs	r6, r0
   164e6:	3608      	adds	r6, #8
   164e8:	0076      	lsls	r6, r6, #1
   164ea:	199e      	adds	r6, r3, r6
   164ec:	8876      	ldrh	r6, [r6, #2]
		hndCount = objectHandleStacks.indexOfNextAvailableHandle[objectclass] -
   164ee:	1b96      	subs	r6, r2, r6
			objectHandleStacks.handleCountWaterMarksOfClass[objectclass])
   164f0:	0002      	movs	r2, r0
   164f2:	3218      	adds	r2, #24
   164f4:	0052      	lsls	r2, r2, #1
   164f6:	189b      	adds	r3, r3, r2
   164f8:	88da      	ldrh	r2, [r3, #6]
		if (hndCount >
   164fa:	4296      	cmp	r6, r2
   164fc:	dde5      	ble.n	164ca <prvTraceGetObjectHandle+0x72>
				(traceHandle)hndCount;
   164fe:	b2f6      	uxtb	r6, r6
			objectHandleStacks.handleCountWaterMarksOfClass[objectclass] =
   16500:	80de      	strh	r6, [r3, #6]
   16502:	e7e2      	b.n	164ca <prvTraceGetObjectHandle+0x72>
   16504:	20000c04 	.word	0x20000c04
   16508:	00029ec0 	.word	0x00029ec0
   1650c:	00016121 	.word	0x00016121
   16510:	0002975a 	.word	0x0002975a
   16514:	20000cb4 	.word	0x20000cb4
   16518:	20000c20 	.word	0x20000c20
   1651c:	00015f15 	.word	0x00015f15

00016520 <prvTraceSetObjectName>:
{
   16520:	b570      	push	{r4, r5, r6, lr}
   16522:	0004      	movs	r4, r0
   16524:	0015      	movs	r5, r2
   16526:	0008      	movs	r0, r1
	TRACE_ASSERT(name != NULL, "prvTraceSetObjectName: name == NULL", TRC_UNUSED);
   16528:	2a00      	cmp	r2, #0
   1652a:	d103      	bne.n	16534 <prvTraceSetObjectName+0x14>
   1652c:	4813      	ldr	r0, [pc, #76]	; (1657c <prvTraceSetObjectName+0x5c>)
		prvTraceError("Illegal object class in prvTraceSetObjectName");
   1652e:	4b14      	ldr	r3, [pc, #80]	; (16580 <prvTraceSetObjectName+0x60>)
   16530:	4798      	blx	r3
}
   16532:	bd70      	pop	{r4, r5, r6, pc}
	if (objectclass >= TRACE_NCLASSES)
   16534:	2c08      	cmp	r4, #8
   16536:	d901      	bls.n	1653c <prvTraceSetObjectName+0x1c>
		prvTraceError("Illegal object class in prvTraceSetObjectName");
   16538:	4812      	ldr	r0, [pc, #72]	; (16584 <prvTraceSetObjectName+0x64>)
   1653a:	e7f8      	b.n	1652e <prvTraceSetObjectName+0xe>
	if (handle == 0)
   1653c:	2900      	cmp	r1, #0
   1653e:	d101      	bne.n	16544 <prvTraceSetObjectName+0x24>
		prvTraceError("Illegal handle (0) in prvTraceSetObjectName.");
   16540:	4811      	ldr	r0, [pc, #68]	; (16588 <prvTraceSetObjectName+0x68>)
   16542:	e7f4      	b.n	1652e <prvTraceSetObjectName+0xe>
	if (handle > RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass])
   16544:	4e11      	ldr	r6, [pc, #68]	; (1658c <prvTraceSetObjectName+0x6c>)
   16546:	6833      	ldr	r3, [r6, #0]
   16548:	191b      	adds	r3, r3, r4
   1654a:	3364      	adds	r3, #100	; 0x64
   1654c:	781b      	ldrb	r3, [r3, #0]
   1654e:	428b      	cmp	r3, r1
   16550:	d203      	bcs.n	1655a <prvTraceSetObjectName+0x3a>
		prvTraceError(pszTraceGetErrorNotEnoughHandles(objectclass));
   16552:	0020      	movs	r0, r4
   16554:	4b0e      	ldr	r3, [pc, #56]	; (16590 <prvTraceSetObjectName+0x70>)
   16556:	4798      	blx	r3
   16558:	e7e9      	b.n	1652e <prvTraceSetObjectName+0xe>
		idx = uiIndexOfObject(handle, objectclass);
   1655a:	4b0e      	ldr	r3, [pc, #56]	; (16594 <prvTraceSetObjectName+0x74>)
   1655c:	0021      	movs	r1, r4
   1655e:	4798      	blx	r3
		if (traceErrorMessage == NULL)
   16560:	4b0d      	ldr	r3, [pc, #52]	; (16598 <prvTraceSetObjectName+0x78>)
   16562:	681b      	ldr	r3, [r3, #0]
   16564:	2b00      	cmp	r3, #0
   16566:	d1e4      	bne.n	16532 <prvTraceSetObjectName+0x12>
			prvStrncpy((char*)&(RecorderDataPtr->ObjectPropertyTable.objbytes[idx]),
   16568:	6833      	ldr	r3, [r6, #0]
   1656a:	309c      	adds	r0, #156	; 0x9c
				RecorderDataPtr->ObjectPropertyTable.NameLengthPerClass[ objectclass ]);
   1656c:	191c      	adds	r4, r3, r4
   1656e:	3470      	adds	r4, #112	; 0x70
			prvStrncpy((char*)&(RecorderDataPtr->ObjectPropertyTable.objbytes[idx]),
   16570:	1818      	adds	r0, r3, r0
   16572:	7822      	ldrb	r2, [r4, #0]
   16574:	0029      	movs	r1, r5
   16576:	4b09      	ldr	r3, [pc, #36]	; (1659c <prvTraceSetObjectName+0x7c>)
   16578:	4798      	blx	r3
   1657a:	e7da      	b.n	16532 <prvTraceSetObjectName+0x12>
   1657c:	00029863 	.word	0x00029863
   16580:	00016121 	.word	0x00016121
   16584:	00029895 	.word	0x00029895
   16588:	000298c3 	.word	0x000298c3
   1658c:	20000c04 	.word	0x20000c04
   16590:	00015f15 	.word	0x00015f15
   16594:	000162a9 	.word	0x000162a9
   16598:	20000cbc 	.word	0x20000cbc
   1659c:	00015f2d 	.word	0x00015f2d

000165a0 <prvTracePortGetTimeStamp>:
 * or the trace recorder library. Typically you should not need to change
 * the code of prvTracePortGetTimeStamp if using the HWTC macros.
 *
 ******************************************************************************/
void prvTracePortGetTimeStamp(uint32_t *pTimestamp)
{
   165a0:	b5f0      	push	{r4, r5, r6, r7, lr}
	static uint32_t last_hwtc_rest = 0;
	uint32_t diff = 0;
	uint32_t diff_scaled = 0;
#endif /*TRC_HWTC_TYPE == TRC_OS_TIMER_INCR || TRC_HWTC_TYPE == TRC_OS_TIMER_DECR*/

	if (trace_disable_timestamp == 1)
   165a2:	4b1e      	ldr	r3, [pc, #120]	; (1661c <prvTracePortGetTimeStamp+0x7c>)
   165a4:	681b      	ldr	r3, [r3, #0]
   165a6:	2b01      	cmp	r3, #1
   165a8:	d105      	bne.n	165b6 <prvTracePortGetTimeStamp+0x16>
	{
		if (pTimestamp)
   165aa:	2800      	cmp	r0, #0
   165ac:	d002      	beq.n	165b4 <prvTracePortGetTimeStamp+0x14>
			*pTimestamp = last_timestamp;
   165ae:	4b1c      	ldr	r3, [pc, #112]	; (16620 <prvTracePortGetTimeStamp+0x80>)
   165b0:	681b      	ldr	r3, [r3, #0]
   165b2:	6003      	str	r3, [r0, #0]
	if (pTimestamp)
		*pTimestamp = last_timestamp;

	/* Store the previous value */
	last_hwtc_count = hwtc_count;
}
   165b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	hwtc_count = (TRC_HWTC_PERIOD) - (TRC_HWTC_COUNT);
   165b6:	4b1b      	ldr	r3, [pc, #108]	; (16624 <prvTracePortGetTimeStamp+0x84>)
   165b8:	4a1b      	ldr	r2, [pc, #108]	; (16628 <prvTracePortGetTimeStamp+0x88>)
   165ba:	6819      	ldr	r1, [r3, #0]
   165bc:	6812      	ldr	r2, [r2, #0]
   165be:	3101      	adds	r1, #1
   165c0:	1a89      	subs	r1, r1, r2
	if (last_traceTickCount - uiTraceTickCount - 1 < 0x80000000)
   165c2:	4a1a      	ldr	r2, [pc, #104]	; (1662c <prvTracePortGetTimeStamp+0x8c>)
   165c4:	4d1a      	ldr	r5, [pc, #104]	; (16630 <prvTracePortGetTimeStamp+0x90>)
   165c6:	6812      	ldr	r2, [r2, #0]
   165c8:	682e      	ldr	r6, [r5, #0]
   165ca:	43d7      	mvns	r7, r2
   165cc:	42f7      	cmn	r7, r6
   165ce:	d523      	bpl.n	16618 <prvTracePortGetTimeStamp+0x78>
	if (traceTickCount == last_traceTickCount && hwtc_count < last_hwtc_count)
   165d0:	4296      	cmp	r6, r2
   165d2:	d105      	bne.n	165e0 <prvTracePortGetTimeStamp+0x40>
		traceTickCount++;
   165d4:	4c17      	ldr	r4, [pc, #92]	; (16634 <prvTracePortGetTimeStamp+0x94>)
   165d6:	6826      	ldr	r6, [r4, #0]
   165d8:	42b1      	cmp	r1, r6
   165da:	41b6      	sbcs	r6, r6
   165dc:	4276      	negs	r6, r6
   165de:	1992      	adds	r2, r2, r6
	if (pTimestamp)
   165e0:	2800      	cmp	r0, #0
   165e2:	d010      	beq.n	16606 <prvTracePortGetTimeStamp+0x66>
		last_timestamp = traceTickCount * ((TRC_HWTC_PERIOD) / (TRC_HWTC_DIVISOR));
   165e4:	681f      	ldr	r7, [r3, #0]
   165e6:	4e0e      	ldr	r6, [pc, #56]	; (16620 <prvTracePortGetTimeStamp+0x80>)
   165e8:	3701      	adds	r7, #1
   165ea:	08bf      	lsrs	r7, r7, #2
   165ec:	4357      	muls	r7, r2
   165ee:	6037      	str	r7, [r6, #0]
		last_timestamp += (hwtc_count + traceTickCount * ((TRC_HWTC_PERIOD) % (TRC_HWTC_DIVISOR))) / (TRC_HWTC_DIVISOR);
   165f0:	681b      	ldr	r3, [r3, #0]
   165f2:	3301      	adds	r3, #1
   165f4:	001c      	movs	r4, r3
   165f6:	2303      	movs	r3, #3
   165f8:	401c      	ands	r4, r3
   165fa:	0023      	movs	r3, r4
   165fc:	4353      	muls	r3, r2
   165fe:	185b      	adds	r3, r3, r1
   16600:	089b      	lsrs	r3, r3, #2
   16602:	19db      	adds	r3, r3, r7
   16604:	6033      	str	r3, [r6, #0]
	last_traceTickCount = traceTickCount;
   16606:	602a      	str	r2, [r5, #0]
	if (pTimestamp)
   16608:	2800      	cmp	r0, #0
   1660a:	d002      	beq.n	16612 <prvTracePortGetTimeStamp+0x72>
		*pTimestamp = last_timestamp;
   1660c:	4b04      	ldr	r3, [pc, #16]	; (16620 <prvTracePortGetTimeStamp+0x80>)
   1660e:	681b      	ldr	r3, [r3, #0]
   16610:	6003      	str	r3, [r0, #0]
	last_hwtc_count = hwtc_count;
   16612:	4b08      	ldr	r3, [pc, #32]	; (16634 <prvTracePortGetTimeStamp+0x94>)
   16614:	6019      	str	r1, [r3, #0]
   16616:	e7cd      	b.n	165b4 <prvTracePortGetTimeStamp+0x14>
	if (last_traceTickCount - uiTraceTickCount - 1 < 0x80000000)
   16618:	0032      	movs	r2, r6
   1661a:	e7db      	b.n	165d4 <prvTracePortGetTimeStamp+0x34>
   1661c:	20000cc0 	.word	0x20000cc0
   16620:	20000c18 	.word	0x20000c18
   16624:	e000e014 	.word	0xe000e014
   16628:	e000e018 	.word	0xe000e018
   1662c:	20000cc8 	.word	0x20000cc8
   16630:	20000c1c 	.word	0x20000c1c
   16634:	20000c14 	.word	0x20000c14

00016638 <prvTraceGetDTS>:
{
   16638:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t timestamp = 0;
   1663a:	2400      	movs	r4, #0
{
   1663c:	b085      	sub	sp, #20
   1663e:	0006      	movs	r6, r0
	uint32_t timestamp = 0;
   16640:	9403      	str	r4, [sp, #12]
	TRACE_ASSERT(param_maxDTS == 0xFF || param_maxDTS == 0xFFFF, "prvTraceGetDTS: Invalid value for param_maxDTS", 0);
   16642:	28ff      	cmp	r0, #255	; 0xff
   16644:	d008      	beq.n	16658 <prvTraceGetDTS+0x20>
   16646:	4b34      	ldr	r3, [pc, #208]	; (16718 <prvTraceGetDTS+0xe0>)
   16648:	4298      	cmp	r0, r3
   1664a:	d005      	beq.n	16658 <prvTraceGetDTS+0x20>
   1664c:	4833      	ldr	r0, [pc, #204]	; (1671c <prvTraceGetDTS+0xe4>)
   1664e:	4b34      	ldr	r3, [pc, #208]	; (16720 <prvTraceGetDTS+0xe8>)
   16650:	4798      	blx	r3
   16652:	0020      	movs	r0, r4
}
   16654:	b005      	add	sp, #20
   16656:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (RecorderDataPtr->frequency == 0)
   16658:	4d32      	ldr	r5, [pc, #200]	; (16724 <prvTraceGetDTS+0xec>)
   1665a:	682c      	ldr	r4, [r5, #0]
   1665c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1665e:	2b00      	cmp	r3, #0
   16660:	d105      	bne.n	1666e <prvTraceGetDTS+0x36>
		if (timestampFrequency != 0)
   16662:	4b31      	ldr	r3, [pc, #196]	; (16728 <prvTraceGetDTS+0xf0>)
   16664:	6818      	ldr	r0, [r3, #0]
   16666:	2800      	cmp	r0, #0
   16668:	d03b      	beq.n	166e2 <prvTraceGetDTS+0xaa>
			RecorderDataPtr->frequency = (TRC_HWTC_FREQ_HZ) / (TRC_HWTC_DIVISOR);		
   1666a:	0880      	lsrs	r0, r0, #2
   1666c:	6260      	str	r0, [r4, #36]	; 0x24
	prvTracePortGetTimeStamp(&timestamp);	
   1666e:	4b2f      	ldr	r3, [pc, #188]	; (1672c <prvTraceGetDTS+0xf4>)
   16670:	a803      	add	r0, sp, #12
   16672:	4798      	blx	r3
	dts = timestamp - old_timestamp;
   16674:	4a2e      	ldr	r2, [pc, #184]	; (16730 <prvTraceGetDTS+0xf8>)
	if (RecorderDataPtr->frequency > 0)
   16676:	682d      	ldr	r5, [r5, #0]
	dts = timestamp - old_timestamp;
   16678:	9b03      	ldr	r3, [sp, #12]
   1667a:	6811      	ldr	r1, [r2, #0]
	if (RecorderDataPtr->frequency > 0)
   1667c:	6a6f      	ldr	r7, [r5, #36]	; 0x24
	dts = timestamp - old_timestamp;
   1667e:	1a5c      	subs	r4, r3, r1
	old_timestamp = timestamp;
   16680:	6013      	str	r3, [r2, #0]
	if (RecorderDataPtr->frequency > 0)
   16682:	2f00      	cmp	r7, #0
   16684:	d039      	beq.n	166fa <prvTraceGetDTS+0xc2>
   16686:	6aab      	ldr	r3, [r5, #40]	; 0x28
   16688:	9301      	str	r3, [sp, #4]
		if (dts > RecorderDataPtr->frequency)
   1668a:	42bc      	cmp	r4, r7
   1668c:	d932      	bls.n	166f4 <prvTraceGetDTS+0xbc>
			RecorderDataPtr->absTimeLastEventSecond += dts / RecorderDataPtr->frequency;
   1668e:	0039      	movs	r1, r7
   16690:	4b28      	ldr	r3, [pc, #160]	; (16734 <prvTraceGetDTS+0xfc>)
   16692:	0020      	movs	r0, r4
   16694:	4798      	blx	r3
   16696:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
			RecorderDataPtr->absTimeLastEvent += dts % RecorderDataPtr->frequency;
   16698:	0039      	movs	r1, r7
			RecorderDataPtr->absTimeLastEventSecond += dts / RecorderDataPtr->frequency;
   1669a:	1818      	adds	r0, r3, r0
   1669c:	62e8      	str	r0, [r5, #44]	; 0x2c
			RecorderDataPtr->absTimeLastEvent += dts % RecorderDataPtr->frequency;
   1669e:	4b26      	ldr	r3, [pc, #152]	; (16738 <prvTraceGetDTS+0x100>)
   166a0:	0020      	movs	r0, r4
   166a2:	4798      	blx	r3
   166a4:	9b01      	ldr	r3, [sp, #4]
   166a6:	1859      	adds	r1, r3, r1
			RecorderDataPtr->absTimeLastEvent += dts;
   166a8:	62a9      	str	r1, [r5, #40]	; 0x28
		if (RecorderDataPtr->absTimeLastEvent >= RecorderDataPtr->frequency)
   166aa:	6aab      	ldr	r3, [r5, #40]	; 0x28
   166ac:	429f      	cmp	r7, r3
   166ae:	d804      	bhi.n	166ba <prvTraceGetDTS+0x82>
			RecorderDataPtr->absTimeLastEventSecond++;
   166b0:	6aea      	ldr	r2, [r5, #44]	; 0x2c
			RecorderDataPtr->absTimeLastEvent -= RecorderDataPtr->frequency;
   166b2:	1bdf      	subs	r7, r3, r7
			RecorderDataPtr->absTimeLastEventSecond++;
   166b4:	3201      	adds	r2, #1
   166b6:	62ea      	str	r2, [r5, #44]	; 0x2c
			RecorderDataPtr->absTimeLastEvent -= RecorderDataPtr->frequency;
   166b8:	62af      	str	r7, [r5, #40]	; 0x28
	if (dts > param_maxDTS)
   166ba:	42b4      	cmp	r4, r6
   166bc:	d90e      	bls.n	166dc <prvTraceGetDTS+0xa4>
		xts = (XTSEvent*) prvTraceNextFreeEventBufferSlot();
   166be:	4b1f      	ldr	r3, [pc, #124]	; (1673c <prvTraceGetDTS+0x104>)
   166c0:	4798      	blx	r3
		if (xts != NULL)
   166c2:	2800      	cmp	r0, #0
   166c4:	d00a      	beq.n	166dc <prvTraceGetDTS+0xa4>
			if (param_maxDTS == 0xFFFF)
   166c6:	4b14      	ldr	r3, [pc, #80]	; (16718 <prvTraceGetDTS+0xe0>)
   166c8:	429e      	cmp	r6, r3
   166ca:	d118      	bne.n	166fe <prvTraceGetDTS+0xc6>
				xts->type = XTS16;
   166cc:	23a9      	movs	r3, #169	; 0xa9
   166ce:	7003      	strb	r3, [r0, #0]
				xts->xts_16 = (uint16_t)((dts / 0x10000) & 0xFFFF);
   166d0:	0c23      	lsrs	r3, r4, #16
   166d2:	8043      	strh	r3, [r0, #2]
				xts->xts_8 = 0;
   166d4:	2300      	movs	r3, #0
				xts->xts_8 = (uint8_t)((dts / 0x1000000) & 0xFF);
   166d6:	7043      	strb	r3, [r0, #1]
			prvTraceUpdateCounters();
   166d8:	4b19      	ldr	r3, [pc, #100]	; (16740 <prvTraceGetDTS+0x108>)
   166da:	4798      	blx	r3
	return (uint16_t)dts & param_maxDTS;
   166dc:	0020      	movs	r0, r4
   166de:	4030      	ands	r0, r6
   166e0:	e7b8      	b.n	16654 <prvTraceGetDTS+0x1c>
		else if (init_hwtc_count != (TRC_HWTC_COUNT))
   166e2:	4b18      	ldr	r3, [pc, #96]	; (16744 <prvTraceGetDTS+0x10c>)
   166e4:	681a      	ldr	r2, [r3, #0]
   166e6:	4b18      	ldr	r3, [pc, #96]	; (16748 <prvTraceGetDTS+0x110>)
   166e8:	681b      	ldr	r3, [r3, #0]
   166ea:	429a      	cmp	r2, r3
   166ec:	d0bf      	beq.n	1666e <prvTraceGetDTS+0x36>
			RecorderDataPtr->frequency = (TRC_HWTC_FREQ_HZ) / (TRC_HWTC_DIVISOR);		
   166ee:	4b17      	ldr	r3, [pc, #92]	; (1674c <prvTraceGetDTS+0x114>)
   166f0:	4798      	blx	r3
   166f2:	e7ba      	b.n	1666a <prvTraceGetDTS+0x32>
			RecorderDataPtr->absTimeLastEvent += dts;
   166f4:	9b01      	ldr	r3, [sp, #4]
   166f6:	1919      	adds	r1, r3, r4
   166f8:	e7d6      	b.n	166a8 <prvTraceGetDTS+0x70>
		RecorderDataPtr->absTimeLastEvent = timestamp;
   166fa:	62ab      	str	r3, [r5, #40]	; 0x28
   166fc:	e7dd      	b.n	166ba <prvTraceGetDTS+0x82>
			else if (param_maxDTS == 0xFF)
   166fe:	2eff      	cmp	r6, #255	; 0xff
   16700:	d105      	bne.n	1670e <prvTraceGetDTS+0xd6>
				xts->type = XTS8;
   16702:	23a8      	movs	r3, #168	; 0xa8
   16704:	7003      	strb	r3, [r0, #0]
				xts->xts_16 = (uint16_t)((dts / 0x100) & 0xFFFF);
   16706:	0a23      	lsrs	r3, r4, #8
   16708:	8043      	strh	r3, [r0, #2]
				xts->xts_8 = (uint8_t)((dts / 0x1000000) & 0xFF);
   1670a:	0e23      	lsrs	r3, r4, #24
   1670c:	e7e3      	b.n	166d6 <prvTraceGetDTS+0x9e>
				prvTraceError("Bad param_maxDTS in prvTraceGetDTS");
   1670e:	4810      	ldr	r0, [pc, #64]	; (16750 <prvTraceGetDTS+0x118>)
   16710:	4b03      	ldr	r3, [pc, #12]	; (16720 <prvTraceGetDTS+0xe8>)
   16712:	4798      	blx	r3
   16714:	e7e0      	b.n	166d8 <prvTraceGetDTS+0xa0>
   16716:	46c0      	nop			; (mov r8, r8)
   16718:	0000ffff 	.word	0x0000ffff
   1671c:	000296fa 	.word	0x000296fa
   16720:	00016121 	.word	0x00016121
   16724:	20000c04 	.word	0x20000c04
   16728:	20000cb8 	.word	0x20000cb8
   1672c:	000165a1 	.word	0x000165a1
   16730:	20000cb0 	.word	0x20000cb0
   16734:	000258bd 	.word	0x000258bd
   16738:	000259c9 	.word	0x000259c9
   1673c:	00016171 	.word	0x00016171
   16740:	00016241 	.word	0x00016241
   16744:	e000e018 	.word	0xe000e018
   16748:	20005048 	.word	0x20005048
   1674c:	0001e729 	.word	0x0001e729
   16750:	00029737 	.word	0x00029737

00016754 <prvTraceStoreTaskReady>:
{
   16754:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16756:	1e05      	subs	r5, r0, #0
	if (handle == 0)
   16758:	d00d      	beq.n	16776 <prvTraceStoreTaskReady+0x22>
	if (! readyEventsEnabled)
   1675a:	4b18      	ldr	r3, [pc, #96]	; (167bc <prvTraceStoreTaskReady+0x68>)
   1675c:	681b      	ldr	r3, [r3, #0]
   1675e:	2b00      	cmp	r3, #0
   16760:	d009      	beq.n	16776 <prvTraceStoreTaskReady+0x22>
	TRACE_ASSERT(handle <= (TRC_CFG_NTASK), "prvTraceStoreTaskReady: Invalid value for handle", TRC_UNUSED);
   16762:	4817      	ldr	r0, [pc, #92]	; (167c0 <prvTraceStoreTaskReady+0x6c>)
   16764:	2d0f      	cmp	r5, #15
   16766:	d804      	bhi.n	16772 <prvTraceStoreTaskReady+0x1e>
	if (recorder_busy)
   16768:	4c16      	ldr	r4, [pc, #88]	; (167c4 <prvTraceStoreTaskReady+0x70>)
   1676a:	6823      	ldr	r3, [r4, #0]
   1676c:	2b00      	cmp	r3, #0
   1676e:	d003      	beq.n	16778 <prvTraceStoreTaskReady+0x24>
		prvTraceError("Recorder busy - high priority ISR using syscall? (1)");
   16770:	4815      	ldr	r0, [pc, #84]	; (167c8 <prvTraceStoreTaskReady+0x74>)
   16772:	4b16      	ldr	r3, [pc, #88]	; (167cc <prvTraceStoreTaskReady+0x78>)
   16774:	4798      	blx	r3
}
   16776:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   16778:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
   1677c:	2301      	movs	r3, #1
   1677e:	f383 8810 	msr	PRIMASK, r3
	trcCRITICAL_SECTION_BEGIN();
   16782:	6823      	ldr	r3, [r4, #0]
   16784:	3301      	adds	r3, #1
   16786:	6023      	str	r3, [r4, #0]
	if (RecorderDataPtr->recorderActive) /* Need to repeat this check! */
   16788:	4b11      	ldr	r3, [pc, #68]	; (167d0 <prvTraceStoreTaskReady+0x7c>)
   1678a:	681b      	ldr	r3, [r3, #0]
   1678c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   1678e:	2b00      	cmp	r3, #0
   16790:	d00d      	beq.n	167ae <prvTraceStoreTaskReady+0x5a>
		dts3 = (uint16_t)prvTraceGetDTS(0xFFFF);
   16792:	4b10      	ldr	r3, [pc, #64]	; (167d4 <prvTraceStoreTaskReady+0x80>)
   16794:	4810      	ldr	r0, [pc, #64]	; (167d8 <prvTraceStoreTaskReady+0x84>)
   16796:	4798      	blx	r3
		tr = (TREvent*)prvTraceNextFreeEventBufferSlot();
   16798:	4b10      	ldr	r3, [pc, #64]	; (167dc <prvTraceStoreTaskReady+0x88>)
		dts3 = (uint16_t)prvTraceGetDTS(0xFFFF);
   1679a:	0007      	movs	r7, r0
		tr = (TREvent*)prvTraceNextFreeEventBufferSlot();
   1679c:	4798      	blx	r3
		if (tr != NULL)
   1679e:	2800      	cmp	r0, #0
   167a0:	d005      	beq.n	167ae <prvTraceStoreTaskReady+0x5a>
			tr->type = DIV_TASK_READY;
   167a2:	2302      	movs	r3, #2
			tr->dts = dts3;
   167a4:	8047      	strh	r7, [r0, #2]
			tr->type = DIV_TASK_READY;
   167a6:	7003      	strb	r3, [r0, #0]
			tr->objHandle = hnd8;
   167a8:	7045      	strb	r5, [r0, #1]
			prvTraceUpdateCounters();
   167aa:	4b0d      	ldr	r3, [pc, #52]	; (167e0 <prvTraceStoreTaskReady+0x8c>)
   167ac:	4798      	blx	r3
	trcCRITICAL_SECTION_END();
   167ae:	6823      	ldr	r3, [r4, #0]
   167b0:	3b01      	subs	r3, #1
   167b2:	6023      	str	r3, [r4, #0]
   167b4:	f386 8810 	msr	PRIMASK, r6
   167b8:	e7dd      	b.n	16776 <prvTraceStoreTaskReady+0x22>
   167ba:	46c0      	nop			; (mov r8, r8)
   167bc:	200001f4 	.word	0x200001f4
   167c0:	00029cd1 	.word	0x00029cd1
   167c4:	20000cb4 	.word	0x20000cb4
   167c8:	00029d10 	.word	0x00029d10
   167cc:	00016121 	.word	0x00016121
   167d0:	20000c04 	.word	0x20000c04
   167d4:	00016639 	.word	0x00016639
   167d8:	0000ffff 	.word	0x0000ffff
   167dc:	00016171 	.word	0x00016171
   167e0:	00016241 	.word	0x00016241

000167e4 <vTraceStoreMemMangEvent>:
{
   167e4:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (RecorderDataPtr == NULL)
   167e6:	4f2c      	ldr	r7, [pc, #176]	; (16898 <vTraceStoreMemMangEvent+0xb4>)
{
   167e8:	b085      	sub	sp, #20
	if (RecorderDataPtr == NULL)
   167ea:	683b      	ldr	r3, [r7, #0]
{
   167ec:	9002      	str	r0, [sp, #8]
   167ee:	000d      	movs	r5, r1
	if (RecorderDataPtr == NULL)
   167f0:	2b00      	cmp	r3, #0
   167f2:	d04f      	beq.n	16894 <vTraceStoreMemMangEvent+0xb0>
		size = (uint32_t)(- signed_size);
   167f4:	17d3      	asrs	r3, r2, #31
   167f6:	18d6      	adds	r6, r2, r3
   167f8:	405e      	eors	r6, r3
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   167fa:	f3ef 8310 	mrs	r3, PRIMASK
   167fe:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
   16800:	2301      	movs	r3, #1
   16802:	f383 8810 	msr	PRIMASK, r3
	trcCRITICAL_SECTION_BEGIN();
   16806:	4c25      	ldr	r4, [pc, #148]	; (1689c <vTraceStoreMemMangEvent+0xb8>)
   16808:	6823      	ldr	r3, [r4, #0]
   1680a:	3301      	adds	r3, #1
   1680c:	6023      	str	r3, [r4, #0]
	if (address != 0)
   1680e:	2900      	cmp	r1, #0
   16810:	d003      	beq.n	1681a <vTraceStoreMemMangEvent+0x36>
		heapMemUsage += (uint32_t)signed_size;
   16812:	4b23      	ldr	r3, [pc, #140]	; (168a0 <vTraceStoreMemMangEvent+0xbc>)
   16814:	6819      	ldr	r1, [r3, #0]
   16816:	188a      	adds	r2, r1, r2
   16818:	601a      	str	r2, [r3, #0]
	if (RecorderDataPtr->recorderActive)
   1681a:	683b      	ldr	r3, [r7, #0]
   1681c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   1681e:	2b00      	cmp	r3, #0
   16820:	d032      	beq.n	16888 <vTraceStoreMemMangEvent+0xa4>
		dts1 = (uint8_t)prvTraceGetDTS(0xFF);
   16822:	4b20      	ldr	r3, [pc, #128]	; (168a4 <vTraceStoreMemMangEvent+0xc0>)
   16824:	20ff      	movs	r0, #255	; 0xff
   16826:	4798      	blx	r3
	if (param <= param_max)
   16828:	4b1f      	ldr	r3, [pc, #124]	; (168a8 <vTraceStoreMemMangEvent+0xc4>)
		dts1 = (uint8_t)prvTraceGetDTS(0xFF);
   1682a:	9003      	str	r0, [sp, #12]
	if (param <= param_max)
   1682c:	429e      	cmp	r6, r3
   1682e:	d904      	bls.n	1683a <vTraceStoreMemMangEvent+0x56>
   16830:	0031      	movs	r1, r6
   16832:	0018      	movs	r0, r3
   16834:	4b1d      	ldr	r3, [pc, #116]	; (168ac <vTraceStoreMemMangEvent+0xc8>)
   16836:	4798      	blx	r3
   16838:	0006      	movs	r6, r0
		ms = (MemEventSize *)prvTraceNextFreeEventBufferSlot();
   1683a:	4b1d      	ldr	r3, [pc, #116]	; (168b0 <vTraceStoreMemMangEvent+0xcc>)
   1683c:	4798      	blx	r3
   1683e:	9000      	str	r0, [sp, #0]
		if (ms != NULL)
   16840:	2800      	cmp	r0, #0
   16842:	d021      	beq.n	16888 <vTraceStoreMemMangEvent+0xa4>
			ms->dts = dts1;
   16844:	466a      	mov	r2, sp
			ms->type = NULL_EVENT; /* Updated when all events are written */
   16846:	2300      	movs	r3, #0
			ms->dts = dts1;
   16848:	7b12      	ldrb	r2, [r2, #12]
			ms->type = NULL_EVENT; /* Updated when all events are written */
   1684a:	7003      	strb	r3, [r0, #0]
			ms->size = size_low;
   1684c:	8046      	strh	r6, [r0, #2]
			ms->dts = dts1;
   1684e:	7042      	strb	r2, [r0, #1]
			prvTraceUpdateCounters();
   16850:	4e18      	ldr	r6, [pc, #96]	; (168b4 <vTraceStoreMemMangEvent+0xd0>)
   16852:	47b0      	blx	r6
	if (param <= param_max)
   16854:	4b14      	ldr	r3, [pc, #80]	; (168a8 <vTraceStoreMemMangEvent+0xc4>)
   16856:	429d      	cmp	r5, r3
   16858:	d904      	bls.n	16864 <vTraceStoreMemMangEvent+0x80>
   1685a:	0029      	movs	r1, r5
   1685c:	0018      	movs	r0, r3
   1685e:	4b13      	ldr	r3, [pc, #76]	; (168ac <vTraceStoreMemMangEvent+0xc8>)
   16860:	4798      	blx	r3
   16862:	0005      	movs	r5, r0
			ma = (MemEventAddr *) prvTraceNextFreeEventBufferSlot();
   16864:	4b12      	ldr	r3, [pc, #72]	; (168b0 <vTraceStoreMemMangEvent+0xcc>)
   16866:	4798      	blx	r3
			if (ma != NULL)
   16868:	2800      	cmp	r0, #0
   1686a:	d00d      	beq.n	16888 <vTraceStoreMemMangEvent+0xa4>
				ma->addr_high = addr_high;
   1686c:	2300      	movs	r3, #0
   1686e:	7043      	strb	r3, [r0, #1]
				ma->type = (uint8_t) (ecode  + 1); /* Note this! */
   16870:	466b      	mov	r3, sp
   16872:	7a1b      	ldrb	r3, [r3, #8]
				ma->addr_low = addr_low;
   16874:	8045      	strh	r5, [r0, #2]
				ma->type = (uint8_t) (ecode  + 1); /* Note this! */
   16876:	1c5a      	adds	r2, r3, #1
   16878:	7002      	strb	r2, [r0, #0]
				ms->type = (uint8_t) ecode;
   1687a:	9a00      	ldr	r2, [sp, #0]
   1687c:	7013      	strb	r3, [r2, #0]
				prvTraceUpdateCounters();					
   1687e:	47b0      	blx	r6
				RecorderDataPtr->heapMemUsage = heapMemUsage;
   16880:	4a07      	ldr	r2, [pc, #28]	; (168a0 <vTraceStoreMemMangEvent+0xbc>)
   16882:	683b      	ldr	r3, [r7, #0]
   16884:	6812      	ldr	r2, [r2, #0]
   16886:	651a      	str	r2, [r3, #80]	; 0x50
	trcCRITICAL_SECTION_END();
   16888:	6823      	ldr	r3, [r4, #0]
   1688a:	3b01      	subs	r3, #1
   1688c:	6023      	str	r3, [r4, #0]
   1688e:	9b01      	ldr	r3, [sp, #4]
   16890:	f383 8810 	msr	PRIMASK, r3
}
   16894:	b005      	add	sp, #20
   16896:	bdf0      	pop	{r4, r5, r6, r7, pc}
   16898:	20000c04 	.word	0x20000c04
   1689c:	20000cb4 	.word	0x20000cb4
   168a0:	20000c0c 	.word	0x20000c0c
   168a4:	00016639 	.word	0x00016639
   168a8:	0000ffff 	.word	0x0000ffff
   168ac:	00016279 	.word	0x00016279
   168b0:	00016171 	.word	0x00016171
   168b4:	00016241 	.word	0x00016241

000168b8 <prvTraceStoreKernelCall>:
{
   168b8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   168ba:	0005      	movs	r5, r0
   168bc:	0017      	movs	r7, r2
	TRACE_ASSERT(ecode < 0xFF, "prvTraceStoreKernelCall: ecode >= 0xFF", TRC_UNUSED);
   168be:	481d      	ldr	r0, [pc, #116]	; (16934 <prvTraceStoreKernelCall+0x7c>)
   168c0:	2dfe      	cmp	r5, #254	; 0xfe
   168c2:	d802      	bhi.n	168ca <prvTraceStoreKernelCall+0x12>
	TRACE_ASSERT(objectClass < TRACE_NCLASSES, "prvTraceStoreKernelCall: objectClass >= TRACE_NCLASSES", TRC_UNUSED);
   168c4:	2908      	cmp	r1, #8
   168c6:	d903      	bls.n	168d0 <prvTraceStoreKernelCall+0x18>
   168c8:	481b      	ldr	r0, [pc, #108]	; (16938 <prvTraceStoreKernelCall+0x80>)
   168ca:	4b1c      	ldr	r3, [pc, #112]	; (1693c <prvTraceStoreKernelCall+0x84>)
   168cc:	4798      	blx	r3
}
   168ce:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
	TRACE_ASSERT(objectNumber <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectClass], "prvTraceStoreKernelCall: Invalid value for objectNumber", TRC_UNUSED);
   168d0:	4a1b      	ldr	r2, [pc, #108]	; (16940 <prvTraceStoreKernelCall+0x88>)
   168d2:	481c      	ldr	r0, [pc, #112]	; (16944 <prvTraceStoreKernelCall+0x8c>)
   168d4:	6813      	ldr	r3, [r2, #0]
   168d6:	1859      	adds	r1, r3, r1
   168d8:	3164      	adds	r1, #100	; 0x64
   168da:	780b      	ldrb	r3, [r1, #0]
   168dc:	42bb      	cmp	r3, r7
   168de:	d3f4      	bcc.n	168ca <prvTraceStoreKernelCall+0x12>
	if (recorder_busy)
   168e0:	4c19      	ldr	r4, [pc, #100]	; (16948 <prvTraceStoreKernelCall+0x90>)
		prvTraceError("Recorder busy - high priority ISR using syscall? (2)");
   168e2:	481a      	ldr	r0, [pc, #104]	; (1694c <prvTraceStoreKernelCall+0x94>)
	if (recorder_busy)
   168e4:	6823      	ldr	r3, [r4, #0]
   168e6:	2b00      	cmp	r3, #0
   168e8:	d1ef      	bne.n	168ca <prvTraceStoreKernelCall+0x12>
	if (handle_of_last_logged_task == 0)
   168ea:	4b19      	ldr	r3, [pc, #100]	; (16950 <prvTraceStoreKernelCall+0x98>)
   168ec:	781b      	ldrb	r3, [r3, #0]
   168ee:	2b00      	cmp	r3, #0
   168f0:	d0ed      	beq.n	168ce <prvTraceStoreKernelCall+0x16>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   168f2:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
   168f6:	2301      	movs	r3, #1
   168f8:	f383 8810 	msr	PRIMASK, r3
	trcCRITICAL_SECTION_BEGIN();
   168fc:	6823      	ldr	r3, [r4, #0]
   168fe:	3301      	adds	r3, #1
   16900:	6023      	str	r3, [r4, #0]
	if (RecorderDataPtr->recorderActive)
   16902:	6813      	ldr	r3, [r2, #0]
   16904:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   16906:	2b00      	cmp	r3, #0
   16908:	d00e      	beq.n	16928 <prvTraceStoreKernelCall+0x70>
		dts1 = (uint16_t)prvTraceGetDTS(0xFFFF);
   1690a:	4b12      	ldr	r3, [pc, #72]	; (16954 <prvTraceStoreKernelCall+0x9c>)
   1690c:	4812      	ldr	r0, [pc, #72]	; (16958 <prvTraceStoreKernelCall+0xa0>)
   1690e:	4798      	blx	r3
		kse = (KernelCall*) prvTraceNextFreeEventBufferSlot();
   16910:	4b12      	ldr	r3, [pc, #72]	; (1695c <prvTraceStoreKernelCall+0xa4>)
		dts1 = (uint16_t)prvTraceGetDTS(0xFFFF);
   16912:	9001      	str	r0, [sp, #4]
		kse = (KernelCall*) prvTraceNextFreeEventBufferSlot();
   16914:	4798      	blx	r3
		if (kse != NULL)
   16916:	2800      	cmp	r0, #0
   16918:	d006      	beq.n	16928 <prvTraceStoreKernelCall+0x70>
			kse->dts = dts1;
   1691a:	466b      	mov	r3, sp
   1691c:	889b      	ldrh	r3, [r3, #4]
			kse->type = (uint8_t)ecode;
   1691e:	7005      	strb	r5, [r0, #0]
			kse->dts = dts1;
   16920:	8043      	strh	r3, [r0, #2]
			kse->objHandle = hnd8;
   16922:	7047      	strb	r7, [r0, #1]
			prvTraceUpdateCounters();
   16924:	4b0e      	ldr	r3, [pc, #56]	; (16960 <prvTraceStoreKernelCall+0xa8>)
   16926:	4798      	blx	r3
	trcCRITICAL_SECTION_END();
   16928:	6823      	ldr	r3, [r4, #0]
   1692a:	3b01      	subs	r3, #1
   1692c:	6023      	str	r3, [r4, #0]
   1692e:	f386 8810 	msr	PRIMASK, r6
   16932:	e7cc      	b.n	168ce <prvTraceStoreKernelCall+0x16>
   16934:	00029a40 	.word	0x00029a40
   16938:	00029a75 	.word	0x00029a75
   1693c:	00016121 	.word	0x00016121
   16940:	20000c04 	.word	0x20000c04
   16944:	00029aba 	.word	0x00029aba
   16948:	20000cb4 	.word	0x20000cb4
   1694c:	00029b00 	.word	0x00029b00
   16950:	20000c08 	.word	0x20000c08
   16954:	00016639 	.word	0x00016639
   16958:	0000ffff 	.word	0x0000ffff
   1695c:	00016171 	.word	0x00016171
   16960:	00016241 	.word	0x00016241

00016964 <prvTraceStoreKernelCallWithParam>:
{
   16964:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   16966:	0006      	movs	r6, r0
   16968:	9200      	str	r2, [sp, #0]
   1696a:	001d      	movs	r5, r3
	TRACE_ASSERT(evtcode < 0xFF, "prvTraceStoreKernelCallWithParam: evtcode >= 0xFF", TRC_UNUSED);
   1696c:	4822      	ldr	r0, [pc, #136]	; (169f8 <prvTraceStoreKernelCallWithParam+0x94>)
   1696e:	2efe      	cmp	r6, #254	; 0xfe
   16970:	d810      	bhi.n	16994 <prvTraceStoreKernelCallWithParam+0x30>
	TRACE_ASSERT(objectClass < TRACE_NCLASSES, "prvTraceStoreKernelCallWithParam: objectClass >= TRACE_NCLASSES", TRC_UNUSED);
   16972:	4822      	ldr	r0, [pc, #136]	; (169fc <prvTraceStoreKernelCallWithParam+0x98>)
   16974:	2908      	cmp	r1, #8
   16976:	d80d      	bhi.n	16994 <prvTraceStoreKernelCallWithParam+0x30>
	TRACE_ASSERT(objectNumber <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectClass], "prvTraceStoreKernelCallWithParam: Invalid value for objectNumber", TRC_UNUSED);
   16978:	4a21      	ldr	r2, [pc, #132]	; (16a00 <prvTraceStoreKernelCallWithParam+0x9c>)
   1697a:	4822      	ldr	r0, [pc, #136]	; (16a04 <prvTraceStoreKernelCallWithParam+0xa0>)
   1697c:	6813      	ldr	r3, [r2, #0]
   1697e:	1859      	adds	r1, r3, r1
   16980:	3164      	adds	r1, #100	; 0x64
   16982:	780b      	ldrb	r3, [r1, #0]
   16984:	9900      	ldr	r1, [sp, #0]
   16986:	428b      	cmp	r3, r1
   16988:	d304      	bcc.n	16994 <prvTraceStoreKernelCallWithParam+0x30>
	if (recorder_busy)
   1698a:	4c1f      	ldr	r4, [pc, #124]	; (16a08 <prvTraceStoreKernelCallWithParam+0xa4>)
   1698c:	6823      	ldr	r3, [r4, #0]
   1698e:	2b00      	cmp	r3, #0
   16990:	d003      	beq.n	1699a <prvTraceStoreKernelCallWithParam+0x36>
		prvTraceError("Recorder busy - high priority ISR using syscall? (3)");
   16992:	481e      	ldr	r0, [pc, #120]	; (16a0c <prvTraceStoreKernelCallWithParam+0xa8>)
   16994:	4b1e      	ldr	r3, [pc, #120]	; (16a10 <prvTraceStoreKernelCallWithParam+0xac>)
   16996:	4798      	blx	r3
}
   16998:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   1699a:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
   1699e:	2301      	movs	r3, #1
   169a0:	f383 8810 	msr	PRIMASK, r3
	trcCRITICAL_SECTION_BEGIN();
   169a4:	6823      	ldr	r3, [r4, #0]
   169a6:	3301      	adds	r3, #1
   169a8:	6023      	str	r3, [r4, #0]
	if (RecorderDataPtr->recorderActive && handle_of_last_logged_task)
   169aa:	6813      	ldr	r3, [r2, #0]
   169ac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   169ae:	2b00      	cmp	r3, #0
   169b0:	d01c      	beq.n	169ec <prvTraceStoreKernelCallWithParam+0x88>
   169b2:	4b18      	ldr	r3, [pc, #96]	; (16a14 <prvTraceStoreKernelCallWithParam+0xb0>)
   169b4:	781b      	ldrb	r3, [r3, #0]
   169b6:	2b00      	cmp	r3, #0
   169b8:	d018      	beq.n	169ec <prvTraceStoreKernelCallWithParam+0x88>
		dts2 = (uint8_t)prvTraceGetDTS(0xFF);
   169ba:	20ff      	movs	r0, #255	; 0xff
   169bc:	4b16      	ldr	r3, [pc, #88]	; (16a18 <prvTraceStoreKernelCallWithParam+0xb4>)
   169be:	4798      	blx	r3
   169c0:	9001      	str	r0, [sp, #4]
	if (param <= param_max)
   169c2:	2dff      	cmp	r5, #255	; 0xff
   169c4:	d904      	bls.n	169d0 <prvTraceStoreKernelCallWithParam+0x6c>
   169c6:	0029      	movs	r1, r5
   169c8:	20ff      	movs	r0, #255	; 0xff
   169ca:	4b14      	ldr	r3, [pc, #80]	; (16a1c <prvTraceStoreKernelCallWithParam+0xb8>)
   169cc:	4798      	blx	r3
   169ce:	0005      	movs	r5, r0
		kse = (KernelCallWithParamAndHandle*) prvTraceNextFreeEventBufferSlot();
   169d0:	4b13      	ldr	r3, [pc, #76]	; (16a20 <prvTraceStoreKernelCallWithParam+0xbc>)
   169d2:	4798      	blx	r3
		if (kse != NULL)
   169d4:	2800      	cmp	r0, #0
   169d6:	d009      	beq.n	169ec <prvTraceStoreKernelCallWithParam+0x88>
			kse->dts = dts2;
   169d8:	466b      	mov	r3, sp
   169da:	791b      	ldrb	r3, [r3, #4]
			kse->type = (uint8_t)evtcode;
   169dc:	7006      	strb	r6, [r0, #0]
			kse->dts = dts2;
   169de:	70c3      	strb	r3, [r0, #3]
			kse->objHandle = hnd8;
   169e0:	466b      	mov	r3, sp
   169e2:	781b      	ldrb	r3, [r3, #0]
			kse->param = p8;
   169e4:	7085      	strb	r5, [r0, #2]
			kse->objHandle = hnd8;
   169e6:	7043      	strb	r3, [r0, #1]
			prvTraceUpdateCounters();
   169e8:	4b0e      	ldr	r3, [pc, #56]	; (16a24 <prvTraceStoreKernelCallWithParam+0xc0>)
   169ea:	4798      	blx	r3
	trcCRITICAL_SECTION_END();
   169ec:	6823      	ldr	r3, [r4, #0]
   169ee:	3b01      	subs	r3, #1
   169f0:	6023      	str	r3, [r4, #0]
   169f2:	f387 8810 	msr	PRIMASK, r7
   169f6:	e7cf      	b.n	16998 <prvTraceStoreKernelCallWithParam+0x34>
   169f8:	00029bbf 	.word	0x00029bbf
   169fc:	00029bff 	.word	0x00029bff
   16a00:	20000c04 	.word	0x20000c04
   16a04:	00029c4d 	.word	0x00029c4d
   16a08:	20000cb4 	.word	0x20000cb4
   16a0c:	00029c9c 	.word	0x00029c9c
   16a10:	00016121 	.word	0x00016121
   16a14:	20000c08 	.word	0x20000c08
   16a18:	00016639 	.word	0x00016639
   16a1c:	00016279 	.word	0x00016279
   16a20:	00016171 	.word	0x00016171
   16a24:	00016241 	.word	0x00016241

00016a28 <prvTraceStoreKernelCallWithNumericParamOnly>:
{
   16a28:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   16a2a:	0006      	movs	r6, r0
   16a2c:	000d      	movs	r5, r1
	TRACE_ASSERT(evtcode < 0xFF, "prvTraceStoreKernelCallWithNumericParamOnly: Invalid value for evtcode", TRC_UNUSED);
   16a2e:	481c      	ldr	r0, [pc, #112]	; (16aa0 <prvTraceStoreKernelCallWithNumericParamOnly+0x78>)
   16a30:	2efe      	cmp	r6, #254	; 0xfe
   16a32:	d804      	bhi.n	16a3e <prvTraceStoreKernelCallWithNumericParamOnly+0x16>
	if (recorder_busy)
   16a34:	4c1b      	ldr	r4, [pc, #108]	; (16aa4 <prvTraceStoreKernelCallWithNumericParamOnly+0x7c>)
   16a36:	6823      	ldr	r3, [r4, #0]
   16a38:	2b00      	cmp	r3, #0
   16a3a:	d003      	beq.n	16a44 <prvTraceStoreKernelCallWithNumericParamOnly+0x1c>
		prvTraceError("Recorder busy - high priority ISR using syscall? (4)");
   16a3c:	481a      	ldr	r0, [pc, #104]	; (16aa8 <prvTraceStoreKernelCallWithNumericParamOnly+0x80>)
   16a3e:	4b1b      	ldr	r3, [pc, #108]	; (16aac <prvTraceStoreKernelCallWithNumericParamOnly+0x84>)
   16a40:	4798      	blx	r3
}
   16a42:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   16a44:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
   16a48:	2301      	movs	r3, #1
   16a4a:	f383 8810 	msr	PRIMASK, r3
	trcCRITICAL_SECTION_BEGIN();
   16a4e:	6823      	ldr	r3, [r4, #0]
   16a50:	3301      	adds	r3, #1
   16a52:	6023      	str	r3, [r4, #0]
	if (RecorderDataPtr->recorderActive && handle_of_last_logged_task)
   16a54:	4b16      	ldr	r3, [pc, #88]	; (16ab0 <prvTraceStoreKernelCallWithNumericParamOnly+0x88>)
   16a56:	681b      	ldr	r3, [r3, #0]
   16a58:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   16a5a:	2b00      	cmp	r3, #0
   16a5c:	d019      	beq.n	16a92 <prvTraceStoreKernelCallWithNumericParamOnly+0x6a>
   16a5e:	4b15      	ldr	r3, [pc, #84]	; (16ab4 <prvTraceStoreKernelCallWithNumericParamOnly+0x8c>)
   16a60:	781b      	ldrb	r3, [r3, #0]
   16a62:	2b00      	cmp	r3, #0
   16a64:	d015      	beq.n	16a92 <prvTraceStoreKernelCallWithNumericParamOnly+0x6a>
		dts6 = (uint8_t)prvTraceGetDTS(0xFF);
   16a66:	20ff      	movs	r0, #255	; 0xff
   16a68:	4b13      	ldr	r3, [pc, #76]	; (16ab8 <prvTraceStoreKernelCallWithNumericParamOnly+0x90>)
   16a6a:	4798      	blx	r3
   16a6c:	9001      	str	r0, [sp, #4]
	if (param <= param_max)
   16a6e:	4813      	ldr	r0, [pc, #76]	; (16abc <prvTraceStoreKernelCallWithNumericParamOnly+0x94>)
   16a70:	4285      	cmp	r5, r0
   16a72:	d903      	bls.n	16a7c <prvTraceStoreKernelCallWithNumericParamOnly+0x54>
   16a74:	0029      	movs	r1, r5
   16a76:	4b12      	ldr	r3, [pc, #72]	; (16ac0 <prvTraceStoreKernelCallWithNumericParamOnly+0x98>)
   16a78:	4798      	blx	r3
   16a7a:	0005      	movs	r5, r0
		kse = (KernelCallWithParam16*) prvTraceNextFreeEventBufferSlot();
   16a7c:	4b11      	ldr	r3, [pc, #68]	; (16ac4 <prvTraceStoreKernelCallWithNumericParamOnly+0x9c>)
   16a7e:	4798      	blx	r3
		if (kse != NULL)
   16a80:	2800      	cmp	r0, #0
   16a82:	d006      	beq.n	16a92 <prvTraceStoreKernelCallWithNumericParamOnly+0x6a>
			kse->dts = dts6;
   16a84:	466b      	mov	r3, sp
   16a86:	791b      	ldrb	r3, [r3, #4]
			kse->type = (uint8_t)evtcode;
   16a88:	7006      	strb	r6, [r0, #0]
			kse->dts = dts6;
   16a8a:	7043      	strb	r3, [r0, #1]
			kse->param = restParam;
   16a8c:	8045      	strh	r5, [r0, #2]
			prvTraceUpdateCounters();
   16a8e:	4b0e      	ldr	r3, [pc, #56]	; (16ac8 <prvTraceStoreKernelCallWithNumericParamOnly+0xa0>)
   16a90:	4798      	blx	r3
	trcCRITICAL_SECTION_END();
   16a92:	6823      	ldr	r3, [r4, #0]
   16a94:	3b01      	subs	r3, #1
   16a96:	6023      	str	r3, [r4, #0]
   16a98:	f387 8810 	msr	PRIMASK, r7
   16a9c:	e7d1      	b.n	16a42 <prvTraceStoreKernelCallWithNumericParamOnly+0x1a>
   16a9e:	46c0      	nop			; (mov r8, r8)
   16aa0:	00029b35 	.word	0x00029b35
   16aa4:	20000cb4 	.word	0x20000cb4
   16aa8:	00029b8a 	.word	0x00029b8a
   16aac:	00016121 	.word	0x00016121
   16ab0:	20000c04 	.word	0x20000c04
   16ab4:	20000c08 	.word	0x20000c08
   16ab8:	00016639 	.word	0x00016639
   16abc:	0000ffff 	.word	0x0000ffff
   16ac0:	00016279 	.word	0x00016279
   16ac4:	00016171 	.word	0x00016171
   16ac8:	00016241 	.word	0x00016241

00016acc <prvTraceStoreTaskswitch>:
{
   16acc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   16ace:	0007      	movs	r7, r0
	TRACE_ASSERT(task_handle <= (TRC_CFG_NTASK),
   16ad0:	280f      	cmp	r0, #15
   16ad2:	d903      	bls.n	16adc <prvTraceStoreTaskswitch+0x10>
   16ad4:	4828      	ldr	r0, [pc, #160]	; (16b78 <prvTraceStoreTaskswitch+0xac>)
   16ad6:	4b29      	ldr	r3, [pc, #164]	; (16b7c <prvTraceStoreTaskswitch+0xb0>)
   16ad8:	4798      	blx	r3
}
   16ada:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   16adc:	f3ef 8310 	mrs	r3, PRIMASK
   16ae0:	9300      	str	r3, [sp, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
   16ae2:	2301      	movs	r3, #1
   16ae4:	f383 8810 	msr	PRIMASK, r3
	trcCRITICAL_SECTION_BEGIN_ON_CORTEX_M_ONLY();
   16ae8:	4d25      	ldr	r5, [pc, #148]	; (16b80 <prvTraceStoreTaskswitch+0xb4>)
   16aea:	682b      	ldr	r3, [r5, #0]
   16aec:	3301      	adds	r3, #1
   16aee:	602b      	str	r3, [r5, #0]
	if ((task_handle != handle_of_last_logged_task) && (RecorderDataPtr->recorderActive))
   16af0:	4b24      	ldr	r3, [pc, #144]	; (16b84 <prvTraceStoreTaskswitch+0xb8>)
   16af2:	781b      	ldrb	r3, [r3, #0]
   16af4:	4283      	cmp	r3, r0
   16af6:	d038      	beq.n	16b6a <prvTraceStoreTaskswitch+0x9e>
   16af8:	4e23      	ldr	r6, [pc, #140]	; (16b88 <prvTraceStoreTaskswitch+0xbc>)
   16afa:	6833      	ldr	r3, [r6, #0]
   16afc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   16afe:	2b00      	cmp	r3, #0
   16b00:	d033      	beq.n	16b6a <prvTraceStoreTaskswitch+0x9e>
		isPendingContextSwitch = 0;
   16b02:	2200      	movs	r2, #0
   16b04:	4b21      	ldr	r3, [pc, #132]	; (16b8c <prvTraceStoreTaskswitch+0xc0>)
		dts3 = (uint16_t)prvTraceGetDTS(0xFFFF);
   16b06:	4822      	ldr	r0, [pc, #136]	; (16b90 <prvTraceStoreTaskswitch+0xc4>)
		isPendingContextSwitch = 0;
   16b08:	601a      	str	r2, [r3, #0]
		dts3 = (uint16_t)prvTraceGetDTS(0xFFFF);
   16b0a:	4b22      	ldr	r3, [pc, #136]	; (16b94 <prvTraceStoreTaskswitch+0xc8>)
   16b0c:	4798      	blx	r3
		handle_of_last_logged_task = task_handle;
   16b0e:	4b1d      	ldr	r3, [pc, #116]	; (16b84 <prvTraceStoreTaskswitch+0xb8>)
		dts3 = (uint16_t)prvTraceGetDTS(0xFFFF);
   16b10:	9001      	str	r0, [sp, #4]
		handle_of_last_logged_task = task_handle;
   16b12:	701f      	strb	r7, [r3, #0]
		ts = (TSEvent*)prvTraceNextFreeEventBufferSlot();
   16b14:	4b20      	ldr	r3, [pc, #128]	; (16b98 <prvTraceStoreTaskswitch+0xcc>)
   16b16:	4798      	blx	r3
   16b18:	1e04      	subs	r4, r0, #0
		if (ts != NULL)
   16b1a:	d026      	beq.n	16b6a <prvTraceStoreTaskswitch+0x9e>
			if (prvTraceGetObjectState(TRACE_CLASS_TASK,
   16b1c:	4b19      	ldr	r3, [pc, #100]	; (16b84 <prvTraceStoreTaskswitch+0xb8>)
   16b1e:	7818      	ldrb	r0, [r3, #0]
	TRACE_ASSERT(id <= RecorderDataPtr->ObjectPropertyTable.NumberOfObjectsPerClass[objectclass],
   16b20:	6833      	ldr	r3, [r6, #0]
   16b22:	3367      	adds	r3, #103	; 0x67
   16b24:	781b      	ldrb	r3, [r3, #0]
   16b26:	4283      	cmp	r3, r0
   16b28:	d204      	bcs.n	16b34 <prvTraceStoreTaskswitch+0x68>
   16b2a:	481c      	ldr	r0, [pc, #112]	; (16b9c <prvTraceStoreTaskswitch+0xd0>)
   16b2c:	4b13      	ldr	r3, [pc, #76]	; (16b7c <prvTraceStoreTaskswitch+0xb0>)
   16b2e:	4798      	blx	r3
				ts->type = TS_TASK_BEGIN;
   16b30:	2306      	movs	r3, #6
   16b32:	e00d      	b.n	16b50 <prvTraceStoreTaskswitch+0x84>
	return TRACE_PROPERTY_OBJECT_STATE(objectclass, id);
   16b34:	4b1a      	ldr	r3, [pc, #104]	; (16ba0 <prvTraceStoreTaskswitch+0xd4>)
   16b36:	2103      	movs	r1, #3
   16b38:	4798      	blx	r3
   16b3a:	6833      	ldr	r3, [r6, #0]
   16b3c:	001a      	movs	r2, r3
   16b3e:	3273      	adds	r2, #115	; 0x73
   16b40:	7812      	ldrb	r2, [r2, #0]
   16b42:	181b      	adds	r3, r3, r0
   16b44:	189b      	adds	r3, r3, r2
   16b46:	339c      	adds	r3, #156	; 0x9c
			if (prvTraceGetObjectState(TRACE_CLASS_TASK,
   16b48:	781b      	ldrb	r3, [r3, #0]
   16b4a:	2b01      	cmp	r3, #1
   16b4c:	d1f0      	bne.n	16b30 <prvTraceStoreTaskswitch+0x64>
				ts->type = TS_TASK_RESUME;
   16b4e:	3306      	adds	r3, #6
				ts->type = TS_TASK_BEGIN;
   16b50:	7023      	strb	r3, [r4, #0]
			ts->dts = dts3;
   16b52:	466b      	mov	r3, sp
   16b54:	889b      	ldrh	r3, [r3, #4]
			ts->objHandle = hnd8;
   16b56:	7067      	strb	r7, [r4, #1]
			ts->dts = dts3;
   16b58:	8063      	strh	r3, [r4, #2]
			prvTraceSetObjectState(TRACE_CLASS_TASK,
   16b5a:	4b0a      	ldr	r3, [pc, #40]	; (16b84 <prvTraceStoreTaskswitch+0xb8>)
   16b5c:	2201      	movs	r2, #1
   16b5e:	7819      	ldrb	r1, [r3, #0]
   16b60:	2003      	movs	r0, #3
   16b62:	4b10      	ldr	r3, [pc, #64]	; (16ba4 <prvTraceStoreTaskswitch+0xd8>)
   16b64:	4798      	blx	r3
			prvTraceUpdateCounters();
   16b66:	4b10      	ldr	r3, [pc, #64]	; (16ba8 <prvTraceStoreTaskswitch+0xdc>)
   16b68:	4798      	blx	r3
	trcCRITICAL_SECTION_END_ON_CORTEX_M_ONLY();
   16b6a:	682b      	ldr	r3, [r5, #0]
   16b6c:	3b01      	subs	r3, #1
   16b6e:	602b      	str	r3, [r5, #0]
   16b70:	9b00      	ldr	r3, [sp, #0]
   16b72:	f383 8810 	msr	PRIMASK, r3
   16b76:	e7b0      	b.n	16ada <prvTraceStoreTaskswitch+0xe>
   16b78:	00029d45 	.word	0x00029d45
   16b7c:	00016121 	.word	0x00016121
   16b80:	20000cb4 	.word	0x20000cb4
   16b84:	20000c08 	.word	0x20000c08
   16b88:	20000c04 	.word	0x20000c04
   16b8c:	20000c10 	.word	0x20000c10
   16b90:	0000ffff 	.word	0x0000ffff
   16b94:	00016639 	.word	0x00016639
   16b98:	00016171 	.word	0x00016171
   16b9c:	00029d8a 	.word	0x00029d8a
   16ba0:	000162a9 	.word	0x000162a9
   16ba4:	000163c5 	.word	0x000163c5
   16ba8:	00016241 	.word	0x00016241

00016bac <uiTraceStart>:
{
   16bac:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (RecorderDataPtr == NULL)
   16bae:	4e1e      	ldr	r6, [pc, #120]	; (16c28 <uiTraceStart+0x7c>)
   16bb0:	6834      	ldr	r4, [r6, #0]
   16bb2:	2c00      	cmp	r4, #0
   16bb4:	d104      	bne.n	16bc0 <uiTraceStart+0x14>
		TRACE_ASSERT(RecorderDataPtr != NULL, "Recorder not initialized. Use vTraceEnable() instead!", 0);
   16bb6:	481d      	ldr	r0, [pc, #116]	; (16c2c <uiTraceStart+0x80>)
   16bb8:	4b1d      	ldr	r3, [pc, #116]	; (16c30 <uiTraceStart+0x84>)
   16bba:	4798      	blx	r3
   16bbc:	0020      	movs	r0, r4
}
   16bbe:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	if (RecorderDataPtr->recorderActive == 1)
   16bc0:	6b20      	ldr	r0, [r4, #48]	; 0x30
   16bc2:	2801      	cmp	r0, #1
   16bc4:	d0fb      	beq.n	16bbe <uiTraceStart+0x12>
	if (traceErrorMessage == NULL)
   16bc6:	4b1b      	ldr	r3, [pc, #108]	; (16c34 <uiTraceStart+0x88>)
   16bc8:	681b      	ldr	r3, [r3, #0]
   16bca:	9301      	str	r3, [sp, #4]
   16bcc:	2b00      	cmp	r3, #0
   16bce:	d127      	bne.n	16c20 <uiTraceStart+0x74>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   16bd0:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
   16bd4:	2201      	movs	r2, #1
   16bd6:	f382 8810 	msr	PRIMASK, r2
		trcCRITICAL_SECTION_BEGIN();
   16bda:	4d17      	ldr	r5, [pc, #92]	; (16c38 <uiTraceStart+0x8c>)
   16bdc:	682b      	ldr	r3, [r5, #0]
   16bde:	189b      	adds	r3, r3, r2
   16be0:	602b      	str	r3, [r5, #0]
		RecorderDataPtr->recorderActive = 1;
   16be2:	6833      	ldr	r3, [r6, #0]
   16be4:	631a      	str	r2, [r3, #48]	; 0x30
		handle = TRACE_GET_TASK_NUMBER(TRACE_GET_CURRENT_TASK());
   16be6:	4b15      	ldr	r3, [pc, #84]	; (16c3c <uiTraceStart+0x90>)
   16be8:	4798      	blx	r3
   16bea:	4b15      	ldr	r3, [pc, #84]	; (16c40 <uiTraceStart+0x94>)
   16bec:	4798      	blx	r3
   16bee:	b2c4      	uxtb	r4, r0
		if (handle == 0)
   16bf0:	2c00      	cmp	r4, #0
   16bf2:	d10d      	bne.n	16c10 <uiTraceStart+0x64>
			handle = prvTraceGetObjectHandle(TRACE_CLASS_TASK);
   16bf4:	4b13      	ldr	r3, [pc, #76]	; (16c44 <uiTraceStart+0x98>)
   16bf6:	2003      	movs	r0, #3
   16bf8:	4798      	blx	r3
   16bfa:	0004      	movs	r4, r0
			prvTraceSetObjectName(TRACE_CLASS_TASK, handle, "(startup)");
   16bfc:	0001      	movs	r1, r0
   16bfe:	4a12      	ldr	r2, [pc, #72]	; (16c48 <uiTraceStart+0x9c>)
   16c00:	2003      	movs	r0, #3
   16c02:	4b12      	ldr	r3, [pc, #72]	; (16c4c <uiTraceStart+0xa0>)
   16c04:	4798      	blx	r3
			prvTraceSetPriorityProperty(TRACE_CLASS_TASK, handle, 0);
   16c06:	9a01      	ldr	r2, [sp, #4]
   16c08:	0021      	movs	r1, r4
   16c0a:	2003      	movs	r0, #3
   16c0c:	4b10      	ldr	r3, [pc, #64]	; (16c50 <uiTraceStart+0xa4>)
   16c0e:	4798      	blx	r3
		prvTraceStoreTaskswitch(handle); /* Register the currently running task */
   16c10:	0020      	movs	r0, r4
   16c12:	4b10      	ldr	r3, [pc, #64]	; (16c54 <uiTraceStart+0xa8>)
   16c14:	4798      	blx	r3
		trcCRITICAL_SECTION_END();
   16c16:	682b      	ldr	r3, [r5, #0]
   16c18:	3b01      	subs	r3, #1
   16c1a:	602b      	str	r3, [r5, #0]
   16c1c:	f387 8810 	msr	PRIMASK, r7
	return RecorderDataPtr->recorderActive;
   16c20:	6833      	ldr	r3, [r6, #0]
   16c22:	6b18      	ldr	r0, [r3, #48]	; 0x30
   16c24:	e7cb      	b.n	16bbe <uiTraceStart+0x12>
   16c26:	46c0      	nop			; (mov r8, r8)
   16c28:	20000c04 	.word	0x20000c04
   16c2c:	00029e40 	.word	0x00029e40
   16c30:	00016121 	.word	0x00016121
   16c34:	20000cbc 	.word	0x20000cbc
   16c38:	20000cb4 	.word	0x20000cb4
   16c3c:	00015d9d 	.word	0x00015d9d
   16c40:	00015c11 	.word	0x00015c11
   16c44:	00016459 	.word	0x00016459
   16c48:	00029e84 	.word	0x00029e84
   16c4c:	00016521 	.word	0x00016521
   16c50:	0001631d 	.word	0x0001631d
   16c54:	00016acd 	.word	0x00016acd

00016c58 <vTraceStart>:
{
   16c58:	b510      	push	{r4, lr}
	(void)uiTraceStart();
   16c5a:	4b01      	ldr	r3, [pc, #4]	; (16c60 <vTraceStart+0x8>)
   16c5c:	4798      	blx	r3
}
   16c5e:	bd10      	pop	{r4, pc}
   16c60:	00016bad 	.word	0x00016bad

00016c64 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   16c64:	0003      	movs	r3, r0

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
   16c66:	2201      	movs	r2, #1
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   16c68:	3308      	adds	r3, #8
   16c6a:	6043      	str	r3, [r0, #4]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   16c6c:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   16c6e:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
   16c70:	2300      	movs	r3, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
   16c72:	4252      	negs	r2, r2
   16c74:	6082      	str	r2, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
   16c76:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
   16c78:	4770      	bx	lr

00016c7a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
   16c7a:	2300      	movs	r3, #0
   16c7c:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
   16c7e:	4770      	bx	lr

00016c80 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
   16c80:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
   16c82:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
   16c84:	689a      	ldr	r2, [r3, #8]
   16c86:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
   16c88:	689a      	ldr	r2, [r3, #8]
   16c8a:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
   16c8c:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   16c8e:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
   16c90:	6803      	ldr	r3, [r0, #0]
   16c92:	3301      	adds	r3, #1
   16c94:	6003      	str	r3, [r0, #0]
}
   16c96:	4770      	bx	lr

00016c98 <vListInsert>:
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   16c98:	0003      	movs	r3, r0
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
   16c9a:	680a      	ldr	r2, [r1, #0]
{
   16c9c:	b530      	push	{r4, r5, lr}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   16c9e:	3308      	adds	r3, #8
	if( xValueOfInsertion == portMAX_DELAY )
   16ca0:	1c54      	adds	r4, r2, #1
   16ca2:	d10b      	bne.n	16cbc <vListInsert+0x24>
		pxIterator = pxList->xListEnd.pxPrevious;
   16ca4:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
   16ca6:	685a      	ldr	r2, [r3, #4]
   16ca8:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
   16caa:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
   16cac:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
   16cae:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   16cb0:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
   16cb2:	6803      	ldr	r3, [r0, #0]
   16cb4:	3301      	adds	r3, #1
   16cb6:	6003      	str	r3, [r0, #0]
}
   16cb8:	bd30      	pop	{r4, r5, pc}
   16cba:	0023      	movs	r3, r4
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   16cbc:	685c      	ldr	r4, [r3, #4]
   16cbe:	6825      	ldr	r5, [r4, #0]
   16cc0:	42aa      	cmp	r2, r5
   16cc2:	d2fa      	bcs.n	16cba <vListInsert+0x22>
   16cc4:	e7ef      	b.n	16ca6 <vListInsert+0xe>

00016cc6 <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   16cc6:	6842      	ldr	r2, [r0, #4]
   16cc8:	6881      	ldr	r1, [r0, #8]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
   16cca:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   16ccc:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   16cce:	6882      	ldr	r2, [r0, #8]
   16cd0:	6841      	ldr	r1, [r0, #4]
   16cd2:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
   16cd4:	685a      	ldr	r2, [r3, #4]
   16cd6:	4290      	cmp	r0, r2
   16cd8:	d101      	bne.n	16cde <uxListRemove+0x18>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
   16cda:	6882      	ldr	r2, [r0, #8]
   16cdc:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
   16cde:	2200      	movs	r2, #0
   16ce0:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
   16ce2:	681a      	ldr	r2, [r3, #0]
   16ce4:	3a01      	subs	r2, #1
   16ce6:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
   16ce8:	6818      	ldr	r0, [r3, #0]
}
   16cea:	4770      	bx	lr

00016cec <prvTaskExitError>:
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
volatile uint32_t ulDummy = 0UL;
   16cec:	2300      	movs	r3, #0
{
   16cee:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0UL;
   16cf0:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
   16cf2:	4b06      	ldr	r3, [pc, #24]	; (16d0c <prvTaskExitError+0x20>)
   16cf4:	681b      	ldr	r3, [r3, #0]
   16cf6:	3301      	adds	r3, #1
   16cf8:	d001      	beq.n	16cfe <prvTaskExitError+0x12>
   16cfa:	b672      	cpsid	i
   16cfc:	e7fe      	b.n	16cfc <prvTaskExitError+0x10>
	portDISABLE_INTERRUPTS();
   16cfe:	b672      	cpsid	i
	while( ulDummy == 0 )
   16d00:	9b01      	ldr	r3, [sp, #4]
   16d02:	2b00      	cmp	r3, #0
   16d04:	d0fc      	beq.n	16d00 <prvTaskExitError+0x14>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
   16d06:	b002      	add	sp, #8
   16d08:	4770      	bx	lr
   16d0a:	46c0      	nop			; (mov r8, r8)
   16d0c:	200001f8 	.word	0x200001f8

00016d10 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
   16d10:	4a0b      	ldr	r2, [pc, #44]	; (16d40 <pxCurrentTCBConst2>)
   16d12:	6813      	ldr	r3, [r2, #0]
   16d14:	6818      	ldr	r0, [r3, #0]
   16d16:	3020      	adds	r0, #32
   16d18:	f380 8809 	msr	PSP, r0
   16d1c:	2002      	movs	r0, #2
   16d1e:	f380 8814 	msr	CONTROL, r0
   16d22:	f3bf 8f6f 	isb	sy
   16d26:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
   16d28:	46ae      	mov	lr, r5
   16d2a:	bc08      	pop	{r3}
   16d2c:	bc04      	pop	{r2}
   16d2e:	b662      	cpsie	i
   16d30:	4718      	bx	r3
   16d32:	46c0      	nop			; (mov r8, r8)
   16d34:	46c0      	nop			; (mov r8, r8)
   16d36:	46c0      	nop			; (mov r8, r8)
   16d38:	46c0      	nop			; (mov r8, r8)
   16d3a:	46c0      	nop			; (mov r8, r8)
   16d3c:	46c0      	nop			; (mov r8, r8)
   16d3e:	46c0      	nop			; (mov r8, r8)

00016d40 <pxCurrentTCBConst2>:
   16d40:	20003bb8 	.word	0x20003bb8

00016d44 <pxPortInitialiseStack>:
{
   16d44:	b510      	push	{r4, lr}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
   16d46:	2480      	movs	r4, #128	; 0x80
   16d48:	1f03      	subs	r3, r0, #4
   16d4a:	0464      	lsls	r4, r4, #17
   16d4c:	601c      	str	r4, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
   16d4e:	3b04      	subs	r3, #4
   16d50:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
   16d52:	4903      	ldr	r1, [pc, #12]	; (16d60 <pxPortInitialiseStack+0x1c>)
   16d54:	3b04      	subs	r3, #4
   16d56:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
   16d58:	3b14      	subs	r3, #20
	pxTopOfStack -= 8; /* R11..R4. */
   16d5a:	3840      	subs	r0, #64	; 0x40
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
   16d5c:	601a      	str	r2, [r3, #0]
}
   16d5e:	bd10      	pop	{r4, pc}
   16d60:	00016ced 	.word	0x00016ced

00016d64 <SVC_Handler>:
}
   16d64:	4770      	bx	lr
	...

00016d68 <xPortStartScheduler>:
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
   16d68:	22ff      	movs	r2, #255	; 0xff
{
   16d6a:	b570      	push	{r4, r5, r6, lr}
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
   16d6c:	4b12      	ldr	r3, [pc, #72]	; (16db8 <xPortStartScheduler+0x50>)
   16d6e:	0412      	lsls	r2, r2, #16
   16d70:	6819      	ldr	r1, [r3, #0]
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
	/* Stop and reset the SysTick. */
	*(portNVIC_SYSTICK_CTRL) = 0UL;
   16d72:	2400      	movs	r4, #0
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
   16d74:	430a      	orrs	r2, r1
   16d76:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
   16d78:	22ff      	movs	r2, #255	; 0xff
   16d7a:	6819      	ldr	r1, [r3, #0]
   16d7c:	0612      	lsls	r2, r2, #24
   16d7e:	430a      	orrs	r2, r1
   16d80:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = 0UL;
   16d82:	4d0e      	ldr	r5, [pc, #56]	; (16dbc <xPortStartScheduler+0x54>)
	*(portNVIC_SYSTICK_CURRENT_VALUE) = 0UL;
   16d84:	4b0e      	ldr	r3, [pc, #56]	; (16dc0 <xPortStartScheduler+0x58>)
	*(portNVIC_SYSTICK_CTRL) = 0UL;
   16d86:	602c      	str	r4, [r5, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
   16d88:	0020      	movs	r0, r4
	*(portNVIC_SYSTICK_CURRENT_VALUE) = 0UL;
   16d8a:	601c      	str	r4, [r3, #0]
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
   16d8c:	4b0d      	ldr	r3, [pc, #52]	; (16dc4 <xPortStartScheduler+0x5c>)
   16d8e:	4798      	blx	r3
   16d90:	21fa      	movs	r1, #250	; 0xfa
   16d92:	4b0d      	ldr	r3, [pc, #52]	; (16dc8 <xPortStartScheduler+0x60>)
   16d94:	0089      	lsls	r1, r1, #2
   16d96:	4798      	blx	r3
   16d98:	4b0c      	ldr	r3, [pc, #48]	; (16dcc <xPortStartScheduler+0x64>)
   16d9a:	3801      	subs	r0, #1
   16d9c:	6018      	str	r0, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
   16d9e:	2307      	movs	r3, #7
   16da0:	602b      	str	r3, [r5, #0]
	uxCriticalNesting = 0;
   16da2:	4b0b      	ldr	r3, [pc, #44]	; (16dd0 <xPortStartScheduler+0x68>)
   16da4:	601c      	str	r4, [r3, #0]
	vPortStartFirstTask();
   16da6:	4b0b      	ldr	r3, [pc, #44]	; (16dd4 <xPortStartScheduler+0x6c>)
   16da8:	4798      	blx	r3
	vTaskSwitchContext();
   16daa:	4b0b      	ldr	r3, [pc, #44]	; (16dd8 <xPortStartScheduler+0x70>)
   16dac:	4798      	blx	r3
	prvTaskExitError();
   16dae:	4b0b      	ldr	r3, [pc, #44]	; (16ddc <xPortStartScheduler+0x74>)
   16db0:	4798      	blx	r3
}
   16db2:	0020      	movs	r0, r4
   16db4:	bd70      	pop	{r4, r5, r6, pc}
   16db6:	46c0      	nop			; (mov r8, r8)
   16db8:	e000ed20 	.word	0xe000ed20
   16dbc:	e000e010 	.word	0xe000e010
   16dc0:	e000e018 	.word	0xe000e018
   16dc4:	0001e729 	.word	0x0001e729
   16dc8:	000258bd 	.word	0x000258bd
   16dcc:	e000e014 	.word	0xe000e014
   16dd0:	200001f8 	.word	0x200001f8
   16dd4:	00016d11 	.word	0x00016d11
   16dd8:	00018649 	.word	0x00018649
   16ddc:	00016ced 	.word	0x00016ced

00016de0 <vPortYield>:
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
   16de0:	2280      	movs	r2, #128	; 0x80
   16de2:	4b02      	ldr	r3, [pc, #8]	; (16dec <vPortYield+0xc>)
   16de4:	0552      	lsls	r2, r2, #21
   16de6:	601a      	str	r2, [r3, #0]
}
   16de8:	4770      	bx	lr
   16dea:	46c0      	nop			; (mov r8, r8)
   16dec:	e000ed04 	.word	0xe000ed04

00016df0 <vPortEnterCritical>:
    portDISABLE_INTERRUPTS();
   16df0:	b672      	cpsid	i
    uxCriticalNesting++;
   16df2:	4a04      	ldr	r2, [pc, #16]	; (16e04 <vPortEnterCritical+0x14>)
   16df4:	6813      	ldr	r3, [r2, #0]
   16df6:	3301      	adds	r3, #1
   16df8:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" ::: "memory" );
   16dfa:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
   16dfe:	f3bf 8f6f 	isb	sy
}
   16e02:	4770      	bx	lr
   16e04:	200001f8 	.word	0x200001f8

00016e08 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
   16e08:	4a05      	ldr	r2, [pc, #20]	; (16e20 <vPortExitCritical+0x18>)
   16e0a:	6813      	ldr	r3, [r2, #0]
   16e0c:	2b00      	cmp	r3, #0
   16e0e:	d101      	bne.n	16e14 <vPortExitCritical+0xc>
   16e10:	b672      	cpsid	i
   16e12:	e7fe      	b.n	16e12 <vPortExitCritical+0xa>
    uxCriticalNesting--;
   16e14:	3b01      	subs	r3, #1
   16e16:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 0 )
   16e18:	2b00      	cmp	r3, #0
   16e1a:	d100      	bne.n	16e1e <vPortExitCritical+0x16>
        portENABLE_INTERRUPTS();
   16e1c:	b662      	cpsie	i
}
   16e1e:	4770      	bx	lr
   16e20:	200001f8 	.word	0x200001f8

00016e24 <ulSetInterruptMaskFromISR>:
	__asm volatile(
   16e24:	f3ef 8010 	mrs	r0, PRIMASK
   16e28:	b672      	cpsid	i
   16e2a:	4770      	bx	lr

00016e2c <vClearInterruptMaskFromISR>:
	__asm volatile(
   16e2c:	f380 8810 	msr	PRIMASK, r0
   16e30:	4770      	bx	lr
	...

00016e40 <PendSV_Handler>:
	__asm volatile
   16e40:	f3ef 8009 	mrs	r0, PSP
   16e44:	4b0e      	ldr	r3, [pc, #56]	; (16e80 <pxCurrentTCBConst>)
   16e46:	681a      	ldr	r2, [r3, #0]
   16e48:	3820      	subs	r0, #32
   16e4a:	6010      	str	r0, [r2, #0]
   16e4c:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
   16e4e:	4644      	mov	r4, r8
   16e50:	464d      	mov	r5, r9
   16e52:	4656      	mov	r6, sl
   16e54:	465f      	mov	r7, fp
   16e56:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
   16e58:	b508      	push	{r3, lr}
   16e5a:	b672      	cpsid	i
   16e5c:	f001 fbf4 	bl	18648 <vTaskSwitchContext>
   16e60:	b662      	cpsie	i
   16e62:	bc0c      	pop	{r2, r3}
   16e64:	6811      	ldr	r1, [r2, #0]
   16e66:	6808      	ldr	r0, [r1, #0]
   16e68:	3010      	adds	r0, #16
   16e6a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
   16e6c:	46a0      	mov	r8, r4
   16e6e:	46a9      	mov	r9, r5
   16e70:	46b2      	mov	sl, r6
   16e72:	46bb      	mov	fp, r7
   16e74:	f380 8809 	msr	PSP, r0
   16e78:	3820      	subs	r0, #32
   16e7a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
   16e7c:	4718      	bx	r3
   16e7e:	46c0      	nop			; (mov r8, r8)

00016e80 <pxCurrentTCBConst>:
   16e80:	20003bb8 	.word	0x20003bb8

00016e84 <SysTick_Handler>:
{
   16e84:	b510      	push	{r4, lr}
	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
   16e86:	4b07      	ldr	r3, [pc, #28]	; (16ea4 <SysTick_Handler+0x20>)
   16e88:	4798      	blx	r3
		if( xTaskIncrementTick() != pdFALSE )
   16e8a:	4b07      	ldr	r3, [pc, #28]	; (16ea8 <SysTick_Handler+0x24>)
	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
   16e8c:	0004      	movs	r4, r0
		if( xTaskIncrementTick() != pdFALSE )
   16e8e:	4798      	blx	r3
   16e90:	2800      	cmp	r0, #0
   16e92:	d003      	beq.n	16e9c <SysTick_Handler+0x18>
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
   16e94:	2280      	movs	r2, #128	; 0x80
   16e96:	4b05      	ldr	r3, [pc, #20]	; (16eac <SysTick_Handler+0x28>)
   16e98:	0552      	lsls	r2, r2, #21
   16e9a:	601a      	str	r2, [r3, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
   16e9c:	0020      	movs	r0, r4
   16e9e:	4b04      	ldr	r3, [pc, #16]	; (16eb0 <SysTick_Handler+0x2c>)
   16ea0:	4798      	blx	r3
}
   16ea2:	bd10      	pop	{r4, pc}
   16ea4:	00016e25 	.word	0x00016e25
   16ea8:	0001832d 	.word	0x0001832d
   16eac:	e000ed04 	.word	0xe000ed04
   16eb0:	00016e2d 	.word	0x00016e2d

00016eb4 <pvPortMalloc>:
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if( portBYTE_ALIGNMENT != 1 )
	{
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
   16eb4:	2307      	movs	r3, #7
{
   16eb6:	b570      	push	{r4, r5, r6, lr}
   16eb8:	0004      	movs	r4, r0
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
   16eba:	4218      	tst	r0, r3
   16ebc:	d001      	beq.n	16ec2 <pvPortMalloc+0xe>
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
   16ebe:	439c      	bics	r4, r3
   16ec0:	3408      	adds	r4, #8
		}
	}
	#endif

	vTaskSuspendAll();
   16ec2:	4b15      	ldr	r3, [pc, #84]	; (16f18 <pvPortMalloc+0x64>)
   16ec4:	4798      	blx	r3
	{
		if( pucAlignedHeap == NULL )
   16ec6:	4915      	ldr	r1, [pc, #84]	; (16f1c <pvPortMalloc+0x68>)
   16ec8:	680b      	ldr	r3, [r1, #0]
   16eca:	2b00      	cmp	r3, #0
   16ecc:	d104      	bne.n	16ed8 <pvPortMalloc+0x24>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
   16ece:	2207      	movs	r2, #7
   16ed0:	4b13      	ldr	r3, [pc, #76]	; (16f20 <pvPortMalloc+0x6c>)
   16ed2:	3308      	adds	r3, #8
   16ed4:	4393      	bics	r3, r2
   16ed6:	600b      	str	r3, [r1, #0]
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
   16ed8:	4812      	ldr	r0, [pc, #72]	; (16f24 <pvPortMalloc+0x70>)
   16eda:	4d13      	ldr	r5, [pc, #76]	; (16f28 <pvPortMalloc+0x74>)
   16edc:	6802      	ldr	r2, [r0, #0]
   16ede:	4e13      	ldr	r6, [pc, #76]	; (16f2c <pvPortMalloc+0x78>)
   16ee0:	18a3      	adds	r3, r4, r2
   16ee2:	42ab      	cmp	r3, r5
   16ee4:	d812      	bhi.n	16f0c <pvPortMalloc+0x58>
   16ee6:	429a      	cmp	r2, r3
   16ee8:	d210      	bcs.n	16f0c <pvPortMalloc+0x58>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
   16eea:	680d      	ldr	r5, [r1, #0]
			xNextFreeByte += xWantedSize;
   16eec:	6003      	str	r3, [r0, #0]
			pvReturn = pucAlignedHeap + xNextFreeByte;
   16eee:	18ad      	adds	r5, r5, r2
		}

		traceMALLOC( pvReturn, xWantedSize );
   16ef0:	2d00      	cmp	r5, #0
   16ef2:	d00b      	beq.n	16f0c <pvPortMalloc+0x58>
   16ef4:	0022      	movs	r2, r4
   16ef6:	0029      	movs	r1, r5
   16ef8:	2094      	movs	r0, #148	; 0x94
   16efa:	47b0      	blx	r6
	}
	( void ) xTaskResumeAll();
   16efc:	4b0c      	ldr	r3, [pc, #48]	; (16f30 <pvPortMalloc+0x7c>)
   16efe:	4798      	blx	r3

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
   16f00:	2d00      	cmp	r5, #0
   16f02:	d101      	bne.n	16f08 <pvPortMalloc+0x54>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
   16f04:	4b0b      	ldr	r3, [pc, #44]	; (16f34 <pvPortMalloc+0x80>)
   16f06:	4798      	blx	r3
		}
	}
	#endif

	return pvReturn;
}
   16f08:	0028      	movs	r0, r5
   16f0a:	bd70      	pop	{r4, r5, r6, pc}
		traceMALLOC( pvReturn, xWantedSize );
   16f0c:	0022      	movs	r2, r4
   16f0e:	2100      	movs	r1, #0
   16f10:	20e8      	movs	r0, #232	; 0xe8
   16f12:	47b0      	blx	r6
   16f14:	2500      	movs	r5, #0
   16f16:	e7f1      	b.n	16efc <pvPortMalloc+0x48>
   16f18:	00018311 	.word	0x00018311
   16f1c:	20000cd0 	.word	0x20000cd0
   16f20:	20000cd4 	.word	0x20000cd4
   16f24:	20003bb4 	.word	0x20003bb4
   16f28:	00002ed7 	.word	0x00002ed7
   16f2c:	000167e5 	.word	0x000167e5
   16f30:	00018499 	.word	0x00018499
   16f34:	00022b6d 	.word	0x00022b6d

00016f38 <vPortFree>:
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
   16f38:	2800      	cmp	r0, #0
   16f3a:	d001      	beq.n	16f40 <vPortFree+0x8>
   16f3c:	b672      	cpsid	i
   16f3e:	e7fe      	b.n	16f3e <vPortFree+0x6>
}
   16f40:	4770      	bx	lr
	...

00016f44 <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
   16f44:	4b02      	ldr	r3, [pc, #8]	; (16f50 <xPortGetFreeHeapSize+0xc>)
   16f46:	4803      	ldr	r0, [pc, #12]	; (16f54 <xPortGetFreeHeapSize+0x10>)
   16f48:	681b      	ldr	r3, [r3, #0]
   16f4a:	1ac0      	subs	r0, r0, r3
}
   16f4c:	4770      	bx	lr
   16f4e:	46c0      	nop			; (mov r8, r8)
   16f50:	20003bb4 	.word	0x20003bb4
   16f54:	00002ed8 	.word	0x00002ed8

00016f58 <prvIsQueueEmpty>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
   16f58:	b510      	push	{r4, lr}
   16f5a:	0004      	movs	r4, r0
BaseType_t xReturn;

	taskENTER_CRITICAL();
   16f5c:	4b03      	ldr	r3, [pc, #12]	; (16f6c <prvIsQueueEmpty+0x14>)
   16f5e:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
   16f60:	6ba4      	ldr	r4, [r4, #56]	; 0x38
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
   16f62:	4b03      	ldr	r3, [pc, #12]	; (16f70 <prvIsQueueEmpty+0x18>)
   16f64:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
   16f66:	4260      	negs	r0, r4
   16f68:	4160      	adcs	r0, r4

	return xReturn;
}
   16f6a:	bd10      	pop	{r4, pc}
   16f6c:	00016df1 	.word	0x00016df1
   16f70:	00016e09 	.word	0x00016e09

00016f74 <prvCopyDataToQueue>:
{
   16f74:	b570      	push	{r4, r5, r6, lr}
   16f76:	0016      	movs	r6, r2
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
   16f78:	6c02      	ldr	r2, [r0, #64]	; 0x40
{
   16f7a:	0004      	movs	r4, r0
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   16f7c:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
   16f7e:	2a00      	cmp	r2, #0
   16f80:	d10a      	bne.n	16f98 <prvCopyDataToQueue+0x24>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   16f82:	6806      	ldr	r6, [r0, #0]
BaseType_t xReturn = pdFALSE;
   16f84:	0010      	movs	r0, r2
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   16f86:	2e00      	cmp	r6, #0
   16f88:	d103      	bne.n	16f92 <prvCopyDataToQueue+0x1e>
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
   16f8a:	6860      	ldr	r0, [r4, #4]
   16f8c:	4b15      	ldr	r3, [pc, #84]	; (16fe4 <prvCopyDataToQueue+0x70>)
   16f8e:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
   16f90:	6066      	str	r6, [r4, #4]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   16f92:	3501      	adds	r5, #1
   16f94:	63a5      	str	r5, [r4, #56]	; 0x38
}
   16f96:	bd70      	pop	{r4, r5, r6, pc}
   16f98:	4b13      	ldr	r3, [pc, #76]	; (16fe8 <prvCopyDataToQueue+0x74>)
	else if( xPosition == queueSEND_TO_BACK )
   16f9a:	2e00      	cmp	r6, #0
   16f9c:	d10c      	bne.n	16fb8 <prvCopyDataToQueue+0x44>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
   16f9e:	6880      	ldr	r0, [r0, #8]
   16fa0:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
   16fa2:	68a3      	ldr	r3, [r4, #8]
   16fa4:	6c22      	ldr	r2, [r4, #64]	; 0x40
BaseType_t xReturn = pdFALSE;
   16fa6:	0030      	movs	r0, r6
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
   16fa8:	189b      	adds	r3, r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   16faa:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
   16fac:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   16fae:	4293      	cmp	r3, r2
   16fb0:	d3ef      	bcc.n	16f92 <prvCopyDataToQueue+0x1e>
			pxQueue->pcWriteTo = pxQueue->pcHead;
   16fb2:	6823      	ldr	r3, [r4, #0]
   16fb4:	60a3      	str	r3, [r4, #8]
   16fb6:	e7ec      	b.n	16f92 <prvCopyDataToQueue+0x1e>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   16fb8:	68c0      	ldr	r0, [r0, #12]
   16fba:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
   16fbc:	6c23      	ldr	r3, [r4, #64]	; 0x40
   16fbe:	68e2      	ldr	r2, [r4, #12]
   16fc0:	425b      	negs	r3, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   16fc2:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
   16fc4:	18d2      	adds	r2, r2, r3
   16fc6:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   16fc8:	428a      	cmp	r2, r1
   16fca:	d202      	bcs.n	16fd2 <prvCopyDataToQueue+0x5e>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
   16fcc:	6862      	ldr	r2, [r4, #4]
   16fce:	18d3      	adds	r3, r2, r3
   16fd0:	60e3      	str	r3, [r4, #12]
BaseType_t xReturn = pdFALSE;
   16fd2:	2000      	movs	r0, #0
		if( xPosition == queueOVERWRITE )
   16fd4:	2e02      	cmp	r6, #2
   16fd6:	d1dc      	bne.n	16f92 <prvCopyDataToQueue+0x1e>
				--uxMessagesWaiting;
   16fd8:	002b      	movs	r3, r5
   16fda:	1e5a      	subs	r2, r3, #1
   16fdc:	4193      	sbcs	r3, r2
   16fde:	1aed      	subs	r5, r5, r3
   16fe0:	e7d7      	b.n	16f92 <prvCopyDataToQueue+0x1e>
   16fe2:	46c0      	nop			; (mov r8, r8)
   16fe4:	00018ba1 	.word	0x00018ba1
   16fe8:	00022c11 	.word	0x00022c11

00016fec <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
	{
   16fec:	b5f0      	push	{r4, r5, r6, r7, lr}
	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
   16fee:	6c84      	ldr	r4, [r0, #72]	; 0x48
	{
   16ff0:	b087      	sub	sp, #28
   16ff2:	9005      	str	r0, [sp, #20]
   16ff4:	9102      	str	r1, [sp, #8]
	BaseType_t xReturn = pdFALSE;

		/* This function must be called form a critical section. */

		configASSERT( pxQueueSetContainer );
   16ff6:	2c00      	cmp	r4, #0
   16ff8:	d101      	bne.n	16ffe <prvNotifyQueueSetContainer+0x12>
   16ffa:	b672      	cpsid	i
   16ffc:	e7fe      	b.n	16ffc <prvNotifyQueueSetContainer+0x10>
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
   16ffe:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   17000:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   17002:	429a      	cmp	r2, r3
   17004:	d301      	bcc.n	1700a <prvNotifyQueueSetContainer+0x1e>
   17006:	b672      	cpsid	i
   17008:	e7fe      	b.n	17008 <prvNotifyQueueSetContainer+0x1c>

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
   1700a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
	BaseType_t xReturn = pdFALSE;
   1700c:	2500      	movs	r5, #0
		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
   1700e:	4293      	cmp	r3, r2
   17010:	d953      	bls.n	170ba <prvNotifyQueueSetContainer+0xce>
		{
			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
   17012:	0023      	movs	r3, r4
   17014:	3345      	adds	r3, #69	; 0x45
   17016:	9303      	str	r3, [sp, #12]
   17018:	781b      	ldrb	r3, [r3, #0]
   1701a:	b25b      	sxtb	r3, r3
   1701c:	9301      	str	r3, [sp, #4]

			traceQUEUE_SEND( pxQueueSetContainer );
   1701e:	4b2b      	ldr	r3, [pc, #172]	; (170cc <prvNotifyQueueSetContainer+0xe0>)
   17020:	4798      	blx	r3
   17022:	4b2b      	ldr	r3, [pc, #172]	; (170d0 <prvNotifyQueueSetContainer+0xe4>)
   17024:	4798      	blx	r3
   17026:	4e2b      	ldr	r6, [pc, #172]	; (170d4 <prvNotifyQueueSetContainer+0xe8>)
   17028:	4d2b      	ldr	r5, [pc, #172]	; (170d8 <prvNotifyQueueSetContainer+0xec>)
   1702a:	8833      	ldrh	r3, [r6, #0]
   1702c:	4203      	tst	r3, r0
   1702e:	d01b      	beq.n	17068 <prvNotifyQueueSetContainer+0x7c>
   17030:	4b2a      	ldr	r3, [pc, #168]	; (170dc <prvNotifyQueueSetContainer+0xf0>)
   17032:	0020      	movs	r0, r4
   17034:	4798      	blx	r3
   17036:	8833      	ldrh	r3, [r6, #0]
   17038:	4203      	tst	r3, r0
   1703a:	d015      	beq.n	17068 <prvNotifyQueueSetContainer+0x7c>
   1703c:	9b02      	ldr	r3, [sp, #8]
   1703e:	2625      	movs	r6, #37	; 0x25
   17040:	2b00      	cmp	r3, #0
   17042:	d105      	bne.n	17050 <prvNotifyQueueSetContainer+0x64>
   17044:	0020      	movs	r0, r4
   17046:	47a8      	blx	r5
   17048:	4b25      	ldr	r3, [pc, #148]	; (170e0 <prvNotifyQueueSetContainer+0xf4>)
   1704a:	5c1e      	ldrb	r6, [r3, r0]
   1704c:	3620      	adds	r6, #32
   1704e:	b2f6      	uxtb	r6, r6
   17050:	0020      	movs	r0, r4
   17052:	47a8      	blx	r5
   17054:	4b22      	ldr	r3, [pc, #136]	; (170e0 <prvNotifyQueueSetContainer+0xf4>)
   17056:	5c1f      	ldrb	r7, [r3, r0]
   17058:	4b22      	ldr	r3, [pc, #136]	; (170e4 <prvNotifyQueueSetContainer+0xf8>)
   1705a:	0020      	movs	r0, r4
   1705c:	4798      	blx	r3
   1705e:	0039      	movs	r1, r7
   17060:	b2c2      	uxtb	r2, r0
   17062:	4b21      	ldr	r3, [pc, #132]	; (170e8 <prvNotifyQueueSetContainer+0xfc>)
   17064:	0030      	movs	r0, r6
   17066:	4798      	blx	r3
   17068:	0020      	movs	r0, r4
   1706a:	47a8      	blx	r5
   1706c:	4e1c      	ldr	r6, [pc, #112]	; (170e0 <prvNotifyQueueSetContainer+0xf4>)
   1706e:	4b1d      	ldr	r3, [pc, #116]	; (170e4 <prvNotifyQueueSetContainer+0xf8>)
   17070:	5c37      	ldrb	r7, [r6, r0]
   17072:	0020      	movs	r0, r4
   17074:	4798      	blx	r3
   17076:	b2c3      	uxtb	r3, r0
   17078:	0020      	movs	r0, r4
   1707a:	9304      	str	r3, [sp, #16]
   1707c:	47a8      	blx	r5
   1707e:	5c33      	ldrb	r3, [r6, r0]
   17080:	2200      	movs	r2, #0
   17082:	2b02      	cmp	r3, #2
   17084:	d002      	beq.n	1708c <prvNotifyQueueSetContainer+0xa0>
   17086:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   17088:	3201      	adds	r2, #1
   1708a:	b2d2      	uxtb	r2, r2
   1708c:	9904      	ldr	r1, [sp, #16]
   1708e:	0038      	movs	r0, r7
   17090:	4b16      	ldr	r3, [pc, #88]	; (170ec <prvNotifyQueueSetContainer+0x100>)
   17092:	4798      	blx	r3

			/* The data copied is the handle of the queue that contains data. */
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
   17094:	4b16      	ldr	r3, [pc, #88]	; (170f0 <prvNotifyQueueSetContainer+0x104>)
   17096:	9a02      	ldr	r2, [sp, #8]
   17098:	a905      	add	r1, sp, #20
   1709a:	0020      	movs	r0, r4
   1709c:	4798      	blx	r3

			if( cTxLock == queueUNLOCKED )
   1709e:	9b01      	ldr	r3, [sp, #4]
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
   170a0:	0005      	movs	r5, r0
			if( cTxLock == queueUNLOCKED )
   170a2:	3301      	adds	r3, #1
   170a4:	d10c      	bne.n	170c0 <prvNotifyQueueSetContainer+0xd4>
			{
				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
   170a6:	6a63      	ldr	r3, [r4, #36]	; 0x24
   170a8:	2b00      	cmp	r3, #0
   170aa:	d006      	beq.n	170ba <prvNotifyQueueSetContainer+0xce>
				{
					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
   170ac:	0020      	movs	r0, r4
   170ae:	4b11      	ldr	r3, [pc, #68]	; (170f4 <prvNotifyQueueSetContainer+0x108>)
   170b0:	3024      	adds	r0, #36	; 0x24
   170b2:	4798      	blx	r3
   170b4:	2800      	cmp	r0, #0
   170b6:	d000      	beq.n	170ba <prvNotifyQueueSetContainer+0xce>
					{
						/* The task waiting has a higher priority. */
						xReturn = pdTRUE;
   170b8:	2501      	movs	r5, #1
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
   170ba:	0028      	movs	r0, r5
   170bc:	b007      	add	sp, #28
   170be:	bdf0      	pop	{r4, r5, r6, r7, pc}
				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
   170c0:	9b01      	ldr	r3, [sp, #4]
   170c2:	9a03      	ldr	r2, [sp, #12]
   170c4:	3301      	adds	r3, #1
   170c6:	b25b      	sxtb	r3, r3
   170c8:	7013      	strb	r3, [r2, #0]
   170ca:	e7f6      	b.n	170ba <prvNotifyQueueSetContainer+0xce>
   170cc:	00015d9d 	.word	0x00015d9d
   170d0:	00015c21 	.word	0x00015c21
   170d4:	200001f0 	.word	0x200001f0
   170d8:	00015c05 	.word	0x00015c05
   170dc:	00015c81 	.word	0x00015c81
   170e0:	200001e8 	.word	0x200001e8
   170e4:	00015c71 	.word	0x00015c71
   170e8:	000168b9 	.word	0x000168b9
   170ec:	000163c5 	.word	0x000163c5
   170f0:	00016f75 	.word	0x00016f75
   170f4:	000188d1 	.word	0x000188d1

000170f8 <prvCopyDataFromQueue>:
{
   170f8:	0003      	movs	r3, r0
   170fa:	b510      	push	{r4, lr}
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
   170fc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
   170fe:	0008      	movs	r0, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
   17100:	2a00      	cmp	r2, #0
   17102:	d00a      	beq.n	1711a <prvCopyDataFromQueue+0x22>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
   17104:	68d9      	ldr	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
   17106:	685c      	ldr	r4, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
   17108:	1889      	adds	r1, r1, r2
   1710a:	60d9      	str	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
   1710c:	42a1      	cmp	r1, r4
   1710e:	d301      	bcc.n	17114 <prvCopyDataFromQueue+0x1c>
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
   17110:	6819      	ldr	r1, [r3, #0]
   17112:	60d9      	str	r1, [r3, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
   17114:	68d9      	ldr	r1, [r3, #12]
   17116:	4b01      	ldr	r3, [pc, #4]	; (1711c <prvCopyDataFromQueue+0x24>)
   17118:	4798      	blx	r3
}
   1711a:	bd10      	pop	{r4, pc}
   1711c:	00022c11 	.word	0x00022c11

00017120 <prvUnlockQueue>:
{
   17120:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   17122:	0004      	movs	r4, r0
		int8_t cTxLock = pxQueue->cTxLock;
   17124:	0026      	movs	r6, r4
	taskENTER_CRITICAL();
   17126:	4f1c      	ldr	r7, [pc, #112]	; (17198 <prvUnlockQueue+0x78>)
		int8_t cTxLock = pxQueue->cTxLock;
   17128:	3645      	adds	r6, #69	; 0x45
	taskENTER_CRITICAL();
   1712a:	47b8      	blx	r7
		int8_t cTxLock = pxQueue->cTxLock;
   1712c:	7835      	ldrb	r5, [r6, #0]
   1712e:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
   17130:	2d00      	cmp	r5, #0
   17132:	dc0e      	bgt.n	17152 <prvUnlockQueue+0x32>
		pxQueue->cTxLock = queueUNLOCKED;
   17134:	23ff      	movs	r3, #255	; 0xff
   17136:	7033      	strb	r3, [r6, #0]
	taskEXIT_CRITICAL();
   17138:	4e18      	ldr	r6, [pc, #96]	; (1719c <prvUnlockQueue+0x7c>)
   1713a:	47b0      	blx	r6
	taskENTER_CRITICAL();
   1713c:	47b8      	blx	r7
		int8_t cRxLock = pxQueue->cRxLock;
   1713e:	0027      	movs	r7, r4
   17140:	3744      	adds	r7, #68	; 0x44
   17142:	783d      	ldrb	r5, [r7, #0]
   17144:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
   17146:	2d00      	cmp	r5, #0
   17148:	dc18      	bgt.n	1717c <prvUnlockQueue+0x5c>
		pxQueue->cRxLock = queueUNLOCKED;
   1714a:	23ff      	movs	r3, #255	; 0xff
   1714c:	703b      	strb	r3, [r7, #0]
	taskEXIT_CRITICAL();
   1714e:	47b0      	blx	r6
}
   17150:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				if( pxQueue->pxQueueSetContainer != NULL )
   17152:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   17154:	2b00      	cmp	r3, #0
   17156:	d009      	beq.n	1716c <prvUnlockQueue+0x4c>
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
   17158:	2100      	movs	r1, #0
   1715a:	0020      	movs	r0, r4
   1715c:	4b10      	ldr	r3, [pc, #64]	; (171a0 <prvUnlockQueue+0x80>)
   1715e:	4798      	blx	r3
   17160:	2800      	cmp	r0, #0
   17162:	d001      	beq.n	17168 <prvUnlockQueue+0x48>
						vTaskMissedYield();
   17164:	4b0f      	ldr	r3, [pc, #60]	; (171a4 <prvUnlockQueue+0x84>)
   17166:	4798      	blx	r3
   17168:	3d01      	subs	r5, #1
   1716a:	e7e0      	b.n	1712e <prvUnlockQueue+0xe>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1716c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1716e:	2b00      	cmp	r3, #0
   17170:	d0e0      	beq.n	17134 <prvUnlockQueue+0x14>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   17172:	0020      	movs	r0, r4
   17174:	4b0c      	ldr	r3, [pc, #48]	; (171a8 <prvUnlockQueue+0x88>)
   17176:	3024      	adds	r0, #36	; 0x24
   17178:	4798      	blx	r3
   1717a:	e7f1      	b.n	17160 <prvUnlockQueue+0x40>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1717c:	6923      	ldr	r3, [r4, #16]
   1717e:	2b00      	cmp	r3, #0
   17180:	d0e3      	beq.n	1714a <prvUnlockQueue+0x2a>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   17182:	0020      	movs	r0, r4
   17184:	4b08      	ldr	r3, [pc, #32]	; (171a8 <prvUnlockQueue+0x88>)
   17186:	3010      	adds	r0, #16
   17188:	4798      	blx	r3
   1718a:	2800      	cmp	r0, #0
   1718c:	d001      	beq.n	17192 <prvUnlockQueue+0x72>
					vTaskMissedYield();
   1718e:	4b05      	ldr	r3, [pc, #20]	; (171a4 <prvUnlockQueue+0x84>)
   17190:	4798      	blx	r3
   17192:	3d01      	subs	r5, #1
   17194:	e7d6      	b.n	17144 <prvUnlockQueue+0x24>
   17196:	46c0      	nop			; (mov r8, r8)
   17198:	00016df1 	.word	0x00016df1
   1719c:	00016e09 	.word	0x00016e09
   171a0:	00016fed 	.word	0x00016fed
   171a4:	00018a31 	.word	0x00018a31
   171a8:	000188d1 	.word	0x000188d1

000171ac <xQueueGenericReset>:
{
   171ac:	b570      	push	{r4, r5, r6, lr}
   171ae:	0004      	movs	r4, r0
   171b0:	000d      	movs	r5, r1
	configASSERT( pxQueue );
   171b2:	2800      	cmp	r0, #0
   171b4:	d101      	bne.n	171ba <xQueueGenericReset+0xe>
   171b6:	b672      	cpsid	i
   171b8:	e7fe      	b.n	171b8 <xQueueGenericReset+0xc>
	taskENTER_CRITICAL();
   171ba:	4b16      	ldr	r3, [pc, #88]	; (17214 <xQueueGenericReset+0x68>)
   171bc:	4798      	blx	r3
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
   171be:	6c21      	ldr	r1, [r4, #64]	; 0x40
   171c0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   171c2:	6822      	ldr	r2, [r4, #0]
   171c4:	434b      	muls	r3, r1
   171c6:	18d0      	adds	r0, r2, r3
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
   171c8:	1a5b      	subs	r3, r3, r1
   171ca:	18d3      	adds	r3, r2, r3
   171cc:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
   171ce:	0023      	movs	r3, r4
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
   171d0:	6060      	str	r0, [r4, #4]
		pxQueue->pcWriteTo = pxQueue->pcHead;
   171d2:	60a2      	str	r2, [r4, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
   171d4:	2000      	movs	r0, #0
		pxQueue->cRxLock = queueUNLOCKED;
   171d6:	22ff      	movs	r2, #255	; 0xff
   171d8:	3344      	adds	r3, #68	; 0x44
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
   171da:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->cRxLock = queueUNLOCKED;
   171dc:	701a      	strb	r2, [r3, #0]
		pxQueue->cTxLock = queueUNLOCKED;
   171de:	705a      	strb	r2, [r3, #1]
		if( xNewQueue == pdFALSE )
   171e0:	4285      	cmp	r5, r0
   171e2:	d10e      	bne.n	17202 <xQueueGenericReset+0x56>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   171e4:	6923      	ldr	r3, [r4, #16]
   171e6:	4283      	cmp	r3, r0
   171e8:	d007      	beq.n	171fa <xQueueGenericReset+0x4e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   171ea:	0020      	movs	r0, r4
   171ec:	4b0a      	ldr	r3, [pc, #40]	; (17218 <xQueueGenericReset+0x6c>)
   171ee:	3010      	adds	r0, #16
   171f0:	4798      	blx	r3
   171f2:	2800      	cmp	r0, #0
   171f4:	d001      	beq.n	171fa <xQueueGenericReset+0x4e>
					queueYIELD_IF_USING_PREEMPTION();
   171f6:	4b09      	ldr	r3, [pc, #36]	; (1721c <xQueueGenericReset+0x70>)
   171f8:	4798      	blx	r3
	taskEXIT_CRITICAL();
   171fa:	4b09      	ldr	r3, [pc, #36]	; (17220 <xQueueGenericReset+0x74>)
   171fc:	4798      	blx	r3
}
   171fe:	2001      	movs	r0, #1
   17200:	bd70      	pop	{r4, r5, r6, pc}
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
   17202:	0020      	movs	r0, r4
   17204:	4d07      	ldr	r5, [pc, #28]	; (17224 <xQueueGenericReset+0x78>)
   17206:	3010      	adds	r0, #16
   17208:	47a8      	blx	r5
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
   1720a:	0020      	movs	r0, r4
   1720c:	3024      	adds	r0, #36	; 0x24
   1720e:	47a8      	blx	r5
   17210:	e7f3      	b.n	171fa <xQueueGenericReset+0x4e>
   17212:	46c0      	nop			; (mov r8, r8)
   17214:	00016df1 	.word	0x00016df1
   17218:	000188d1 	.word	0x000188d1
   1721c:	00016de1 	.word	0x00016de1
   17220:	00016e09 	.word	0x00016e09
   17224:	00016c65 	.word	0x00016c65

00017228 <xQueueGenericCreate>:
	{
   17228:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1722a:	0006      	movs	r6, r0
   1722c:	000d      	movs	r5, r1
   1722e:	0017      	movs	r7, r2
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
   17230:	2800      	cmp	r0, #0
   17232:	d101      	bne.n	17238 <xQueueGenericCreate+0x10>
   17234:	b672      	cpsid	i
   17236:	e7fe      	b.n	17236 <xQueueGenericCreate+0xe>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   17238:	0008      	movs	r0, r1
   1723a:	4370      	muls	r0, r6
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
   1723c:	4b36      	ldr	r3, [pc, #216]	; (17318 <xQueueGenericCreate+0xf0>)
   1723e:	3054      	adds	r0, #84	; 0x54
   17240:	4798      	blx	r3
   17242:	1e04      	subs	r4, r0, #0
		if( pxNewQueue != NULL )
   17244:	d057      	beq.n	172f6 <xQueueGenericCreate+0xce>
	if( uxItemSize == ( UBaseType_t ) 0 )
   17246:	2d00      	cmp	r5, #0
   17248:	d151      	bne.n	172ee <xQueueGenericCreate+0xc6>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
   1724a:	6020      	str	r0, [r4, #0]
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
   1724c:	2101      	movs	r1, #1
	pxNewQueue->uxLength = uxQueueLength;
   1724e:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
   17250:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
   17252:	4b32      	ldr	r3, [pc, #200]	; (1731c <xQueueGenericCreate+0xf4>)
   17254:	0020      	movs	r0, r4
   17256:	4798      	blx	r3
		pxNewQueue->ucQueueType = ucQueueType;
   17258:	0023      	movs	r3, r4
   1725a:	3350      	adds	r3, #80	; 0x50
   1725c:	701f      	strb	r7, [r3, #0]
		pxNewQueue->pxQueueSetContainer = NULL;
   1725e:	2300      	movs	r3, #0
	traceQUEUE_CREATE( pxNewQueue );
   17260:	4e2f      	ldr	r6, [pc, #188]	; (17320 <xQueueGenericCreate+0xf8>)
		pxNewQueue->pxQueueSetContainer = NULL;
   17262:	64a3      	str	r3, [r4, #72]	; 0x48
	traceQUEUE_CREATE( pxNewQueue );
   17264:	0020      	movs	r0, r4
   17266:	47b0      	blx	r6
   17268:	4d2e      	ldr	r5, [pc, #184]	; (17324 <xQueueGenericCreate+0xfc>)
   1726a:	4b2f      	ldr	r3, [pc, #188]	; (17328 <xQueueGenericCreate+0x100>)
   1726c:	5c28      	ldrb	r0, [r5, r0]
   1726e:	4798      	blx	r3
   17270:	4b2e      	ldr	r3, [pc, #184]	; (1732c <xQueueGenericCreate+0x104>)
   17272:	b281      	uxth	r1, r0
   17274:	0020      	movs	r0, r4
   17276:	4798      	blx	r3
   17278:	4b2d      	ldr	r3, [pc, #180]	; (17330 <xQueueGenericCreate+0x108>)
   1727a:	0020      	movs	r0, r4
   1727c:	8819      	ldrh	r1, [r3, #0]
   1727e:	4b2d      	ldr	r3, [pc, #180]	; (17334 <xQueueGenericCreate+0x10c>)
   17280:	4798      	blx	r3
   17282:	0020      	movs	r0, r4
   17284:	47b0      	blx	r6
   17286:	4b2c      	ldr	r3, [pc, #176]	; (17338 <xQueueGenericCreate+0x110>)
   17288:	5c2f      	ldrb	r7, [r5, r0]
   1728a:	0020      	movs	r0, r4
   1728c:	4798      	blx	r3
   1728e:	4b2b      	ldr	r3, [pc, #172]	; (1733c <xQueueGenericCreate+0x114>)
   17290:	b2c1      	uxtb	r1, r0
   17292:	0038      	movs	r0, r7
   17294:	4798      	blx	r3
   17296:	4b2a      	ldr	r3, [pc, #168]	; (17340 <xQueueGenericCreate+0x118>)
   17298:	4798      	blx	r3
   1729a:	4b2a      	ldr	r3, [pc, #168]	; (17344 <xQueueGenericCreate+0x11c>)
   1729c:	4798      	blx	r3
   1729e:	4f2a      	ldr	r7, [pc, #168]	; (17348 <xQueueGenericCreate+0x120>)
   172a0:	883b      	ldrh	r3, [r7, #0]
   172a2:	4203      	tst	r3, r0
   172a4:	d016      	beq.n	172d4 <xQueueGenericCreate+0xac>
   172a6:	4b29      	ldr	r3, [pc, #164]	; (1734c <xQueueGenericCreate+0x124>)
   172a8:	0020      	movs	r0, r4
   172aa:	4798      	blx	r3
   172ac:	883b      	ldrh	r3, [r7, #0]
   172ae:	4203      	tst	r3, r0
   172b0:	d010      	beq.n	172d4 <xQueueGenericCreate+0xac>
   172b2:	0020      	movs	r0, r4
   172b4:	47b0      	blx	r6
   172b6:	5c2f      	ldrb	r7, [r5, r0]
   172b8:	0020      	movs	r0, r4
   172ba:	47b0      	blx	r6
   172bc:	5c2b      	ldrb	r3, [r5, r0]
   172be:	0020      	movs	r0, r4
   172c0:	9301      	str	r3, [sp, #4]
   172c2:	4b1d      	ldr	r3, [pc, #116]	; (17338 <xQueueGenericCreate+0x110>)
   172c4:	4798      	blx	r3
   172c6:	3718      	adds	r7, #24
   172c8:	b2ff      	uxtb	r7, r7
   172ca:	b2c2      	uxtb	r2, r0
   172cc:	9901      	ldr	r1, [sp, #4]
   172ce:	0038      	movs	r0, r7
   172d0:	4b1f      	ldr	r3, [pc, #124]	; (17350 <xQueueGenericCreate+0x128>)
   172d2:	4798      	blx	r3
   172d4:	0020      	movs	r0, r4
   172d6:	47b0      	blx	r6
   172d8:	4b17      	ldr	r3, [pc, #92]	; (17338 <xQueueGenericCreate+0x110>)
   172da:	5c2d      	ldrb	r5, [r5, r0]
   172dc:	0020      	movs	r0, r4
   172de:	4798      	blx	r3
   172e0:	2200      	movs	r2, #0
   172e2:	b2c1      	uxtb	r1, r0
   172e4:	4b1b      	ldr	r3, [pc, #108]	; (17354 <xQueueGenericCreate+0x12c>)
   172e6:	0028      	movs	r0, r5
   172e8:	4798      	blx	r3
	}
   172ea:	0020      	movs	r0, r4
   172ec:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
   172ee:	0003      	movs	r3, r0
   172f0:	3354      	adds	r3, #84	; 0x54
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
   172f2:	6003      	str	r3, [r0, #0]
   172f4:	e7aa      	b.n	1724c <xQueueGenericCreate+0x24>
			traceQUEUE_CREATE_FAILED( ucQueueType );
   172f6:	4b12      	ldr	r3, [pc, #72]	; (17340 <xQueueGenericCreate+0x118>)
   172f8:	4798      	blx	r3
   172fa:	4b12      	ldr	r3, [pc, #72]	; (17344 <xQueueGenericCreate+0x11c>)
   172fc:	4798      	blx	r3
   172fe:	4b12      	ldr	r3, [pc, #72]	; (17348 <xQueueGenericCreate+0x120>)
   17300:	881b      	ldrh	r3, [r3, #0]
   17302:	4203      	tst	r3, r0
   17304:	d0f1      	beq.n	172ea <xQueueGenericCreate+0xc2>
   17306:	4b07      	ldr	r3, [pc, #28]	; (17324 <xQueueGenericCreate+0xfc>)
   17308:	0021      	movs	r1, r4
   1730a:	5dd8      	ldrb	r0, [r3, r7]
   1730c:	4b12      	ldr	r3, [pc, #72]	; (17358 <xQueueGenericCreate+0x130>)
   1730e:	3040      	adds	r0, #64	; 0x40
   17310:	b2c0      	uxtb	r0, r0
   17312:	4798      	blx	r3
   17314:	e7e9      	b.n	172ea <xQueueGenericCreate+0xc2>
   17316:	46c0      	nop			; (mov r8, r8)
   17318:	00016eb5 	.word	0x00016eb5
   1731c:	000171ad 	.word	0x000171ad
   17320:	00015c05 	.word	0x00015c05
   17324:	200001e8 	.word	0x200001e8
   17328:	00016459 	.word	0x00016459
   1732c:	00015c91 	.word	0x00015c91
   17330:	200001ee 	.word	0x200001ee
   17334:	00015cb1 	.word	0x00015cb1
   17338:	00015c71 	.word	0x00015c71
   1733c:	000162f9 	.word	0x000162f9
   17340:	00015d9d 	.word	0x00015d9d
   17344:	00015c21 	.word	0x00015c21
   17348:	200001f0 	.word	0x200001f0
   1734c:	00015c81 	.word	0x00015c81
   17350:	000168b9 	.word	0x000168b9
   17354:	000163c5 	.word	0x000163c5
   17358:	00016a29 	.word	0x00016a29

0001735c <xQueueGenericSend>:
{
   1735c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1735e:	b087      	sub	sp, #28
   17360:	1e04      	subs	r4, r0, #0
   17362:	9101      	str	r1, [sp, #4]
   17364:	9203      	str	r2, [sp, #12]
   17366:	9300      	str	r3, [sp, #0]
	configASSERT( pxQueue );
   17368:	d101      	bne.n	1736e <xQueueGenericSend+0x12>
   1736a:	b672      	cpsid	i
   1736c:	e7fe      	b.n	1736c <xQueueGenericSend+0x10>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   1736e:	9b01      	ldr	r3, [sp, #4]
   17370:	2b00      	cmp	r3, #0
   17372:	d000      	beq.n	17376 <xQueueGenericSend+0x1a>
   17374:	e0fd      	b.n	17572 <xQueueGenericSend+0x216>
   17376:	6c03      	ldr	r3, [r0, #64]	; 0x40
   17378:	2b00      	cmp	r3, #0
   1737a:	d100      	bne.n	1737e <xQueueGenericSend+0x22>
   1737c:	e0f9      	b.n	17572 <xQueueGenericSend+0x216>
   1737e:	b672      	cpsid	i
   17380:	e7fe      	b.n	17380 <xQueueGenericSend+0x24>
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   17382:	6a63      	ldr	r3, [r4, #36]	; 0x24
   17384:	2b00      	cmp	r3, #0
   17386:	d100      	bne.n	1738a <xQueueGenericSend+0x2e>
   17388:	e0e0      	b.n	1754c <xQueueGenericSend+0x1f0>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1738a:	0020      	movs	r0, r4
   1738c:	4b83      	ldr	r3, [pc, #524]	; (1759c <xQueueGenericSend+0x240>)
   1738e:	3024      	adds	r0, #36	; 0x24
   17390:	4798      	blx	r3
   17392:	e0db      	b.n	1754c <xQueueGenericSend+0x1f0>
				if( xTicksToWait == ( TickType_t ) 0 )
   17394:	9b03      	ldr	r3, [sp, #12]
   17396:	2b00      	cmp	r3, #0
   17398:	d127      	bne.n	173ea <xQueueGenericSend+0x8e>
					taskEXIT_CRITICAL();
   1739a:	4b81      	ldr	r3, [pc, #516]	; (175a0 <xQueueGenericSend+0x244>)
   1739c:	4798      	blx	r3
			traceQUEUE_SEND_FAILED( pxQueue );
   1739e:	4b81      	ldr	r3, [pc, #516]	; (175a4 <xQueueGenericSend+0x248>)
   173a0:	4798      	blx	r3
   173a2:	4b81      	ldr	r3, [pc, #516]	; (175a8 <xQueueGenericSend+0x24c>)
   173a4:	4798      	blx	r3
   173a6:	4d81      	ldr	r5, [pc, #516]	; (175ac <xQueueGenericSend+0x250>)
   173a8:	882b      	ldrh	r3, [r5, #0]
   173aa:	4203      	tst	r3, r0
   173ac:	d01b      	beq.n	173e6 <xQueueGenericSend+0x8a>
   173ae:	4b80      	ldr	r3, [pc, #512]	; (175b0 <xQueueGenericSend+0x254>)
   173b0:	0020      	movs	r0, r4
   173b2:	4798      	blx	r3
   173b4:	882b      	ldrh	r3, [r5, #0]
   173b6:	4203      	tst	r3, r0
   173b8:	d015      	beq.n	173e6 <xQueueGenericSend+0x8a>
   173ba:	9b00      	ldr	r3, [sp, #0]
   173bc:	4f7d      	ldr	r7, [pc, #500]	; (175b4 <xQueueGenericSend+0x258>)
   173be:	4e7e      	ldr	r6, [pc, #504]	; (175b8 <xQueueGenericSend+0x25c>)
   173c0:	254d      	movs	r5, #77	; 0x4d
   173c2:	2b00      	cmp	r3, #0
   173c4:	d104      	bne.n	173d0 <xQueueGenericSend+0x74>
   173c6:	0020      	movs	r0, r4
   173c8:	47b8      	blx	r7
   173ca:	5c35      	ldrb	r5, [r6, r0]
   173cc:	3548      	adds	r5, #72	; 0x48
   173ce:	b2ed      	uxtb	r5, r5
   173d0:	0020      	movs	r0, r4
   173d2:	47b8      	blx	r7
   173d4:	4b79      	ldr	r3, [pc, #484]	; (175bc <xQueueGenericSend+0x260>)
   173d6:	5c36      	ldrb	r6, [r6, r0]
   173d8:	0020      	movs	r0, r4
   173da:	4798      	blx	r3
   173dc:	0031      	movs	r1, r6
   173de:	b2c2      	uxtb	r2, r0
   173e0:	4b77      	ldr	r3, [pc, #476]	; (175c0 <xQueueGenericSend+0x264>)
   173e2:	0028      	movs	r0, r5
   173e4:	4798      	blx	r3
			return errQUEUE_FULL;
   173e6:	2000      	movs	r0, #0
   173e8:	e0b7      	b.n	1755a <xQueueGenericSend+0x1fe>
				else if( xEntryTimeSet == pdFALSE )
   173ea:	2d00      	cmp	r5, #0
   173ec:	d102      	bne.n	173f4 <xQueueGenericSend+0x98>
					vTaskInternalSetTimeOutState( &xTimeOut );
   173ee:	a804      	add	r0, sp, #16
   173f0:	4b74      	ldr	r3, [pc, #464]	; (175c4 <xQueueGenericSend+0x268>)
   173f2:	4798      	blx	r3
		taskEXIT_CRITICAL();
   173f4:	4b6a      	ldr	r3, [pc, #424]	; (175a0 <xQueueGenericSend+0x244>)
   173f6:	4798      	blx	r3
		vTaskSuspendAll();
   173f8:	4b73      	ldr	r3, [pc, #460]	; (175c8 <xQueueGenericSend+0x26c>)
   173fa:	4798      	blx	r3
		prvLockQueue( pxQueue );
   173fc:	47b0      	blx	r6
   173fe:	0022      	movs	r2, r4
   17400:	3244      	adds	r2, #68	; 0x44
   17402:	7813      	ldrb	r3, [r2, #0]
   17404:	b25b      	sxtb	r3, r3
   17406:	3301      	adds	r3, #1
   17408:	d101      	bne.n	1740e <xQueueGenericSend+0xb2>
   1740a:	2300      	movs	r3, #0
   1740c:	7013      	strb	r3, [r2, #0]
   1740e:	0022      	movs	r2, r4
   17410:	3245      	adds	r2, #69	; 0x45
   17412:	7813      	ldrb	r3, [r2, #0]
   17414:	b25b      	sxtb	r3, r3
   17416:	3301      	adds	r3, #1
   17418:	d101      	bne.n	1741e <xQueueGenericSend+0xc2>
   1741a:	2300      	movs	r3, #0
   1741c:	7013      	strb	r3, [r2, #0]
   1741e:	4b60      	ldr	r3, [pc, #384]	; (175a0 <xQueueGenericSend+0x244>)
   17420:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   17422:	a903      	add	r1, sp, #12
   17424:	a804      	add	r0, sp, #16
   17426:	4b69      	ldr	r3, [pc, #420]	; (175cc <xQueueGenericSend+0x270>)
   17428:	4798      	blx	r3
   1742a:	4f69      	ldr	r7, [pc, #420]	; (175d0 <xQueueGenericSend+0x274>)
   1742c:	2800      	cmp	r0, #0
   1742e:	d000      	beq.n	17432 <xQueueGenericSend+0xd6>
   17430:	e09a      	b.n	17568 <xQueueGenericSend+0x20c>
	taskENTER_CRITICAL();
   17432:	47b0      	blx	r6
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   17434:	6ba6      	ldr	r6, [r4, #56]	; 0x38
   17436:	6be5      	ldr	r5, [r4, #60]	; 0x3c
	taskEXIT_CRITICAL();
   17438:	4b59      	ldr	r3, [pc, #356]	; (175a0 <xQueueGenericSend+0x244>)
   1743a:	4798      	blx	r3
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
   1743c:	42ae      	cmp	r6, r5
   1743e:	d000      	beq.n	17442 <xQueueGenericSend+0xe6>
   17440:	e08d      	b.n	1755e <xQueueGenericSend+0x202>
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
   17442:	4b58      	ldr	r3, [pc, #352]	; (175a4 <xQueueGenericSend+0x248>)
   17444:	4798      	blx	r3
   17446:	4b58      	ldr	r3, [pc, #352]	; (175a8 <xQueueGenericSend+0x24c>)
   17448:	4798      	blx	r3
   1744a:	4d58      	ldr	r5, [pc, #352]	; (175ac <xQueueGenericSend+0x250>)
   1744c:	882b      	ldrh	r3, [r5, #0]
   1744e:	4203      	tst	r3, r0
   17450:	d01c      	beq.n	1748c <xQueueGenericSend+0x130>
   17452:	4b57      	ldr	r3, [pc, #348]	; (175b0 <xQueueGenericSend+0x254>)
   17454:	0020      	movs	r0, r4
   17456:	4798      	blx	r3
   17458:	882b      	ldrh	r3, [r5, #0]
   1745a:	4203      	tst	r3, r0
   1745c:	d016      	beq.n	1748c <xQueueGenericSend+0x130>
   1745e:	9b00      	ldr	r3, [sp, #0]
   17460:	4e54      	ldr	r6, [pc, #336]	; (175b4 <xQueueGenericSend+0x258>)
   17462:	2575      	movs	r5, #117	; 0x75
   17464:	2b00      	cmp	r3, #0
   17466:	d105      	bne.n	17474 <xQueueGenericSend+0x118>
   17468:	0020      	movs	r0, r4
   1746a:	47b0      	blx	r6
   1746c:	4b52      	ldr	r3, [pc, #328]	; (175b8 <xQueueGenericSend+0x25c>)
   1746e:	5c1d      	ldrb	r5, [r3, r0]
   17470:	3570      	adds	r5, #112	; 0x70
   17472:	b2ed      	uxtb	r5, r5
   17474:	0020      	movs	r0, r4
   17476:	47b0      	blx	r6
   17478:	4b4f      	ldr	r3, [pc, #316]	; (175b8 <xQueueGenericSend+0x25c>)
   1747a:	5c1e      	ldrb	r6, [r3, r0]
   1747c:	4b4f      	ldr	r3, [pc, #316]	; (175bc <xQueueGenericSend+0x260>)
   1747e:	0020      	movs	r0, r4
   17480:	4798      	blx	r3
   17482:	0031      	movs	r1, r6
   17484:	b2c2      	uxtb	r2, r0
   17486:	4b4e      	ldr	r3, [pc, #312]	; (175c0 <xQueueGenericSend+0x264>)
   17488:	0028      	movs	r0, r5
   1748a:	4798      	blx	r3
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
   1748c:	0020      	movs	r0, r4
   1748e:	4b51      	ldr	r3, [pc, #324]	; (175d4 <xQueueGenericSend+0x278>)
   17490:	9903      	ldr	r1, [sp, #12]
   17492:	3010      	adds	r0, #16
   17494:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
   17496:	0020      	movs	r0, r4
   17498:	47b8      	blx	r7
				if( xTaskResumeAll() == pdFALSE )
   1749a:	4b4f      	ldr	r3, [pc, #316]	; (175d8 <xQueueGenericSend+0x27c>)
   1749c:	4798      	blx	r3
   1749e:	2800      	cmp	r0, #0
   174a0:	d101      	bne.n	174a6 <xQueueGenericSend+0x14a>
					portYIELD_WITHIN_API();
   174a2:	4b4e      	ldr	r3, [pc, #312]	; (175dc <xQueueGenericSend+0x280>)
   174a4:	4798      	blx	r3
   174a6:	2501      	movs	r5, #1
		taskENTER_CRITICAL();
   174a8:	4e4d      	ldr	r6, [pc, #308]	; (175e0 <xQueueGenericSend+0x284>)
   174aa:	47b0      	blx	r6
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   174ac:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   174ae:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   174b0:	4293      	cmp	r3, r2
   174b2:	d303      	bcc.n	174bc <xQueueGenericSend+0x160>
   174b4:	9b00      	ldr	r3, [sp, #0]
   174b6:	2b02      	cmp	r3, #2
   174b8:	d000      	beq.n	174bc <xQueueGenericSend+0x160>
   174ba:	e76b      	b.n	17394 <xQueueGenericSend+0x38>
				traceQUEUE_SEND( pxQueue );
   174bc:	4b39      	ldr	r3, [pc, #228]	; (175a4 <xQueueGenericSend+0x248>)
   174be:	4798      	blx	r3
   174c0:	4b39      	ldr	r3, [pc, #228]	; (175a8 <xQueueGenericSend+0x24c>)
   174c2:	4798      	blx	r3
   174c4:	4e39      	ldr	r6, [pc, #228]	; (175ac <xQueueGenericSend+0x250>)
   174c6:	4d3b      	ldr	r5, [pc, #236]	; (175b4 <xQueueGenericSend+0x258>)
   174c8:	8833      	ldrh	r3, [r6, #0]
   174ca:	4203      	tst	r3, r0
   174cc:	d01b      	beq.n	17506 <xQueueGenericSend+0x1aa>
   174ce:	4b38      	ldr	r3, [pc, #224]	; (175b0 <xQueueGenericSend+0x254>)
   174d0:	0020      	movs	r0, r4
   174d2:	4798      	blx	r3
   174d4:	8833      	ldrh	r3, [r6, #0]
   174d6:	4203      	tst	r3, r0
   174d8:	d015      	beq.n	17506 <xQueueGenericSend+0x1aa>
   174da:	9b00      	ldr	r3, [sp, #0]
   174dc:	2625      	movs	r6, #37	; 0x25
   174de:	2b00      	cmp	r3, #0
   174e0:	d105      	bne.n	174ee <xQueueGenericSend+0x192>
   174e2:	0020      	movs	r0, r4
   174e4:	47a8      	blx	r5
   174e6:	4b34      	ldr	r3, [pc, #208]	; (175b8 <xQueueGenericSend+0x25c>)
   174e8:	5c1e      	ldrb	r6, [r3, r0]
   174ea:	3620      	adds	r6, #32
   174ec:	b2f6      	uxtb	r6, r6
   174ee:	0020      	movs	r0, r4
   174f0:	47a8      	blx	r5
   174f2:	4b31      	ldr	r3, [pc, #196]	; (175b8 <xQueueGenericSend+0x25c>)
   174f4:	5c1f      	ldrb	r7, [r3, r0]
   174f6:	4b31      	ldr	r3, [pc, #196]	; (175bc <xQueueGenericSend+0x260>)
   174f8:	0020      	movs	r0, r4
   174fa:	4798      	blx	r3
   174fc:	0039      	movs	r1, r7
   174fe:	b2c2      	uxtb	r2, r0
   17500:	4b2f      	ldr	r3, [pc, #188]	; (175c0 <xQueueGenericSend+0x264>)
   17502:	0030      	movs	r0, r6
   17504:	4798      	blx	r3
   17506:	0020      	movs	r0, r4
   17508:	47a8      	blx	r5
   1750a:	4e2b      	ldr	r6, [pc, #172]	; (175b8 <xQueueGenericSend+0x25c>)
   1750c:	4b2b      	ldr	r3, [pc, #172]	; (175bc <xQueueGenericSend+0x260>)
   1750e:	5c37      	ldrb	r7, [r6, r0]
   17510:	0020      	movs	r0, r4
   17512:	4798      	blx	r3
   17514:	b2c3      	uxtb	r3, r0
   17516:	0020      	movs	r0, r4
   17518:	9302      	str	r3, [sp, #8]
   1751a:	47a8      	blx	r5
   1751c:	5c33      	ldrb	r3, [r6, r0]
   1751e:	2200      	movs	r2, #0
   17520:	2b02      	cmp	r3, #2
   17522:	d002      	beq.n	1752a <xQueueGenericSend+0x1ce>
   17524:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   17526:	3201      	adds	r2, #1
   17528:	b2d2      	uxtb	r2, r2
   1752a:	9902      	ldr	r1, [sp, #8]
   1752c:	0038      	movs	r0, r7
   1752e:	4b2d      	ldr	r3, [pc, #180]	; (175e4 <xQueueGenericSend+0x288>)
   17530:	4798      	blx	r3
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   17532:	4b2d      	ldr	r3, [pc, #180]	; (175e8 <xQueueGenericSend+0x28c>)
   17534:	9a00      	ldr	r2, [sp, #0]
   17536:	9901      	ldr	r1, [sp, #4]
   17538:	0020      	movs	r0, r4
   1753a:	4798      	blx	r3
					if( pxQueue->pxQueueSetContainer != NULL )
   1753c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   1753e:	2b00      	cmp	r3, #0
   17540:	d100      	bne.n	17544 <xQueueGenericSend+0x1e8>
   17542:	e71e      	b.n	17382 <xQueueGenericSend+0x26>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
   17544:	9900      	ldr	r1, [sp, #0]
   17546:	0020      	movs	r0, r4
   17548:	4b28      	ldr	r3, [pc, #160]	; (175ec <xQueueGenericSend+0x290>)
   1754a:	4798      	blx	r3
   1754c:	2800      	cmp	r0, #0
   1754e:	d001      	beq.n	17554 <xQueueGenericSend+0x1f8>
							queueYIELD_IF_USING_PREEMPTION();
   17550:	4b22      	ldr	r3, [pc, #136]	; (175dc <xQueueGenericSend+0x280>)
   17552:	4798      	blx	r3
				taskEXIT_CRITICAL();
   17554:	4b12      	ldr	r3, [pc, #72]	; (175a0 <xQueueGenericSend+0x244>)
   17556:	4798      	blx	r3
				return pdPASS;
   17558:	2001      	movs	r0, #1
}
   1755a:	b007      	add	sp, #28
   1755c:	bdf0      	pop	{r4, r5, r6, r7, pc}
				prvUnlockQueue( pxQueue );
   1755e:	0020      	movs	r0, r4
   17560:	47b8      	blx	r7
				( void ) xTaskResumeAll();
   17562:	4b1d      	ldr	r3, [pc, #116]	; (175d8 <xQueueGenericSend+0x27c>)
   17564:	4798      	blx	r3
   17566:	e79e      	b.n	174a6 <xQueueGenericSend+0x14a>
			prvUnlockQueue( pxQueue );
   17568:	0020      	movs	r0, r4
   1756a:	47b8      	blx	r7
			( void ) xTaskResumeAll();
   1756c:	4b1a      	ldr	r3, [pc, #104]	; (175d8 <xQueueGenericSend+0x27c>)
   1756e:	4798      	blx	r3
   17570:	e715      	b.n	1739e <xQueueGenericSend+0x42>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
   17572:	9b00      	ldr	r3, [sp, #0]
   17574:	2b02      	cmp	r3, #2
   17576:	d102      	bne.n	1757e <xQueueGenericSend+0x222>
   17578:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1757a:	2b01      	cmp	r3, #1
   1757c:	d10b      	bne.n	17596 <xQueueGenericSend+0x23a>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   1757e:	4b1c      	ldr	r3, [pc, #112]	; (175f0 <xQueueGenericSend+0x294>)
   17580:	4798      	blx	r3
   17582:	2500      	movs	r5, #0
   17584:	2800      	cmp	r0, #0
   17586:	d000      	beq.n	1758a <xQueueGenericSend+0x22e>
   17588:	e78e      	b.n	174a8 <xQueueGenericSend+0x14c>
   1758a:	9d03      	ldr	r5, [sp, #12]
   1758c:	2d00      	cmp	r5, #0
   1758e:	d100      	bne.n	17592 <xQueueGenericSend+0x236>
   17590:	e78a      	b.n	174a8 <xQueueGenericSend+0x14c>
   17592:	b672      	cpsid	i
   17594:	e7fe      	b.n	17594 <xQueueGenericSend+0x238>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
   17596:	b672      	cpsid	i
   17598:	e7fe      	b.n	17598 <xQueueGenericSend+0x23c>
   1759a:	46c0      	nop			; (mov r8, r8)
   1759c:	000188d1 	.word	0x000188d1
   175a0:	00016e09 	.word	0x00016e09
   175a4:	00015d9d 	.word	0x00015d9d
   175a8:	00015c21 	.word	0x00015c21
   175ac:	200001f0 	.word	0x200001f0
   175b0:	00015c81 	.word	0x00015c81
   175b4:	00015c05 	.word	0x00015c05
   175b8:	200001e8 	.word	0x200001e8
   175bc:	00015c71 	.word	0x00015c71
   175c0:	000168b9 	.word	0x000168b9
   175c4:	000189a9 	.word	0x000189a9
   175c8:	00018311 	.word	0x00018311
   175cc:	000189c1 	.word	0x000189c1
   175d0:	00017121 	.word	0x00017121
   175d4:	00018811 	.word	0x00018811
   175d8:	00018499 	.word	0x00018499
   175dc:	00016de1 	.word	0x00016de1
   175e0:	00016df1 	.word	0x00016df1
   175e4:	000163c5 	.word	0x000163c5
   175e8:	00016f75 	.word	0x00016f75
   175ec:	00016fed 	.word	0x00016fed
   175f0:	00018a7d 	.word	0x00018a7d

000175f4 <xQueueCreateMutex>:
	{
   175f4:	b570      	push	{r4, r5, r6, lr}
   175f6:	0002      	movs	r2, r0
		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
   175f8:	2100      	movs	r1, #0
   175fa:	2001      	movs	r0, #1
   175fc:	4b06      	ldr	r3, [pc, #24]	; (17618 <xQueueCreateMutex+0x24>)
   175fe:	4798      	blx	r3
   17600:	1e04      	subs	r4, r0, #0
		if( pxNewQueue != NULL )
   17602:	d007      	beq.n	17614 <xQueueCreateMutex+0x20>
			pxNewQueue->pxMutexHolder = NULL;
   17604:	2100      	movs	r1, #0
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
   17606:	4d05      	ldr	r5, [pc, #20]	; (1761c <xQueueCreateMutex+0x28>)
			pxNewQueue->pxMutexHolder = NULL;
   17608:	6041      	str	r1, [r0, #4]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
   1760a:	6001      	str	r1, [r0, #0]
			pxNewQueue->u.uxRecursiveCallCount = 0;
   1760c:	60c1      	str	r1, [r0, #12]
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
   1760e:	000b      	movs	r3, r1
   17610:	000a      	movs	r2, r1
   17612:	47a8      	blx	r5
	}
   17614:	0020      	movs	r0, r4
   17616:	bd70      	pop	{r4, r5, r6, pc}
   17618:	00017229 	.word	0x00017229
   1761c:	0001735d 	.word	0x0001735d

00017620 <xQueueGenericSendFromISR>:
{
   17620:	b5f0      	push	{r4, r5, r6, r7, lr}
   17622:	b085      	sub	sp, #20
   17624:	0004      	movs	r4, r0
   17626:	9102      	str	r1, [sp, #8]
   17628:	0017      	movs	r7, r2
   1762a:	9300      	str	r3, [sp, #0]
	configASSERT( pxQueue );
   1762c:	2800      	cmp	r0, #0
   1762e:	d101      	bne.n	17634 <xQueueGenericSendFromISR+0x14>
   17630:	b672      	cpsid	i
   17632:	e7fe      	b.n	17632 <xQueueGenericSendFromISR+0x12>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   17634:	9b02      	ldr	r3, [sp, #8]
   17636:	2b00      	cmp	r3, #0
   17638:	d13c      	bne.n	176b4 <xQueueGenericSendFromISR+0x94>
   1763a:	6c03      	ldr	r3, [r0, #64]	; 0x40
   1763c:	2b00      	cmp	r3, #0
   1763e:	d039      	beq.n	176b4 <xQueueGenericSendFromISR+0x94>
   17640:	b672      	cpsid	i
   17642:	e7fe      	b.n	17642 <xQueueGenericSendFromISR+0x22>
							if( pxHigherPriorityTaskWoken != NULL )
   17644:	2f00      	cmp	r7, #0
   17646:	d100      	bne.n	1764a <xQueueGenericSendFromISR+0x2a>
   17648:	e088      	b.n	1775c <xQueueGenericSendFromISR+0x13c>
								*pxHigherPriorityTaskWoken = pdTRUE;
   1764a:	2501      	movs	r5, #1
   1764c:	603d      	str	r5, [r7, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   1764e:	9803      	ldr	r0, [sp, #12]
   17650:	4b44      	ldr	r3, [pc, #272]	; (17764 <xQueueGenericSendFromISR+0x144>)
   17652:	4798      	blx	r3
}
   17654:	0028      	movs	r0, r5
   17656:	b005      	add	sp, #20
   17658:	bdf0      	pop	{r4, r5, r6, r7, pc}
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1765a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1765c:	2b00      	cmp	r3, #0
   1765e:	d07d      	beq.n	1775c <xQueueGenericSendFromISR+0x13c>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   17660:	0020      	movs	r0, r4
   17662:	4b41      	ldr	r3, [pc, #260]	; (17768 <xQueueGenericSendFromISR+0x148>)
   17664:	3024      	adds	r0, #36	; 0x24
   17666:	4798      	blx	r3
   17668:	e075      	b.n	17756 <xQueueGenericSendFromISR+0x136>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
   1766a:	9b01      	ldr	r3, [sp, #4]
   1766c:	3445      	adds	r4, #69	; 0x45
   1766e:	3301      	adds	r3, #1
   17670:	b25b      	sxtb	r3, r3
   17672:	7023      	strb	r3, [r4, #0]
   17674:	e072      	b.n	1775c <xQueueGenericSendFromISR+0x13c>
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
   17676:	0020      	movs	r0, r4
   17678:	4798      	blx	r3
   1767a:	4b3c      	ldr	r3, [pc, #240]	; (1776c <xQueueGenericSendFromISR+0x14c>)
			xReturn = errQUEUE_FULL;
   1767c:	2500      	movs	r5, #0
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
   1767e:	881b      	ldrh	r3, [r3, #0]
   17680:	4203      	tst	r3, r0
   17682:	d0e4      	beq.n	1764e <xQueueGenericSendFromISR+0x2e>
   17684:	9b00      	ldr	r3, [sp, #0]
   17686:	4f3a      	ldr	r7, [pc, #232]	; (17770 <xQueueGenericSendFromISR+0x150>)
   17688:	4e3a      	ldr	r6, [pc, #232]	; (17774 <xQueueGenericSendFromISR+0x154>)
   1768a:	355d      	adds	r5, #93	; 0x5d
   1768c:	2b00      	cmp	r3, #0
   1768e:	d104      	bne.n	1769a <xQueueGenericSendFromISR+0x7a>
   17690:	0020      	movs	r0, r4
   17692:	47b8      	blx	r7
   17694:	5c35      	ldrb	r5, [r6, r0]
   17696:	3558      	adds	r5, #88	; 0x58
   17698:	b2ed      	uxtb	r5, r5
   1769a:	0020      	movs	r0, r4
   1769c:	47b8      	blx	r7
   1769e:	4b36      	ldr	r3, [pc, #216]	; (17778 <xQueueGenericSendFromISR+0x158>)
   176a0:	5c36      	ldrb	r6, [r6, r0]
   176a2:	0020      	movs	r0, r4
   176a4:	4798      	blx	r3
   176a6:	0031      	movs	r1, r6
   176a8:	b2c2      	uxtb	r2, r0
   176aa:	4b34      	ldr	r3, [pc, #208]	; (1777c <xQueueGenericSendFromISR+0x15c>)
   176ac:	0028      	movs	r0, r5
   176ae:	4798      	blx	r3
			xReturn = errQUEUE_FULL;
   176b0:	2500      	movs	r5, #0
   176b2:	e7cc      	b.n	1764e <xQueueGenericSendFromISR+0x2e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
   176b4:	9b00      	ldr	r3, [sp, #0]
   176b6:	2b02      	cmp	r3, #2
   176b8:	d102      	bne.n	176c0 <xQueueGenericSendFromISR+0xa0>
   176ba:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   176bc:	2b01      	cmp	r3, #1
   176be:	d14f      	bne.n	17760 <xQueueGenericSendFromISR+0x140>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   176c0:	4b2f      	ldr	r3, [pc, #188]	; (17780 <xQueueGenericSendFromISR+0x160>)
   176c2:	4798      	blx	r3
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   176c4:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   176c6:	6be1      	ldr	r1, [r4, #60]	; 0x3c
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   176c8:	9003      	str	r0, [sp, #12]
   176ca:	4b2e      	ldr	r3, [pc, #184]	; (17784 <xQueueGenericSendFromISR+0x164>)
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   176cc:	428a      	cmp	r2, r1
   176ce:	d302      	bcc.n	176d6 <xQueueGenericSendFromISR+0xb6>
   176d0:	9a00      	ldr	r2, [sp, #0]
   176d2:	2a02      	cmp	r2, #2
   176d4:	d1cf      	bne.n	17676 <xQueueGenericSendFromISR+0x56>
			const int8_t cTxLock = pxQueue->cTxLock;
   176d6:	0022      	movs	r2, r4
   176d8:	3245      	adds	r2, #69	; 0x45
   176da:	7812      	ldrb	r2, [r2, #0]
			traceQUEUE_SEND_FROM_ISR( pxQueue );
   176dc:	0020      	movs	r0, r4
			const int8_t cTxLock = pxQueue->cTxLock;
   176de:	b252      	sxtb	r2, r2
   176e0:	9201      	str	r2, [sp, #4]
			traceQUEUE_SEND_FROM_ISR( pxQueue );
   176e2:	4798      	blx	r3
   176e4:	4b21      	ldr	r3, [pc, #132]	; (1776c <xQueueGenericSendFromISR+0x14c>)
   176e6:	881b      	ldrh	r3, [r3, #0]
   176e8:	4203      	tst	r3, r0
   176ea:	d016      	beq.n	1771a <xQueueGenericSendFromISR+0xfa>
   176ec:	9b00      	ldr	r3, [sp, #0]
   176ee:	4e20      	ldr	r6, [pc, #128]	; (17770 <xQueueGenericSendFromISR+0x150>)
   176f0:	2535      	movs	r5, #53	; 0x35
   176f2:	2b00      	cmp	r3, #0
   176f4:	d105      	bne.n	17702 <xQueueGenericSendFromISR+0xe2>
   176f6:	0020      	movs	r0, r4
   176f8:	47b0      	blx	r6
   176fa:	4b1e      	ldr	r3, [pc, #120]	; (17774 <xQueueGenericSendFromISR+0x154>)
   176fc:	5c1d      	ldrb	r5, [r3, r0]
   176fe:	3530      	adds	r5, #48	; 0x30
   17700:	b2ed      	uxtb	r5, r5
   17702:	0020      	movs	r0, r4
   17704:	47b0      	blx	r6
   17706:	4b1b      	ldr	r3, [pc, #108]	; (17774 <xQueueGenericSendFromISR+0x154>)
   17708:	5c1e      	ldrb	r6, [r3, r0]
   1770a:	4b1b      	ldr	r3, [pc, #108]	; (17778 <xQueueGenericSendFromISR+0x158>)
   1770c:	0020      	movs	r0, r4
   1770e:	4798      	blx	r3
   17710:	0031      	movs	r1, r6
   17712:	b2c2      	uxtb	r2, r0
   17714:	4b19      	ldr	r3, [pc, #100]	; (1777c <xQueueGenericSendFromISR+0x15c>)
   17716:	0028      	movs	r0, r5
   17718:	4798      	blx	r3
   1771a:	4b15      	ldr	r3, [pc, #84]	; (17770 <xQueueGenericSendFromISR+0x150>)
   1771c:	0020      	movs	r0, r4
   1771e:	4798      	blx	r3
   17720:	4b14      	ldr	r3, [pc, #80]	; (17774 <xQueueGenericSendFromISR+0x154>)
   17722:	5c1d      	ldrb	r5, [r3, r0]
   17724:	4b14      	ldr	r3, [pc, #80]	; (17778 <xQueueGenericSendFromISR+0x158>)
   17726:	0020      	movs	r0, r4
   17728:	4798      	blx	r3
   1772a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   1772c:	b2c1      	uxtb	r1, r0
   1772e:	3201      	adds	r2, #1
   17730:	b2d2      	uxtb	r2, r2
   17732:	0028      	movs	r0, r5
   17734:	4b14      	ldr	r3, [pc, #80]	; (17788 <xQueueGenericSendFromISR+0x168>)
   17736:	4798      	blx	r3
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   17738:	4b14      	ldr	r3, [pc, #80]	; (1778c <xQueueGenericSendFromISR+0x16c>)
   1773a:	9a00      	ldr	r2, [sp, #0]
   1773c:	9902      	ldr	r1, [sp, #8]
   1773e:	0020      	movs	r0, r4
   17740:	4798      	blx	r3
			if( cTxLock == queueUNLOCKED )
   17742:	9b01      	ldr	r3, [sp, #4]
   17744:	3301      	adds	r3, #1
   17746:	d190      	bne.n	1766a <xQueueGenericSendFromISR+0x4a>
					if( pxQueue->pxQueueSetContainer != NULL )
   17748:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   1774a:	2b00      	cmp	r3, #0
   1774c:	d085      	beq.n	1765a <xQueueGenericSendFromISR+0x3a>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
   1774e:	9900      	ldr	r1, [sp, #0]
   17750:	0020      	movs	r0, r4
   17752:	4b0f      	ldr	r3, [pc, #60]	; (17790 <xQueueGenericSendFromISR+0x170>)
   17754:	4798      	blx	r3
   17756:	2800      	cmp	r0, #0
   17758:	d000      	beq.n	1775c <xQueueGenericSendFromISR+0x13c>
   1775a:	e773      	b.n	17644 <xQueueGenericSendFromISR+0x24>
			xReturn = pdPASS;
   1775c:	2501      	movs	r5, #1
   1775e:	e776      	b.n	1764e <xQueueGenericSendFromISR+0x2e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
   17760:	b672      	cpsid	i
   17762:	e7fe      	b.n	17762 <xQueueGenericSendFromISR+0x142>
   17764:	00016e2d 	.word	0x00016e2d
   17768:	000188d1 	.word	0x000188d1
   1776c:	200001f0 	.word	0x200001f0
   17770:	00015c05 	.word	0x00015c05
   17774:	200001e8 	.word	0x200001e8
   17778:	00015c71 	.word	0x00015c71
   1777c:	000168b9 	.word	0x000168b9
   17780:	00016e25 	.word	0x00016e25
   17784:	00015c81 	.word	0x00015c81
   17788:	000163c5 	.word	0x000163c5
   1778c:	00016f75 	.word	0x00016f75
   17790:	00016fed 	.word	0x00016fed

00017794 <MyWrapper>:
{
   17794:	b5f0      	push	{r4, r5, r6, r7, lr}
   17796:	b085      	sub	sp, #20
   17798:	0004      	movs	r4, r0
   1779a:	000f      	movs	r7, r1
   1779c:	9202      	str	r2, [sp, #8]
	configASSERT( pxQueue );
   1779e:	2800      	cmp	r0, #0
   177a0:	d101      	bne.n	177a6 <MyWrapper+0x12>
   177a2:	b672      	cpsid	i
   177a4:	e7fe      	b.n	177a4 <MyWrapper+0x10>
	configASSERT( pxQueue->uxItemSize == 0 );
   177a6:	6c03      	ldr	r3, [r0, #64]	; 0x40
   177a8:	2b00      	cmp	r3, #0
   177aa:	d001      	beq.n	177b0 <MyWrapper+0x1c>
   177ac:	b672      	cpsid	i
   177ae:	e7fe      	b.n	177ae <MyWrapper+0x1a>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
   177b0:	6803      	ldr	r3, [r0, #0]
   177b2:	2b00      	cmp	r3, #0
   177b4:	d103      	bne.n	177be <MyWrapper+0x2a>
   177b6:	6843      	ldr	r3, [r0, #4]
   177b8:	2b00      	cmp	r3, #0
   177ba:	d000      	beq.n	177be <MyWrapper+0x2a>
   177bc:	e082      	b.n	178c4 <MyWrapper+0x130>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   177be:	4b42      	ldr	r3, [pc, #264]	; (178c8 <MyWrapper+0x134>)
   177c0:	4798      	blx	r3
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   177c2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
		if( uxMessagesWaiting < pxQueue->uxLength )
   177c4:	6be1      	ldr	r1, [r4, #60]	; 0x3c
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   177c6:	9300      	str	r3, [sp, #0]
		if( uxMessagesWaiting < pxQueue->uxLength )
   177c8:	9a00      	ldr	r2, [sp, #0]
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   177ca:	9003      	str	r0, [sp, #12]
   177cc:	4b3f      	ldr	r3, [pc, #252]	; (178cc <MyWrapper+0x138>)
		if( uxMessagesWaiting < pxQueue->uxLength )
   177ce:	428a      	cmp	r2, r1
   177d0:	d31e      	bcc.n	17810 <MyWrapper+0x7c>
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
   177d2:	0020      	movs	r0, r4
   177d4:	4798      	blx	r3
   177d6:	4b3e      	ldr	r3, [pc, #248]	; (178d0 <MyWrapper+0x13c>)
			xReturn = errQUEUE_FULL;
   177d8:	2500      	movs	r5, #0
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
   177da:	881b      	ldrh	r3, [r3, #0]
   177dc:	4203      	tst	r3, r0
   177de:	d05d      	beq.n	1789c <MyWrapper+0x108>
   177e0:	9b02      	ldr	r3, [sp, #8]
   177e2:	4f3c      	ldr	r7, [pc, #240]	; (178d4 <MyWrapper+0x140>)
   177e4:	4e3c      	ldr	r6, [pc, #240]	; (178d8 <MyWrapper+0x144>)
   177e6:	355d      	adds	r5, #93	; 0x5d
   177e8:	2b00      	cmp	r3, #0
   177ea:	d104      	bne.n	177f6 <MyWrapper+0x62>
   177ec:	0020      	movs	r0, r4
   177ee:	47b8      	blx	r7
   177f0:	5c35      	ldrb	r5, [r6, r0]
   177f2:	3558      	adds	r5, #88	; 0x58
   177f4:	b2ed      	uxtb	r5, r5
   177f6:	0020      	movs	r0, r4
   177f8:	47b8      	blx	r7
   177fa:	4b38      	ldr	r3, [pc, #224]	; (178dc <MyWrapper+0x148>)
   177fc:	5c36      	ldrb	r6, [r6, r0]
   177fe:	0020      	movs	r0, r4
   17800:	4798      	blx	r3
   17802:	0031      	movs	r1, r6
   17804:	b2c2      	uxtb	r2, r0
   17806:	4b36      	ldr	r3, [pc, #216]	; (178e0 <MyWrapper+0x14c>)
   17808:	0028      	movs	r0, r5
   1780a:	4798      	blx	r3
			xReturn = errQUEUE_FULL;
   1780c:	2500      	movs	r5, #0
   1780e:	e045      	b.n	1789c <MyWrapper+0x108>
			const int8_t cTxLock = pxQueue->cTxLock;
   17810:	0022      	movs	r2, r4
   17812:	3245      	adds	r2, #69	; 0x45
   17814:	7812      	ldrb	r2, [r2, #0]
			traceQUEUE_SEND_FROM_ISR( pxQueue );
   17816:	0020      	movs	r0, r4
			const int8_t cTxLock = pxQueue->cTxLock;
   17818:	b252      	sxtb	r2, r2
   1781a:	9201      	str	r2, [sp, #4]
			traceQUEUE_SEND_FROM_ISR( pxQueue );
   1781c:	4798      	blx	r3
   1781e:	4b2c      	ldr	r3, [pc, #176]	; (178d0 <MyWrapper+0x13c>)
   17820:	881b      	ldrh	r3, [r3, #0]
   17822:	4203      	tst	r3, r0
   17824:	d016      	beq.n	17854 <MyWrapper+0xc0>
   17826:	9b02      	ldr	r3, [sp, #8]
   17828:	4e2a      	ldr	r6, [pc, #168]	; (178d4 <MyWrapper+0x140>)
   1782a:	2535      	movs	r5, #53	; 0x35
   1782c:	2b00      	cmp	r3, #0
   1782e:	d105      	bne.n	1783c <MyWrapper+0xa8>
   17830:	0020      	movs	r0, r4
   17832:	47b0      	blx	r6
   17834:	4b28      	ldr	r3, [pc, #160]	; (178d8 <MyWrapper+0x144>)
   17836:	5c1d      	ldrb	r5, [r3, r0]
   17838:	3530      	adds	r5, #48	; 0x30
   1783a:	b2ed      	uxtb	r5, r5
   1783c:	0020      	movs	r0, r4
   1783e:	47b0      	blx	r6
   17840:	4b25      	ldr	r3, [pc, #148]	; (178d8 <MyWrapper+0x144>)
   17842:	5c1e      	ldrb	r6, [r3, r0]
   17844:	4b25      	ldr	r3, [pc, #148]	; (178dc <MyWrapper+0x148>)
   17846:	0020      	movs	r0, r4
   17848:	4798      	blx	r3
   1784a:	0031      	movs	r1, r6
   1784c:	b2c2      	uxtb	r2, r0
   1784e:	4b24      	ldr	r3, [pc, #144]	; (178e0 <MyWrapper+0x14c>)
   17850:	0028      	movs	r0, r5
   17852:	4798      	blx	r3
   17854:	4b1f      	ldr	r3, [pc, #124]	; (178d4 <MyWrapper+0x140>)
   17856:	0020      	movs	r0, r4
   17858:	4798      	blx	r3
   1785a:	4b1f      	ldr	r3, [pc, #124]	; (178d8 <MyWrapper+0x144>)
   1785c:	5c1d      	ldrb	r5, [r3, r0]
   1785e:	4b1f      	ldr	r3, [pc, #124]	; (178dc <MyWrapper+0x148>)
   17860:	0020      	movs	r0, r4
   17862:	4798      	blx	r3
   17864:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   17866:	b2c1      	uxtb	r1, r0
   17868:	3201      	adds	r2, #1
   1786a:	4b1e      	ldr	r3, [pc, #120]	; (178e4 <MyWrapper+0x150>)
   1786c:	b2d2      	uxtb	r2, r2
   1786e:	0028      	movs	r0, r5
   17870:	4798      	blx	r3
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   17872:	9b00      	ldr	r3, [sp, #0]
   17874:	3301      	adds	r3, #1
   17876:	63a3      	str	r3, [r4, #56]	; 0x38
			if( cTxLock == queueUNLOCKED )
   17878:	9b01      	ldr	r3, [sp, #4]
   1787a:	3301      	adds	r3, #1
   1787c:	d11c      	bne.n	178b8 <MyWrapper+0x124>
					if( pxQueue->pxQueueSetContainer != NULL )
   1787e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   17880:	2b00      	cmp	r3, #0
   17882:	d011      	beq.n	178a8 <MyWrapper+0x114>
						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
   17884:	2100      	movs	r1, #0
   17886:	0020      	movs	r0, r4
   17888:	4b17      	ldr	r3, [pc, #92]	; (178e8 <MyWrapper+0x154>)
   1788a:	4798      	blx	r3
   1788c:	2800      	cmp	r0, #0
   1788e:	d101      	bne.n	17894 <MyWrapper+0x100>
			xReturn = pdPASS;
   17890:	2501      	movs	r5, #1
   17892:	e003      	b.n	1789c <MyWrapper+0x108>
							if( pxHigherPriorityTaskWoken != NULL )
   17894:	2f00      	cmp	r7, #0
   17896:	d0fb      	beq.n	17890 <MyWrapper+0xfc>
								*pxHigherPriorityTaskWoken = pdTRUE;
   17898:	2501      	movs	r5, #1
   1789a:	603d      	str	r5, [r7, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   1789c:	9803      	ldr	r0, [sp, #12]
   1789e:	4b13      	ldr	r3, [pc, #76]	; (178ec <MyWrapper+0x158>)
   178a0:	4798      	blx	r3
}
   178a2:	0028      	movs	r0, r5
   178a4:	b005      	add	sp, #20
   178a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   178a8:	6a63      	ldr	r3, [r4, #36]	; 0x24
   178aa:	2b00      	cmp	r3, #0
   178ac:	d0f0      	beq.n	17890 <MyWrapper+0xfc>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   178ae:	0020      	movs	r0, r4
   178b0:	4b0f      	ldr	r3, [pc, #60]	; (178f0 <MyWrapper+0x15c>)
   178b2:	3024      	adds	r0, #36	; 0x24
   178b4:	4798      	blx	r3
   178b6:	e7e9      	b.n	1788c <MyWrapper+0xf8>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
   178b8:	9b01      	ldr	r3, [sp, #4]
   178ba:	3445      	adds	r4, #69	; 0x45
   178bc:	3301      	adds	r3, #1
   178be:	b25b      	sxtb	r3, r3
   178c0:	7023      	strb	r3, [r4, #0]
   178c2:	e7e5      	b.n	17890 <MyWrapper+0xfc>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
   178c4:	b672      	cpsid	i
   178c6:	e7fe      	b.n	178c6 <MyWrapper+0x132>
   178c8:	00016e25 	.word	0x00016e25
   178cc:	00015c81 	.word	0x00015c81
   178d0:	200001f0 	.word	0x200001f0
   178d4:	00015c05 	.word	0x00015c05
   178d8:	200001e8 	.word	0x200001e8
   178dc:	00015c71 	.word	0x00015c71
   178e0:	000168b9 	.word	0x000168b9
   178e4:	000163c5 	.word	0x000163c5
   178e8:	00016fed 	.word	0x00016fed
   178ec:	00016e2d 	.word	0x00016e2d
   178f0:	000188d1 	.word	0x000188d1

000178f4 <xQueueGiveFromISR>:
BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
   178f4:	b510      	push	{r4, lr}
   178f6:	2200      	movs	r2, #0
   178f8:	4b01      	ldr	r3, [pc, #4]	; (17900 <xQueueGiveFromISR+0xc>)
   178fa:	4798      	blx	r3
   178fc:	bd10      	pop	{r4, pc}
   178fe:	46c0      	nop			; (mov r8, r8)
   17900:	00017795 	.word	0x00017795

00017904 <xQueueReceive>:
{
   17904:	b5f0      	push	{r4, r5, r6, r7, lr}
   17906:	b087      	sub	sp, #28
   17908:	1e04      	subs	r4, r0, #0
   1790a:	9102      	str	r1, [sp, #8]
   1790c:	9203      	str	r2, [sp, #12]
	configASSERT( ( pxQueue ) );
   1790e:	d101      	bne.n	17914 <xQueueReceive+0x10>
   17910:	b672      	cpsid	i
   17912:	e7fe      	b.n	17912 <xQueueReceive+0xe>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
   17914:	9b02      	ldr	r3, [sp, #8]
   17916:	2b00      	cmp	r3, #0
   17918:	d000      	beq.n	1791c <xQueueReceive+0x18>
   1791a:	e103      	b.n	17b24 <xQueueReceive+0x220>
   1791c:	6c03      	ldr	r3, [r0, #64]	; 0x40
   1791e:	2b00      	cmp	r3, #0
   17920:	d100      	bne.n	17924 <xQueueReceive+0x20>
   17922:	e0ff      	b.n	17b24 <xQueueReceive+0x220>
   17924:	b672      	cpsid	i
   17926:	e7fe      	b.n	17926 <xQueueReceive+0x22>
				traceQUEUE_RECEIVE( pxQueue );
   17928:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   1792a:	3a01      	subs	r2, #1
   1792c:	b2d2      	uxtb	r2, r2
   1792e:	e0d6      	b.n	17ade <xQueueReceive+0x1da>
				if( xTicksToWait == ( TickType_t ) 0 )
   17930:	9b03      	ldr	r3, [sp, #12]
   17932:	9301      	str	r3, [sp, #4]
   17934:	2b00      	cmp	r3, #0
   17936:	d123      	bne.n	17980 <xQueueReceive+0x7c>
					taskEXIT_CRITICAL();
   17938:	4b80      	ldr	r3, [pc, #512]	; (17b3c <xQueueReceive+0x238>)
   1793a:	4798      	blx	r3
				traceQUEUE_RECEIVE_FAILED( pxQueue );
   1793c:	4b80      	ldr	r3, [pc, #512]	; (17b40 <xQueueReceive+0x23c>)
   1793e:	4798      	blx	r3
   17940:	4b80      	ldr	r3, [pc, #512]	; (17b44 <xQueueReceive+0x240>)
   17942:	4798      	blx	r3
   17944:	4d80      	ldr	r5, [pc, #512]	; (17b48 <xQueueReceive+0x244>)
   17946:	882b      	ldrh	r3, [r5, #0]
   17948:	4203      	tst	r3, r0
   1794a:	d017      	beq.n	1797c <xQueueReceive+0x78>
   1794c:	4b7f      	ldr	r3, [pc, #508]	; (17b4c <xQueueReceive+0x248>)
   1794e:	0020      	movs	r0, r4
   17950:	4798      	blx	r3
   17952:	882b      	ldrh	r3, [r5, #0]
   17954:	4203      	tst	r3, r0
   17956:	d011      	beq.n	1797c <xQueueReceive+0x78>
   17958:	4f7d      	ldr	r7, [pc, #500]	; (17b50 <xQueueReceive+0x24c>)
   1795a:	0020      	movs	r0, r4
   1795c:	47b8      	blx	r7
   1795e:	4e7d      	ldr	r6, [pc, #500]	; (17b54 <xQueueReceive+0x250>)
   17960:	5c35      	ldrb	r5, [r6, r0]
   17962:	0020      	movs	r0, r4
   17964:	47b8      	blx	r7
   17966:	4b7c      	ldr	r3, [pc, #496]	; (17b58 <xQueueReceive+0x254>)
   17968:	5c36      	ldrb	r6, [r6, r0]
   1796a:	0020      	movs	r0, r4
   1796c:	4798      	blx	r3
   1796e:	3550      	adds	r5, #80	; 0x50
   17970:	b2ed      	uxtb	r5, r5
   17972:	b2c2      	uxtb	r2, r0
   17974:	0031      	movs	r1, r6
   17976:	0028      	movs	r0, r5
   17978:	4b78      	ldr	r3, [pc, #480]	; (17b5c <xQueueReceive+0x258>)
   1797a:	4798      	blx	r3
				return errQUEUE_EMPTY;
   1797c:	2000      	movs	r0, #0
   1797e:	e0c3      	b.n	17b08 <xQueueReceive+0x204>
				else if( xEntryTimeSet == pdFALSE )
   17980:	2d00      	cmp	r5, #0
   17982:	d102      	bne.n	1798a <xQueueReceive+0x86>
					vTaskInternalSetTimeOutState( &xTimeOut );
   17984:	a804      	add	r0, sp, #16
   17986:	4b76      	ldr	r3, [pc, #472]	; (17b60 <xQueueReceive+0x25c>)
   17988:	4798      	blx	r3
		taskEXIT_CRITICAL();
   1798a:	4b6c      	ldr	r3, [pc, #432]	; (17b3c <xQueueReceive+0x238>)
   1798c:	4798      	blx	r3
		vTaskSuspendAll();
   1798e:	4b75      	ldr	r3, [pc, #468]	; (17b64 <xQueueReceive+0x260>)
   17990:	4798      	blx	r3
		prvLockQueue( pxQueue );
   17992:	47b0      	blx	r6
   17994:	0022      	movs	r2, r4
   17996:	3244      	adds	r2, #68	; 0x44
   17998:	7813      	ldrb	r3, [r2, #0]
   1799a:	b25b      	sxtb	r3, r3
   1799c:	3301      	adds	r3, #1
   1799e:	d101      	bne.n	179a4 <xQueueReceive+0xa0>
   179a0:	2300      	movs	r3, #0
   179a2:	7013      	strb	r3, [r2, #0]
   179a4:	0022      	movs	r2, r4
   179a6:	3245      	adds	r2, #69	; 0x45
   179a8:	7813      	ldrb	r3, [r2, #0]
   179aa:	b25b      	sxtb	r3, r3
   179ac:	3301      	adds	r3, #1
   179ae:	d101      	bne.n	179b4 <xQueueReceive+0xb0>
   179b0:	2300      	movs	r3, #0
   179b2:	7013      	strb	r3, [r2, #0]
   179b4:	4b61      	ldr	r3, [pc, #388]	; (17b3c <xQueueReceive+0x238>)
   179b6:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   179b8:	a903      	add	r1, sp, #12
   179ba:	a804      	add	r0, sp, #16
   179bc:	4b6a      	ldr	r3, [pc, #424]	; (17b68 <xQueueReceive+0x264>)
   179be:	4798      	blx	r3
   179c0:	4d6a      	ldr	r5, [pc, #424]	; (17b6c <xQueueReceive+0x268>)
   179c2:	4f6b      	ldr	r7, [pc, #428]	; (17b70 <xQueueReceive+0x26c>)
   179c4:	4e6b      	ldr	r6, [pc, #428]	; (17b74 <xQueueReceive+0x270>)
   179c6:	2800      	cmp	r0, #0
   179c8:	d000      	beq.n	179cc <xQueueReceive+0xc8>
   179ca:	e0a3      	b.n	17b14 <xQueueReceive+0x210>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   179cc:	0020      	movs	r0, r4
   179ce:	47a8      	blx	r5
   179d0:	2800      	cmp	r0, #0
   179d2:	d100      	bne.n	179d6 <xQueueReceive+0xd2>
   179d4:	e09a      	b.n	17b0c <xQueueReceive+0x208>
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
   179d6:	4b5a      	ldr	r3, [pc, #360]	; (17b40 <xQueueReceive+0x23c>)
   179d8:	4798      	blx	r3
   179da:	4b5a      	ldr	r3, [pc, #360]	; (17b44 <xQueueReceive+0x240>)
   179dc:	4798      	blx	r3
   179de:	4d5a      	ldr	r5, [pc, #360]	; (17b48 <xQueueReceive+0x244>)
   179e0:	882b      	ldrh	r3, [r5, #0]
   179e2:	4203      	tst	r3, r0
   179e4:	d019      	beq.n	17a1a <xQueueReceive+0x116>
   179e6:	4b59      	ldr	r3, [pc, #356]	; (17b4c <xQueueReceive+0x248>)
   179e8:	0020      	movs	r0, r4
   179ea:	4798      	blx	r3
   179ec:	882b      	ldrh	r3, [r5, #0]
   179ee:	4203      	tst	r3, r0
   179f0:	d013      	beq.n	17a1a <xQueueReceive+0x116>
   179f2:	4b57      	ldr	r3, [pc, #348]	; (17b50 <xQueueReceive+0x24c>)
   179f4:	0020      	movs	r0, r4
   179f6:	4798      	blx	r3
   179f8:	4d56      	ldr	r5, [pc, #344]	; (17b54 <xQueueReceive+0x250>)
   179fa:	5c2b      	ldrb	r3, [r5, r0]
   179fc:	0020      	movs	r0, r4
   179fe:	3368      	adds	r3, #104	; 0x68
   17a00:	b2db      	uxtb	r3, r3
   17a02:	9301      	str	r3, [sp, #4]
   17a04:	4b52      	ldr	r3, [pc, #328]	; (17b50 <xQueueReceive+0x24c>)
   17a06:	4798      	blx	r3
   17a08:	4b53      	ldr	r3, [pc, #332]	; (17b58 <xQueueReceive+0x254>)
   17a0a:	5c2d      	ldrb	r5, [r5, r0]
   17a0c:	0020      	movs	r0, r4
   17a0e:	4798      	blx	r3
   17a10:	0029      	movs	r1, r5
   17a12:	b2c2      	uxtb	r2, r0
   17a14:	4b51      	ldr	r3, [pc, #324]	; (17b5c <xQueueReceive+0x258>)
   17a16:	9801      	ldr	r0, [sp, #4]
   17a18:	4798      	blx	r3
   17a1a:	4b4d      	ldr	r3, [pc, #308]	; (17b50 <xQueueReceive+0x24c>)
   17a1c:	0020      	movs	r0, r4
   17a1e:	4798      	blx	r3
   17a20:	4b4c      	ldr	r3, [pc, #304]	; (17b54 <xQueueReceive+0x250>)
   17a22:	5c1b      	ldrb	r3, [r3, r0]
   17a24:	2b02      	cmp	r3, #2
   17a26:	d00e      	beq.n	17a46 <xQueueReceive+0x142>
   17a28:	4b45      	ldr	r3, [pc, #276]	; (17b40 <xQueueReceive+0x23c>)
   17a2a:	4798      	blx	r3
   17a2c:	4b45      	ldr	r3, [pc, #276]	; (17b44 <xQueueReceive+0x240>)
   17a2e:	4798      	blx	r3
   17a30:	4b45      	ldr	r3, [pc, #276]	; (17b48 <xQueueReceive+0x244>)
   17a32:	881b      	ldrh	r3, [r3, #0]
   17a34:	4203      	tst	r3, r0
   17a36:	d006      	beq.n	17a46 <xQueueReceive+0x142>
   17a38:	4b41      	ldr	r3, [pc, #260]	; (17b40 <xQueueReceive+0x23c>)
   17a3a:	4798      	blx	r3
   17a3c:	4b4e      	ldr	r3, [pc, #312]	; (17b78 <xQueueReceive+0x274>)
   17a3e:	4798      	blx	r3
   17a40:	4b4e      	ldr	r3, [pc, #312]	; (17b7c <xQueueReceive+0x278>)
   17a42:	b2c0      	uxtb	r0, r0
   17a44:	4798      	blx	r3
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   17a46:	0020      	movs	r0, r4
   17a48:	9903      	ldr	r1, [sp, #12]
   17a4a:	3024      	adds	r0, #36	; 0x24
   17a4c:	4b4c      	ldr	r3, [pc, #304]	; (17b80 <xQueueReceive+0x27c>)
   17a4e:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
   17a50:	0020      	movs	r0, r4
   17a52:	47b8      	blx	r7
				if( xTaskResumeAll() == pdFALSE )
   17a54:	47b0      	blx	r6
   17a56:	2800      	cmp	r0, #0
   17a58:	d101      	bne.n	17a5e <xQueueReceive+0x15a>
					portYIELD_WITHIN_API();
   17a5a:	4b4a      	ldr	r3, [pc, #296]	; (17b84 <xQueueReceive+0x280>)
   17a5c:	4798      	blx	r3
   17a5e:	2501      	movs	r5, #1
		taskENTER_CRITICAL();
   17a60:	4e49      	ldr	r6, [pc, #292]	; (17b88 <xQueueReceive+0x284>)
   17a62:	47b0      	blx	r6
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   17a64:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   17a66:	9301      	str	r3, [sp, #4]
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   17a68:	2b00      	cmp	r3, #0
   17a6a:	d100      	bne.n	17a6e <xQueueReceive+0x16a>
   17a6c:	e760      	b.n	17930 <xQueueReceive+0x2c>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
   17a6e:	9902      	ldr	r1, [sp, #8]
   17a70:	0020      	movs	r0, r4
   17a72:	4b46      	ldr	r3, [pc, #280]	; (17b8c <xQueueReceive+0x288>)
   17a74:	4798      	blx	r3
				traceQUEUE_RECEIVE( pxQueue );
   17a76:	4b32      	ldr	r3, [pc, #200]	; (17b40 <xQueueReceive+0x23c>)
   17a78:	4798      	blx	r3
   17a7a:	4b32      	ldr	r3, [pc, #200]	; (17b44 <xQueueReceive+0x240>)
   17a7c:	4798      	blx	r3
   17a7e:	4d32      	ldr	r5, [pc, #200]	; (17b48 <xQueueReceive+0x244>)
   17a80:	4e33      	ldr	r6, [pc, #204]	; (17b50 <xQueueReceive+0x24c>)
   17a82:	882b      	ldrh	r3, [r5, #0]
   17a84:	4203      	tst	r3, r0
   17a86:	d016      	beq.n	17ab6 <xQueueReceive+0x1b2>
   17a88:	4b30      	ldr	r3, [pc, #192]	; (17b4c <xQueueReceive+0x248>)
   17a8a:	0020      	movs	r0, r4
   17a8c:	4798      	blx	r3
   17a8e:	882b      	ldrh	r3, [r5, #0]
   17a90:	4203      	tst	r3, r0
   17a92:	d010      	beq.n	17ab6 <xQueueReceive+0x1b2>
   17a94:	0020      	movs	r0, r4
   17a96:	47b0      	blx	r6
   17a98:	4f2e      	ldr	r7, [pc, #184]	; (17b54 <xQueueReceive+0x250>)
   17a9a:	5c3d      	ldrb	r5, [r7, r0]
   17a9c:	0020      	movs	r0, r4
   17a9e:	47b0      	blx	r6
   17aa0:	4b2d      	ldr	r3, [pc, #180]	; (17b58 <xQueueReceive+0x254>)
   17aa2:	5c3f      	ldrb	r7, [r7, r0]
   17aa4:	0020      	movs	r0, r4
   17aa6:	4798      	blx	r3
   17aa8:	3528      	adds	r5, #40	; 0x28
   17aaa:	b2ed      	uxtb	r5, r5
   17aac:	b2c2      	uxtb	r2, r0
   17aae:	0039      	movs	r1, r7
   17ab0:	0028      	movs	r0, r5
   17ab2:	4b2a      	ldr	r3, [pc, #168]	; (17b5c <xQueueReceive+0x258>)
   17ab4:	4798      	blx	r3
   17ab6:	0020      	movs	r0, r4
   17ab8:	47b0      	blx	r6
   17aba:	4d26      	ldr	r5, [pc, #152]	; (17b54 <xQueueReceive+0x250>)
   17abc:	4b26      	ldr	r3, [pc, #152]	; (17b58 <xQueueReceive+0x254>)
   17abe:	5c2f      	ldrb	r7, [r5, r0]
   17ac0:	0020      	movs	r0, r4
   17ac2:	4798      	blx	r3
   17ac4:	b2c3      	uxtb	r3, r0
   17ac6:	0020      	movs	r0, r4
   17ac8:	9302      	str	r3, [sp, #8]
   17aca:	47b0      	blx	r6
   17acc:	5c2b      	ldrb	r3, [r5, r0]
   17ace:	2b02      	cmp	r3, #2
   17ad0:	d000      	beq.n	17ad4 <xQueueReceive+0x1d0>
   17ad2:	e729      	b.n	17928 <xQueueReceive+0x24>
   17ad4:	4b1a      	ldr	r3, [pc, #104]	; (17b40 <xQueueReceive+0x23c>)
   17ad6:	4798      	blx	r3
   17ad8:	4b27      	ldr	r3, [pc, #156]	; (17b78 <xQueueReceive+0x274>)
   17ada:	4798      	blx	r3
   17adc:	b2c2      	uxtb	r2, r0
   17ade:	4b2c      	ldr	r3, [pc, #176]	; (17b90 <xQueueReceive+0x28c>)
   17ae0:	9902      	ldr	r1, [sp, #8]
   17ae2:	0038      	movs	r0, r7
   17ae4:	4798      	blx	r3
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
   17ae6:	9b01      	ldr	r3, [sp, #4]
   17ae8:	3b01      	subs	r3, #1
   17aea:	63a3      	str	r3, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   17aec:	6923      	ldr	r3, [r4, #16]
   17aee:	2b00      	cmp	r3, #0
   17af0:	d007      	beq.n	17b02 <xQueueReceive+0x1fe>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   17af2:	0020      	movs	r0, r4
   17af4:	4b27      	ldr	r3, [pc, #156]	; (17b94 <xQueueReceive+0x290>)
   17af6:	3010      	adds	r0, #16
   17af8:	4798      	blx	r3
   17afa:	2800      	cmp	r0, #0
   17afc:	d001      	beq.n	17b02 <xQueueReceive+0x1fe>
						queueYIELD_IF_USING_PREEMPTION();
   17afe:	4b21      	ldr	r3, [pc, #132]	; (17b84 <xQueueReceive+0x280>)
   17b00:	4798      	blx	r3
				taskEXIT_CRITICAL();
   17b02:	4b0e      	ldr	r3, [pc, #56]	; (17b3c <xQueueReceive+0x238>)
   17b04:	4798      	blx	r3
				return pdPASS;
   17b06:	2001      	movs	r0, #1
}
   17b08:	b007      	add	sp, #28
   17b0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
				prvUnlockQueue( pxQueue );
   17b0c:	0020      	movs	r0, r4
   17b0e:	47b8      	blx	r7
				( void ) xTaskResumeAll();
   17b10:	47b0      	blx	r6
   17b12:	e7a4      	b.n	17a5e <xQueueReceive+0x15a>
			prvUnlockQueue( pxQueue );
   17b14:	0020      	movs	r0, r4
   17b16:	47b8      	blx	r7
			( void ) xTaskResumeAll();
   17b18:	47b0      	blx	r6
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   17b1a:	0020      	movs	r0, r4
   17b1c:	47a8      	blx	r5
   17b1e:	2800      	cmp	r0, #0
   17b20:	d09d      	beq.n	17a5e <xQueueReceive+0x15a>
   17b22:	e70b      	b.n	1793c <xQueueReceive+0x38>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   17b24:	4b1c      	ldr	r3, [pc, #112]	; (17b98 <xQueueReceive+0x294>)
   17b26:	4798      	blx	r3
   17b28:	2500      	movs	r5, #0
   17b2a:	2800      	cmp	r0, #0
   17b2c:	d198      	bne.n	17a60 <xQueueReceive+0x15c>
   17b2e:	9d03      	ldr	r5, [sp, #12]
   17b30:	2d00      	cmp	r5, #0
   17b32:	d100      	bne.n	17b36 <xQueueReceive+0x232>
   17b34:	e794      	b.n	17a60 <xQueueReceive+0x15c>
   17b36:	b672      	cpsid	i
   17b38:	e7fe      	b.n	17b38 <xQueueReceive+0x234>
   17b3a:	46c0      	nop			; (mov r8, r8)
   17b3c:	00016e09 	.word	0x00016e09
   17b40:	00015d9d 	.word	0x00015d9d
   17b44:	00015c21 	.word	0x00015c21
   17b48:	200001f0 	.word	0x200001f0
   17b4c:	00015c81 	.word	0x00015c81
   17b50:	00015c05 	.word	0x00015c05
   17b54:	200001e8 	.word	0x200001e8
   17b58:	00015c71 	.word	0x00015c71
   17b5c:	000168b9 	.word	0x000168b9
   17b60:	000189a9 	.word	0x000189a9
   17b64:	00018311 	.word	0x00018311
   17b68:	000189c1 	.word	0x000189c1
   17b6c:	00016f59 	.word	0x00016f59
   17b70:	00017121 	.word	0x00017121
   17b74:	00018499 	.word	0x00018499
   17b78:	00015c11 	.word	0x00015c11
   17b7c:	00016419 	.word	0x00016419
   17b80:	00018811 	.word	0x00018811
   17b84:	00016de1 	.word	0x00016de1
   17b88:	00016df1 	.word	0x00016df1
   17b8c:	000170f9 	.word	0x000170f9
   17b90:	000163c5 	.word	0x000163c5
   17b94:	000188d1 	.word	0x000188d1
   17b98:	00018a7d 	.word	0x00018a7d

00017b9c <xQueueSemaphoreTake>:
{
   17b9c:	b5f0      	push	{r4, r5, r6, r7, lr}
   17b9e:	b087      	sub	sp, #28
   17ba0:	1e04      	subs	r4, r0, #0
   17ba2:	9103      	str	r1, [sp, #12]
	configASSERT( ( pxQueue ) );
   17ba4:	d101      	bne.n	17baa <xQueueSemaphoreTake+0xe>
   17ba6:	b672      	cpsid	i
   17ba8:	e7fe      	b.n	17ba8 <xQueueSemaphoreTake+0xc>
	configASSERT( pxQueue->uxItemSize == 0 );
   17baa:	6c07      	ldr	r7, [r0, #64]	; 0x40
   17bac:	2f00      	cmp	r7, #0
   17bae:	d001      	beq.n	17bb4 <xQueueSemaphoreTake+0x18>
   17bb0:	b672      	cpsid	i
   17bb2:	e7fe      	b.n	17bb2 <xQueueSemaphoreTake+0x16>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   17bb4:	4ba6      	ldr	r3, [pc, #664]	; (17e50 <xQueueSemaphoreTake+0x2b4>)
   17bb6:	4798      	blx	r3
   17bb8:	2800      	cmp	r0, #0
   17bba:	d103      	bne.n	17bc4 <xQueueSemaphoreTake+0x28>
   17bbc:	9f03      	ldr	r7, [sp, #12]
   17bbe:	2f00      	cmp	r7, #0
   17bc0:	d000      	beq.n	17bc4 <xQueueSemaphoreTake+0x28>
   17bc2:	e143      	b.n	17e4c <xQueueSemaphoreTake+0x2b0>
   17bc4:	003d      	movs	r5, r7
		taskENTER_CRITICAL();
   17bc6:	4ba3      	ldr	r3, [pc, #652]	; (17e54 <xQueueSemaphoreTake+0x2b8>)
   17bc8:	4798      	blx	r3
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
   17bca:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   17bcc:	9301      	str	r3, [sp, #4]
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
   17bce:	2b00      	cmp	r3, #0
   17bd0:	d054      	beq.n	17c7c <xQueueSemaphoreTake+0xe0>
				traceQUEUE_RECEIVE( pxQueue );
   17bd2:	4ba1      	ldr	r3, [pc, #644]	; (17e58 <xQueueSemaphoreTake+0x2bc>)
   17bd4:	4798      	blx	r3
   17bd6:	4ba1      	ldr	r3, [pc, #644]	; (17e5c <xQueueSemaphoreTake+0x2c0>)
   17bd8:	4798      	blx	r3
   17bda:	4da1      	ldr	r5, [pc, #644]	; (17e60 <xQueueSemaphoreTake+0x2c4>)
   17bdc:	4ea1      	ldr	r6, [pc, #644]	; (17e64 <xQueueSemaphoreTake+0x2c8>)
   17bde:	882b      	ldrh	r3, [r5, #0]
   17be0:	4203      	tst	r3, r0
   17be2:	d016      	beq.n	17c12 <xQueueSemaphoreTake+0x76>
   17be4:	4ba0      	ldr	r3, [pc, #640]	; (17e68 <xQueueSemaphoreTake+0x2cc>)
   17be6:	0020      	movs	r0, r4
   17be8:	4798      	blx	r3
   17bea:	882b      	ldrh	r3, [r5, #0]
   17bec:	4203      	tst	r3, r0
   17bee:	d010      	beq.n	17c12 <xQueueSemaphoreTake+0x76>
   17bf0:	0020      	movs	r0, r4
   17bf2:	47b0      	blx	r6
   17bf4:	4f9d      	ldr	r7, [pc, #628]	; (17e6c <xQueueSemaphoreTake+0x2d0>)
   17bf6:	5c3d      	ldrb	r5, [r7, r0]
   17bf8:	0020      	movs	r0, r4
   17bfa:	47b0      	blx	r6
   17bfc:	4b9c      	ldr	r3, [pc, #624]	; (17e70 <xQueueSemaphoreTake+0x2d4>)
   17bfe:	5c3f      	ldrb	r7, [r7, r0]
   17c00:	0020      	movs	r0, r4
   17c02:	4798      	blx	r3
   17c04:	3528      	adds	r5, #40	; 0x28
   17c06:	b2ed      	uxtb	r5, r5
   17c08:	b2c2      	uxtb	r2, r0
   17c0a:	0039      	movs	r1, r7
   17c0c:	0028      	movs	r0, r5
   17c0e:	4b99      	ldr	r3, [pc, #612]	; (17e74 <xQueueSemaphoreTake+0x2d8>)
   17c10:	4798      	blx	r3
   17c12:	0020      	movs	r0, r4
   17c14:	47b0      	blx	r6
   17c16:	4d95      	ldr	r5, [pc, #596]	; (17e6c <xQueueSemaphoreTake+0x2d0>)
   17c18:	4b95      	ldr	r3, [pc, #596]	; (17e70 <xQueueSemaphoreTake+0x2d4>)
   17c1a:	5c2f      	ldrb	r7, [r5, r0]
   17c1c:	0020      	movs	r0, r4
   17c1e:	4798      	blx	r3
   17c20:	b2c3      	uxtb	r3, r0
   17c22:	0020      	movs	r0, r4
   17c24:	9302      	str	r3, [sp, #8]
   17c26:	47b0      	blx	r6
   17c28:	5c2b      	ldrb	r3, [r5, r0]
   17c2a:	2b02      	cmp	r3, #2
   17c2c:	d122      	bne.n	17c74 <xQueueSemaphoreTake+0xd8>
   17c2e:	4b8a      	ldr	r3, [pc, #552]	; (17e58 <xQueueSemaphoreTake+0x2bc>)
   17c30:	4798      	blx	r3
   17c32:	4b91      	ldr	r3, [pc, #580]	; (17e78 <xQueueSemaphoreTake+0x2dc>)
   17c34:	4798      	blx	r3
   17c36:	b2c2      	uxtb	r2, r0
   17c38:	4b90      	ldr	r3, [pc, #576]	; (17e7c <xQueueSemaphoreTake+0x2e0>)
   17c3a:	9902      	ldr	r1, [sp, #8]
   17c3c:	0038      	movs	r0, r7
   17c3e:	4798      	blx	r3
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
   17c40:	9b01      	ldr	r3, [sp, #4]
   17c42:	3b01      	subs	r3, #1
   17c44:	63a3      	str	r3, [r4, #56]	; 0x38
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   17c46:	6823      	ldr	r3, [r4, #0]
   17c48:	2b00      	cmp	r3, #0
   17c4a:	d102      	bne.n	17c52 <xQueueSemaphoreTake+0xb6>
						pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
   17c4c:	4b8c      	ldr	r3, [pc, #560]	; (17e80 <xQueueSemaphoreTake+0x2e4>)
   17c4e:	4798      	blx	r3
   17c50:	6060      	str	r0, [r4, #4]
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   17c52:	6923      	ldr	r3, [r4, #16]
   17c54:	2b00      	cmp	r3, #0
   17c56:	d007      	beq.n	17c68 <xQueueSemaphoreTake+0xcc>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   17c58:	0020      	movs	r0, r4
   17c5a:	4b8a      	ldr	r3, [pc, #552]	; (17e84 <xQueueSemaphoreTake+0x2e8>)
   17c5c:	3010      	adds	r0, #16
   17c5e:	4798      	blx	r3
   17c60:	2800      	cmp	r0, #0
   17c62:	d001      	beq.n	17c68 <xQueueSemaphoreTake+0xcc>
						queueYIELD_IF_USING_PREEMPTION();
   17c64:	4b88      	ldr	r3, [pc, #544]	; (17e88 <xQueueSemaphoreTake+0x2ec>)
   17c66:	4798      	blx	r3
				taskEXIT_CRITICAL();
   17c68:	4b88      	ldr	r3, [pc, #544]	; (17e8c <xQueueSemaphoreTake+0x2f0>)
   17c6a:	4798      	blx	r3
				return pdPASS;
   17c6c:	2701      	movs	r7, #1
}
   17c6e:	0038      	movs	r0, r7
   17c70:	b007      	add	sp, #28
   17c72:	bdf0      	pop	{r4, r5, r6, r7, pc}
				traceQUEUE_RECEIVE( pxQueue );
   17c74:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   17c76:	3a01      	subs	r2, #1
   17c78:	b2d2      	uxtb	r2, r2
   17c7a:	e7dd      	b.n	17c38 <xQueueSemaphoreTake+0x9c>
				if( xTicksToWait == ( TickType_t ) 0 )
   17c7c:	9b03      	ldr	r3, [sp, #12]
   17c7e:	2b00      	cmp	r3, #0
   17c80:	d129      	bne.n	17cd6 <xQueueSemaphoreTake+0x13a>
						configASSERT( xInheritanceOccurred == pdFALSE );
   17c82:	2f00      	cmp	r7, #0
   17c84:	d001      	beq.n	17c8a <xQueueSemaphoreTake+0xee>
   17c86:	b672      	cpsid	i
   17c88:	e7fe      	b.n	17c88 <xQueueSemaphoreTake+0xec>
					taskEXIT_CRITICAL();
   17c8a:	4b80      	ldr	r3, [pc, #512]	; (17e8c <xQueueSemaphoreTake+0x2f0>)
   17c8c:	4798      	blx	r3
					traceQUEUE_RECEIVE_FAILED( pxQueue );
   17c8e:	4b72      	ldr	r3, [pc, #456]	; (17e58 <xQueueSemaphoreTake+0x2bc>)
   17c90:	4798      	blx	r3
   17c92:	4b72      	ldr	r3, [pc, #456]	; (17e5c <xQueueSemaphoreTake+0x2c0>)
   17c94:	4798      	blx	r3
   17c96:	4d72      	ldr	r5, [pc, #456]	; (17e60 <xQueueSemaphoreTake+0x2c4>)
   17c98:	882b      	ldrh	r3, [r5, #0]
   17c9a:	4203      	tst	r3, r0
   17c9c:	d101      	bne.n	17ca2 <xQueueSemaphoreTake+0x106>
				return errQUEUE_EMPTY;
   17c9e:	2700      	movs	r7, #0
   17ca0:	e7e5      	b.n	17c6e <xQueueSemaphoreTake+0xd2>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
   17ca2:	4b71      	ldr	r3, [pc, #452]	; (17e68 <xQueueSemaphoreTake+0x2cc>)
   17ca4:	0020      	movs	r0, r4
   17ca6:	4798      	blx	r3
   17ca8:	882b      	ldrh	r3, [r5, #0]
   17caa:	4203      	tst	r3, r0
   17cac:	d0f7      	beq.n	17c9e <xQueueSemaphoreTake+0x102>
   17cae:	0020      	movs	r0, r4
   17cb0:	4b6c      	ldr	r3, [pc, #432]	; (17e64 <xQueueSemaphoreTake+0x2c8>)
   17cb2:	4798      	blx	r3
   17cb4:	4e6d      	ldr	r6, [pc, #436]	; (17e6c <xQueueSemaphoreTake+0x2d0>)
   17cb6:	4b6b      	ldr	r3, [pc, #428]	; (17e64 <xQueueSemaphoreTake+0x2c8>)
   17cb8:	5c35      	ldrb	r5, [r6, r0]
   17cba:	0020      	movs	r0, r4
   17cbc:	4798      	blx	r3
   17cbe:	4b6c      	ldr	r3, [pc, #432]	; (17e70 <xQueueSemaphoreTake+0x2d4>)
   17cc0:	5c36      	ldrb	r6, [r6, r0]
   17cc2:	0020      	movs	r0, r4
   17cc4:	4798      	blx	r3
   17cc6:	3550      	adds	r5, #80	; 0x50
   17cc8:	b2ed      	uxtb	r5, r5
   17cca:	b2c2      	uxtb	r2, r0
   17ccc:	0031      	movs	r1, r6
   17cce:	0028      	movs	r0, r5
   17cd0:	4b68      	ldr	r3, [pc, #416]	; (17e74 <xQueueSemaphoreTake+0x2d8>)
   17cd2:	4798      	blx	r3
   17cd4:	e7cb      	b.n	17c6e <xQueueSemaphoreTake+0xd2>
				else if( xEntryTimeSet == pdFALSE )
   17cd6:	2d00      	cmp	r5, #0
   17cd8:	d102      	bne.n	17ce0 <xQueueSemaphoreTake+0x144>
					vTaskInternalSetTimeOutState( &xTimeOut );
   17cda:	a804      	add	r0, sp, #16
   17cdc:	4b6c      	ldr	r3, [pc, #432]	; (17e90 <xQueueSemaphoreTake+0x2f4>)
   17cde:	4798      	blx	r3
		taskEXIT_CRITICAL();
   17ce0:	4b6a      	ldr	r3, [pc, #424]	; (17e8c <xQueueSemaphoreTake+0x2f0>)
   17ce2:	4798      	blx	r3
		vTaskSuspendAll();
   17ce4:	4b6b      	ldr	r3, [pc, #428]	; (17e94 <xQueueSemaphoreTake+0x2f8>)
   17ce6:	4798      	blx	r3
		prvLockQueue( pxQueue );
   17ce8:	4b5a      	ldr	r3, [pc, #360]	; (17e54 <xQueueSemaphoreTake+0x2b8>)
   17cea:	4798      	blx	r3
   17cec:	0022      	movs	r2, r4
   17cee:	3244      	adds	r2, #68	; 0x44
   17cf0:	7813      	ldrb	r3, [r2, #0]
   17cf2:	b25b      	sxtb	r3, r3
   17cf4:	3301      	adds	r3, #1
   17cf6:	d101      	bne.n	17cfc <xQueueSemaphoreTake+0x160>
   17cf8:	2300      	movs	r3, #0
   17cfa:	7013      	strb	r3, [r2, #0]
   17cfc:	0022      	movs	r2, r4
   17cfe:	3245      	adds	r2, #69	; 0x45
   17d00:	7813      	ldrb	r3, [r2, #0]
   17d02:	b25b      	sxtb	r3, r3
   17d04:	3301      	adds	r3, #1
   17d06:	d101      	bne.n	17d0c <xQueueSemaphoreTake+0x170>
   17d08:	2300      	movs	r3, #0
   17d0a:	7013      	strb	r3, [r2, #0]
   17d0c:	4b5f      	ldr	r3, [pc, #380]	; (17e8c <xQueueSemaphoreTake+0x2f0>)
   17d0e:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   17d10:	a903      	add	r1, sp, #12
   17d12:	a804      	add	r0, sp, #16
   17d14:	4b60      	ldr	r3, [pc, #384]	; (17e98 <xQueueSemaphoreTake+0x2fc>)
   17d16:	4798      	blx	r3
   17d18:	4d60      	ldr	r5, [pc, #384]	; (17e9c <xQueueSemaphoreTake+0x300>)
   17d1a:	4e61      	ldr	r6, [pc, #388]	; (17ea0 <xQueueSemaphoreTake+0x304>)
   17d1c:	2800      	cmp	r0, #0
   17d1e:	d159      	bne.n	17dd4 <xQueueSemaphoreTake+0x238>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   17d20:	0020      	movs	r0, r4
   17d22:	47a8      	blx	r5
   17d24:	2800      	cmp	r0, #0
   17d26:	d050      	beq.n	17dca <xQueueSemaphoreTake+0x22e>
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
   17d28:	4b4b      	ldr	r3, [pc, #300]	; (17e58 <xQueueSemaphoreTake+0x2bc>)
   17d2a:	4798      	blx	r3
   17d2c:	4b4b      	ldr	r3, [pc, #300]	; (17e5c <xQueueSemaphoreTake+0x2c0>)
   17d2e:	4798      	blx	r3
   17d30:	4d4b      	ldr	r5, [pc, #300]	; (17e60 <xQueueSemaphoreTake+0x2c4>)
   17d32:	882b      	ldrh	r3, [r5, #0]
   17d34:	4203      	tst	r3, r0
   17d36:	d018      	beq.n	17d6a <xQueueSemaphoreTake+0x1ce>
   17d38:	4b4b      	ldr	r3, [pc, #300]	; (17e68 <xQueueSemaphoreTake+0x2cc>)
   17d3a:	0020      	movs	r0, r4
   17d3c:	4798      	blx	r3
   17d3e:	882b      	ldrh	r3, [r5, #0]
   17d40:	4203      	tst	r3, r0
   17d42:	d012      	beq.n	17d6a <xQueueSemaphoreTake+0x1ce>
   17d44:	4e47      	ldr	r6, [pc, #284]	; (17e64 <xQueueSemaphoreTake+0x2c8>)
   17d46:	0020      	movs	r0, r4
   17d48:	47b0      	blx	r6
   17d4a:	4d48      	ldr	r5, [pc, #288]	; (17e6c <xQueueSemaphoreTake+0x2d0>)
   17d4c:	5c2b      	ldrb	r3, [r5, r0]
   17d4e:	0020      	movs	r0, r4
   17d50:	3368      	adds	r3, #104	; 0x68
   17d52:	b2db      	uxtb	r3, r3
   17d54:	9301      	str	r3, [sp, #4]
   17d56:	47b0      	blx	r6
   17d58:	4b45      	ldr	r3, [pc, #276]	; (17e70 <xQueueSemaphoreTake+0x2d4>)
   17d5a:	5c2d      	ldrb	r5, [r5, r0]
   17d5c:	0020      	movs	r0, r4
   17d5e:	4798      	blx	r3
   17d60:	0029      	movs	r1, r5
   17d62:	b2c2      	uxtb	r2, r0
   17d64:	4b43      	ldr	r3, [pc, #268]	; (17e74 <xQueueSemaphoreTake+0x2d8>)
   17d66:	9801      	ldr	r0, [sp, #4]
   17d68:	4798      	blx	r3
   17d6a:	4b3e      	ldr	r3, [pc, #248]	; (17e64 <xQueueSemaphoreTake+0x2c8>)
   17d6c:	0020      	movs	r0, r4
   17d6e:	4798      	blx	r3
   17d70:	4b3e      	ldr	r3, [pc, #248]	; (17e6c <xQueueSemaphoreTake+0x2d0>)
   17d72:	5c1b      	ldrb	r3, [r3, r0]
   17d74:	2b02      	cmp	r3, #2
   17d76:	d00d      	beq.n	17d94 <xQueueSemaphoreTake+0x1f8>
   17d78:	4d37      	ldr	r5, [pc, #220]	; (17e58 <xQueueSemaphoreTake+0x2bc>)
   17d7a:	47a8      	blx	r5
   17d7c:	4b37      	ldr	r3, [pc, #220]	; (17e5c <xQueueSemaphoreTake+0x2c0>)
   17d7e:	4798      	blx	r3
   17d80:	4b37      	ldr	r3, [pc, #220]	; (17e60 <xQueueSemaphoreTake+0x2c4>)
   17d82:	881b      	ldrh	r3, [r3, #0]
   17d84:	4203      	tst	r3, r0
   17d86:	d005      	beq.n	17d94 <xQueueSemaphoreTake+0x1f8>
   17d88:	47a8      	blx	r5
   17d8a:	4b3b      	ldr	r3, [pc, #236]	; (17e78 <xQueueSemaphoreTake+0x2dc>)
   17d8c:	4798      	blx	r3
   17d8e:	4b45      	ldr	r3, [pc, #276]	; (17ea4 <xQueueSemaphoreTake+0x308>)
   17d90:	b2c0      	uxtb	r0, r0
   17d92:	4798      	blx	r3
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   17d94:	6823      	ldr	r3, [r4, #0]
   17d96:	2b00      	cmp	r3, #0
   17d98:	d107      	bne.n	17daa <xQueueSemaphoreTake+0x20e>
						taskENTER_CRITICAL();
   17d9a:	4b2e      	ldr	r3, [pc, #184]	; (17e54 <xQueueSemaphoreTake+0x2b8>)
   17d9c:	4798      	blx	r3
							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
   17d9e:	4b42      	ldr	r3, [pc, #264]	; (17ea8 <xQueueSemaphoreTake+0x30c>)
   17da0:	6860      	ldr	r0, [r4, #4]
   17da2:	4798      	blx	r3
						taskEXIT_CRITICAL();
   17da4:	4b39      	ldr	r3, [pc, #228]	; (17e8c <xQueueSemaphoreTake+0x2f0>)
							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
   17da6:	0007      	movs	r7, r0
						taskEXIT_CRITICAL();
   17da8:	4798      	blx	r3
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   17daa:	0020      	movs	r0, r4
   17dac:	9903      	ldr	r1, [sp, #12]
   17dae:	3024      	adds	r0, #36	; 0x24
   17db0:	4b3e      	ldr	r3, [pc, #248]	; (17eac <xQueueSemaphoreTake+0x310>)
   17db2:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
   17db4:	4b3e      	ldr	r3, [pc, #248]	; (17eb0 <xQueueSemaphoreTake+0x314>)
   17db6:	0020      	movs	r0, r4
   17db8:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
   17dba:	4b39      	ldr	r3, [pc, #228]	; (17ea0 <xQueueSemaphoreTake+0x304>)
   17dbc:	4798      	blx	r3
   17dbe:	2800      	cmp	r0, #0
   17dc0:	d101      	bne.n	17dc6 <xQueueSemaphoreTake+0x22a>
					portYIELD_WITHIN_API();
   17dc2:	4b31      	ldr	r3, [pc, #196]	; (17e88 <xQueueSemaphoreTake+0x2ec>)
   17dc4:	4798      	blx	r3
   17dc6:	2501      	movs	r5, #1
   17dc8:	e6fd      	b.n	17bc6 <xQueueSemaphoreTake+0x2a>
				prvUnlockQueue( pxQueue );
   17dca:	0020      	movs	r0, r4
   17dcc:	4b38      	ldr	r3, [pc, #224]	; (17eb0 <xQueueSemaphoreTake+0x314>)
   17dce:	4798      	blx	r3
				( void ) xTaskResumeAll();
   17dd0:	47b0      	blx	r6
   17dd2:	e7f8      	b.n	17dc6 <xQueueSemaphoreTake+0x22a>
			prvUnlockQueue( pxQueue );
   17dd4:	0020      	movs	r0, r4
   17dd6:	4b36      	ldr	r3, [pc, #216]	; (17eb0 <xQueueSemaphoreTake+0x314>)
   17dd8:	4798      	blx	r3
			( void ) xTaskResumeAll();
   17dda:	47b0      	blx	r6
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   17ddc:	0020      	movs	r0, r4
   17dde:	47a8      	blx	r5
   17de0:	2800      	cmp	r0, #0
   17de2:	d0f0      	beq.n	17dc6 <xQueueSemaphoreTake+0x22a>
					if( xInheritanceOccurred != pdFALSE )
   17de4:	2f00      	cmp	r7, #0
   17de6:	d00e      	beq.n	17e06 <xQueueSemaphoreTake+0x26a>
						taskENTER_CRITICAL();
   17de8:	4b1a      	ldr	r3, [pc, #104]	; (17e54 <xQueueSemaphoreTake+0x2b8>)
   17dea:	4798      	blx	r3
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
   17dec:	2100      	movs	r1, #0
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0 )
   17dee:	6a63      	ldr	r3, [r4, #36]	; 0x24
   17df0:	428b      	cmp	r3, r1
   17df2:	d003      	beq.n	17dfc <xQueueSemaphoreTake+0x260>
			uxHighestPriorityOfWaitingTasks = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
   17df4:	6b23      	ldr	r3, [r4, #48]	; 0x30
   17df6:	3105      	adds	r1, #5
   17df8:	681b      	ldr	r3, [r3, #0]
   17dfa:	1ac9      	subs	r1, r1, r3
							vTaskPriorityDisinheritAfterTimeout( ( void * ) pxQueue->pxMutexHolder, uxHighestWaitingPriority );
   17dfc:	4b2d      	ldr	r3, [pc, #180]	; (17eb4 <xQueueSemaphoreTake+0x318>)
   17dfe:	6860      	ldr	r0, [r4, #4]
   17e00:	4798      	blx	r3
						taskEXIT_CRITICAL();
   17e02:	4b22      	ldr	r3, [pc, #136]	; (17e8c <xQueueSemaphoreTake+0x2f0>)
   17e04:	4798      	blx	r3
				traceQUEUE_RECEIVE_FAILED( pxQueue );
   17e06:	4b14      	ldr	r3, [pc, #80]	; (17e58 <xQueueSemaphoreTake+0x2bc>)
   17e08:	4798      	blx	r3
   17e0a:	4b14      	ldr	r3, [pc, #80]	; (17e5c <xQueueSemaphoreTake+0x2c0>)
   17e0c:	4798      	blx	r3
   17e0e:	4d14      	ldr	r5, [pc, #80]	; (17e60 <xQueueSemaphoreTake+0x2c4>)
   17e10:	882b      	ldrh	r3, [r5, #0]
   17e12:	4203      	tst	r3, r0
   17e14:	d100      	bne.n	17e18 <xQueueSemaphoreTake+0x27c>
   17e16:	e742      	b.n	17c9e <xQueueSemaphoreTake+0x102>
   17e18:	4b13      	ldr	r3, [pc, #76]	; (17e68 <xQueueSemaphoreTake+0x2cc>)
   17e1a:	0020      	movs	r0, r4
   17e1c:	4798      	blx	r3
   17e1e:	882b      	ldrh	r3, [r5, #0]
   17e20:	4203      	tst	r3, r0
   17e22:	d100      	bne.n	17e26 <xQueueSemaphoreTake+0x28a>
   17e24:	e73b      	b.n	17c9e <xQueueSemaphoreTake+0x102>
   17e26:	4f0f      	ldr	r7, [pc, #60]	; (17e64 <xQueueSemaphoreTake+0x2c8>)
   17e28:	0020      	movs	r0, r4
   17e2a:	47b8      	blx	r7
   17e2c:	4e0f      	ldr	r6, [pc, #60]	; (17e6c <xQueueSemaphoreTake+0x2d0>)
   17e2e:	5c35      	ldrb	r5, [r6, r0]
   17e30:	0020      	movs	r0, r4
   17e32:	47b8      	blx	r7
   17e34:	4b0e      	ldr	r3, [pc, #56]	; (17e70 <xQueueSemaphoreTake+0x2d4>)
   17e36:	5c36      	ldrb	r6, [r6, r0]
   17e38:	0020      	movs	r0, r4
   17e3a:	4798      	blx	r3
   17e3c:	3550      	adds	r5, #80	; 0x50
   17e3e:	b2ed      	uxtb	r5, r5
   17e40:	b2c2      	uxtb	r2, r0
   17e42:	0031      	movs	r1, r6
   17e44:	0028      	movs	r0, r5
   17e46:	4b0b      	ldr	r3, [pc, #44]	; (17e74 <xQueueSemaphoreTake+0x2d8>)
   17e48:	4798      	blx	r3
   17e4a:	e728      	b.n	17c9e <xQueueSemaphoreTake+0x102>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   17e4c:	b672      	cpsid	i
   17e4e:	e7fe      	b.n	17e4e <xQueueSemaphoreTake+0x2b2>
   17e50:	00018a7d 	.word	0x00018a7d
   17e54:	00016df1 	.word	0x00016df1
   17e58:	00015d9d 	.word	0x00015d9d
   17e5c:	00015c21 	.word	0x00015c21
   17e60:	200001f0 	.word	0x200001f0
   17e64:	00015c05 	.word	0x00015c05
   17e68:	00015c81 	.word	0x00015c81
   17e6c:	200001e8 	.word	0x200001e8
   17e70:	00015c71 	.word	0x00015c71
   17e74:	000168b9 	.word	0x000168b9
   17e78:	00015c11 	.word	0x00015c11
   17e7c:	000163c5 	.word	0x000163c5
   17e80:	00018d85 	.word	0x00018d85
   17e84:	000188d1 	.word	0x000188d1
   17e88:	00016de1 	.word	0x00016de1
   17e8c:	00016e09 	.word	0x00016e09
   17e90:	000189a9 	.word	0x000189a9
   17e94:	00018311 	.word	0x00018311
   17e98:	000189c1 	.word	0x000189c1
   17e9c:	00016f59 	.word	0x00016f59
   17ea0:	00018499 	.word	0x00018499
   17ea4:	00016419 	.word	0x00016419
   17ea8:	00018a9d 	.word	0x00018a9d
   17eac:	00018811 	.word	0x00018811
   17eb0:	00017121 	.word	0x00017121
   17eb4:	00018c8d 	.word	0x00018c8d

00017eb8 <uxQueueGetQueueNumber>:
		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
   17eb8:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
	}
   17eba:	4770      	bx	lr

00017ebc <vQueueSetQueueNumber>:
		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
   17ebc:	64c1      	str	r1, [r0, #76]	; 0x4c
	}
   17ebe:	4770      	bx	lr

00017ec0 <ucQueueGetQueueType>:
		return ( ( Queue_t * ) xQueue )->ucQueueType;
   17ec0:	3050      	adds	r0, #80	; 0x50
   17ec2:	7800      	ldrb	r0, [r0, #0]
	}
   17ec4:	4770      	bx	lr
	...

00017ec8 <vQueueWaitForMessageRestricted>:
	{
   17ec8:	b570      	push	{r4, r5, r6, lr}
   17eca:	0004      	movs	r4, r0
		prvLockQueue( pxQueue );
   17ecc:	4b11      	ldr	r3, [pc, #68]	; (17f14 <vQueueWaitForMessageRestricted+0x4c>)
	{
   17ece:	0016      	movs	r6, r2
   17ed0:	000d      	movs	r5, r1
		prvLockQueue( pxQueue );
   17ed2:	4798      	blx	r3
   17ed4:	0022      	movs	r2, r4
   17ed6:	3244      	adds	r2, #68	; 0x44
   17ed8:	7813      	ldrb	r3, [r2, #0]
   17eda:	b25b      	sxtb	r3, r3
   17edc:	3301      	adds	r3, #1
   17ede:	d101      	bne.n	17ee4 <vQueueWaitForMessageRestricted+0x1c>
   17ee0:	2300      	movs	r3, #0
   17ee2:	7013      	strb	r3, [r2, #0]
   17ee4:	0022      	movs	r2, r4
   17ee6:	3245      	adds	r2, #69	; 0x45
   17ee8:	7813      	ldrb	r3, [r2, #0]
   17eea:	b25b      	sxtb	r3, r3
   17eec:	3301      	adds	r3, #1
   17eee:	d101      	bne.n	17ef4 <vQueueWaitForMessageRestricted+0x2c>
   17ef0:	2300      	movs	r3, #0
   17ef2:	7013      	strb	r3, [r2, #0]
   17ef4:	4b08      	ldr	r3, [pc, #32]	; (17f18 <vQueueWaitForMessageRestricted+0x50>)
   17ef6:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
   17ef8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   17efa:	2b00      	cmp	r3, #0
   17efc:	d105      	bne.n	17f0a <vQueueWaitForMessageRestricted+0x42>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
   17efe:	0020      	movs	r0, r4
   17f00:	0032      	movs	r2, r6
   17f02:	0029      	movs	r1, r5
   17f04:	3024      	adds	r0, #36	; 0x24
   17f06:	4b05      	ldr	r3, [pc, #20]	; (17f1c <vQueueWaitForMessageRestricted+0x54>)
   17f08:	4798      	blx	r3
		prvUnlockQueue( pxQueue );
   17f0a:	0020      	movs	r0, r4
   17f0c:	4b04      	ldr	r3, [pc, #16]	; (17f20 <vQueueWaitForMessageRestricted+0x58>)
   17f0e:	4798      	blx	r3
	}
   17f10:	bd70      	pop	{r4, r5, r6, pc}
   17f12:	46c0      	nop			; (mov r8, r8)
   17f14:	00016df1 	.word	0x00016df1
   17f18:	00016e09 	.word	0x00016e09
   17f1c:	0001883d 	.word	0x0001883d
   17f20:	00017121 	.word	0x00017121

00017f24 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   17f24:	4a07      	ldr	r2, [pc, #28]	; (17f44 <prvResetNextTaskUnblockTime+0x20>)
   17f26:	6813      	ldr	r3, [r2, #0]
   17f28:	6819      	ldr	r1, [r3, #0]
   17f2a:	4b07      	ldr	r3, [pc, #28]	; (17f48 <prvResetNextTaskUnblockTime+0x24>)
   17f2c:	2900      	cmp	r1, #0
   17f2e:	d103      	bne.n	17f38 <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
   17f30:	2201      	movs	r2, #1
   17f32:	4252      	negs	r2, r2
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
   17f34:	601a      	str	r2, [r3, #0]
	}
}
   17f36:	4770      	bx	lr
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   17f38:	6812      	ldr	r2, [r2, #0]
   17f3a:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
   17f3c:	68d2      	ldr	r2, [r2, #12]
   17f3e:	6852      	ldr	r2, [r2, #4]
   17f40:	e7f8      	b.n	17f34 <prvResetNextTaskUnblockTime+0x10>
   17f42:	46c0      	nop			; (mov r8, r8)
   17f44:	20003bbc 	.word	0x20003bbc
   17f48:	20003c6c 	.word	0x20003c6c

00017f4c <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
   17f4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   17f4e:	0004      	movs	r4, r0
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
   17f50:	4b13      	ldr	r3, [pc, #76]	; (17fa0 <prvAddCurrentTaskToDelayedList+0x54>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   17f52:	4d14      	ldr	r5, [pc, #80]	; (17fa4 <prvAddCurrentTaskToDelayedList+0x58>)
const TickType_t xConstTickCount = xTickCount;
   17f54:	681e      	ldr	r6, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   17f56:	6828      	ldr	r0, [r5, #0]
   17f58:	4b13      	ldr	r3, [pc, #76]	; (17fa8 <prvAddCurrentTaskToDelayedList+0x5c>)
   17f5a:	3004      	adds	r0, #4
{
   17f5c:	000f      	movs	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   17f5e:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   17f60:	1c63      	adds	r3, r4, #1
   17f62:	d107      	bne.n	17f74 <prvAddCurrentTaskToDelayedList+0x28>
   17f64:	2f00      	cmp	r7, #0
   17f66:	d005      	beq.n	17f74 <prvAddCurrentTaskToDelayedList+0x28>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
   17f68:	6829      	ldr	r1, [r5, #0]
   17f6a:	4810      	ldr	r0, [pc, #64]	; (17fac <prvAddCurrentTaskToDelayedList+0x60>)
   17f6c:	4b10      	ldr	r3, [pc, #64]	; (17fb0 <prvAddCurrentTaskToDelayedList+0x64>)
   17f6e:	3104      	adds	r1, #4

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   17f70:	4798      	blx	r3

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
   17f72:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   17f74:	682b      	ldr	r3, [r5, #0]
			xTimeToWake = xConstTickCount + xTicksToWait;
   17f76:	1934      	adds	r4, r6, r4
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   17f78:	605c      	str	r4, [r3, #4]
   17f7a:	4b0e      	ldr	r3, [pc, #56]	; (17fb4 <prvAddCurrentTaskToDelayedList+0x68>)
			if( xTimeToWake < xConstTickCount )
   17f7c:	42a6      	cmp	r6, r4
   17f7e:	d904      	bls.n	17f8a <prvAddCurrentTaskToDelayedList+0x3e>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   17f80:	4a0d      	ldr	r2, [pc, #52]	; (17fb8 <prvAddCurrentTaskToDelayedList+0x6c>)
   17f82:	6810      	ldr	r0, [r2, #0]
   17f84:	6829      	ldr	r1, [r5, #0]
   17f86:	3104      	adds	r1, #4
   17f88:	e7f2      	b.n	17f70 <prvAddCurrentTaskToDelayedList+0x24>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   17f8a:	4a0c      	ldr	r2, [pc, #48]	; (17fbc <prvAddCurrentTaskToDelayedList+0x70>)
   17f8c:	6810      	ldr	r0, [r2, #0]
   17f8e:	6829      	ldr	r1, [r5, #0]
   17f90:	3104      	adds	r1, #4
   17f92:	4798      	blx	r3
				if( xTimeToWake < xNextTaskUnblockTime )
   17f94:	4b0a      	ldr	r3, [pc, #40]	; (17fc0 <prvAddCurrentTaskToDelayedList+0x74>)
   17f96:	681a      	ldr	r2, [r3, #0]
   17f98:	4294      	cmp	r4, r2
   17f9a:	d2ea      	bcs.n	17f72 <prvAddCurrentTaskToDelayedList+0x26>
					xNextTaskUnblockTime = xTimeToWake;
   17f9c:	601c      	str	r4, [r3, #0]
}
   17f9e:	e7e8      	b.n	17f72 <prvAddCurrentTaskToDelayedList+0x26>
   17fa0:	20003cb4 	.word	0x20003cb4
   17fa4:	20003bb8 	.word	0x20003bb8
   17fa8:	00016cc7 	.word	0x00016cc7
   17fac:	20003c8c 	.word	0x20003c8c
   17fb0:	00016c81 	.word	0x00016c81
   17fb4:	00016c99 	.word	0x00016c99
   17fb8:	20003bc0 	.word	0x20003bc0
   17fbc:	20003bbc 	.word	0x20003bbc
   17fc0:	20003c6c 	.word	0x20003c6c

00017fc4 <prvIdleTask>:
{
   17fc4:	b570      	push	{r4, r5, r6, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   17fc6:	4c11      	ldr	r4, [pc, #68]	; (1800c <prvIdleTask+0x48>)
   17fc8:	6823      	ldr	r3, [r4, #0]
   17fca:	2b00      	cmp	r3, #0
   17fcc:	d106      	bne.n	17fdc <prvIdleTask+0x18>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
   17fce:	4b10      	ldr	r3, [pc, #64]	; (18010 <prvIdleTask+0x4c>)
   17fd0:	681b      	ldr	r3, [r3, #0]
   17fd2:	2b01      	cmp	r3, #1
   17fd4:	d9f7      	bls.n	17fc6 <prvIdleTask+0x2>
				taskYIELD();
   17fd6:	4b0f      	ldr	r3, [pc, #60]	; (18014 <prvIdleTask+0x50>)
   17fd8:	4798      	blx	r3
   17fda:	e7f4      	b.n	17fc6 <prvIdleTask+0x2>
			taskENTER_CRITICAL();
   17fdc:	4b0e      	ldr	r3, [pc, #56]	; (18018 <prvIdleTask+0x54>)
   17fde:	4798      	blx	r3
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
   17fe0:	4b0e      	ldr	r3, [pc, #56]	; (1801c <prvIdleTask+0x58>)
   17fe2:	68db      	ldr	r3, [r3, #12]
   17fe4:	68dd      	ldr	r5, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   17fe6:	4b0e      	ldr	r3, [pc, #56]	; (18020 <prvIdleTask+0x5c>)
   17fe8:	1d28      	adds	r0, r5, #4
   17fea:	4798      	blx	r3
				--uxCurrentNumberOfTasks;
   17fec:	4a0d      	ldr	r2, [pc, #52]	; (18024 <prvIdleTask+0x60>)
   17fee:	6813      	ldr	r3, [r2, #0]
   17ff0:	3b01      	subs	r3, #1
   17ff2:	6013      	str	r3, [r2, #0]
				--uxDeletedTasksWaitingCleanUp;
   17ff4:	6823      	ldr	r3, [r4, #0]
   17ff6:	3b01      	subs	r3, #1
   17ff8:	6023      	str	r3, [r4, #0]
			taskEXIT_CRITICAL();
   17ffa:	4b0b      	ldr	r3, [pc, #44]	; (18028 <prvIdleTask+0x64>)
   17ffc:	4798      	blx	r3
			vPortFree( pxTCB->pxStack );
   17ffe:	6b28      	ldr	r0, [r5, #48]	; 0x30
   18000:	4c0a      	ldr	r4, [pc, #40]	; (1802c <prvIdleTask+0x68>)
   18002:	47a0      	blx	r4
			vPortFree( pxTCB );
   18004:	0028      	movs	r0, r5
   18006:	47a0      	blx	r4
   18008:	e7dd      	b.n	17fc6 <prvIdleTask+0x2>
   1800a:	46c0      	nop			; (mov r8, r8)
   1800c:	20003c2c 	.word	0x20003c2c
   18010:	20003bc4 	.word	0x20003bc4
   18014:	00016de1 	.word	0x00016de1
   18018:	00016df1 	.word	0x00016df1
   1801c:	20003ca0 	.word	0x20003ca0
   18020:	00016cc7 	.word	0x00016cc7
   18024:	20003c28 	.word	0x20003c28
   18028:	00016e09 	.word	0x00016e09
   1802c:	00016f39 	.word	0x00016f39

00018030 <xTaskCreate>:
	{
   18030:	b5f0      	push	{r4, r5, r6, r7, lr}
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   18032:	0095      	lsls	r5, r2, #2
	{
   18034:	b085      	sub	sp, #20
   18036:	9001      	str	r0, [sp, #4]
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   18038:	4c77      	ldr	r4, [pc, #476]	; (18218 <xTaskCreate+0x1e8>)
   1803a:	0028      	movs	r0, r5
	{
   1803c:	000f      	movs	r7, r1
   1803e:	9302      	str	r3, [sp, #8]
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   18040:	47a0      	blx	r4
   18042:	1e06      	subs	r6, r0, #0
			if( pxStack != NULL )
   18044:	d100      	bne.n	18048 <xTaskCreate+0x18>
   18046:	e0d7      	b.n	181f8 <xTaskCreate+0x1c8>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
   18048:	2054      	movs	r0, #84	; 0x54
   1804a:	47a0      	blx	r4
   1804c:	1e04      	subs	r4, r0, #0
				if( pxNewTCB != NULL )
   1804e:	d100      	bne.n	18052 <xTaskCreate+0x22>
   18050:	e0cf      	b.n	181f2 <xTaskCreate+0x1c2>
					pxNewTCB->pxStack = pxStack;
   18052:	6306      	str	r6, [r0, #48]	; 0x30
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
   18054:	002a      	movs	r2, r5
   18056:	4b71      	ldr	r3, [pc, #452]	; (1821c <xTaskCreate+0x1ec>)
   18058:	21a5      	movs	r1, #165	; 0xa5
   1805a:	0030      	movs	r0, r6
   1805c:	4798      	blx	r3
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
   1805e:	6b23      	ldr	r3, [r4, #48]	; 0x30
   18060:	3d04      	subs	r5, #4
   18062:	195d      	adds	r5, r3, r5
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
   18064:	2307      	movs	r3, #7
   18066:	439d      	bics	r5, r3
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   18068:	2300      	movs	r3, #0
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
   1806a:	9500      	str	r5, [sp, #0]
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
   1806c:	001a      	movs	r2, r3
   1806e:	5cf9      	ldrb	r1, [r7, r3]
   18070:	3234      	adds	r2, #52	; 0x34
   18072:	54a1      	strb	r1, [r4, r2]
		if( pcName[ x ] == 0x00 )
   18074:	5cfa      	ldrb	r2, [r7, r3]
   18076:	2a00      	cmp	r2, #0
   18078:	d002      	beq.n	18080 <xTaskCreate+0x50>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   1807a:	3301      	adds	r3, #1
   1807c:	2b08      	cmp	r3, #8
   1807e:	d1f5      	bne.n	1806c <xTaskCreate+0x3c>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   18080:	0023      	movs	r3, r4
   18082:	2700      	movs	r7, #0
   18084:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   18086:	333b      	adds	r3, #59	; 0x3b
   18088:	701f      	strb	r7, [r3, #0]
   1808a:	2d04      	cmp	r5, #4
   1808c:	d900      	bls.n	18090 <xTaskCreate+0x60>
   1808e:	2504      	movs	r5, #4
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
   18090:	1d23      	adds	r3, r4, #4
   18092:	0018      	movs	r0, r3
	pxNewTCB->uxPriority = uxPriority;
   18094:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
   18096:	6465      	str	r5, [r4, #68]	; 0x44
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
   18098:	4e61      	ldr	r6, [pc, #388]	; (18220 <xTaskCreate+0x1f0>)
		pxNewTCB->uxMutexesHeld = 0;
   1809a:	64a7      	str	r7, [r4, #72]	; 0x48
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
   1809c:	9303      	str	r3, [sp, #12]
   1809e:	47b0      	blx	r6
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
   180a0:	0020      	movs	r0, r4
   180a2:	3018      	adds	r0, #24
   180a4:	47b0      	blx	r6
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   180a6:	2305      	movs	r3, #5
   180a8:	1b5d      	subs	r5, r3, r5
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   180aa:	0023      	movs	r3, r4
   180ac:	3350      	adds	r3, #80	; 0x50
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
   180ae:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   180b0:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
   180b2:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
   180b4:	64e7      	str	r7, [r4, #76]	; 0x4c
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   180b6:	9a02      	ldr	r2, [sp, #8]
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   180b8:	701f      	strb	r7, [r3, #0]
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   180ba:	9901      	ldr	r1, [sp, #4]
   180bc:	4b59      	ldr	r3, [pc, #356]	; (18224 <xTaskCreate+0x1f4>)
   180be:	9800      	ldr	r0, [sp, #0]
   180c0:	4798      	blx	r3
	if( ( void * ) pxCreatedTask != NULL )
   180c2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   180c4:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
   180c6:	2b00      	cmp	r3, #0
   180c8:	d000      	beq.n	180cc <xTaskCreate+0x9c>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
   180ca:	601c      	str	r4, [r3, #0]
	taskENTER_CRITICAL();
   180cc:	4b56      	ldr	r3, [pc, #344]	; (18228 <xTaskCreate+0x1f8>)
   180ce:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
   180d0:	4b56      	ldr	r3, [pc, #344]	; (1822c <xTaskCreate+0x1fc>)
		if( pxCurrentTCB == NULL )
   180d2:	4e57      	ldr	r6, [pc, #348]	; (18230 <xTaskCreate+0x200>)
		uxCurrentNumberOfTasks++;
   180d4:	681a      	ldr	r2, [r3, #0]
   180d6:	3201      	adds	r2, #1
   180d8:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
   180da:	6832      	ldr	r2, [r6, #0]
   180dc:	2a00      	cmp	r2, #0
   180de:	d000      	beq.n	180e2 <xTaskCreate+0xb2>
   180e0:	e08d      	b.n	181fe <xTaskCreate+0x1ce>
			pxCurrentTCB = pxNewTCB;
   180e2:	6034      	str	r4, [r6, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
   180e4:	681b      	ldr	r3, [r3, #0]
   180e6:	2b01      	cmp	r3, #1
   180e8:	d11e      	bne.n	18128 <xTaskCreate+0xf8>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   180ea:	4d52      	ldr	r5, [pc, #328]	; (18234 <xTaskCreate+0x204>)
   180ec:	4852      	ldr	r0, [pc, #328]	; (18238 <xTaskCreate+0x208>)
   180ee:	47a8      	blx	r5
   180f0:	4851      	ldr	r0, [pc, #324]	; (18238 <xTaskCreate+0x208>)
   180f2:	3014      	adds	r0, #20
   180f4:	47a8      	blx	r5
   180f6:	4850      	ldr	r0, [pc, #320]	; (18238 <xTaskCreate+0x208>)
   180f8:	3028      	adds	r0, #40	; 0x28
   180fa:	47a8      	blx	r5
   180fc:	484e      	ldr	r0, [pc, #312]	; (18238 <xTaskCreate+0x208>)
   180fe:	303c      	adds	r0, #60	; 0x3c
   18100:	47a8      	blx	r5
   18102:	484d      	ldr	r0, [pc, #308]	; (18238 <xTaskCreate+0x208>)
   18104:	3050      	adds	r0, #80	; 0x50
   18106:	47a8      	blx	r5
	vListInitialise( &xDelayedTaskList1 );
   18108:	4f4c      	ldr	r7, [pc, #304]	; (1823c <xTaskCreate+0x20c>)
   1810a:	0038      	movs	r0, r7
   1810c:	47a8      	blx	r5
	vListInitialise( &xDelayedTaskList2 );
   1810e:	484c      	ldr	r0, [pc, #304]	; (18240 <xTaskCreate+0x210>)
   18110:	47a8      	blx	r5
	vListInitialise( &xPendingReadyList );
   18112:	484c      	ldr	r0, [pc, #304]	; (18244 <xTaskCreate+0x214>)
   18114:	47a8      	blx	r5
		vListInitialise( &xTasksWaitingTermination );
   18116:	484c      	ldr	r0, [pc, #304]	; (18248 <xTaskCreate+0x218>)
   18118:	47a8      	blx	r5
		vListInitialise( &xSuspendedTaskList );
   1811a:	484c      	ldr	r0, [pc, #304]	; (1824c <xTaskCreate+0x21c>)
   1811c:	47a8      	blx	r5
	pxDelayedTaskList = &xDelayedTaskList1;
   1811e:	4b4c      	ldr	r3, [pc, #304]	; (18250 <xTaskCreate+0x220>)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   18120:	4a47      	ldr	r2, [pc, #284]	; (18240 <xTaskCreate+0x210>)
	pxDelayedTaskList = &xDelayedTaskList1;
   18122:	601f      	str	r7, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   18124:	4b4b      	ldr	r3, [pc, #300]	; (18254 <xTaskCreate+0x224>)
   18126:	601a      	str	r2, [r3, #0]
		uxTaskNumber++;
   18128:	4a4b      	ldr	r2, [pc, #300]	; (18258 <xTaskCreate+0x228>)
		traceTASK_CREATE( pxNewTCB );
   1812a:	2003      	movs	r0, #3
		uxTaskNumber++;
   1812c:	6813      	ldr	r3, [r2, #0]
   1812e:	3301      	adds	r3, #1
   18130:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
   18132:	63e3      	str	r3, [r4, #60]	; 0x3c
		traceTASK_CREATE( pxNewTCB );
   18134:	4b49      	ldr	r3, [pc, #292]	; (1825c <xTaskCreate+0x22c>)
   18136:	4798      	blx	r3
   18138:	4b49      	ldr	r3, [pc, #292]	; (18260 <xTaskCreate+0x230>)
   1813a:	b281      	uxth	r1, r0
   1813c:	0020      	movs	r0, r4
   1813e:	4798      	blx	r3
   18140:	4b48      	ldr	r3, [pc, #288]	; (18264 <xTaskCreate+0x234>)
   18142:	0020      	movs	r0, r4
   18144:	8819      	ldrh	r1, [r3, #0]
   18146:	4b48      	ldr	r3, [pc, #288]	; (18268 <xTaskCreate+0x238>)
   18148:	4798      	blx	r3
   1814a:	4f48      	ldr	r7, [pc, #288]	; (1826c <xTaskCreate+0x23c>)
   1814c:	0020      	movs	r0, r4
   1814e:	47b8      	blx	r7
   18150:	0022      	movs	r2, r4
   18152:	b2c1      	uxtb	r1, r0
   18154:	3234      	adds	r2, #52	; 0x34
   18156:	4b46      	ldr	r3, [pc, #280]	; (18270 <xTaskCreate+0x240>)
   18158:	2003      	movs	r0, #3
   1815a:	4798      	blx	r3
   1815c:	0020      	movs	r0, r4
   1815e:	47b8      	blx	r7
   18160:	232c      	movs	r3, #44	; 0x2c
   18162:	18e3      	adds	r3, r4, r3
   18164:	781a      	ldrb	r2, [r3, #0]
   18166:	b2c1      	uxtb	r1, r0
   18168:	4b42      	ldr	r3, [pc, #264]	; (18274 <xTaskCreate+0x244>)
   1816a:	2003      	movs	r0, #3
   1816c:	4798      	blx	r3
   1816e:	4b42      	ldr	r3, [pc, #264]	; (18278 <xTaskCreate+0x248>)
   18170:	4798      	blx	r3
   18172:	4b42      	ldr	r3, [pc, #264]	; (1827c <xTaskCreate+0x24c>)
   18174:	4798      	blx	r3
   18176:	4d42      	ldr	r5, [pc, #264]	; (18280 <xTaskCreate+0x250>)
   18178:	882b      	ldrh	r3, [r5, #0]
   1817a:	4203      	tst	r3, r0
   1817c:	d00c      	beq.n	18198 <xTaskCreate+0x168>
   1817e:	4b3f      	ldr	r3, [pc, #252]	; (1827c <xTaskCreate+0x24c>)
   18180:	0020      	movs	r0, r4
   18182:	4798      	blx	r3
   18184:	882b      	ldrh	r3, [r5, #0]
   18186:	4203      	tst	r3, r0
   18188:	d006      	beq.n	18198 <xTaskCreate+0x168>
   1818a:	0020      	movs	r0, r4
   1818c:	47b8      	blx	r7
   1818e:	2103      	movs	r1, #3
   18190:	b2c2      	uxtb	r2, r0
   18192:	4b3c      	ldr	r3, [pc, #240]	; (18284 <xTaskCreate+0x254>)
   18194:	201b      	movs	r0, #27
   18196:	4798      	blx	r3
   18198:	0020      	movs	r0, r4
   1819a:	4b3b      	ldr	r3, [pc, #236]	; (18288 <xTaskCreate+0x258>)
   1819c:	4798      	blx	r3
		prvAddTaskToReadyList( pxNewTCB );
   1819e:	4b37      	ldr	r3, [pc, #220]	; (1827c <xTaskCreate+0x24c>)
   181a0:	0020      	movs	r0, r4
   181a2:	4798      	blx	r3
   181a4:	4b36      	ldr	r3, [pc, #216]	; (18280 <xTaskCreate+0x250>)
   181a6:	881b      	ldrh	r3, [r3, #0]
   181a8:	4203      	tst	r3, r0
   181aa:	d004      	beq.n	181b6 <xTaskCreate+0x186>
   181ac:	0020      	movs	r0, r4
   181ae:	47b8      	blx	r7
   181b0:	4b36      	ldr	r3, [pc, #216]	; (1828c <xTaskCreate+0x25c>)
   181b2:	b2c0      	uxtb	r0, r0
   181b4:	4798      	blx	r3
   181b6:	4a36      	ldr	r2, [pc, #216]	; (18290 <xTaskCreate+0x260>)
   181b8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   181ba:	6811      	ldr	r1, [r2, #0]
   181bc:	428b      	cmp	r3, r1
   181be:	d900      	bls.n	181c2 <xTaskCreate+0x192>
   181c0:	6013      	str	r3, [r2, #0]
   181c2:	2014      	movs	r0, #20
   181c4:	4358      	muls	r0, r3
   181c6:	4b1c      	ldr	r3, [pc, #112]	; (18238 <xTaskCreate+0x208>)
   181c8:	1d21      	adds	r1, r4, #4
   181ca:	1818      	adds	r0, r3, r0
   181cc:	4b31      	ldr	r3, [pc, #196]	; (18294 <xTaskCreate+0x264>)
   181ce:	4798      	blx	r3
	taskEXIT_CRITICAL();
   181d0:	4b31      	ldr	r3, [pc, #196]	; (18298 <xTaskCreate+0x268>)
   181d2:	4798      	blx	r3
	if( xSchedulerRunning != pdFALSE )
   181d4:	4b31      	ldr	r3, [pc, #196]	; (1829c <xTaskCreate+0x26c>)
			xReturn = pdPASS;
   181d6:	2501      	movs	r5, #1
	if( xSchedulerRunning != pdFALSE )
   181d8:	681b      	ldr	r3, [r3, #0]
   181da:	2b00      	cmp	r3, #0
   181dc:	d006      	beq.n	181ec <xTaskCreate+0x1bc>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
   181de:	6833      	ldr	r3, [r6, #0]
   181e0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   181e2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   181e4:	429a      	cmp	r2, r3
   181e6:	d201      	bcs.n	181ec <xTaskCreate+0x1bc>
			taskYIELD_IF_USING_PREEMPTION();
   181e8:	4b2d      	ldr	r3, [pc, #180]	; (182a0 <xTaskCreate+0x270>)
   181ea:	4798      	blx	r3
	}
   181ec:	0028      	movs	r0, r5
   181ee:	b005      	add	sp, #20
   181f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
					vPortFree( pxStack );
   181f2:	0030      	movs	r0, r6
   181f4:	4b2b      	ldr	r3, [pc, #172]	; (182a4 <xTaskCreate+0x274>)
   181f6:	4798      	blx	r3
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   181f8:	2501      	movs	r5, #1
   181fa:	426d      	negs	r5, r5
   181fc:	e7f6      	b.n	181ec <xTaskCreate+0x1bc>
			if( xSchedulerRunning == pdFALSE )
   181fe:	4b27      	ldr	r3, [pc, #156]	; (1829c <xTaskCreate+0x26c>)
   18200:	681b      	ldr	r3, [r3, #0]
   18202:	2b00      	cmp	r3, #0
   18204:	d000      	beq.n	18208 <xTaskCreate+0x1d8>
   18206:	e78f      	b.n	18128 <xTaskCreate+0xf8>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
   18208:	6833      	ldr	r3, [r6, #0]
   1820a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   1820c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1820e:	4293      	cmp	r3, r2
   18210:	d900      	bls.n	18214 <xTaskCreate+0x1e4>
   18212:	e789      	b.n	18128 <xTaskCreate+0xf8>
					pxCurrentTCB = pxNewTCB;
   18214:	6034      	str	r4, [r6, #0]
   18216:	e787      	b.n	18128 <xTaskCreate+0xf8>
   18218:	00016eb5 	.word	0x00016eb5
   1821c:	00022c47 	.word	0x00022c47
   18220:	00016c7b 	.word	0x00016c7b
   18224:	00016d45 	.word	0x00016d45
   18228:	00016df1 	.word	0x00016df1
   1822c:	20003c28 	.word	0x20003c28
   18230:	20003bb8 	.word	0x20003bb8
   18234:	00016c65 	.word	0x00016c65
   18238:	20003bc4 	.word	0x20003bc4
   1823c:	20003c40 	.word	0x20003c40
   18240:	20003c54 	.word	0x20003c54
   18244:	20003c74 	.word	0x20003c74
   18248:	20003ca0 	.word	0x20003ca0
   1824c:	20003c8c 	.word	0x20003c8c
   18250:	20003bbc 	.word	0x20003bbc
   18254:	20003bc0 	.word	0x20003bc0
   18258:	20003c38 	.word	0x20003c38
   1825c:	00016459 	.word	0x00016459
   18260:	00015c31 	.word	0x00015c31
   18264:	200001ee 	.word	0x200001ee
   18268:	00015c51 	.word	0x00015c51
   1826c:	00015c11 	.word	0x00015c11
   18270:	00016521 	.word	0x00016521
   18274:	0001631d 	.word	0x0001631d
   18278:	00015d9d 	.word	0x00015d9d
   1827c:	00015c21 	.word	0x00015c21
   18280:	200001f0 	.word	0x200001f0
   18284:	000168b9 	.word	0x000168b9
   18288:	00015cd1 	.word	0x00015cd1
   1828c:	00016755 	.word	0x00016755
   18290:	20003c3c 	.word	0x20003c3c
   18294:	00016c81 	.word	0x00016c81
   18298:	00016e09 	.word	0x00016e09
   1829c:	20003c88 	.word	0x20003c88
   182a0:	00016de1 	.word	0x00016de1
   182a4:	00016f39 	.word	0x00016f39

000182a8 <vTaskStartScheduler>:
{
   182a8:	b537      	push	{r0, r1, r2, r4, r5, lr}
		xReturn = xTaskCreate(	prvIdleTask,
   182aa:	2400      	movs	r4, #0
   182ac:	4b0f      	ldr	r3, [pc, #60]	; (182ec <vTaskStartScheduler+0x44>)
   182ae:	9400      	str	r4, [sp, #0]
   182b0:	9301      	str	r3, [sp, #4]
   182b2:	2264      	movs	r2, #100	; 0x64
   182b4:	0023      	movs	r3, r4
   182b6:	490e      	ldr	r1, [pc, #56]	; (182f0 <vTaskStartScheduler+0x48>)
   182b8:	480e      	ldr	r0, [pc, #56]	; (182f4 <vTaskStartScheduler+0x4c>)
   182ba:	4d0f      	ldr	r5, [pc, #60]	; (182f8 <vTaskStartScheduler+0x50>)
   182bc:	47a8      	blx	r5
		if( xReturn == pdPASS )
   182be:	2801      	cmp	r0, #1
   182c0:	d10f      	bne.n	182e2 <vTaskStartScheduler+0x3a>
			xReturn = xTimerCreateTimerTask();
   182c2:	4b0e      	ldr	r3, [pc, #56]	; (182fc <vTaskStartScheduler+0x54>)
   182c4:	4798      	blx	r3
	if( xReturn == pdPASS )
   182c6:	2801      	cmp	r0, #1
   182c8:	d10b      	bne.n	182e2 <vTaskStartScheduler+0x3a>
		portDISABLE_INTERRUPTS();
   182ca:	b672      	cpsid	i
		xNextTaskUnblockTime = portMAX_DELAY;
   182cc:	2201      	movs	r2, #1
   182ce:	4b0c      	ldr	r3, [pc, #48]	; (18300 <vTaskStartScheduler+0x58>)
   182d0:	4252      	negs	r2, r2
   182d2:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
   182d4:	4b0b      	ldr	r3, [pc, #44]	; (18304 <vTaskStartScheduler+0x5c>)
   182d6:	6018      	str	r0, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
   182d8:	4b0b      	ldr	r3, [pc, #44]	; (18308 <vTaskStartScheduler+0x60>)
   182da:	601c      	str	r4, [r3, #0]
		if( xPortStartScheduler() != pdFALSE )
   182dc:	4b0b      	ldr	r3, [pc, #44]	; (1830c <vTaskStartScheduler+0x64>)
   182de:	4798      	blx	r3
}
   182e0:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
   182e2:	1c43      	adds	r3, r0, #1
   182e4:	d1fc      	bne.n	182e0 <vTaskStartScheduler+0x38>
   182e6:	b672      	cpsid	i
   182e8:	e7fe      	b.n	182e8 <vTaskStartScheduler+0x40>
   182ea:	46c0      	nop			; (mov r8, r8)
   182ec:	20003c68 	.word	0x20003c68
   182f0:	00029f03 	.word	0x00029f03
   182f4:	00017fc5 	.word	0x00017fc5
   182f8:	00018031 	.word	0x00018031
   182fc:	00018e39 	.word	0x00018e39
   18300:	20003c6c 	.word	0x20003c6c
   18304:	20003c88 	.word	0x20003c88
   18308:	20003cb4 	.word	0x20003cb4
   1830c:	00016d69 	.word	0x00016d69

00018310 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
   18310:	4a02      	ldr	r2, [pc, #8]	; (1831c <vTaskSuspendAll+0xc>)
   18312:	6813      	ldr	r3, [r2, #0]
   18314:	3301      	adds	r3, #1
   18316:	6013      	str	r3, [r2, #0]
}
   18318:	4770      	bx	lr
   1831a:	46c0      	nop			; (mov r8, r8)
   1831c:	20003c34 	.word	0x20003c34

00018320 <xTaskGetTickCount>:
   18320:	4b01      	ldr	r3, [pc, #4]	; (18328 <xTaskGetTickCount+0x8>)
   18322:	6818      	ldr	r0, [r3, #0]
   18324:	4770      	bx	lr
   18326:	46c0      	nop			; (mov r8, r8)
   18328:	20003cb4 	.word	0x20003cb4

0001832c <xTaskIncrementTick>:
{
   1832c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	traceTASK_INCREMENT_TICK( xTickCount );
   1832e:	4c45      	ldr	r4, [pc, #276]	; (18444 <xTaskIncrementTick+0x118>)
   18330:	6823      	ldr	r3, [r4, #0]
   18332:	2b01      	cmp	r3, #1
   18334:	d003      	beq.n	1833e <xTaskIncrementTick+0x12>
   18336:	4b44      	ldr	r3, [pc, #272]	; (18448 <xTaskIncrementTick+0x11c>)
   18338:	681b      	ldr	r3, [r3, #0]
   1833a:	2b00      	cmp	r3, #0
   1833c:	d106      	bne.n	1834c <xTaskIncrementTick+0x20>
   1833e:	4a43      	ldr	r2, [pc, #268]	; (1844c <xTaskIncrementTick+0x120>)
   18340:	2000      	movs	r0, #0
   18342:	6813      	ldr	r3, [r2, #0]
   18344:	3301      	adds	r3, #1
   18346:	6013      	str	r3, [r2, #0]
   18348:	4b41      	ldr	r3, [pc, #260]	; (18450 <xTaskIncrementTick+0x124>)
   1834a:	4798      	blx	r3
   1834c:	6823      	ldr	r3, [r4, #0]
   1834e:	2b00      	cmp	r3, #0
   18350:	d105      	bne.n	1835e <xTaskIncrementTick+0x32>
   18352:	4b40      	ldr	r3, [pc, #256]	; (18454 <xTaskIncrementTick+0x128>)
   18354:	2003      	movs	r0, #3
   18356:	6819      	ldr	r1, [r3, #0]
   18358:	4b3f      	ldr	r3, [pc, #252]	; (18458 <xTaskIncrementTick+0x12c>)
   1835a:	3101      	adds	r1, #1
   1835c:	4798      	blx	r3
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   1835e:	6823      	ldr	r3, [r4, #0]
   18360:	2b00      	cmp	r3, #0
   18362:	d135      	bne.n	183d0 <xTaskIncrementTick+0xa4>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
   18364:	4b3b      	ldr	r3, [pc, #236]	; (18454 <xTaskIncrementTick+0x128>)
   18366:	681f      	ldr	r7, [r3, #0]
   18368:	3701      	adds	r7, #1
		xTickCount = xConstTickCount;
   1836a:	601f      	str	r7, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
   1836c:	2f00      	cmp	r7, #0
   1836e:	d111      	bne.n	18394 <xTaskIncrementTick+0x68>
			taskSWITCH_DELAYED_LISTS();
   18370:	4b3a      	ldr	r3, [pc, #232]	; (1845c <xTaskIncrementTick+0x130>)
   18372:	681a      	ldr	r2, [r3, #0]
   18374:	6812      	ldr	r2, [r2, #0]
   18376:	2a00      	cmp	r2, #0
   18378:	d001      	beq.n	1837e <xTaskIncrementTick+0x52>
   1837a:	b672      	cpsid	i
   1837c:	e7fe      	b.n	1837c <xTaskIncrementTick+0x50>
   1837e:	4a38      	ldr	r2, [pc, #224]	; (18460 <xTaskIncrementTick+0x134>)
   18380:	6819      	ldr	r1, [r3, #0]
   18382:	6810      	ldr	r0, [r2, #0]
   18384:	6018      	str	r0, [r3, #0]
   18386:	6011      	str	r1, [r2, #0]
   18388:	4a36      	ldr	r2, [pc, #216]	; (18464 <xTaskIncrementTick+0x138>)
   1838a:	6813      	ldr	r3, [r2, #0]
   1838c:	3301      	adds	r3, #1
   1838e:	6013      	str	r3, [r2, #0]
   18390:	4b35      	ldr	r3, [pc, #212]	; (18468 <xTaskIncrementTick+0x13c>)
   18392:	4798      	blx	r3
		if( xConstTickCount >= xNextTaskUnblockTime )
   18394:	4e35      	ldr	r6, [pc, #212]	; (1846c <xTaskIncrementTick+0x140>)
BaseType_t xSwitchRequired = pdFALSE;
   18396:	2500      	movs	r5, #0
		if( xConstTickCount >= xNextTaskUnblockTime )
   18398:	6833      	ldr	r3, [r6, #0]
   1839a:	429f      	cmp	r7, r3
   1839c:	d307      	bcc.n	183ae <xTaskIncrementTick+0x82>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   1839e:	4b2f      	ldr	r3, [pc, #188]	; (1845c <xTaskIncrementTick+0x130>)
   183a0:	681a      	ldr	r2, [r3, #0]
   183a2:	6812      	ldr	r2, [r2, #0]
   183a4:	2a00      	cmp	r2, #0
   183a6:	d119      	bne.n	183dc <xTaskIncrementTick+0xb0>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   183a8:	2301      	movs	r3, #1
   183aa:	425b      	negs	r3, r3
   183ac:	6033      	str	r3, [r6, #0]
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   183ae:	4b30      	ldr	r3, [pc, #192]	; (18470 <xTaskIncrementTick+0x144>)
   183b0:	681b      	ldr	r3, [r3, #0]
   183b2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   183b4:	2314      	movs	r3, #20
   183b6:	4353      	muls	r3, r2
   183b8:	4a2e      	ldr	r2, [pc, #184]	; (18474 <xTaskIncrementTick+0x148>)
   183ba:	58d3      	ldr	r3, [r2, r3]
   183bc:	2b01      	cmp	r3, #1
   183be:	d900      	bls.n	183c2 <xTaskIncrementTick+0x96>
				xSwitchRequired = pdTRUE;
   183c0:	2501      	movs	r5, #1
		if( xYieldPending != pdFALSE )
   183c2:	4b2d      	ldr	r3, [pc, #180]	; (18478 <xTaskIncrementTick+0x14c>)
   183c4:	681b      	ldr	r3, [r3, #0]
   183c6:	2b00      	cmp	r3, #0
   183c8:	d000      	beq.n	183cc <xTaskIncrementTick+0xa0>
			xSwitchRequired = pdTRUE;
   183ca:	2501      	movs	r5, #1
}
   183cc:	0028      	movs	r0, r5
   183ce:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		++uxPendedTicks;
   183d0:	4a1d      	ldr	r2, [pc, #116]	; (18448 <xTaskIncrementTick+0x11c>)
BaseType_t xSwitchRequired = pdFALSE;
   183d2:	2500      	movs	r5, #0
		++uxPendedTicks;
   183d4:	6813      	ldr	r3, [r2, #0]
   183d6:	3301      	adds	r3, #1
   183d8:	6013      	str	r3, [r2, #0]
   183da:	e7f2      	b.n	183c2 <xTaskIncrementTick+0x96>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   183dc:	681b      	ldr	r3, [r3, #0]
   183de:	68db      	ldr	r3, [r3, #12]
   183e0:	68dc      	ldr	r4, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
   183e2:	6863      	ldr	r3, [r4, #4]
					if( xConstTickCount < xItemValue )
   183e4:	429f      	cmp	r7, r3
   183e6:	d3e1      	bcc.n	183ac <xTaskIncrementTick+0x80>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   183e8:	1d23      	adds	r3, r4, #4
   183ea:	9301      	str	r3, [sp, #4]
   183ec:	0018      	movs	r0, r3
   183ee:	4b23      	ldr	r3, [pc, #140]	; (1847c <xTaskIncrementTick+0x150>)
   183f0:	4798      	blx	r3
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   183f2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   183f4:	2b00      	cmp	r3, #0
   183f6:	d003      	beq.n	18400 <xTaskIncrementTick+0xd4>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   183f8:	0020      	movs	r0, r4
   183fa:	4b20      	ldr	r3, [pc, #128]	; (1847c <xTaskIncrementTick+0x150>)
   183fc:	3018      	adds	r0, #24
   183fe:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
   18400:	4b1f      	ldr	r3, [pc, #124]	; (18480 <xTaskIncrementTick+0x154>)
   18402:	0020      	movs	r0, r4
   18404:	4798      	blx	r3
   18406:	4b1f      	ldr	r3, [pc, #124]	; (18484 <xTaskIncrementTick+0x158>)
   18408:	881b      	ldrh	r3, [r3, #0]
   1840a:	4203      	tst	r3, r0
   1840c:	d005      	beq.n	1841a <xTaskIncrementTick+0xee>
   1840e:	4b1e      	ldr	r3, [pc, #120]	; (18488 <xTaskIncrementTick+0x15c>)
   18410:	0020      	movs	r0, r4
   18412:	4798      	blx	r3
   18414:	4b1d      	ldr	r3, [pc, #116]	; (1848c <xTaskIncrementTick+0x160>)
   18416:	b2c0      	uxtb	r0, r0
   18418:	4798      	blx	r3
   1841a:	4b1d      	ldr	r3, [pc, #116]	; (18490 <xTaskIncrementTick+0x164>)
   1841c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   1841e:	681a      	ldr	r2, [r3, #0]
   18420:	4290      	cmp	r0, r2
   18422:	d900      	bls.n	18426 <xTaskIncrementTick+0xfa>
   18424:	6018      	str	r0, [r3, #0]
   18426:	2314      	movs	r3, #20
   18428:	4358      	muls	r0, r3
   1842a:	4b12      	ldr	r3, [pc, #72]	; (18474 <xTaskIncrementTick+0x148>)
   1842c:	1d21      	adds	r1, r4, #4
   1842e:	1818      	adds	r0, r3, r0
   18430:	4b18      	ldr	r3, [pc, #96]	; (18494 <xTaskIncrementTick+0x168>)
   18432:	4798      	blx	r3
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   18434:	4b0e      	ldr	r3, [pc, #56]	; (18470 <xTaskIncrementTick+0x144>)
   18436:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   18438:	681b      	ldr	r3, [r3, #0]
   1843a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1843c:	429a      	cmp	r2, r3
   1843e:	d3ae      	bcc.n	1839e <xTaskIncrementTick+0x72>
							xSwitchRequired = pdTRUE;
   18440:	2501      	movs	r5, #1
   18442:	e7ac      	b.n	1839e <xTaskIncrementTick+0x72>
   18444:	20003c34 	.word	0x20003c34
   18448:	20003c30 	.word	0x20003c30
   1844c:	20000cc8 	.word	0x20000cc8
   18450:	000165a1 	.word	0x000165a1
   18454:	20003cb4 	.word	0x20003cb4
   18458:	00016a29 	.word	0x00016a29
   1845c:	20003bbc 	.word	0x20003bbc
   18460:	20003bc0 	.word	0x20003bc0
   18464:	20003c70 	.word	0x20003c70
   18468:	00017f25 	.word	0x00017f25
   1846c:	20003c6c 	.word	0x20003c6c
   18470:	20003bb8 	.word	0x20003bb8
   18474:	20003bc4 	.word	0x20003bc4
   18478:	20003cb8 	.word	0x20003cb8
   1847c:	00016cc7 	.word	0x00016cc7
   18480:	00015c21 	.word	0x00015c21
   18484:	200001f0 	.word	0x200001f0
   18488:	00015c11 	.word	0x00015c11
   1848c:	00016755 	.word	0x00016755
   18490:	20003c3c 	.word	0x20003c3c
   18494:	00016c81 	.word	0x00016c81

00018498 <xTaskResumeAll>:
{
   18498:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( uxSchedulerSuspended );
   1849a:	4c31      	ldr	r4, [pc, #196]	; (18560 <xTaskResumeAll+0xc8>)
   1849c:	6823      	ldr	r3, [r4, #0]
   1849e:	2b00      	cmp	r3, #0
   184a0:	d101      	bne.n	184a6 <xTaskResumeAll+0xe>
   184a2:	b672      	cpsid	i
   184a4:	e7fe      	b.n	184a4 <xTaskResumeAll+0xc>
	taskENTER_CRITICAL();
   184a6:	4b2f      	ldr	r3, [pc, #188]	; (18564 <xTaskResumeAll+0xcc>)
   184a8:	4798      	blx	r3
		--uxSchedulerSuspended;
   184aa:	6823      	ldr	r3, [r4, #0]
   184ac:	3b01      	subs	r3, #1
   184ae:	6023      	str	r3, [r4, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   184b0:	6824      	ldr	r4, [r4, #0]
   184b2:	2c00      	cmp	r4, #0
   184b4:	d004      	beq.n	184c0 <xTaskResumeAll+0x28>
BaseType_t xAlreadyYielded = pdFALSE;
   184b6:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
   184b8:	4b2b      	ldr	r3, [pc, #172]	; (18568 <xTaskResumeAll+0xd0>)
   184ba:	4798      	blx	r3
}
   184bc:	0020      	movs	r0, r4
   184be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   184c0:	4b2a      	ldr	r3, [pc, #168]	; (1856c <xTaskResumeAll+0xd4>)
						xYieldPending = pdTRUE;
   184c2:	2701      	movs	r7, #1
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   184c4:	681b      	ldr	r3, [r3, #0]
   184c6:	2b00      	cmp	r3, #0
   184c8:	d0f5      	beq.n	184b6 <xTaskResumeAll+0x1e>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   184ca:	4b29      	ldr	r3, [pc, #164]	; (18570 <xTaskResumeAll+0xd8>)
   184cc:	681a      	ldr	r2, [r3, #0]
   184ce:	2a00      	cmp	r2, #0
   184d0:	d11a      	bne.n	18508 <xTaskResumeAll+0x70>
				if( pxTCB != NULL )
   184d2:	2c00      	cmp	r4, #0
   184d4:	d001      	beq.n	184da <xTaskResumeAll+0x42>
					prvResetNextTaskUnblockTime();
   184d6:	4b27      	ldr	r3, [pc, #156]	; (18574 <xTaskResumeAll+0xdc>)
   184d8:	4798      	blx	r3
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
   184da:	4d27      	ldr	r5, [pc, #156]	; (18578 <xTaskResumeAll+0xe0>)
   184dc:	682c      	ldr	r4, [r5, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
   184de:	2c00      	cmp	r4, #0
   184e0:	d00a      	beq.n	184f8 <xTaskResumeAll+0x60>
								xYieldPending = pdTRUE;
   184e2:	2601      	movs	r6, #1
							if( xTaskIncrementTick() != pdFALSE )
   184e4:	4b25      	ldr	r3, [pc, #148]	; (1857c <xTaskResumeAll+0xe4>)
   184e6:	4798      	blx	r3
   184e8:	2800      	cmp	r0, #0
   184ea:	d001      	beq.n	184f0 <xTaskResumeAll+0x58>
								xYieldPending = pdTRUE;
   184ec:	4b24      	ldr	r3, [pc, #144]	; (18580 <xTaskResumeAll+0xe8>)
   184ee:	601e      	str	r6, [r3, #0]
							--uxPendedCounts;
   184f0:	3c01      	subs	r4, #1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
   184f2:	2c00      	cmp	r4, #0
   184f4:	d1f6      	bne.n	184e4 <xTaskResumeAll+0x4c>
						uxPendedTicks = 0;
   184f6:	602c      	str	r4, [r5, #0]
				if( xYieldPending != pdFALSE )
   184f8:	4b21      	ldr	r3, [pc, #132]	; (18580 <xTaskResumeAll+0xe8>)
   184fa:	681b      	ldr	r3, [r3, #0]
   184fc:	2b00      	cmp	r3, #0
   184fe:	d0da      	beq.n	184b6 <xTaskResumeAll+0x1e>
					taskYIELD_IF_USING_PREEMPTION();
   18500:	4b20      	ldr	r3, [pc, #128]	; (18584 <xTaskResumeAll+0xec>)
   18502:	4798      	blx	r3
						xAlreadyYielded = pdTRUE;
   18504:	2401      	movs	r4, #1
   18506:	e7d7      	b.n	184b8 <xTaskResumeAll+0x20>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
   18508:	68db      	ldr	r3, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   1850a:	4e1f      	ldr	r6, [pc, #124]	; (18588 <xTaskResumeAll+0xf0>)
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
   1850c:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   1850e:	0020      	movs	r0, r4
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   18510:	1d25      	adds	r5, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   18512:	3018      	adds	r0, #24
   18514:	47b0      	blx	r6
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   18516:	0028      	movs	r0, r5
   18518:	47b0      	blx	r6
					prvAddTaskToReadyList( pxTCB );
   1851a:	4b1c      	ldr	r3, [pc, #112]	; (1858c <xTaskResumeAll+0xf4>)
   1851c:	0020      	movs	r0, r4
   1851e:	4798      	blx	r3
   18520:	4b1b      	ldr	r3, [pc, #108]	; (18590 <xTaskResumeAll+0xf8>)
   18522:	881b      	ldrh	r3, [r3, #0]
   18524:	4203      	tst	r3, r0
   18526:	d005      	beq.n	18534 <xTaskResumeAll+0x9c>
   18528:	4b1a      	ldr	r3, [pc, #104]	; (18594 <xTaskResumeAll+0xfc>)
   1852a:	0020      	movs	r0, r4
   1852c:	4798      	blx	r3
   1852e:	4b1a      	ldr	r3, [pc, #104]	; (18598 <xTaskResumeAll+0x100>)
   18530:	b2c0      	uxtb	r0, r0
   18532:	4798      	blx	r3
   18534:	4b19      	ldr	r3, [pc, #100]	; (1859c <xTaskResumeAll+0x104>)
   18536:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   18538:	681a      	ldr	r2, [r3, #0]
   1853a:	4290      	cmp	r0, r2
   1853c:	d900      	bls.n	18540 <xTaskResumeAll+0xa8>
   1853e:	6018      	str	r0, [r3, #0]
   18540:	2314      	movs	r3, #20
   18542:	4358      	muls	r0, r3
   18544:	4b16      	ldr	r3, [pc, #88]	; (185a0 <xTaskResumeAll+0x108>)
   18546:	0029      	movs	r1, r5
   18548:	1818      	adds	r0, r3, r0
   1854a:	4b16      	ldr	r3, [pc, #88]	; (185a4 <xTaskResumeAll+0x10c>)
   1854c:	4798      	blx	r3
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1854e:	4b16      	ldr	r3, [pc, #88]	; (185a8 <xTaskResumeAll+0x110>)
   18550:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   18552:	681b      	ldr	r3, [r3, #0]
   18554:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   18556:	429a      	cmp	r2, r3
   18558:	d3b7      	bcc.n	184ca <xTaskResumeAll+0x32>
						xYieldPending = pdTRUE;
   1855a:	4b09      	ldr	r3, [pc, #36]	; (18580 <xTaskResumeAll+0xe8>)
   1855c:	601f      	str	r7, [r3, #0]
   1855e:	e7b4      	b.n	184ca <xTaskResumeAll+0x32>
   18560:	20003c34 	.word	0x20003c34
   18564:	00016df1 	.word	0x00016df1
   18568:	00016e09 	.word	0x00016e09
   1856c:	20003c28 	.word	0x20003c28
   18570:	20003c74 	.word	0x20003c74
   18574:	00017f25 	.word	0x00017f25
   18578:	20003c30 	.word	0x20003c30
   1857c:	0001832d 	.word	0x0001832d
   18580:	20003cb8 	.word	0x20003cb8
   18584:	00016de1 	.word	0x00016de1
   18588:	00016cc7 	.word	0x00016cc7
   1858c:	00015c21 	.word	0x00015c21
   18590:	200001f0 	.word	0x200001f0
   18594:	00015c11 	.word	0x00015c11
   18598:	00016755 	.word	0x00016755
   1859c:	20003c3c 	.word	0x20003c3c
   185a0:	20003bc4 	.word	0x20003bc4
   185a4:	00016c81 	.word	0x00016c81
   185a8:	20003bb8 	.word	0x20003bb8

000185ac <vTaskDelay>:
	{
   185ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   185ae:	1e04      	subs	r4, r0, #0
		if( xTicksToDelay > ( TickType_t ) 0U )
   185b0:	d102      	bne.n	185b8 <vTaskDelay+0xc>
			portYIELD_WITHIN_API();
   185b2:	4b19      	ldr	r3, [pc, #100]	; (18618 <vTaskDelay+0x6c>)
   185b4:	4798      	blx	r3
	}
   185b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			configASSERT( uxSchedulerSuspended == 0 );
   185b8:	4b18      	ldr	r3, [pc, #96]	; (1861c <vTaskDelay+0x70>)
   185ba:	681b      	ldr	r3, [r3, #0]
   185bc:	2b00      	cmp	r3, #0
   185be:	d001      	beq.n	185c4 <vTaskDelay+0x18>
   185c0:	b672      	cpsid	i
   185c2:	e7fe      	b.n	185c2 <vTaskDelay+0x16>
			vTaskSuspendAll();
   185c4:	4b16      	ldr	r3, [pc, #88]	; (18620 <vTaskDelay+0x74>)
   185c6:	4798      	blx	r3
				traceTASK_DELAY();
   185c8:	4f16      	ldr	r7, [pc, #88]	; (18624 <vTaskDelay+0x78>)
   185ca:	4e17      	ldr	r6, [pc, #92]	; (18628 <vTaskDelay+0x7c>)
   185cc:	6838      	ldr	r0, [r7, #0]
   185ce:	47b0      	blx	r6
   185d0:	4d16      	ldr	r5, [pc, #88]	; (1862c <vTaskDelay+0x80>)
   185d2:	882b      	ldrh	r3, [r5, #0]
   185d4:	4203      	tst	r3, r0
   185d6:	d009      	beq.n	185ec <vTaskDelay+0x40>
   185d8:	0021      	movs	r1, r4
   185da:	2089      	movs	r0, #137	; 0x89
   185dc:	4b14      	ldr	r3, [pc, #80]	; (18630 <vTaskDelay+0x84>)
   185de:	4798      	blx	r3
   185e0:	4b14      	ldr	r3, [pc, #80]	; (18634 <vTaskDelay+0x88>)
   185e2:	6838      	ldr	r0, [r7, #0]
   185e4:	4798      	blx	r3
   185e6:	4b14      	ldr	r3, [pc, #80]	; (18638 <vTaskDelay+0x8c>)
   185e8:	b2c0      	uxtb	r0, r0
   185ea:	4798      	blx	r3
   185ec:	4f13      	ldr	r7, [pc, #76]	; (1863c <vTaskDelay+0x90>)
   185ee:	47b8      	blx	r7
   185f0:	47b0      	blx	r6
   185f2:	882b      	ldrh	r3, [r5, #0]
   185f4:	4203      	tst	r3, r0
   185f6:	d005      	beq.n	18604 <vTaskDelay+0x58>
   185f8:	47b8      	blx	r7
   185fa:	4b0e      	ldr	r3, [pc, #56]	; (18634 <vTaskDelay+0x88>)
   185fc:	4798      	blx	r3
   185fe:	4b0e      	ldr	r3, [pc, #56]	; (18638 <vTaskDelay+0x8c>)
   18600:	b2c0      	uxtb	r0, r0
   18602:	4798      	blx	r3
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
   18604:	4b0e      	ldr	r3, [pc, #56]	; (18640 <vTaskDelay+0x94>)
   18606:	2100      	movs	r1, #0
   18608:	0020      	movs	r0, r4
   1860a:	4798      	blx	r3
			xAlreadyYielded = xTaskResumeAll();
   1860c:	4b0d      	ldr	r3, [pc, #52]	; (18644 <vTaskDelay+0x98>)
   1860e:	4798      	blx	r3
		if( xAlreadyYielded == pdFALSE )
   18610:	2800      	cmp	r0, #0
   18612:	d1d0      	bne.n	185b6 <vTaskDelay+0xa>
   18614:	e7cd      	b.n	185b2 <vTaskDelay+0x6>
   18616:	46c0      	nop			; (mov r8, r8)
   18618:	00016de1 	.word	0x00016de1
   1861c:	20003c34 	.word	0x20003c34
   18620:	00018311 	.word	0x00018311
   18624:	20003bb8 	.word	0x20003bb8
   18628:	00015c21 	.word	0x00015c21
   1862c:	200001f0 	.word	0x200001f0
   18630:	00016a29 	.word	0x00016a29
   18634:	00015c11 	.word	0x00015c11
   18638:	00016419 	.word	0x00016419
   1863c:	00015d9d 	.word	0x00015d9d
   18640:	00017f4d 	.word	0x00017f4d
   18644:	00018499 	.word	0x00018499

00018648 <vTaskSwitchContext>:
{
   18648:	b570      	push	{r4, r5, r6, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   1864a:	4b24      	ldr	r3, [pc, #144]	; (186dc <vTaskSwitchContext+0x94>)
   1864c:	681a      	ldr	r2, [r3, #0]
   1864e:	4b24      	ldr	r3, [pc, #144]	; (186e0 <vTaskSwitchContext+0x98>)
   18650:	2a00      	cmp	r2, #0
   18652:	d002      	beq.n	1865a <vTaskSwitchContext+0x12>
		xYieldPending = pdTRUE;
   18654:	2201      	movs	r2, #1
   18656:	601a      	str	r2, [r3, #0]
}
   18658:	bd70      	pop	{r4, r5, r6, pc}
		taskCHECK_FOR_STACK_OVERFLOW();
   1865a:	4c22      	ldr	r4, [pc, #136]	; (186e4 <vTaskSwitchContext+0x9c>)
		xYieldPending = pdFALSE;
   1865c:	601a      	str	r2, [r3, #0]
		taskCHECK_FOR_STACK_OVERFLOW();
   1865e:	6822      	ldr	r2, [r4, #0]
   18660:	6823      	ldr	r3, [r4, #0]
   18662:	6812      	ldr	r2, [r2, #0]
   18664:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   18666:	429a      	cmp	r2, r3
   18668:	d804      	bhi.n	18674 <vTaskSwitchContext+0x2c>
   1866a:	6820      	ldr	r0, [r4, #0]
   1866c:	6821      	ldr	r1, [r4, #0]
   1866e:	4b1e      	ldr	r3, [pc, #120]	; (186e8 <vTaskSwitchContext+0xa0>)
   18670:	3134      	adds	r1, #52	; 0x34
   18672:	4798      	blx	r3
		taskSELECT_HIGHEST_PRIORITY_TASK();
   18674:	2614      	movs	r6, #20
   18676:	481d      	ldr	r0, [pc, #116]	; (186ec <vTaskSwitchContext+0xa4>)
   18678:	491d      	ldr	r1, [pc, #116]	; (186f0 <vTaskSwitchContext+0xa8>)
   1867a:	6802      	ldr	r2, [r0, #0]
   1867c:	0033      	movs	r3, r6
   1867e:	4353      	muls	r3, r2
   18680:	585d      	ldr	r5, [r3, r1]
   18682:	2d00      	cmp	r5, #0
   18684:	d024      	beq.n	186d0 <vTaskSwitchContext+0x88>
   18686:	18cd      	adds	r5, r1, r3
   18688:	686e      	ldr	r6, [r5, #4]
   1868a:	3308      	adds	r3, #8
   1868c:	6876      	ldr	r6, [r6, #4]
   1868e:	18cb      	adds	r3, r1, r3
   18690:	606e      	str	r6, [r5, #4]
   18692:	429e      	cmp	r6, r3
   18694:	d101      	bne.n	1869a <vTaskSwitchContext+0x52>
   18696:	6873      	ldr	r3, [r6, #4]
   18698:	606b      	str	r3, [r5, #4]
   1869a:	2314      	movs	r3, #20
   1869c:	4353      	muls	r3, r2
   1869e:	18c9      	adds	r1, r1, r3
   186a0:	684b      	ldr	r3, [r1, #4]
		traceTASK_SWITCHED_IN();
   186a2:	4d14      	ldr	r5, [pc, #80]	; (186f4 <vTaskSwitchContext+0xac>)
		taskSELECT_HIGHEST_PRIORITY_TASK();
   186a4:	68db      	ldr	r3, [r3, #12]
   186a6:	6023      	str	r3, [r4, #0]
		traceTASK_SWITCHED_IN();
   186a8:	2301      	movs	r3, #1
   186aa:	4c13      	ldr	r4, [pc, #76]	; (186f8 <vTaskSwitchContext+0xb0>)
		taskSELECT_HIGHEST_PRIORITY_TASK();
   186ac:	6002      	str	r2, [r0, #0]
		traceTASK_SWITCHED_IN();
   186ae:	6023      	str	r3, [r4, #0]
   186b0:	47a8      	blx	r5
   186b2:	4b12      	ldr	r3, [pc, #72]	; (186fc <vTaskSwitchContext+0xb4>)
   186b4:	4798      	blx	r3
   186b6:	4b12      	ldr	r3, [pc, #72]	; (18700 <vTaskSwitchContext+0xb8>)
   186b8:	881b      	ldrh	r3, [r3, #0]
   186ba:	4203      	tst	r3, r0
   186bc:	d005      	beq.n	186ca <vTaskSwitchContext+0x82>
   186be:	47a8      	blx	r5
   186c0:	4b10      	ldr	r3, [pc, #64]	; (18704 <vTaskSwitchContext+0xbc>)
   186c2:	4798      	blx	r3
   186c4:	4b10      	ldr	r3, [pc, #64]	; (18708 <vTaskSwitchContext+0xc0>)
   186c6:	b2c0      	uxtb	r0, r0
   186c8:	4798      	blx	r3
   186ca:	2302      	movs	r3, #2
   186cc:	6023      	str	r3, [r4, #0]
}
   186ce:	e7c3      	b.n	18658 <vTaskSwitchContext+0x10>
		taskSELECT_HIGHEST_PRIORITY_TASK();
   186d0:	2a00      	cmp	r2, #0
   186d2:	d101      	bne.n	186d8 <vTaskSwitchContext+0x90>
   186d4:	b672      	cpsid	i
   186d6:	e7fe      	b.n	186d6 <vTaskSwitchContext+0x8e>
   186d8:	3a01      	subs	r2, #1
   186da:	e7cf      	b.n	1867c <vTaskSwitchContext+0x34>
   186dc:	20003c34 	.word	0x20003c34
   186e0:	20003cb8 	.word	0x20003cb8
   186e4:	20003bb8 	.word	0x20003bb8
   186e8:	00022b81 	.word	0x00022b81
   186ec:	20003c3c 	.word	0x20003c3c
   186f0:	20003bc4 	.word	0x20003bc4
   186f4:	00015d9d 	.word	0x00015d9d
   186f8:	20000cc4 	.word	0x20000cc4
   186fc:	00015c21 	.word	0x00015c21
   18700:	200001f0 	.word	0x200001f0
   18704:	00015c11 	.word	0x00015c11
   18708:	00016acd 	.word	0x00016acd

0001870c <vTaskSuspend>:
	{
   1870c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		taskENTER_CRITICAL();
   1870e:	4b2e      	ldr	r3, [pc, #184]	; (187c8 <vTaskSuspend+0xbc>)
	{
   18710:	0004      	movs	r4, r0
		taskENTER_CRITICAL();
   18712:	4798      	blx	r3
   18714:	4d2d      	ldr	r5, [pc, #180]	; (187cc <vTaskSuspend+0xc0>)
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
   18716:	2c00      	cmp	r4, #0
   18718:	d100      	bne.n	1871c <vTaskSuspend+0x10>
   1871a:	682c      	ldr	r4, [r5, #0]
			traceTASK_SUSPEND( pxTCB );
   1871c:	4b2c      	ldr	r3, [pc, #176]	; (187d0 <vTaskSuspend+0xc4>)
   1871e:	4798      	blx	r3
   18720:	4f2c      	ldr	r7, [pc, #176]	; (187d4 <vTaskSuspend+0xc8>)
   18722:	47b8      	blx	r7
   18724:	4e2c      	ldr	r6, [pc, #176]	; (187d8 <vTaskSuspend+0xcc>)
   18726:	8833      	ldrh	r3, [r6, #0]
   18728:	4203      	tst	r3, r0
   1872a:	d00c      	beq.n	18746 <vTaskSuspend+0x3a>
   1872c:	0020      	movs	r0, r4
   1872e:	47b8      	blx	r7
   18730:	8833      	ldrh	r3, [r6, #0]
   18732:	4203      	tst	r3, r0
   18734:	d007      	beq.n	18746 <vTaskSuspend+0x3a>
   18736:	4b29      	ldr	r3, [pc, #164]	; (187dc <vTaskSuspend+0xd0>)
   18738:	0020      	movs	r0, r4
   1873a:	4798      	blx	r3
   1873c:	2103      	movs	r1, #3
   1873e:	b2c2      	uxtb	r2, r0
   18740:	4b27      	ldr	r3, [pc, #156]	; (187e0 <vTaskSuspend+0xd4>)
   18742:	208a      	movs	r0, #138	; 0x8a
   18744:	4798      	blx	r3
   18746:	4b25      	ldr	r3, [pc, #148]	; (187dc <vTaskSuspend+0xd0>)
   18748:	0020      	movs	r0, r4
   1874a:	4798      	blx	r3
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   1874c:	1d27      	adds	r7, r4, #4
			traceTASK_SUSPEND( pxTCB );
   1874e:	4b25      	ldr	r3, [pc, #148]	; (187e4 <vTaskSuspend+0xd8>)
   18750:	b2c0      	uxtb	r0, r0
   18752:	4798      	blx	r3
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   18754:	0038      	movs	r0, r7
   18756:	4e24      	ldr	r6, [pc, #144]	; (187e8 <vTaskSuspend+0xdc>)
   18758:	47b0      	blx	r6
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   1875a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1875c:	2b00      	cmp	r3, #0
   1875e:	d002      	beq.n	18766 <vTaskSuspend+0x5a>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   18760:	0020      	movs	r0, r4
   18762:	3018      	adds	r0, #24
   18764:	47b0      	blx	r6
			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
   18766:	4e21      	ldr	r6, [pc, #132]	; (187ec <vTaskSuspend+0xe0>)
   18768:	4b21      	ldr	r3, [pc, #132]	; (187f0 <vTaskSuspend+0xe4>)
   1876a:	0039      	movs	r1, r7
   1876c:	0030      	movs	r0, r6
   1876e:	4798      	blx	r3
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
   18770:	0023      	movs	r3, r4
   18772:	3350      	adds	r3, #80	; 0x50
   18774:	781a      	ldrb	r2, [r3, #0]
   18776:	2a01      	cmp	r2, #1
   18778:	d101      	bne.n	1877e <vTaskSuspend+0x72>
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   1877a:	2200      	movs	r2, #0
   1877c:	701a      	strb	r2, [r3, #0]
		taskEXIT_CRITICAL();
   1877e:	4b1d      	ldr	r3, [pc, #116]	; (187f4 <vTaskSuspend+0xe8>)
   18780:	4798      	blx	r3
		if( xSchedulerRunning != pdFALSE )
   18782:	4f1d      	ldr	r7, [pc, #116]	; (187f8 <vTaskSuspend+0xec>)
   18784:	683b      	ldr	r3, [r7, #0]
   18786:	2b00      	cmp	r3, #0
   18788:	d005      	beq.n	18796 <vTaskSuspend+0x8a>
			taskENTER_CRITICAL();
   1878a:	4b0f      	ldr	r3, [pc, #60]	; (187c8 <vTaskSuspend+0xbc>)
   1878c:	4798      	blx	r3
				prvResetNextTaskUnblockTime();
   1878e:	4b1b      	ldr	r3, [pc, #108]	; (187fc <vTaskSuspend+0xf0>)
   18790:	4798      	blx	r3
			taskEXIT_CRITICAL();
   18792:	4b18      	ldr	r3, [pc, #96]	; (187f4 <vTaskSuspend+0xe8>)
   18794:	4798      	blx	r3
		if( pxTCB == pxCurrentTCB )
   18796:	682b      	ldr	r3, [r5, #0]
   18798:	429c      	cmp	r4, r3
   1879a:	d10a      	bne.n	187b2 <vTaskSuspend+0xa6>
			if( xSchedulerRunning != pdFALSE )
   1879c:	683b      	ldr	r3, [r7, #0]
   1879e:	2b00      	cmp	r3, #0
   187a0:	d008      	beq.n	187b4 <vTaskSuspend+0xa8>
				configASSERT( uxSchedulerSuspended == 0 );
   187a2:	4b17      	ldr	r3, [pc, #92]	; (18800 <vTaskSuspend+0xf4>)
   187a4:	681b      	ldr	r3, [r3, #0]
   187a6:	2b00      	cmp	r3, #0
   187a8:	d001      	beq.n	187ae <vTaskSuspend+0xa2>
   187aa:	b672      	cpsid	i
   187ac:	e7fe      	b.n	187ac <vTaskSuspend+0xa0>
				portYIELD_WITHIN_API();
   187ae:	4b15      	ldr	r3, [pc, #84]	; (18804 <vTaskSuspend+0xf8>)
   187b0:	4798      	blx	r3
	}
   187b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
   187b4:	4a14      	ldr	r2, [pc, #80]	; (18808 <vTaskSuspend+0xfc>)
   187b6:	6831      	ldr	r1, [r6, #0]
   187b8:	6812      	ldr	r2, [r2, #0]
   187ba:	4291      	cmp	r1, r2
   187bc:	d101      	bne.n	187c2 <vTaskSuspend+0xb6>
					pxCurrentTCB = NULL;
   187be:	602b      	str	r3, [r5, #0]
   187c0:	e7f7      	b.n	187b2 <vTaskSuspend+0xa6>
					vTaskSwitchContext();
   187c2:	4b12      	ldr	r3, [pc, #72]	; (1880c <vTaskSuspend+0x100>)
   187c4:	4798      	blx	r3
	}
   187c6:	e7f4      	b.n	187b2 <vTaskSuspend+0xa6>
   187c8:	00016df1 	.word	0x00016df1
   187cc:	20003bb8 	.word	0x20003bb8
   187d0:	00015d9d 	.word	0x00015d9d
   187d4:	00015c21 	.word	0x00015c21
   187d8:	200001f0 	.word	0x200001f0
   187dc:	00015c11 	.word	0x00015c11
   187e0:	000168b9 	.word	0x000168b9
   187e4:	00016419 	.word	0x00016419
   187e8:	00016cc7 	.word	0x00016cc7
   187ec:	20003c8c 	.word	0x20003c8c
   187f0:	00016c81 	.word	0x00016c81
   187f4:	00016e09 	.word	0x00016e09
   187f8:	20003c88 	.word	0x20003c88
   187fc:	00017f25 	.word	0x00017f25
   18800:	20003c34 	.word	0x20003c34
   18804:	00016de1 	.word	0x00016de1
   18808:	20003c28 	.word	0x20003c28
   1880c:	00018649 	.word	0x00018649

00018810 <vTaskPlaceOnEventList>:
{
   18810:	b510      	push	{r4, lr}
   18812:	000c      	movs	r4, r1
	configASSERT( pxEventList );
   18814:	2800      	cmp	r0, #0
   18816:	d101      	bne.n	1881c <vTaskPlaceOnEventList+0xc>
   18818:	b672      	cpsid	i
   1881a:	e7fe      	b.n	1881a <vTaskPlaceOnEventList+0xa>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   1881c:	4b04      	ldr	r3, [pc, #16]	; (18830 <vTaskPlaceOnEventList+0x20>)
   1881e:	6819      	ldr	r1, [r3, #0]
   18820:	4b04      	ldr	r3, [pc, #16]	; (18834 <vTaskPlaceOnEventList+0x24>)
   18822:	3118      	adds	r1, #24
   18824:	4798      	blx	r3
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   18826:	2101      	movs	r1, #1
   18828:	0020      	movs	r0, r4
   1882a:	4b03      	ldr	r3, [pc, #12]	; (18838 <vTaskPlaceOnEventList+0x28>)
   1882c:	4798      	blx	r3
}
   1882e:	bd10      	pop	{r4, pc}
   18830:	20003bb8 	.word	0x20003bb8
   18834:	00016c99 	.word	0x00016c99
   18838:	00017f4d 	.word	0x00017f4d

0001883c <vTaskPlaceOnEventListRestricted>:
	{
   1883c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1883e:	000c      	movs	r4, r1
   18840:	0016      	movs	r6, r2
		configASSERT( pxEventList );
   18842:	2800      	cmp	r0, #0
   18844:	d101      	bne.n	1884a <vTaskPlaceOnEventListRestricted+0xe>
   18846:	b672      	cpsid	i
   18848:	e7fe      	b.n	18848 <vTaskPlaceOnEventListRestricted+0xc>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   1884a:	4d17      	ldr	r5, [pc, #92]	; (188a8 <vTaskPlaceOnEventListRestricted+0x6c>)
   1884c:	4b17      	ldr	r3, [pc, #92]	; (188ac <vTaskPlaceOnEventListRestricted+0x70>)
   1884e:	6829      	ldr	r1, [r5, #0]
   18850:	3118      	adds	r1, #24
   18852:	4798      	blx	r3
		if( xWaitIndefinitely != pdFALSE )
   18854:	2e00      	cmp	r6, #0
   18856:	d001      	beq.n	1885c <vTaskPlaceOnEventListRestricted+0x20>
			xTicksToWait = portMAX_DELAY;
   18858:	2401      	movs	r4, #1
   1885a:	4264      	negs	r4, r4
		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
   1885c:	6828      	ldr	r0, [r5, #0]
   1885e:	4f14      	ldr	r7, [pc, #80]	; (188b0 <vTaskPlaceOnEventListRestricted+0x74>)
   18860:	47b8      	blx	r7
   18862:	4b14      	ldr	r3, [pc, #80]	; (188b4 <vTaskPlaceOnEventListRestricted+0x78>)
   18864:	881b      	ldrh	r3, [r3, #0]
   18866:	4203      	tst	r3, r0
   18868:	d00b      	beq.n	18882 <vTaskPlaceOnEventListRestricted+0x46>
   1886a:	4b13      	ldr	r3, [pc, #76]	; (188b8 <vTaskPlaceOnEventListRestricted+0x7c>)
   1886c:	2088      	movs	r0, #136	; 0x88
   1886e:	6819      	ldr	r1, [r3, #0]
   18870:	4b12      	ldr	r3, [pc, #72]	; (188bc <vTaskPlaceOnEventListRestricted+0x80>)
   18872:	1861      	adds	r1, r4, r1
   18874:	4798      	blx	r3
   18876:	4b12      	ldr	r3, [pc, #72]	; (188c0 <vTaskPlaceOnEventListRestricted+0x84>)
   18878:	6828      	ldr	r0, [r5, #0]
   1887a:	4798      	blx	r3
   1887c:	4b11      	ldr	r3, [pc, #68]	; (188c4 <vTaskPlaceOnEventListRestricted+0x88>)
   1887e:	b2c0      	uxtb	r0, r0
   18880:	4798      	blx	r3
   18882:	4d11      	ldr	r5, [pc, #68]	; (188c8 <vTaskPlaceOnEventListRestricted+0x8c>)
   18884:	47a8      	blx	r5
   18886:	47b8      	blx	r7
   18888:	4b0a      	ldr	r3, [pc, #40]	; (188b4 <vTaskPlaceOnEventListRestricted+0x78>)
   1888a:	881b      	ldrh	r3, [r3, #0]
   1888c:	4203      	tst	r3, r0
   1888e:	d005      	beq.n	1889c <vTaskPlaceOnEventListRestricted+0x60>
   18890:	47a8      	blx	r5
   18892:	4b0b      	ldr	r3, [pc, #44]	; (188c0 <vTaskPlaceOnEventListRestricted+0x84>)
   18894:	4798      	blx	r3
   18896:	4b0b      	ldr	r3, [pc, #44]	; (188c4 <vTaskPlaceOnEventListRestricted+0x88>)
   18898:	b2c0      	uxtb	r0, r0
   1889a:	4798      	blx	r3
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
   1889c:	0031      	movs	r1, r6
   1889e:	0020      	movs	r0, r4
   188a0:	4b0a      	ldr	r3, [pc, #40]	; (188cc <vTaskPlaceOnEventListRestricted+0x90>)
   188a2:	4798      	blx	r3
	}
   188a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   188a6:	46c0      	nop			; (mov r8, r8)
   188a8:	20003bb8 	.word	0x20003bb8
   188ac:	00016c81 	.word	0x00016c81
   188b0:	00015c21 	.word	0x00015c21
   188b4:	200001f0 	.word	0x200001f0
   188b8:	20003cb4 	.word	0x20003cb4
   188bc:	00016a29 	.word	0x00016a29
   188c0:	00015c11 	.word	0x00015c11
   188c4:	00016419 	.word	0x00016419
   188c8:	00015d9d 	.word	0x00015d9d
   188cc:	00017f4d 	.word	0x00017f4d

000188d0 <xTaskRemoveFromEventList>:
{
   188d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   188d2:	68c3      	ldr	r3, [r0, #12]
   188d4:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
   188d6:	2c00      	cmp	r4, #0
   188d8:	d101      	bne.n	188de <xTaskRemoveFromEventList+0xe>
   188da:	b672      	cpsid	i
   188dc:	e7fe      	b.n	188dc <xTaskRemoveFromEventList+0xc>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   188de:	0026      	movs	r6, r4
   188e0:	3618      	adds	r6, #24
   188e2:	0030      	movs	r0, r6
   188e4:	4f18      	ldr	r7, [pc, #96]	; (18948 <xTaskRemoveFromEventList+0x78>)
   188e6:	47b8      	blx	r7
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   188e8:	4b18      	ldr	r3, [pc, #96]	; (1894c <xTaskRemoveFromEventList+0x7c>)
   188ea:	4d19      	ldr	r5, [pc, #100]	; (18950 <xTaskRemoveFromEventList+0x80>)
   188ec:	681b      	ldr	r3, [r3, #0]
   188ee:	2b00      	cmp	r3, #0
   188f0:	d126      	bne.n	18940 <xTaskRemoveFromEventList+0x70>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   188f2:	1d26      	adds	r6, r4, #4
   188f4:	0030      	movs	r0, r6
   188f6:	47b8      	blx	r7
		prvAddTaskToReadyList( pxUnblockedTCB );
   188f8:	4b16      	ldr	r3, [pc, #88]	; (18954 <xTaskRemoveFromEventList+0x84>)
   188fa:	0020      	movs	r0, r4
   188fc:	4798      	blx	r3
   188fe:	4b16      	ldr	r3, [pc, #88]	; (18958 <xTaskRemoveFromEventList+0x88>)
   18900:	881b      	ldrh	r3, [r3, #0]
   18902:	4203      	tst	r3, r0
   18904:	d005      	beq.n	18912 <xTaskRemoveFromEventList+0x42>
   18906:	4b15      	ldr	r3, [pc, #84]	; (1895c <xTaskRemoveFromEventList+0x8c>)
   18908:	0020      	movs	r0, r4
   1890a:	4798      	blx	r3
   1890c:	4b14      	ldr	r3, [pc, #80]	; (18960 <xTaskRemoveFromEventList+0x90>)
   1890e:	b2c0      	uxtb	r0, r0
   18910:	4798      	blx	r3
   18912:	4a14      	ldr	r2, [pc, #80]	; (18964 <xTaskRemoveFromEventList+0x94>)
   18914:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   18916:	6811      	ldr	r1, [r2, #0]
   18918:	428b      	cmp	r3, r1
   1891a:	d900      	bls.n	1891e <xTaskRemoveFromEventList+0x4e>
   1891c:	6013      	str	r3, [r2, #0]
   1891e:	2014      	movs	r0, #20
   18920:	0031      	movs	r1, r6
   18922:	4343      	muls	r3, r0
   18924:	4810      	ldr	r0, [pc, #64]	; (18968 <xTaskRemoveFromEventList+0x98>)
   18926:	18c0      	adds	r0, r0, r3
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   18928:	47a8      	blx	r5
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   1892a:	4b10      	ldr	r3, [pc, #64]	; (1896c <xTaskRemoveFromEventList+0x9c>)
   1892c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   1892e:	681b      	ldr	r3, [r3, #0]
		xReturn = pdFALSE;
   18930:	2000      	movs	r0, #0
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   18932:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   18934:	429a      	cmp	r2, r3
   18936:	d902      	bls.n	1893e <xTaskRemoveFromEventList+0x6e>
		xYieldPending = pdTRUE;
   18938:	4b0d      	ldr	r3, [pc, #52]	; (18970 <xTaskRemoveFromEventList+0xa0>)
   1893a:	3001      	adds	r0, #1
   1893c:	6018      	str	r0, [r3, #0]
}
   1893e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   18940:	0031      	movs	r1, r6
   18942:	480c      	ldr	r0, [pc, #48]	; (18974 <xTaskRemoveFromEventList+0xa4>)
   18944:	e7f0      	b.n	18928 <xTaskRemoveFromEventList+0x58>
   18946:	46c0      	nop			; (mov r8, r8)
   18948:	00016cc7 	.word	0x00016cc7
   1894c:	20003c34 	.word	0x20003c34
   18950:	00016c81 	.word	0x00016c81
   18954:	00015c21 	.word	0x00015c21
   18958:	200001f0 	.word	0x200001f0
   1895c:	00015c11 	.word	0x00015c11
   18960:	00016755 	.word	0x00016755
   18964:	20003c3c 	.word	0x20003c3c
   18968:	20003bc4 	.word	0x20003bc4
   1896c:	20003bb8 	.word	0x20003bb8
   18970:	20003cb8 	.word	0x20003cb8
   18974:	20003c74 	.word	0x20003c74

00018978 <vTaskSetTimeOutState>:
{
   18978:	b510      	push	{r4, lr}
   1897a:	1e04      	subs	r4, r0, #0
	configASSERT( pxTimeOut );
   1897c:	d101      	bne.n	18982 <vTaskSetTimeOutState+0xa>
   1897e:	b672      	cpsid	i
   18980:	e7fe      	b.n	18980 <vTaskSetTimeOutState+0x8>
	taskENTER_CRITICAL();
   18982:	4b05      	ldr	r3, [pc, #20]	; (18998 <vTaskSetTimeOutState+0x20>)
   18984:	4798      	blx	r3
		pxTimeOut->xOverflowCount = xNumOfOverflows;
   18986:	4b05      	ldr	r3, [pc, #20]	; (1899c <vTaskSetTimeOutState+0x24>)
   18988:	681b      	ldr	r3, [r3, #0]
   1898a:	6023      	str	r3, [r4, #0]
		pxTimeOut->xTimeOnEntering = xTickCount;
   1898c:	4b04      	ldr	r3, [pc, #16]	; (189a0 <vTaskSetTimeOutState+0x28>)
   1898e:	681b      	ldr	r3, [r3, #0]
   18990:	6063      	str	r3, [r4, #4]
	taskEXIT_CRITICAL();
   18992:	4b04      	ldr	r3, [pc, #16]	; (189a4 <vTaskSetTimeOutState+0x2c>)
   18994:	4798      	blx	r3
}
   18996:	bd10      	pop	{r4, pc}
   18998:	00016df1 	.word	0x00016df1
   1899c:	20003c70 	.word	0x20003c70
   189a0:	20003cb4 	.word	0x20003cb4
   189a4:	00016e09 	.word	0x00016e09

000189a8 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
   189a8:	4b03      	ldr	r3, [pc, #12]	; (189b8 <vTaskInternalSetTimeOutState+0x10>)
   189aa:	681b      	ldr	r3, [r3, #0]
   189ac:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
   189ae:	4b03      	ldr	r3, [pc, #12]	; (189bc <vTaskInternalSetTimeOutState+0x14>)
   189b0:	681b      	ldr	r3, [r3, #0]
   189b2:	6043      	str	r3, [r0, #4]
}
   189b4:	4770      	bx	lr
   189b6:	46c0      	nop			; (mov r8, r8)
   189b8:	20003c70 	.word	0x20003c70
   189bc:	20003cb4 	.word	0x20003cb4

000189c0 <xTaskCheckForTimeOut>:
{
   189c0:	b570      	push	{r4, r5, r6, lr}
   189c2:	0005      	movs	r5, r0
   189c4:	000c      	movs	r4, r1
	configASSERT( pxTimeOut );
   189c6:	2800      	cmp	r0, #0
   189c8:	d101      	bne.n	189ce <xTaskCheckForTimeOut+0xe>
   189ca:	b672      	cpsid	i
   189cc:	e7fe      	b.n	189cc <xTaskCheckForTimeOut+0xc>
	configASSERT( pxTicksToWait );
   189ce:	2900      	cmp	r1, #0
   189d0:	d101      	bne.n	189d6 <xTaskCheckForTimeOut+0x16>
   189d2:	b672      	cpsid	i
   189d4:	e7fe      	b.n	189d4 <xTaskCheckForTimeOut+0x14>
	taskENTER_CRITICAL();
   189d6:	4b11      	ldr	r3, [pc, #68]	; (18a1c <xTaskCheckForTimeOut+0x5c>)
   189d8:	4798      	blx	r3
		const TickType_t xConstTickCount = xTickCount;
   189da:	4b11      	ldr	r3, [pc, #68]	; (18a20 <xTaskCheckForTimeOut+0x60>)
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
   189dc:	6869      	ldr	r1, [r5, #4]
		const TickType_t xConstTickCount = xTickCount;
   189de:	681a      	ldr	r2, [r3, #0]
			if( *pxTicksToWait == portMAX_DELAY )
   189e0:	6823      	ldr	r3, [r4, #0]
				xReturn = pdFALSE;
   189e2:	2600      	movs	r6, #0
			if( *pxTicksToWait == portMAX_DELAY )
   189e4:	1c58      	adds	r0, r3, #1
   189e6:	d010      	beq.n	18a0a <xTaskCheckForTimeOut+0x4a>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   189e8:	480e      	ldr	r0, [pc, #56]	; (18a24 <xTaskCheckForTimeOut+0x64>)
   189ea:	682e      	ldr	r6, [r5, #0]
   189ec:	6800      	ldr	r0, [r0, #0]
   189ee:	4286      	cmp	r6, r0
   189f0:	d002      	beq.n	189f8 <xTaskCheckForTimeOut+0x38>
			xReturn = pdTRUE;
   189f2:	2601      	movs	r6, #1
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   189f4:	428a      	cmp	r2, r1
   189f6:	d208      	bcs.n	18a0a <xTaskCheckForTimeOut+0x4a>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
   189f8:	1a52      	subs	r2, r2, r1
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
   189fa:	429a      	cmp	r2, r3
   189fc:	d209      	bcs.n	18a12 <xTaskCheckForTimeOut+0x52>
			*pxTicksToWait -= xElapsedTime;
   189fe:	1a9b      	subs	r3, r3, r2
   18a00:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
   18a02:	0028      	movs	r0, r5
   18a04:	4b08      	ldr	r3, [pc, #32]	; (18a28 <xTaskCheckForTimeOut+0x68>)
   18a06:	4798      	blx	r3
			xReturn = pdFALSE;
   18a08:	2600      	movs	r6, #0
	taskEXIT_CRITICAL();
   18a0a:	4b08      	ldr	r3, [pc, #32]	; (18a2c <xTaskCheckForTimeOut+0x6c>)
   18a0c:	4798      	blx	r3
}
   18a0e:	0030      	movs	r0, r6
   18a10:	bd70      	pop	{r4, r5, r6, pc}
			*pxTicksToWait = 0;
   18a12:	2300      	movs	r3, #0
			xReturn = pdTRUE;
   18a14:	2601      	movs	r6, #1
			*pxTicksToWait = 0;
   18a16:	6023      	str	r3, [r4, #0]
   18a18:	e7f7      	b.n	18a0a <xTaskCheckForTimeOut+0x4a>
   18a1a:	46c0      	nop			; (mov r8, r8)
   18a1c:	00016df1 	.word	0x00016df1
   18a20:	20003cb4 	.word	0x20003cb4
   18a24:	20003c70 	.word	0x20003c70
   18a28:	000189a9 	.word	0x000189a9
   18a2c:	00016e09 	.word	0x00016e09

00018a30 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
   18a30:	2201      	movs	r2, #1
   18a32:	4b01      	ldr	r3, [pc, #4]	; (18a38 <vTaskMissedYield+0x8>)
   18a34:	601a      	str	r2, [r3, #0]
}
   18a36:	4770      	bx	lr
   18a38:	20003cb8 	.word	0x20003cb8

00018a3c <uxTaskGetTaskNumber>:
		if( xTask != NULL )
   18a3c:	2800      	cmp	r0, #0
   18a3e:	d000      	beq.n	18a42 <uxTaskGetTaskNumber+0x6>
			uxReturn = pxTCB->uxTaskNumber;
   18a40:	6c00      	ldr	r0, [r0, #64]	; 0x40
	}
   18a42:	4770      	bx	lr

00018a44 <vTaskSetTaskNumber>:
		if( xTask != NULL )
   18a44:	2800      	cmp	r0, #0
   18a46:	d000      	beq.n	18a4a <vTaskSetTaskNumber+0x6>
			pxTCB->uxTaskNumber = uxHandle;
   18a48:	6401      	str	r1, [r0, #64]	; 0x40
	}
   18a4a:	4770      	bx	lr

00018a4c <uxTaskGetStackHighWaterMark>:
		pxTCB = prvGetTCBFromHandle( xTask );
   18a4c:	2800      	cmp	r0, #0
   18a4e:	d101      	bne.n	18a54 <uxTaskGetStackHighWaterMark+0x8>
   18a50:	4b06      	ldr	r3, [pc, #24]	; (18a6c <uxTaskGetStackHighWaterMark+0x20>)
   18a52:	6818      	ldr	r0, [r3, #0]
			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
   18a54:	6b02      	ldr	r2, [r0, #48]	; 0x30
   18a56:	0013      	movs	r3, r2
		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
   18a58:	7819      	ldrb	r1, [r3, #0]
   18a5a:	1a98      	subs	r0, r3, r2
   18a5c:	29a5      	cmp	r1, #165	; 0xa5
   18a5e:	d002      	beq.n	18a66 <uxTaskGetStackHighWaterMark+0x1a>
		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
   18a60:	0880      	lsrs	r0, r0, #2
		return uxReturn;
   18a62:	b280      	uxth	r0, r0
	}
   18a64:	4770      	bx	lr
			pucStackByte -= portSTACK_GROWTH;
   18a66:	3301      	adds	r3, #1
   18a68:	e7f6      	b.n	18a58 <uxTaskGetStackHighWaterMark+0xc>
   18a6a:	46c0      	nop			; (mov r8, r8)
   18a6c:	20003bb8 	.word	0x20003bb8

00018a70 <xTaskGetCurrentTaskHandle>:
		xReturn = pxCurrentTCB;
   18a70:	4b01      	ldr	r3, [pc, #4]	; (18a78 <xTaskGetCurrentTaskHandle+0x8>)
   18a72:	6818      	ldr	r0, [r3, #0]
	}
   18a74:	4770      	bx	lr
   18a76:	46c0      	nop			; (mov r8, r8)
   18a78:	20003bb8 	.word	0x20003bb8

00018a7c <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
   18a7c:	4b05      	ldr	r3, [pc, #20]	; (18a94 <xTaskGetSchedulerState+0x18>)
			xReturn = taskSCHEDULER_NOT_STARTED;
   18a7e:	2001      	movs	r0, #1
		if( xSchedulerRunning == pdFALSE )
   18a80:	681b      	ldr	r3, [r3, #0]
   18a82:	2b00      	cmp	r3, #0
   18a84:	d004      	beq.n	18a90 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   18a86:	4b04      	ldr	r3, [pc, #16]	; (18a98 <xTaskGetSchedulerState+0x1c>)
   18a88:	6818      	ldr	r0, [r3, #0]
				xReturn = taskSCHEDULER_SUSPENDED;
   18a8a:	4243      	negs	r3, r0
   18a8c:	4158      	adcs	r0, r3
   18a8e:	0040      	lsls	r0, r0, #1
	}
   18a90:	4770      	bx	lr
   18a92:	46c0      	nop			; (mov r8, r8)
   18a94:	20003c88 	.word	0x20003c88
   18a98:	20003c34 	.word	0x20003c34

00018a9c <xTaskPriorityInherit>:
	{
   18a9c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   18a9e:	0004      	movs	r4, r0
	BaseType_t xReturn = pdFALSE;
   18aa0:	1e06      	subs	r6, r0, #0
		if( pxMutexHolder != NULL )
   18aa2:	d057      	beq.n	18b54 <xTaskPriorityInherit+0xb8>
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
   18aa4:	4d32      	ldr	r5, [pc, #200]	; (18b70 <xTaskPriorityInherit+0xd4>)
   18aa6:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
   18aa8:	682b      	ldr	r3, [r5, #0]
   18aaa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   18aac:	4299      	cmp	r1, r3
   18aae:	d253      	bcs.n	18b58 <xTaskPriorityInherit+0xbc>
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   18ab0:	6983      	ldr	r3, [r0, #24]
   18ab2:	2b00      	cmp	r3, #0
   18ab4:	db04      	blt.n	18ac0 <xTaskPriorityInherit+0x24>
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   18ab6:	2205      	movs	r2, #5
   18ab8:	682b      	ldr	r3, [r5, #0]
   18aba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   18abc:	1ad2      	subs	r2, r2, r3
   18abe:	6182      	str	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
   18ac0:	2314      	movs	r3, #20
   18ac2:	434b      	muls	r3, r1
   18ac4:	4a2b      	ldr	r2, [pc, #172]	; (18b74 <xTaskPriorityInherit+0xd8>)
   18ac6:	4e2c      	ldr	r6, [pc, #176]	; (18b78 <xTaskPriorityInherit+0xdc>)
   18ac8:	18d3      	adds	r3, r2, r3
   18aca:	6962      	ldr	r2, [r4, #20]
   18acc:	4f2b      	ldr	r7, [pc, #172]	; (18b7c <xTaskPriorityInherit+0xe0>)
   18ace:	429a      	cmp	r2, r3
   18ad0:	d149      	bne.n	18b66 <xTaskPriorityInherit+0xca>
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   18ad2:	1d23      	adds	r3, r4, #4
   18ad4:	9301      	str	r3, [sp, #4]
   18ad6:	0018      	movs	r0, r3
   18ad8:	4b29      	ldr	r3, [pc, #164]	; (18b80 <xTaskPriorityInherit+0xe4>)
   18ada:	4798      	blx	r3
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   18adc:	682b      	ldr	r3, [r5, #0]
					prvAddTaskToReadyList( pxMutexHolderTCB );
   18ade:	0020      	movs	r0, r4
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   18ae0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   18ae2:	62e3      	str	r3, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
   18ae4:	47b0      	blx	r6
   18ae6:	883b      	ldrh	r3, [r7, #0]
   18ae8:	4203      	tst	r3, r0
   18aea:	d005      	beq.n	18af8 <xTaskPriorityInherit+0x5c>
   18aec:	4b25      	ldr	r3, [pc, #148]	; (18b84 <xTaskPriorityInherit+0xe8>)
   18aee:	0020      	movs	r0, r4
   18af0:	4798      	blx	r3
   18af2:	4b25      	ldr	r3, [pc, #148]	; (18b88 <xTaskPriorityInherit+0xec>)
   18af4:	b2c0      	uxtb	r0, r0
   18af6:	4798      	blx	r3
   18af8:	4a24      	ldr	r2, [pc, #144]	; (18b8c <xTaskPriorityInherit+0xf0>)
   18afa:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   18afc:	6811      	ldr	r1, [r2, #0]
   18afe:	428b      	cmp	r3, r1
   18b00:	d900      	bls.n	18b04 <xTaskPriorityInherit+0x68>
   18b02:	6013      	str	r3, [r2, #0]
   18b04:	2014      	movs	r0, #20
   18b06:	4358      	muls	r0, r3
   18b08:	4b1a      	ldr	r3, [pc, #104]	; (18b74 <xTaskPriorityInherit+0xd8>)
   18b0a:	1d21      	adds	r1, r4, #4
   18b0c:	1818      	adds	r0, r3, r0
   18b0e:	4b20      	ldr	r3, [pc, #128]	; (18b90 <xTaskPriorityInherit+0xf4>)
   18b10:	4798      	blx	r3
				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
   18b12:	0020      	movs	r0, r4
   18b14:	47b0      	blx	r6
   18b16:	883b      	ldrh	r3, [r7, #0]
				xReturn = pdTRUE;
   18b18:	2601      	movs	r6, #1
				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
   18b1a:	4203      	tst	r3, r0
   18b1c:	d01a      	beq.n	18b54 <xTaskPriorityInherit+0xb8>
   18b1e:	4b19      	ldr	r3, [pc, #100]	; (18b84 <xTaskPriorityInherit+0xe8>)
   18b20:	0020      	movs	r0, r4
   18b22:	4798      	blx	r3
   18b24:	4b17      	ldr	r3, [pc, #92]	; (18b84 <xTaskPriorityInherit+0xe8>)
   18b26:	0007      	movs	r7, r0
   18b28:	0020      	movs	r0, r4
   18b2a:	4798      	blx	r3
   18b2c:	4b19      	ldr	r3, [pc, #100]	; (18b94 <xTaskPriorityInherit+0xf8>)
   18b2e:	b2c1      	uxtb	r1, r0
   18b30:	2003      	movs	r0, #3
   18b32:	4798      	blx	r3
   18b34:	b2fa      	uxtb	r2, r7
   18b36:	0003      	movs	r3, r0
   18b38:	2103      	movs	r1, #3
   18b3a:	208e      	movs	r0, #142	; 0x8e
   18b3c:	4f16      	ldr	r7, [pc, #88]	; (18b98 <xTaskPriorityInherit+0xfc>)
   18b3e:	47b8      	blx	r7
   18b40:	4b10      	ldr	r3, [pc, #64]	; (18b84 <xTaskPriorityInherit+0xe8>)
   18b42:	0020      	movs	r0, r4
   18b44:	4798      	blx	r3
   18b46:	682b      	ldr	r3, [r5, #0]
   18b48:	b2c1      	uxtb	r1, r0
   18b4a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   18b4c:	2003      	movs	r0, #3
   18b4e:	b2d2      	uxtb	r2, r2
   18b50:	4b12      	ldr	r3, [pc, #72]	; (18b9c <xTaskPriorityInherit+0x100>)
   18b52:	4798      	blx	r3
	}
   18b54:	0030      	movs	r0, r6
   18b56:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
   18b58:	682b      	ldr	r3, [r5, #0]
   18b5a:	6c46      	ldr	r6, [r0, #68]	; 0x44
   18b5c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   18b5e:	429e      	cmp	r6, r3
   18b60:	41b6      	sbcs	r6, r6
   18b62:	4276      	negs	r6, r6
   18b64:	e7f6      	b.n	18b54 <xTaskPriorityInherit+0xb8>
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   18b66:	682b      	ldr	r3, [r5, #0]
   18b68:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   18b6a:	62e3      	str	r3, [r4, #44]	; 0x2c
   18b6c:	e7d1      	b.n	18b12 <xTaskPriorityInherit+0x76>
   18b6e:	46c0      	nop			; (mov r8, r8)
   18b70:	20003bb8 	.word	0x20003bb8
   18b74:	20003bc4 	.word	0x20003bc4
   18b78:	00015c21 	.word	0x00015c21
   18b7c:	200001f0 	.word	0x200001f0
   18b80:	00016cc7 	.word	0x00016cc7
   18b84:	00015c11 	.word	0x00015c11
   18b88:	00016755 	.word	0x00016755
   18b8c:	20003c3c 	.word	0x20003c3c
   18b90:	00016c81 	.word	0x00016c81
   18b94:	00016371 	.word	0x00016371
   18b98:	00016965 	.word	0x00016965
   18b9c:	0001631d 	.word	0x0001631d

00018ba0 <xTaskPriorityDisinherit>:
	{
   18ba0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18ba2:	1e04      	subs	r4, r0, #0
		if( pxMutexHolder != NULL )
   18ba4:	d101      	bne.n	18baa <xTaskPriorityDisinherit+0xa>
	BaseType_t xReturn = pdFALSE;
   18ba6:	2000      	movs	r0, #0
	}
   18ba8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			configASSERT( pxTCB == pxCurrentTCB );
   18baa:	4b2c      	ldr	r3, [pc, #176]	; (18c5c <xTaskPriorityDisinherit+0xbc>)
   18bac:	681b      	ldr	r3, [r3, #0]
   18bae:	4298      	cmp	r0, r3
   18bb0:	d001      	beq.n	18bb6 <xTaskPriorityDisinherit+0x16>
   18bb2:	b672      	cpsid	i
   18bb4:	e7fe      	b.n	18bb4 <xTaskPriorityDisinherit+0x14>
			configASSERT( pxTCB->uxMutexesHeld );
   18bb6:	6c83      	ldr	r3, [r0, #72]	; 0x48
   18bb8:	2b00      	cmp	r3, #0
   18bba:	d101      	bne.n	18bc0 <xTaskPriorityDisinherit+0x20>
   18bbc:	b672      	cpsid	i
   18bbe:	e7fe      	b.n	18bbe <xTaskPriorityDisinherit+0x1e>
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   18bc0:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
   18bc2:	6c41      	ldr	r1, [r0, #68]	; 0x44
			( pxTCB->uxMutexesHeld )--;
   18bc4:	3b01      	subs	r3, #1
   18bc6:	6483      	str	r3, [r0, #72]	; 0x48
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   18bc8:	428a      	cmp	r2, r1
   18bca:	d0ec      	beq.n	18ba6 <xTaskPriorityDisinherit+0x6>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
   18bcc:	2b00      	cmp	r3, #0
   18bce:	d1ea      	bne.n	18ba6 <xTaskPriorityDisinherit+0x6>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   18bd0:	1d07      	adds	r7, r0, #4
   18bd2:	4b23      	ldr	r3, [pc, #140]	; (18c60 <xTaskPriorityDisinherit+0xc0>)
   18bd4:	0038      	movs	r0, r7
   18bd6:	4798      	blx	r3
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
   18bd8:	4b22      	ldr	r3, [pc, #136]	; (18c64 <xTaskPriorityDisinherit+0xc4>)
   18bda:	0020      	movs	r0, r4
   18bdc:	4798      	blx	r3
   18bde:	4b22      	ldr	r3, [pc, #136]	; (18c68 <xTaskPriorityDisinherit+0xc8>)
   18be0:	881b      	ldrh	r3, [r3, #0]
   18be2:	4203      	tst	r3, r0
   18be4:	d018      	beq.n	18c18 <xTaskPriorityDisinherit+0x78>
   18be6:	4d21      	ldr	r5, [pc, #132]	; (18c6c <xTaskPriorityDisinherit+0xcc>)
   18be8:	0020      	movs	r0, r4
   18bea:	47a8      	blx	r5
   18bec:	0006      	movs	r6, r0
   18bee:	0020      	movs	r0, r4
   18bf0:	47a8      	blx	r5
   18bf2:	4b1f      	ldr	r3, [pc, #124]	; (18c70 <xTaskPriorityDisinherit+0xd0>)
   18bf4:	b2c1      	uxtb	r1, r0
   18bf6:	2003      	movs	r0, #3
   18bf8:	4798      	blx	r3
   18bfa:	b2f2      	uxtb	r2, r6
   18bfc:	0003      	movs	r3, r0
   18bfe:	2103      	movs	r1, #3
   18c00:	208f      	movs	r0, #143	; 0x8f
   18c02:	4e1c      	ldr	r6, [pc, #112]	; (18c74 <xTaskPriorityDisinherit+0xd4>)
   18c04:	47b0      	blx	r6
   18c06:	0020      	movs	r0, r4
   18c08:	47a8      	blx	r5
   18c0a:	2344      	movs	r3, #68	; 0x44
   18c0c:	18e3      	adds	r3, r4, r3
   18c0e:	781a      	ldrb	r2, [r3, #0]
   18c10:	b2c1      	uxtb	r1, r0
   18c12:	4b19      	ldr	r3, [pc, #100]	; (18c78 <xTaskPriorityDisinherit+0xd8>)
   18c14:	2003      	movs	r0, #3
   18c16:	4798      	blx	r3
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   18c18:	2305      	movs	r3, #5
					pxTCB->uxPriority = pxTCB->uxBasePriority;
   18c1a:	6c62      	ldr	r2, [r4, #68]	; 0x44
					prvAddTaskToReadyList( pxTCB );
   18c1c:	0020      	movs	r0, r4
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   18c1e:	1a9b      	subs	r3, r3, r2
   18c20:	61a3      	str	r3, [r4, #24]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
   18c22:	62e2      	str	r2, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
   18c24:	4b0f      	ldr	r3, [pc, #60]	; (18c64 <xTaskPriorityDisinherit+0xc4>)
   18c26:	4798      	blx	r3
   18c28:	4b0f      	ldr	r3, [pc, #60]	; (18c68 <xTaskPriorityDisinherit+0xc8>)
   18c2a:	881b      	ldrh	r3, [r3, #0]
   18c2c:	4203      	tst	r3, r0
   18c2e:	d005      	beq.n	18c3c <xTaskPriorityDisinherit+0x9c>
   18c30:	4b0e      	ldr	r3, [pc, #56]	; (18c6c <xTaskPriorityDisinherit+0xcc>)
   18c32:	0020      	movs	r0, r4
   18c34:	4798      	blx	r3
   18c36:	4b11      	ldr	r3, [pc, #68]	; (18c7c <xTaskPriorityDisinherit+0xdc>)
   18c38:	b2c0      	uxtb	r0, r0
   18c3a:	4798      	blx	r3
   18c3c:	4a10      	ldr	r2, [pc, #64]	; (18c80 <xTaskPriorityDisinherit+0xe0>)
   18c3e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   18c40:	6811      	ldr	r1, [r2, #0]
   18c42:	428b      	cmp	r3, r1
   18c44:	d900      	bls.n	18c48 <xTaskPriorityDisinherit+0xa8>
   18c46:	6013      	str	r3, [r2, #0]
   18c48:	2014      	movs	r0, #20
   18c4a:	4343      	muls	r3, r0
   18c4c:	480d      	ldr	r0, [pc, #52]	; (18c84 <xTaskPriorityDisinherit+0xe4>)
   18c4e:	0039      	movs	r1, r7
   18c50:	18c0      	adds	r0, r0, r3
   18c52:	4b0d      	ldr	r3, [pc, #52]	; (18c88 <xTaskPriorityDisinherit+0xe8>)
   18c54:	4798      	blx	r3
					xReturn = pdTRUE;
   18c56:	2001      	movs	r0, #1
		return xReturn;
   18c58:	e7a6      	b.n	18ba8 <xTaskPriorityDisinherit+0x8>
   18c5a:	46c0      	nop			; (mov r8, r8)
   18c5c:	20003bb8 	.word	0x20003bb8
   18c60:	00016cc7 	.word	0x00016cc7
   18c64:	00015c21 	.word	0x00015c21
   18c68:	200001f0 	.word	0x200001f0
   18c6c:	00015c11 	.word	0x00015c11
   18c70:	00016371 	.word	0x00016371
   18c74:	00016965 	.word	0x00016965
   18c78:	0001631d 	.word	0x0001631d
   18c7c:	00016755 	.word	0x00016755
   18c80:	20003c3c 	.word	0x20003c3c
   18c84:	20003bc4 	.word	0x20003bc4
   18c88:	00016c81 	.word	0x00016c81

00018c8c <vTaskPriorityDisinheritAfterTimeout>:
	{
   18c8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18c8e:	1e04      	subs	r4, r0, #0
		if( pxMutexHolder != NULL )
   18c90:	d05f      	beq.n	18d52 <vTaskPriorityDisinheritAfterTimeout+0xc6>
			configASSERT( pxTCB->uxMutexesHeld );
   18c92:	6c83      	ldr	r3, [r0, #72]	; 0x48
   18c94:	2b00      	cmp	r3, #0
   18c96:	d101      	bne.n	18c9c <vTaskPriorityDisinheritAfterTimeout+0x10>
   18c98:	b672      	cpsid	i
   18c9a:	e7fe      	b.n	18c9a <vTaskPriorityDisinheritAfterTimeout+0xe>
   18c9c:	6c45      	ldr	r5, [r0, #68]	; 0x44
   18c9e:	428d      	cmp	r5, r1
   18ca0:	d200      	bcs.n	18ca4 <vTaskPriorityDisinheritAfterTimeout+0x18>
   18ca2:	000d      	movs	r5, r1
			if( pxTCB->uxPriority != uxPriorityToUse )
   18ca4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   18ca6:	42aa      	cmp	r2, r5
   18ca8:	d053      	beq.n	18d52 <vTaskPriorityDisinheritAfterTimeout+0xc6>
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
   18caa:	2b01      	cmp	r3, #1
   18cac:	d151      	bne.n	18d52 <vTaskPriorityDisinheritAfterTimeout+0xc6>
					configASSERT( pxTCB != pxCurrentTCB );
   18cae:	4b29      	ldr	r3, [pc, #164]	; (18d54 <vTaskPriorityDisinheritAfterTimeout+0xc8>)
   18cb0:	681b      	ldr	r3, [r3, #0]
   18cb2:	429c      	cmp	r4, r3
   18cb4:	d101      	bne.n	18cba <vTaskPriorityDisinheritAfterTimeout+0x2e>
   18cb6:	b672      	cpsid	i
   18cb8:	e7fe      	b.n	18cb8 <vTaskPriorityDisinheritAfterTimeout+0x2c>
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
   18cba:	4b27      	ldr	r3, [pc, #156]	; (18d58 <vTaskPriorityDisinheritAfterTimeout+0xcc>)
   18cbc:	0020      	movs	r0, r4
   18cbe:	4798      	blx	r3
   18cc0:	4b26      	ldr	r3, [pc, #152]	; (18d5c <vTaskPriorityDisinheritAfterTimeout+0xd0>)
   18cc2:	881b      	ldrh	r3, [r3, #0]
   18cc4:	4203      	tst	r3, r0
   18cc6:	d018      	beq.n	18cfa <vTaskPriorityDisinheritAfterTimeout+0x6e>
   18cc8:	4e25      	ldr	r6, [pc, #148]	; (18d60 <vTaskPriorityDisinheritAfterTimeout+0xd4>)
   18cca:	0020      	movs	r0, r4
   18ccc:	47b0      	blx	r6
   18cce:	0007      	movs	r7, r0
   18cd0:	0020      	movs	r0, r4
   18cd2:	47b0      	blx	r6
   18cd4:	4b23      	ldr	r3, [pc, #140]	; (18d64 <vTaskPriorityDisinheritAfterTimeout+0xd8>)
   18cd6:	b2c1      	uxtb	r1, r0
   18cd8:	2003      	movs	r0, #3
   18cda:	4798      	blx	r3
   18cdc:	b2fa      	uxtb	r2, r7
   18cde:	0003      	movs	r3, r0
   18ce0:	2103      	movs	r1, #3
   18ce2:	208f      	movs	r0, #143	; 0x8f
   18ce4:	4f20      	ldr	r7, [pc, #128]	; (18d68 <vTaskPriorityDisinheritAfterTimeout+0xdc>)
   18ce6:	47b8      	blx	r7
   18ce8:	0020      	movs	r0, r4
   18cea:	47b0      	blx	r6
   18cec:	2344      	movs	r3, #68	; 0x44
   18cee:	18e3      	adds	r3, r4, r3
   18cf0:	781a      	ldrb	r2, [r3, #0]
   18cf2:	b2c1      	uxtb	r1, r0
   18cf4:	4b1d      	ldr	r3, [pc, #116]	; (18d6c <vTaskPriorityDisinheritAfterTimeout+0xe0>)
   18cf6:	2003      	movs	r0, #3
   18cf8:	4798      	blx	r3
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   18cfa:	69a3      	ldr	r3, [r4, #24]
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
   18cfc:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
					pxTCB->uxPriority = uxPriorityToUse;
   18cfe:	62e5      	str	r5, [r4, #44]	; 0x2c
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   18d00:	2b00      	cmp	r3, #0
   18d02:	db02      	blt.n	18d0a <vTaskPriorityDisinheritAfterTimeout+0x7e>
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   18d04:	2205      	movs	r2, #5
   18d06:	1b55      	subs	r5, r2, r5
   18d08:	61a5      	str	r5, [r4, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
   18d0a:	2314      	movs	r3, #20
   18d0c:	434b      	muls	r3, r1
   18d0e:	4e18      	ldr	r6, [pc, #96]	; (18d70 <vTaskPriorityDisinheritAfterTimeout+0xe4>)
   18d10:	6962      	ldr	r2, [r4, #20]
   18d12:	18f3      	adds	r3, r6, r3
   18d14:	429a      	cmp	r2, r3
   18d16:	d11c      	bne.n	18d52 <vTaskPriorityDisinheritAfterTimeout+0xc6>
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   18d18:	1d25      	adds	r5, r4, #4
   18d1a:	4b16      	ldr	r3, [pc, #88]	; (18d74 <vTaskPriorityDisinheritAfterTimeout+0xe8>)
   18d1c:	0028      	movs	r0, r5
   18d1e:	4798      	blx	r3
						prvAddTaskToReadyList( pxTCB );
   18d20:	4b0d      	ldr	r3, [pc, #52]	; (18d58 <vTaskPriorityDisinheritAfterTimeout+0xcc>)
   18d22:	0020      	movs	r0, r4
   18d24:	4798      	blx	r3
   18d26:	4b0d      	ldr	r3, [pc, #52]	; (18d5c <vTaskPriorityDisinheritAfterTimeout+0xd0>)
   18d28:	881b      	ldrh	r3, [r3, #0]
   18d2a:	4203      	tst	r3, r0
   18d2c:	d005      	beq.n	18d3a <vTaskPriorityDisinheritAfterTimeout+0xae>
   18d2e:	4b0c      	ldr	r3, [pc, #48]	; (18d60 <vTaskPriorityDisinheritAfterTimeout+0xd4>)
   18d30:	0020      	movs	r0, r4
   18d32:	4798      	blx	r3
   18d34:	4b10      	ldr	r3, [pc, #64]	; (18d78 <vTaskPriorityDisinheritAfterTimeout+0xec>)
   18d36:	b2c0      	uxtb	r0, r0
   18d38:	4798      	blx	r3
   18d3a:	4a10      	ldr	r2, [pc, #64]	; (18d7c <vTaskPriorityDisinheritAfterTimeout+0xf0>)
   18d3c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   18d3e:	6811      	ldr	r1, [r2, #0]
   18d40:	428b      	cmp	r3, r1
   18d42:	d900      	bls.n	18d46 <vTaskPriorityDisinheritAfterTimeout+0xba>
   18d44:	6013      	str	r3, [r2, #0]
   18d46:	2014      	movs	r0, #20
   18d48:	4358      	muls	r0, r3
   18d4a:	0029      	movs	r1, r5
   18d4c:	1830      	adds	r0, r6, r0
   18d4e:	4b0c      	ldr	r3, [pc, #48]	; (18d80 <vTaskPriorityDisinheritAfterTimeout+0xf4>)
   18d50:	4798      	blx	r3
	}
   18d52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   18d54:	20003bb8 	.word	0x20003bb8
   18d58:	00015c21 	.word	0x00015c21
   18d5c:	200001f0 	.word	0x200001f0
   18d60:	00015c11 	.word	0x00015c11
   18d64:	00016371 	.word	0x00016371
   18d68:	00016965 	.word	0x00016965
   18d6c:	0001631d 	.word	0x0001631d
   18d70:	20003bc4 	.word	0x20003bc4
   18d74:	00016cc7 	.word	0x00016cc7
   18d78:	00016755 	.word	0x00016755
   18d7c:	20003c3c 	.word	0x20003c3c
   18d80:	00016c81 	.word	0x00016c81

00018d84 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
   18d84:	4b04      	ldr	r3, [pc, #16]	; (18d98 <pvTaskIncrementMutexHeldCount+0x14>)
   18d86:	681a      	ldr	r2, [r3, #0]
   18d88:	2a00      	cmp	r2, #0
   18d8a:	d003      	beq.n	18d94 <pvTaskIncrementMutexHeldCount+0x10>
			( pxCurrentTCB->uxMutexesHeld )++;
   18d8c:	6819      	ldr	r1, [r3, #0]
   18d8e:	6c8a      	ldr	r2, [r1, #72]	; 0x48
   18d90:	3201      	adds	r2, #1
   18d92:	648a      	str	r2, [r1, #72]	; 0x48
		return pxCurrentTCB;
   18d94:	6818      	ldr	r0, [r3, #0]
	}
   18d96:	4770      	bx	lr
   18d98:	20003bb8 	.word	0x20003bb8

00018d9c <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
   18d9c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
   18d9e:	4b0d      	ldr	r3, [pc, #52]	; (18dd4 <prvCheckForValidListAndQueue+0x38>)
   18da0:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
   18da2:	4c0d      	ldr	r4, [pc, #52]	; (18dd8 <prvCheckForValidListAndQueue+0x3c>)
   18da4:	6823      	ldr	r3, [r4, #0]
   18da6:	9301      	str	r3, [sp, #4]
   18da8:	2b00      	cmp	r3, #0
   18daa:	d110      	bne.n	18dce <prvCheckForValidListAndQueue+0x32>
		{
			vListInitialise( &xActiveTimerList1 );
   18dac:	4e0b      	ldr	r6, [pc, #44]	; (18ddc <prvCheckForValidListAndQueue+0x40>)
   18dae:	4f0c      	ldr	r7, [pc, #48]	; (18de0 <prvCheckForValidListAndQueue+0x44>)
   18db0:	0030      	movs	r0, r6
   18db2:	47b8      	blx	r7
			vListInitialise( &xActiveTimerList2 );
   18db4:	4d0b      	ldr	r5, [pc, #44]	; (18de4 <prvCheckForValidListAndQueue+0x48>)
   18db6:	0028      	movs	r0, r5
   18db8:	47b8      	blx	r7
			pxCurrentTimerList = &xActiveTimerList1;
   18dba:	4b0b      	ldr	r3, [pc, #44]	; (18de8 <prvCheckForValidListAndQueue+0x4c>)

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
   18dbc:	9a01      	ldr	r2, [sp, #4]
			pxCurrentTimerList = &xActiveTimerList1;
   18dbe:	601e      	str	r6, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
   18dc0:	4b0a      	ldr	r3, [pc, #40]	; (18dec <prvCheckForValidListAndQueue+0x50>)
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
   18dc2:	210c      	movs	r1, #12
			pxOverflowTimerList = &xActiveTimerList2;
   18dc4:	601d      	str	r5, [r3, #0]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
   18dc6:	2005      	movs	r0, #5
   18dc8:	4b09      	ldr	r3, [pc, #36]	; (18df0 <prvCheckForValidListAndQueue+0x54>)
   18dca:	4798      	blx	r3
   18dcc:	6020      	str	r0, [r4, #0]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
   18dce:	4b09      	ldr	r3, [pc, #36]	; (18df4 <prvCheckForValidListAndQueue+0x58>)
   18dd0:	4798      	blx	r3
}
   18dd2:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   18dd4:	00016df1 	.word	0x00016df1
   18dd8:	20003cf0 	.word	0x20003cf0
   18ddc:	20003cc4 	.word	0x20003cc4
   18de0:	00016c65 	.word	0x00016c65
   18de4:	20003cd8 	.word	0x20003cd8
   18de8:	20003cbc 	.word	0x20003cbc
   18dec:	20003cc0 	.word	0x20003cc0
   18df0:	00017229 	.word	0x00017229
   18df4:	00016e09 	.word	0x00016e09

00018df8 <prvInsertTimerInActiveList>:
{
   18df8:	b510      	push	{r4, lr}
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
   18dfa:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   18dfc:	6100      	str	r0, [r0, #16]
	if( xNextExpiryTime <= xTimeNow )
   18dfe:	4291      	cmp	r1, r2
   18e00:	d80c      	bhi.n	18e1c <prvInsertTimerInActiveList+0x24>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   18e02:	1ad2      	subs	r2, r2, r3
   18e04:	6983      	ldr	r3, [r0, #24]
			xProcessTimerNow = pdTRUE;
   18e06:	2401      	movs	r4, #1
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   18e08:	429a      	cmp	r2, r3
   18e0a:	d205      	bcs.n	18e18 <prvInsertTimerInActiveList+0x20>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
   18e0c:	4b07      	ldr	r3, [pc, #28]	; (18e2c <prvInsertTimerInActiveList+0x34>)
   18e0e:	1d01      	adds	r1, r0, #4
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   18e10:	6818      	ldr	r0, [r3, #0]
   18e12:	4b07      	ldr	r3, [pc, #28]	; (18e30 <prvInsertTimerInActiveList+0x38>)
   18e14:	4798      	blx	r3
BaseType_t xProcessTimerNow = pdFALSE;
   18e16:	2400      	movs	r4, #0
}
   18e18:	0020      	movs	r0, r4
   18e1a:	bd10      	pop	{r4, pc}
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
   18e1c:	429a      	cmp	r2, r3
   18e1e:	d202      	bcs.n	18e26 <prvInsertTimerInActiveList+0x2e>
			xProcessTimerNow = pdTRUE;
   18e20:	2401      	movs	r4, #1
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
   18e22:	4299      	cmp	r1, r3
   18e24:	d2f8      	bcs.n	18e18 <prvInsertTimerInActiveList+0x20>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   18e26:	1d01      	adds	r1, r0, #4
   18e28:	4b02      	ldr	r3, [pc, #8]	; (18e34 <prvInsertTimerInActiveList+0x3c>)
   18e2a:	e7f1      	b.n	18e10 <prvInsertTimerInActiveList+0x18>
   18e2c:	20003cc0 	.word	0x20003cc0
   18e30:	00016c99 	.word	0x00016c99
   18e34:	20003cbc 	.word	0x20003cbc

00018e38 <xTimerCreateTimerTask>:
	prvCheckForValidListAndQueue();
   18e38:	4b0a      	ldr	r3, [pc, #40]	; (18e64 <xTimerCreateTimerTask+0x2c>)
{
   18e3a:	b513      	push	{r0, r1, r4, lr}
	prvCheckForValidListAndQueue();
   18e3c:	4798      	blx	r3
	if( xTimerQueue != NULL )
   18e3e:	4b0a      	ldr	r3, [pc, #40]	; (18e68 <xTimerCreateTimerTask+0x30>)
   18e40:	681b      	ldr	r3, [r3, #0]
   18e42:	2b00      	cmp	r3, #0
   18e44:	d101      	bne.n	18e4a <xTimerCreateTimerTask+0x12>
	configASSERT( xReturn );
   18e46:	b672      	cpsid	i
   18e48:	e7fe      	b.n	18e48 <xTimerCreateTimerTask+0x10>
			xReturn = xTaskCreate(	prvTimerTask,
   18e4a:	4b08      	ldr	r3, [pc, #32]	; (18e6c <xTimerCreateTimerTask+0x34>)
   18e4c:	2280      	movs	r2, #128	; 0x80
   18e4e:	9301      	str	r3, [sp, #4]
   18e50:	2302      	movs	r3, #2
   18e52:	4907      	ldr	r1, [pc, #28]	; (18e70 <xTimerCreateTimerTask+0x38>)
   18e54:	9300      	str	r3, [sp, #0]
   18e56:	4807      	ldr	r0, [pc, #28]	; (18e74 <xTimerCreateTimerTask+0x3c>)
   18e58:	2300      	movs	r3, #0
   18e5a:	4c07      	ldr	r4, [pc, #28]	; (18e78 <xTimerCreateTimerTask+0x40>)
   18e5c:	47a0      	blx	r4
	configASSERT( xReturn );
   18e5e:	2800      	cmp	r0, #0
   18e60:	d0f1      	beq.n	18e46 <xTimerCreateTimerTask+0xe>
}
   18e62:	bd16      	pop	{r1, r2, r4, pc}
   18e64:	00018d9d 	.word	0x00018d9d
   18e68:	20003cf0 	.word	0x20003cf0
   18e6c:	20003cf4 	.word	0x20003cf4
   18e70:	00029f08 	.word	0x00029f08
   18e74:	00018f45 	.word	0x00018f45
   18e78:	00018031 	.word	0x00018031

00018e7c <xTimerGenericCommand>:
{
   18e7c:	b5f0      	push	{r4, r5, r6, r7, lr}
   18e7e:	0017      	movs	r7, r2
   18e80:	b085      	sub	sp, #20
   18e82:	0006      	movs	r6, r0
   18e84:	001a      	movs	r2, r3
	configASSERT( xTimer );
   18e86:	2800      	cmp	r0, #0
   18e88:	d101      	bne.n	18e8e <xTimerGenericCommand+0x12>
   18e8a:	b672      	cpsid	i
   18e8c:	e7fe      	b.n	18e8c <xTimerGenericCommand+0x10>
	if( xTimerQueue != NULL )
   18e8e:	4d0d      	ldr	r5, [pc, #52]	; (18ec4 <xTimerGenericCommand+0x48>)
   18e90:	682c      	ldr	r4, [r5, #0]
BaseType_t xReturn = pdFAIL;
   18e92:	1e20      	subs	r0, r4, #0
	if( xTimerQueue != NULL )
   18e94:	d00f      	beq.n	18eb6 <xTimerGenericCommand+0x3a>
		xMessage.xMessageID = xCommandID;
   18e96:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
   18e98:	9702      	str	r7, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
   18e9a:	9603      	str	r6, [sp, #12]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
   18e9c:	2905      	cmp	r1, #5
   18e9e:	dc0c      	bgt.n	18eba <xTimerGenericCommand+0x3e>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
   18ea0:	4b09      	ldr	r3, [pc, #36]	; (18ec8 <xTimerGenericCommand+0x4c>)
   18ea2:	4798      	blx	r3
   18ea4:	4c09      	ldr	r4, [pc, #36]	; (18ecc <xTimerGenericCommand+0x50>)
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
   18ea6:	2300      	movs	r3, #0
   18ea8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
   18eaa:	2802      	cmp	r0, #2
   18eac:	d000      	beq.n	18eb0 <xTimerGenericCommand+0x34>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
   18eae:	001a      	movs	r2, r3
   18eb0:	6828      	ldr	r0, [r5, #0]
   18eb2:	a901      	add	r1, sp, #4
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
   18eb4:	47a0      	blx	r4
}
   18eb6:	b005      	add	sp, #20
   18eb8:	bdf0      	pop	{r4, r5, r6, r7, pc}
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
   18eba:	0020      	movs	r0, r4
   18ebc:	2300      	movs	r3, #0
   18ebe:	a901      	add	r1, sp, #4
   18ec0:	4c03      	ldr	r4, [pc, #12]	; (18ed0 <xTimerGenericCommand+0x54>)
   18ec2:	e7f7      	b.n	18eb4 <xTimerGenericCommand+0x38>
   18ec4:	20003cf0 	.word	0x20003cf0
   18ec8:	00018a7d 	.word	0x00018a7d
   18ecc:	0001735d 	.word	0x0001735d
   18ed0:	00017621 	.word	0x00017621

00018ed4 <prvSwitchTimerLists>:
{
   18ed4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
   18ed6:	4d16      	ldr	r5, [pc, #88]	; (18f30 <prvSwitchTimerLists+0x5c>)
   18ed8:	682b      	ldr	r3, [r5, #0]
   18eda:	681a      	ldr	r2, [r3, #0]
   18edc:	2a00      	cmp	r2, #0
   18ede:	d104      	bne.n	18eea <prvSwitchTimerLists+0x16>
	pxCurrentTimerList = pxOverflowTimerList;
   18ee0:	4a14      	ldr	r2, [pc, #80]	; (18f34 <prvSwitchTimerLists+0x60>)
   18ee2:	6811      	ldr	r1, [r2, #0]
	pxOverflowTimerList = pxTemp;
   18ee4:	6013      	str	r3, [r2, #0]
	pxCurrentTimerList = pxOverflowTimerList;
   18ee6:	6029      	str	r1, [r5, #0]
}
   18ee8:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   18eea:	68db      	ldr	r3, [r3, #12]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
   18eec:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   18eee:	681e      	ldr	r6, [r3, #0]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   18ef0:	1d27      	adds	r7, r4, #4
   18ef2:	4b11      	ldr	r3, [pc, #68]	; (18f38 <prvSwitchTimerLists+0x64>)
   18ef4:	0038      	movs	r0, r7
   18ef6:	4798      	blx	r3
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   18ef8:	6a63      	ldr	r3, [r4, #36]	; 0x24
   18efa:	0020      	movs	r0, r4
   18efc:	4798      	blx	r3
		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   18efe:	69e3      	ldr	r3, [r4, #28]
   18f00:	2b01      	cmp	r3, #1
   18f02:	d1e8      	bne.n	18ed6 <prvSwitchTimerLists+0x2>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
   18f04:	69a3      	ldr	r3, [r4, #24]
   18f06:	18f3      	adds	r3, r6, r3
			if( xReloadTime > xNextExpireTime )
   18f08:	429e      	cmp	r6, r3
   18f0a:	d206      	bcs.n	18f1a <prvSwitchTimerLists+0x46>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
   18f0c:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   18f0e:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   18f10:	0039      	movs	r1, r7
   18f12:	6828      	ldr	r0, [r5, #0]
   18f14:	4b09      	ldr	r3, [pc, #36]	; (18f3c <prvSwitchTimerLists+0x68>)
   18f16:	4798      	blx	r3
   18f18:	e7dd      	b.n	18ed6 <prvSwitchTimerLists+0x2>
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
   18f1a:	2100      	movs	r1, #0
   18f1c:	0020      	movs	r0, r4
   18f1e:	9100      	str	r1, [sp, #0]
   18f20:	000b      	movs	r3, r1
   18f22:	0032      	movs	r2, r6
   18f24:	4c06      	ldr	r4, [pc, #24]	; (18f40 <prvSwitchTimerLists+0x6c>)
   18f26:	47a0      	blx	r4
				configASSERT( xResult );
   18f28:	2800      	cmp	r0, #0
   18f2a:	d1d4      	bne.n	18ed6 <prvSwitchTimerLists+0x2>
   18f2c:	b672      	cpsid	i
   18f2e:	e7fe      	b.n	18f2e <prvSwitchTimerLists+0x5a>
   18f30:	20003cbc 	.word	0x20003cbc
   18f34:	20003cc0 	.word	0x20003cc0
   18f38:	00016cc7 	.word	0x00016cc7
   18f3c:	00016c99 	.word	0x00016c99
   18f40:	00018e7d 	.word	0x00018e7d

00018f44 <prvTimerTask>:
{
   18f44:	b5f0      	push	{r4, r5, r6, r7, lr}
		vApplicationDaemonTaskStartupHook();
   18f46:	4b59      	ldr	r3, [pc, #356]	; (190ac <prvTimerTask+0x168>)
{
   18f48:	b089      	sub	sp, #36	; 0x24
		vApplicationDaemonTaskStartupHook();
   18f4a:	4798      	blx	r3
		xNextExpireTime = ( TickType_t ) 0U;
   18f4c:	2700      	movs	r7, #0
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
   18f4e:	4b58      	ldr	r3, [pc, #352]	; (190b0 <prvTimerTask+0x16c>)
   18f50:	681b      	ldr	r3, [r3, #0]
   18f52:	681a      	ldr	r2, [r3, #0]
   18f54:	9203      	str	r2, [sp, #12]
	if( *pxListWasEmpty == pdFALSE )
   18f56:	42ba      	cmp	r2, r7
   18f58:	d001      	beq.n	18f5e <prvTimerTask+0x1a>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   18f5a:	68db      	ldr	r3, [r3, #12]
   18f5c:	681f      	ldr	r7, [r3, #0]
	vTaskSuspendAll();
   18f5e:	4b55      	ldr	r3, [pc, #340]	; (190b4 <prvTimerTask+0x170>)
   18f60:	4798      	blx	r3
	xTimeNow = xTaskGetTickCount();
   18f62:	4b55      	ldr	r3, [pc, #340]	; (190b8 <prvTimerTask+0x174>)
   18f64:	4798      	blx	r3
	if( xTimeNow < xLastTime )
   18f66:	4d55      	ldr	r5, [pc, #340]	; (190bc <prvTimerTask+0x178>)
	xTimeNow = xTaskGetTickCount();
   18f68:	0004      	movs	r4, r0
	if( xTimeNow < xLastTime )
   18f6a:	682b      	ldr	r3, [r5, #0]
		*pxTimerListsWereSwitched = pdFALSE;
   18f6c:	2600      	movs	r6, #0
	if( xTimeNow < xLastTime )
   18f6e:	4298      	cmp	r0, r3
   18f70:	d202      	bcs.n	18f78 <prvTimerTask+0x34>
		prvSwitchTimerLists();
   18f72:	4b53      	ldr	r3, [pc, #332]	; (190c0 <prvTimerTask+0x17c>)
   18f74:	4798      	blx	r3
		*pxTimerListsWereSwitched = pdTRUE;
   18f76:	3601      	adds	r6, #1
	xLastTime = xTimeNow;
   18f78:	602c      	str	r4, [r5, #0]
   18f7a:	4d52      	ldr	r5, [pc, #328]	; (190c4 <prvTimerTask+0x180>)
		if( xTimerListsWereSwitched == pdFALSE )
   18f7c:	2e00      	cmp	r6, #0
   18f7e:	d168      	bne.n	19052 <prvTimerTask+0x10e>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
   18f80:	9b03      	ldr	r3, [sp, #12]
   18f82:	2b00      	cmp	r3, #0
   18f84:	d054      	beq.n	19030 <prvTimerTask+0xec>
   18f86:	0030      	movs	r0, r6
   18f88:	42a7      	cmp	r7, r4
   18f8a:	d856      	bhi.n	1903a <prvTimerTask+0xf6>
				( void ) xTaskResumeAll();
   18f8c:	47a8      	blx	r5
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
   18f8e:	4b48      	ldr	r3, [pc, #288]	; (190b0 <prvTimerTask+0x16c>)
   18f90:	681b      	ldr	r3, [r3, #0]
   18f92:	68db      	ldr	r3, [r3, #12]
   18f94:	68dd      	ldr	r5, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   18f96:	4b4c      	ldr	r3, [pc, #304]	; (190c8 <prvTimerTask+0x184>)
   18f98:	1d28      	adds	r0, r5, #4
   18f9a:	4798      	blx	r3
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   18f9c:	69eb      	ldr	r3, [r5, #28]
   18f9e:	2b01      	cmp	r3, #1
   18fa0:	d113      	bne.n	18fca <prvTimerTask+0x86>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
   18fa2:	69ab      	ldr	r3, [r5, #24]
   18fa4:	0022      	movs	r2, r4
   18fa6:	18f9      	adds	r1, r7, r3
   18fa8:	0028      	movs	r0, r5
   18faa:	003b      	movs	r3, r7
   18fac:	4c47      	ldr	r4, [pc, #284]	; (190cc <prvTimerTask+0x188>)
   18fae:	47a0      	blx	r4
   18fb0:	2800      	cmp	r0, #0
   18fb2:	d00a      	beq.n	18fca <prvTimerTask+0x86>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
   18fb4:	9600      	str	r6, [sp, #0]
   18fb6:	0033      	movs	r3, r6
   18fb8:	003a      	movs	r2, r7
   18fba:	0031      	movs	r1, r6
   18fbc:	0028      	movs	r0, r5
   18fbe:	4c44      	ldr	r4, [pc, #272]	; (190d0 <prvTimerTask+0x18c>)
   18fc0:	47a0      	blx	r4
			configASSERT( xResult );
   18fc2:	2800      	cmp	r0, #0
   18fc4:	d101      	bne.n	18fca <prvTimerTask+0x86>
   18fc6:	b672      	cpsid	i
   18fc8:	e7fe      	b.n	18fc8 <prvTimerTask+0x84>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   18fca:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   18fcc:	0028      	movs	r0, r5
   18fce:	4798      	blx	r3
   18fd0:	2784      	movs	r7, #132	; 0x84
   18fd2:	00bf      	lsls	r7, r7, #2
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
   18fd4:	4b3f      	ldr	r3, [pc, #252]	; (190d4 <prvTimerTask+0x190>)
   18fd6:	2200      	movs	r2, #0
   18fd8:	6818      	ldr	r0, [r3, #0]
   18fda:	a905      	add	r1, sp, #20
   18fdc:	4b3e      	ldr	r3, [pc, #248]	; (190d8 <prvTimerTask+0x194>)
   18fde:	4798      	blx	r3
   18fe0:	2800      	cmp	r0, #0
   18fe2:	d0b3      	beq.n	18f4c <prvTimerTask+0x8>
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
   18fe4:	9b05      	ldr	r3, [sp, #20]
   18fe6:	2b00      	cmp	r3, #0
   18fe8:	dbf4      	blt.n	18fd4 <prvTimerTask+0x90>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
   18fea:	9c07      	ldr	r4, [sp, #28]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
   18fec:	6963      	ldr	r3, [r4, #20]
   18fee:	2b00      	cmp	r3, #0
   18ff0:	d002      	beq.n	18ff8 <prvTimerTask+0xb4>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   18ff2:	1d20      	adds	r0, r4, #4
   18ff4:	4b34      	ldr	r3, [pc, #208]	; (190c8 <prvTimerTask+0x184>)
   18ff6:	4798      	blx	r3
	xTimeNow = xTaskGetTickCount();
   18ff8:	4b2f      	ldr	r3, [pc, #188]	; (190b8 <prvTimerTask+0x174>)
   18ffa:	4798      	blx	r3
	if( xTimeNow < xLastTime )
   18ffc:	4e2f      	ldr	r6, [pc, #188]	; (190bc <prvTimerTask+0x178>)
	xTimeNow = xTaskGetTickCount();
   18ffe:	0005      	movs	r5, r0
	if( xTimeNow < xLastTime )
   19000:	6833      	ldr	r3, [r6, #0]
   19002:	4298      	cmp	r0, r3
   19004:	d201      	bcs.n	1900a <prvTimerTask+0xc6>
		prvSwitchTimerLists();
   19006:	4b2e      	ldr	r3, [pc, #184]	; (190c0 <prvTimerTask+0x17c>)
   19008:	4798      	blx	r3
   1900a:	9b05      	ldr	r3, [sp, #20]
	xLastTime = xTimeNow;
   1900c:	6035      	str	r5, [r6, #0]
   1900e:	2b09      	cmp	r3, #9
   19010:	d8e0      	bhi.n	18fd4 <prvTimerTask+0x90>
   19012:	2201      	movs	r2, #1
   19014:	409a      	lsls	r2, r3
   19016:	0016      	movs	r6, r2
   19018:	0013      	movs	r3, r2
   1901a:	403e      	ands	r6, r7
   1901c:	d138      	bne.n	19090 <prvTimerTask+0x14c>
   1901e:	22c7      	movs	r2, #199	; 0xc7
   19020:	4213      	tst	r3, r2
   19022:	d118      	bne.n	19056 <prvTimerTask+0x112>
   19024:	069b      	lsls	r3, r3, #26
   19026:	d5d5      	bpl.n	18fd4 <prvTimerTask+0x90>
						vPortFree( pxTimer );
   19028:	0020      	movs	r0, r4
   1902a:	4b2c      	ldr	r3, [pc, #176]	; (190dc <prvTimerTask+0x198>)
   1902c:	4798      	blx	r3
   1902e:	e7d1      	b.n	18fd4 <prvTimerTask+0x90>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
   19030:	4b2b      	ldr	r3, [pc, #172]	; (190e0 <prvTimerTask+0x19c>)
   19032:	681b      	ldr	r3, [r3, #0]
   19034:	681a      	ldr	r2, [r3, #0]
   19036:	4250      	negs	r0, r2
   19038:	4150      	adcs	r0, r2
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
   1903a:	4b26      	ldr	r3, [pc, #152]	; (190d4 <prvTimerTask+0x190>)
   1903c:	0002      	movs	r2, r0
   1903e:	1b39      	subs	r1, r7, r4
   19040:	6818      	ldr	r0, [r3, #0]
   19042:	4b28      	ldr	r3, [pc, #160]	; (190e4 <prvTimerTask+0x1a0>)
   19044:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
   19046:	47a8      	blx	r5
   19048:	2800      	cmp	r0, #0
   1904a:	d1c1      	bne.n	18fd0 <prvTimerTask+0x8c>
					portYIELD_WITHIN_API();
   1904c:	4b26      	ldr	r3, [pc, #152]	; (190e8 <prvTimerTask+0x1a4>)
   1904e:	4798      	blx	r3
   19050:	e7be      	b.n	18fd0 <prvTimerTask+0x8c>
			( void ) xTaskResumeAll();
   19052:	47a8      	blx	r5
   19054:	e7bc      	b.n	18fd0 <prvTimerTask+0x8c>
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
   19056:	9b06      	ldr	r3, [sp, #24]
   19058:	69a2      	ldr	r2, [r4, #24]
   1905a:	0020      	movs	r0, r4
   1905c:	1899      	adds	r1, r3, r2
   1905e:	002a      	movs	r2, r5
   19060:	4d1a      	ldr	r5, [pc, #104]	; (190cc <prvTimerTask+0x188>)
   19062:	9303      	str	r3, [sp, #12]
   19064:	47a8      	blx	r5
   19066:	2800      	cmp	r0, #0
   19068:	d0b4      	beq.n	18fd4 <prvTimerTask+0x90>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   1906a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1906c:	0020      	movs	r0, r4
   1906e:	4798      	blx	r3
						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   19070:	69e3      	ldr	r3, [r4, #28]
   19072:	2b01      	cmp	r3, #1
   19074:	d1ae      	bne.n	18fd4 <prvTimerTask+0x90>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
   19076:	69a3      	ldr	r3, [r4, #24]
   19078:	9a06      	ldr	r2, [sp, #24]
   1907a:	0020      	movs	r0, r4
   1907c:	18d2      	adds	r2, r2, r3
   1907e:	9600      	str	r6, [sp, #0]
   19080:	0033      	movs	r3, r6
   19082:	0031      	movs	r1, r6
   19084:	4c12      	ldr	r4, [pc, #72]	; (190d0 <prvTimerTask+0x18c>)
   19086:	47a0      	blx	r4
							configASSERT( xResult );
   19088:	2800      	cmp	r0, #0
   1908a:	d1a3      	bne.n	18fd4 <prvTimerTask+0x90>
   1908c:	b672      	cpsid	i
   1908e:	e7fe      	b.n	1908e <prvTimerTask+0x14a>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
   19090:	9906      	ldr	r1, [sp, #24]
   19092:	61a1      	str	r1, [r4, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
   19094:	2900      	cmp	r1, #0
   19096:	d101      	bne.n	1909c <prvTimerTask+0x158>
   19098:	b672      	cpsid	i
   1909a:	e7fe      	b.n	1909a <prvTimerTask+0x156>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
   1909c:	1949      	adds	r1, r1, r5
   1909e:	002b      	movs	r3, r5
   190a0:	002a      	movs	r2, r5
   190a2:	0020      	movs	r0, r4
   190a4:	4c09      	ldr	r4, [pc, #36]	; (190cc <prvTimerTask+0x188>)
   190a6:	47a0      	blx	r4
   190a8:	e794      	b.n	18fd4 <prvTimerTask+0x90>
   190aa:	46c0      	nop			; (mov r8, r8)
   190ac:	000229a9 	.word	0x000229a9
   190b0:	20003cbc 	.word	0x20003cbc
   190b4:	00018311 	.word	0x00018311
   190b8:	00018321 	.word	0x00018321
   190bc:	20003cec 	.word	0x20003cec
   190c0:	00018ed5 	.word	0x00018ed5
   190c4:	00018499 	.word	0x00018499
   190c8:	00016cc7 	.word	0x00016cc7
   190cc:	00018df9 	.word	0x00018df9
   190d0:	00018e7d 	.word	0x00018e7d
   190d4:	20003cf0 	.word	0x20003cf0
   190d8:	00017905 	.word	0x00017905
   190dc:	00016f39 	.word	0x00016f39
   190e0:	20003cc0 	.word	0x20003cc0
   190e4:	00017ec9 	.word	0x00017ec9
   190e8:	00016de1 	.word	0x00016de1

000190ec <advance_pointer>:
 };

 #pragma mark - Private Functions -

 static void advance_pointer(cbuf_handle_t cbuf)
 {
   190ec:	b570      	push	{r4, r5, r6, lr}
	 //assert(cbuf);

	 if(cbuf->full)
   190ee:	7c03      	ldrb	r3, [r0, #16]
 {
   190f0:	0004      	movs	r4, r0
   190f2:	4d09      	ldr	r5, [pc, #36]	; (19118 <advance_pointer+0x2c>)
	 if(cbuf->full)
   190f4:	2b00      	cmp	r3, #0
   190f6:	d004      	beq.n	19102 <advance_pointer+0x16>
	 {
		 cbuf->tail = (cbuf->tail + 1) % cbuf->max;
   190f8:	6883      	ldr	r3, [r0, #8]
   190fa:	68e1      	ldr	r1, [r4, #12]
   190fc:	1c58      	adds	r0, r3, #1
   190fe:	47a8      	blx	r5
   19100:	60a1      	str	r1, [r4, #8]
	 }

	 cbuf->head = (cbuf->head + 1) % cbuf->max;
   19102:	6863      	ldr	r3, [r4, #4]
   19104:	68e1      	ldr	r1, [r4, #12]
   19106:	1c58      	adds	r0, r3, #1
   19108:	47a8      	blx	r5

	 // We mark full because we will advance tail on the next time around
	 cbuf->full = (cbuf->head == cbuf->tail);
   1910a:	68a3      	ldr	r3, [r4, #8]
	 cbuf->head = (cbuf->head + 1) % cbuf->max;
   1910c:	6061      	str	r1, [r4, #4]
	 cbuf->full = (cbuf->head == cbuf->tail);
   1910e:	1a59      	subs	r1, r3, r1
   19110:	424a      	negs	r2, r1
   19112:	414a      	adcs	r2, r1
   19114:	7422      	strb	r2, [r4, #16]
 }
   19116:	bd70      	pop	{r4, r5, r6, pc}
   19118:	000259c9 	.word	0x000259c9

0001911c <circular_buf_init>:
 }

 #pragma mark - APIs -

 cbuf_handle_t circular_buf_init(uint8_t* buffer, size_t size)
 {
   1911c:	b570      	push	{r4, r5, r6, lr}
	// assert(buffer && size);

	 cbuf_handle_t cbuf = malloc(sizeof(circular_buf_t));
   1911e:	4b06      	ldr	r3, [pc, #24]	; (19138 <circular_buf_init+0x1c>)
 {
   19120:	0005      	movs	r5, r0
	 cbuf_handle_t cbuf = malloc(sizeof(circular_buf_t));
   19122:	2014      	movs	r0, #20
 {
   19124:	000c      	movs	r4, r1
	 cbuf_handle_t cbuf = malloc(sizeof(circular_buf_t));
   19126:	4798      	blx	r3

 void circular_buf_reset(cbuf_handle_t cbuf)
 {
	// assert(cbuf);

	 cbuf->head = 0;
   19128:	2300      	movs	r3, #0
	 cbuf->buffer = buffer;
   1912a:	6005      	str	r5, [r0, #0]
	 cbuf->max = size;
   1912c:	60c4      	str	r4, [r0, #12]
	 cbuf->head = 0;
   1912e:	6043      	str	r3, [r0, #4]
	 cbuf->tail = 0;
   19130:	6083      	str	r3, [r0, #8]
	 cbuf->full = false;
   19132:	7403      	strb	r3, [r0, #16]
 }
   19134:	bd70      	pop	{r4, r5, r6, pc}
   19136:	46c0      	nop			; (mov r8, r8)
   19138:	00022be9 	.word	0x00022be9

0001913c <circular_buf_put>:

	 return cbuf->max;
 }

 void circular_buf_put(cbuf_handle_t cbuf, uint8_t data)
 {
   1913c:	b510      	push	{r4, lr}
	 //assert(cbuf && cbuf->buffer);

	 cbuf->buffer[cbuf->head] = data;
   1913e:	6803      	ldr	r3, [r0, #0]
   19140:	6842      	ldr	r2, [r0, #4]
   19142:	5499      	strb	r1, [r3, r2]

	 advance_pointer(cbuf);
   19144:	4b01      	ldr	r3, [pc, #4]	; (1914c <circular_buf_put+0x10>)
   19146:	4798      	blx	r3
 }
   19148:	bd10      	pop	{r4, pc}
   1914a:	46c0      	nop			; (mov r8, r8)
   1914c:	000190ed 	.word	0x000190ed

00019150 <circular_buf_empty>:

	 return r;
 }

 bool circular_buf_empty(cbuf_handle_t cbuf)
 {
   19150:	2300      	movs	r3, #0
	 //assert(cbuf);

	 return (!cbuf->full && (cbuf->head == cbuf->tail));
   19152:	7c02      	ldrb	r2, [r0, #16]
   19154:	429a      	cmp	r2, r3
   19156:	d105      	bne.n	19164 <circular_buf_empty+0x14>
   19158:	6843      	ldr	r3, [r0, #4]
   1915a:	6880      	ldr	r0, [r0, #8]
   1915c:	1a1b      	subs	r3, r3, r0
   1915e:	4258      	negs	r0, r3
   19160:	4143      	adcs	r3, r0
   19162:	b2db      	uxtb	r3, r3
   19164:	0018      	movs	r0, r3
 }
   19166:	4770      	bx	lr

00019168 <circular_buf_get>:
 {
   19168:	b570      	push	{r4, r5, r6, lr}
	 if(!circular_buf_empty(cbuf))
   1916a:	4b0b      	ldr	r3, [pc, #44]	; (19198 <circular_buf_get+0x30>)
 {
   1916c:	0004      	movs	r4, r0
   1916e:	000e      	movs	r6, r1
	 if(!circular_buf_empty(cbuf))
   19170:	4798      	blx	r3
   19172:	1e05      	subs	r5, r0, #0
   19174:	d10c      	bne.n	19190 <circular_buf_get+0x28>
		 *data = cbuf->buffer[cbuf->tail];
   19176:	68a2      	ldr	r2, [r4, #8]
   19178:	6823      	ldr	r3, [r4, #0]
   1917a:	5c9b      	ldrb	r3, [r3, r2]
   1917c:	7033      	strb	r3, [r6, #0]
	 cbuf->tail = (cbuf->tail + 1) % cbuf->max;
   1917e:	68a3      	ldr	r3, [r4, #8]
	 cbuf->full = false;
   19180:	7420      	strb	r0, [r4, #16]
	 cbuf->tail = (cbuf->tail + 1) % cbuf->max;
   19182:	68e1      	ldr	r1, [r4, #12]
   19184:	1c58      	adds	r0, r3, #1
   19186:	4b05      	ldr	r3, [pc, #20]	; (1919c <circular_buf_get+0x34>)
   19188:	4798      	blx	r3
		 r = 0;
   1918a:	0028      	movs	r0, r5
	 cbuf->tail = (cbuf->tail + 1) % cbuf->max;
   1918c:	60a1      	str	r1, [r4, #8]
 }
   1918e:	bd70      	pop	{r4, r5, r6, pc}
	 int r = -1;
   19190:	2001      	movs	r0, #1
   19192:	4240      	negs	r0, r0
	 return r;
   19194:	e7fb      	b.n	1918e <circular_buf_get+0x26>
   19196:	46c0      	nop			; (mov r8, r8)
   19198:	00019151 	.word	0x00019151
   1919c:	000259c9 	.word	0x000259c9

000191a0 <usart_read_callback>:
 * @fn			void usart_read_callback(struct usart_module *const usart_module)
 * @brief		Callback called when the system finishes receives all the bytes requested from a UART read job
 * @note
 */
void usart_read_callback(struct usart_module *const usart_module)
{
   191a0:	b510      	push	{r4, lr}
    circular_buf_put(cbufRx, (uint8_t)latestRx);                      // Add the latest read character into the RX circular Buffer
   191a2:	4b07      	ldr	r3, [pc, #28]	; (191c0 <usart_read_callback+0x20>)
   191a4:	4c07      	ldr	r4, [pc, #28]	; (191c4 <usart_read_callback+0x24>)
   191a6:	6818      	ldr	r0, [r3, #0]
   191a8:	7821      	ldrb	r1, [r4, #0]
   191aa:	4b07      	ldr	r3, [pc, #28]	; (191c8 <usart_read_callback+0x28>)
   191ac:	4798      	blx	r3
    usart_read_buffer_job(&usart_instance, (uint8_t *)&latestRx, 1);  // Order the MCU to keep reading
   191ae:	2201      	movs	r2, #1
   191b0:	0021      	movs	r1, r4
   191b2:	4b06      	ldr	r3, [pc, #24]	; (191cc <usart_read_callback+0x2c>)
   191b4:	4806      	ldr	r0, [pc, #24]	; (191d0 <usart_read_callback+0x30>)
   191b6:	4798      	blx	r3
    CliCharReadySemaphoreGiveFromISR();                               // Give binary semaphore
   191b8:	4b06      	ldr	r3, [pc, #24]	; (191d4 <usart_read_callback+0x34>)
   191ba:	4798      	blx	r3
}
   191bc:	bd10      	pop	{r4, pc}
   191be:	46c0      	nop			; (mov r8, r8)
   191c0:	20005100 	.word	0x20005100
   191c4:	20005104 	.word	0x20005104
   191c8:	0001913d 	.word	0x0001913d
   191cc:	0001e0fd 	.word	0x0001e0fd
   191d0:	200050cc 	.word	0x200050cc
   191d4:	00013dc9 	.word	0x00013dc9

000191d8 <usart_write_callback>:
 * @fn			void usart_write_callback(struct usart_module *const usart_module)
 * @brief		Callback called when the system finishes sending all the bytes requested from a UART read job
 * @note
 */
void usart_write_callback(struct usart_module *const usart_module)
{
   191d8:	b510      	push	{r4, lr}
    if (circular_buf_get(cbufTx, (uint8_t *)&latestTx) != -1)  // Only continue if there are more characters to send
   191da:	4b07      	ldr	r3, [pc, #28]	; (191f8 <usart_write_callback+0x20>)
   191dc:	4c07      	ldr	r4, [pc, #28]	; (191fc <usart_write_callback+0x24>)
   191de:	6818      	ldr	r0, [r3, #0]
   191e0:	0021      	movs	r1, r4
   191e2:	4b07      	ldr	r3, [pc, #28]	; (19200 <usart_write_callback+0x28>)
   191e4:	4798      	blx	r3
   191e6:	1c43      	adds	r3, r0, #1
   191e8:	d004      	beq.n	191f4 <usart_write_callback+0x1c>
    {
        usart_write_buffer_job(&usart_instance, (uint8_t *)&latestTx, 1);
   191ea:	2201      	movs	r2, #1
   191ec:	0021      	movs	r1, r4
   191ee:	4805      	ldr	r0, [pc, #20]	; (19204 <usart_write_callback+0x2c>)
   191f0:	4b05      	ldr	r3, [pc, #20]	; (19208 <usart_write_callback+0x30>)
   191f2:	4798      	blx	r3
    }
}
   191f4:	bd10      	pop	{r4, pc}
   191f6:	46c0      	nop			; (mov r8, r8)
   191f8:	20005508 	.word	0x20005508
   191fc:	20005505 	.word	0x20005505
   19200:	00019169 	.word	0x00019169
   19204:	200050cc 	.word	0x200050cc
   19208:	0001e0dd 	.word	0x0001e0dd

0001920c <InitializeSerialConsole>:
    cbufRx = circular_buf_init((uint8_t *)rxCharacterBuffer, RX_BUFFER_SIZE);
   1920c:	2180      	movs	r1, #128	; 0x80
{
   1920e:	b530      	push	{r4, r5, lr}
    cbufRx = circular_buf_init((uint8_t *)rxCharacterBuffer, RX_BUFFER_SIZE);
   19210:	0089      	lsls	r1, r1, #2
{
   19212:	b091      	sub	sp, #68	; 0x44
    cbufRx = circular_buf_init((uint8_t *)rxCharacterBuffer, RX_BUFFER_SIZE);
   19214:	4c36      	ldr	r4, [pc, #216]	; (192f0 <InitializeSerialConsole+0xe4>)
   19216:	4837      	ldr	r0, [pc, #220]	; (192f4 <InitializeSerialConsole+0xe8>)
   19218:	47a0      	blx	r4
    cbufTx = circular_buf_init((uint8_t *)txCharacterBuffer, RX_BUFFER_SIZE);
   1921a:	2180      	movs	r1, #128	; 0x80
    cbufRx = circular_buf_init((uint8_t *)rxCharacterBuffer, RX_BUFFER_SIZE);
   1921c:	4b36      	ldr	r3, [pc, #216]	; (192f8 <InitializeSerialConsole+0xec>)
    cbufTx = circular_buf_init((uint8_t *)txCharacterBuffer, RX_BUFFER_SIZE);
   1921e:	0089      	lsls	r1, r1, #2
    cbufRx = circular_buf_init((uint8_t *)rxCharacterBuffer, RX_BUFFER_SIZE);
   19220:	6018      	str	r0, [r3, #0]
    cbufTx = circular_buf_init((uint8_t *)txCharacterBuffer, RX_BUFFER_SIZE);
   19222:	4836      	ldr	r0, [pc, #216]	; (192fc <InitializeSerialConsole+0xf0>)
   19224:	47a0      	blx	r4
   19226:	4b36      	ldr	r3, [pc, #216]	; (19300 <InitializeSerialConsole+0xf4>)
	Assert(config);

	/* Set default config in the config struct */
	config->data_order       = USART_DATAORDER_LSB;
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
	config->parity           = USART_PARITY_NONE;
   19228:	4669      	mov	r1, sp
   1922a:	6018      	str	r0, [r3, #0]
	config->data_order       = USART_DATAORDER_LSB;
   1922c:	2380      	movs	r3, #128	; 0x80
	config->parity           = USART_PARITY_NONE;
   1922e:	22ff      	movs	r2, #255	; 0xff
	config->data_order       = USART_DATAORDER_LSB;
   19230:	05db      	lsls	r3, r3, #23
   19232:	9300      	str	r3, [sp, #0]
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
   19234:	2300      	movs	r3, #0
	config->parity           = USART_PARITY_NONE;
   19236:	810a      	strh	r2, [r1, #8]
	config->stopbits         = USART_STOPBITS_1;
	config->character_size   = USART_CHARACTER_SIZE_8BIT;
	config->baudrate         = 9600;
	config->receiver_enable  = true;
   19238:	2201      	movs	r2, #1
	config->stopbits         = USART_STOPBITS_1;
   1923a:	728b      	strb	r3, [r1, #10]
	config->character_size   = USART_CHARACTER_SIZE_8BIT;
   1923c:	72cb      	strb	r3, [r1, #11]
	config->receiver_enable  = true;
   1923e:	3105      	adds	r1, #5
   19240:	77ca      	strb	r2, [r1, #31]
	config->transmitter_enable = true;
   19242:	4669      	mov	r1, sp
   19244:	3106      	adds	r1, #6
   19246:	77ca      	strb	r2, [r1, #31]
	config->clock_polarity_inverted = false;
   19248:	466a      	mov	r2, sp
   1924a:	3207      	adds	r2, #7
   1924c:	77d3      	strb	r3, [r2, #31]
	config->use_external_clock = false;
   1924e:	aa02      	add	r2, sp, #8
   19250:	77d3      	strb	r3, [r2, #31]
	config->ext_clock_freq   = 0;
	config->mux_setting      = USART_RX_1_TX_2_XCK_3;
	config->run_in_standby   = false;
   19252:	aa0b      	add	r2, sp, #44	; 0x2c
   19254:	7013      	strb	r3, [r2, #0]
	config->generator_source = GCLK_GENERATOR_0;
   19256:	222d      	movs	r2, #45	; 0x2d
   19258:	446a      	add	r2, sp
   1925a:	7013      	strb	r3, [r2, #0]
#ifdef FEATURE_USART_START_FRAME_DECTION
	config->start_frame_detection_enable            = false;
#endif
#ifdef FEATURE_USART_IRDA
	config->encoding_format_enable                  = false;
	config->receive_pulse_length                    = 19;
   1925c:	4669      	mov	r1, sp
	config->sample_rate           = USART_SAMPLE_RATE_16X_ARITHMETIC;
   1925e:	466a      	mov	r2, sp
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
   19260:	9301      	str	r3, [sp, #4]
	config->sample_rate           = USART_SAMPLE_RATE_16X_ARITHMETIC;
   19262:	8213      	strh	r3, [r2, #16]
	config->lin_slave_enable      = false;
   19264:	76d3      	strb	r3, [r2, #27]
	config->immediate_buffer_overflow_notification  = false;
   19266:	7613      	strb	r3, [r2, #24]
	config->start_frame_detection_enable            = false;
   19268:	7713      	strb	r3, [r2, #28]
	config->encoding_format_enable                  = false;
   1926a:	7653      	strb	r3, [r2, #25]
	config->ext_clock_freq   = 0;
   1926c:	930a      	str	r3, [sp, #40]	; 0x28
	config->sample_adjustment     = USART_SAMPLE_ADJUSTMENT_7_8_9;
   1926e:	9305      	str	r3, [sp, #20]
	config->iso7816_config.inhibit_nack             = ISO7816_INHIBIT_NACK_DISABLE;
	config->iso7816_config.successive_recv_nack     = ISO7816_SUCCESSIVE_RECV_NACK_DISABLE;
	config->iso7816_config.max_iterations           = 7;
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
	config->collision_detection_enable              = false;
   19270:	774b      	strb	r3, [r1, #29]
    config_usart.baudrate = 115200;
   19272:	23e1      	movs	r3, #225	; 0xe1
   19274:	025b      	lsls	r3, r3, #9
   19276:	9308      	str	r3, [sp, #32]
    config_usart.mux_setting = EDBG_CDC_SERCOM_MUX_SETTING;
   19278:	23c4      	movs	r3, #196	; 0xc4
   1927a:	039b      	lsls	r3, r3, #14
   1927c:	9303      	str	r3, [sp, #12]
    config_usart.pinmux_pad0 = EDBG_CDC_SERCOM_PINMUX_PAD0;
   1927e:	2301      	movs	r3, #1
	config->receive_pulse_length                    = 19;
   19280:	2213      	movs	r2, #19
   19282:	425b      	negs	r3, r3
   19284:	930c      	str	r3, [sp, #48]	; 0x30
    config_usart.pinmux_pad1 = EDBG_CDC_SERCOM_PINMUX_PAD1;
   19286:	930d      	str	r3, [sp, #52]	; 0x34
    config_usart.pinmux_pad2 = EDBG_CDC_SERCOM_PINMUX_PAD2;
   19288:	4b1e      	ldr	r3, [pc, #120]	; (19304 <InitializeSerialConsole+0xf8>)
   1928a:	768a      	strb	r2, [r1, #26]
   1928c:	930e      	str	r3, [sp, #56]	; 0x38
    config_usart.pinmux_pad3 = EDBG_CDC_SERCOM_PINMUX_PAD3;
   1928e:	4b1e      	ldr	r3, [pc, #120]	; (19308 <InitializeSerialConsole+0xfc>)
   19290:	930f      	str	r3, [sp, #60]	; 0x3c
    while (usart_init(&usart_instance, EDBG_CDC_MODULE, &config_usart) != STATUS_OK) {
   19292:	4c1e      	ldr	r4, [pc, #120]	; (1930c <InitializeSerialConsole+0x100>)
   19294:	466a      	mov	r2, sp
   19296:	491e      	ldr	r1, [pc, #120]	; (19310 <InitializeSerialConsole+0x104>)
   19298:	0020      	movs	r0, r4
   1929a:	4b1e      	ldr	r3, [pc, #120]	; (19314 <InitializeSerialConsole+0x108>)
   1929c:	4798      	blx	r3
   1929e:	2800      	cmp	r0, #0
   192a0:	d1f7      	bne.n	19292 <InitializeSerialConsole+0x86>
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
   192a2:	6825      	ldr	r5, [r4, #0]

#if USART_CALLBACK_MODE == true
	/* Enable Global interrupt for module */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
   192a4:	4b1c      	ldr	r3, [pc, #112]	; (19318 <InitializeSerialConsole+0x10c>)
   192a6:	0028      	movs	r0, r5
   192a8:	4798      	blx	r3
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
   192aa:	231f      	movs	r3, #31
   192ac:	4018      	ands	r0, r3
   192ae:	3b1e      	subs	r3, #30
   192b0:	4083      	lsls	r3, r0
   192b2:	4a1a      	ldr	r2, [pc, #104]	; (1931c <InitializeSerialConsole+0x110>)
   192b4:	6013      	str	r3, [r2, #0]
	SercomUsart *const usart_hw = &(module->hw->USART);
   192b6:	6823      	ldr	r3, [r4, #0]
	return (usart_hw->SYNCBUSY.reg);
   192b8:	69da      	ldr	r2, [r3, #28]
	while (usart_is_syncing(module)) {
   192ba:	2a00      	cmp	r2, #0
   192bc:	d1fc      	bne.n	192b8 <InitializeSerialConsole+0xac>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Enable USART module */
	usart_hw->CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
   192be:	2302      	movs	r3, #2
   192c0:	6829      	ldr	r1, [r5, #0]
    usart_register_callback(&usart_instance, usart_write_callback, USART_CALLBACK_BUFFER_TRANSMITTED);
   192c2:	0020      	movs	r0, r4
   192c4:	430b      	orrs	r3, r1
   192c6:	602b      	str	r3, [r5, #0]
   192c8:	4915      	ldr	r1, [pc, #84]	; (19320 <InitializeSerialConsole+0x114>)
   192ca:	4d16      	ldr	r5, [pc, #88]	; (19324 <InitializeSerialConsole+0x118>)
   192cc:	47a8      	blx	r5
    usart_register_callback(&usart_instance, usart_read_callback, USART_CALLBACK_BUFFER_RECEIVED);
   192ce:	0020      	movs	r0, r4
   192d0:	2201      	movs	r2, #1
   192d2:	4915      	ldr	r1, [pc, #84]	; (19328 <InitializeSerialConsole+0x11c>)
   192d4:	47a8      	blx	r5
{
	/* Sanity check arguments */
	Assert(module);

	/* Enable callback */
	module->callback_enable_mask |= (1 << callback_type);
   192d6:	0022      	movs	r2, r4
   192d8:	2303      	movs	r3, #3
   192da:	3231      	adds	r2, #49	; 0x31
   192dc:	7811      	ldrb	r1, [r2, #0]
    usart_read_buffer_job(&usart_instance, (uint8_t *)&latestRx, 1);  // Kicks off constant reading of characters
   192de:	0020      	movs	r0, r4
   192e0:	430b      	orrs	r3, r1
   192e2:	7013      	strb	r3, [r2, #0]
   192e4:	4911      	ldr	r1, [pc, #68]	; (1932c <InitializeSerialConsole+0x120>)
   192e6:	2201      	movs	r2, #1
   192e8:	4b11      	ldr	r3, [pc, #68]	; (19330 <InitializeSerialConsole+0x124>)
   192ea:	4798      	blx	r3
}
   192ec:	b011      	add	sp, #68	; 0x44
   192ee:	bd30      	pop	{r4, r5, pc}
   192f0:	0001911d 	.word	0x0001911d
   192f4:	20005305 	.word	0x20005305
   192f8:	20005100 	.word	0x20005100
   192fc:	20005105 	.word	0x20005105
   19300:	20005508 	.word	0x20005508
   19304:	002a0003 	.word	0x002a0003
   19308:	002b0003 	.word	0x002b0003
   1930c:	200050cc 	.word	0x200050cc
   19310:	42001800 	.word	0x42001800
   19314:	0001dd71 	.word	0x0001dd71
   19318:	0001d699 	.word	0x0001d699
   1931c:	e000e100 	.word	0xe000e100
   19320:	000191d9 	.word	0x000191d9
   19324:	0001e0c5 	.word	0x0001e0c5
   19328:	000191a1 	.word	0x000191a1
   1932c:	20005104 	.word	0x20005104
   19330:	0001e0fd 	.word	0x0001e0fd

00019334 <SerialConsoleWriteString>:
{
   19334:	b570      	push	{r4, r5, r6, lr}
    vTaskSuspendAll();
   19336:	4b13      	ldr	r3, [pc, #76]	; (19384 <SerialConsoleWriteString+0x50>)
{
   19338:	0005      	movs	r5, r0
   1933a:	2400      	movs	r4, #0
    vTaskSuspendAll();
   1933c:	4798      	blx	r3
    if (string != NULL) {
   1933e:	2d00      	cmp	r5, #0
   19340:	d108      	bne.n	19354 <SerialConsoleWriteString+0x20>
    xTaskResumeAll();
   19342:	4b11      	ldr	r3, [pc, #68]	; (19388 <SerialConsoleWriteString+0x54>)
   19344:	4798      	blx	r3
}
   19346:	bd70      	pop	{r4, r5, r6, pc}
            circular_buf_put(cbufTx, string[iter]);
   19348:	4b10      	ldr	r3, [pc, #64]	; (1938c <SerialConsoleWriteString+0x58>)
   1934a:	5d29      	ldrb	r1, [r5, r4]
   1934c:	6818      	ldr	r0, [r3, #0]
   1934e:	4b10      	ldr	r3, [pc, #64]	; (19390 <SerialConsoleWriteString+0x5c>)
   19350:	4798      	blx	r3
        for (size_t iter = 0; iter < strlen(string); iter++) {
   19352:	3401      	adds	r4, #1
   19354:	0028      	movs	r0, r5
   19356:	4b0f      	ldr	r3, [pc, #60]	; (19394 <SerialConsoleWriteString+0x60>)
   19358:	4798      	blx	r3
   1935a:	4284      	cmp	r4, r0
   1935c:	d3f4      	bcc.n	19348 <SerialConsoleWriteString+0x14>
        if (usart_get_job_status(&usart_instance, USART_TRANSCEIVER_TX) == STATUS_OK) {
   1935e:	4c0e      	ldr	r4, [pc, #56]	; (19398 <SerialConsoleWriteString+0x64>)
   19360:	2101      	movs	r1, #1
   19362:	0020      	movs	r0, r4
   19364:	4b0d      	ldr	r3, [pc, #52]	; (1939c <SerialConsoleWriteString+0x68>)
   19366:	4798      	blx	r3
   19368:	2800      	cmp	r0, #0
   1936a:	d1ea      	bne.n	19342 <SerialConsoleWriteString+0xe>
            circular_buf_get(cbufTx, (uint8_t *)&latestTx);  // Perform only if the SERCOM TX is free (not busy)
   1936c:	4d0c      	ldr	r5, [pc, #48]	; (193a0 <SerialConsoleWriteString+0x6c>)
   1936e:	4b07      	ldr	r3, [pc, #28]	; (1938c <SerialConsoleWriteString+0x58>)
   19370:	0029      	movs	r1, r5
   19372:	6818      	ldr	r0, [r3, #0]
   19374:	4b0b      	ldr	r3, [pc, #44]	; (193a4 <SerialConsoleWriteString+0x70>)
   19376:	4798      	blx	r3
            usart_write_buffer_job(&usart_instance, (uint8_t *)&latestTx, 1);
   19378:	2201      	movs	r2, #1
   1937a:	0029      	movs	r1, r5
   1937c:	0020      	movs	r0, r4
   1937e:	4b0a      	ldr	r3, [pc, #40]	; (193a8 <SerialConsoleWriteString+0x74>)
   19380:	4798      	blx	r3
   19382:	e7de      	b.n	19342 <SerialConsoleWriteString+0xe>
   19384:	00018311 	.word	0x00018311
   19388:	00018499 	.word	0x00018499
   1938c:	20005508 	.word	0x20005508
   19390:	0001913d 	.word	0x0001913d
   19394:	000238c3 	.word	0x000238c3
   19398:	200050cc 	.word	0x200050cc
   1939c:	0001e11d 	.word	0x0001e11d
   193a0:	20005505 	.word	0x20005505
   193a4:	00019169 	.word	0x00019169
   193a8:	0001e0dd 	.word	0x0001e0dd

000193ac <SerialConsoleReadCharacter>:
{
   193ac:	b510      	push	{r4, lr}
   193ae:	0004      	movs	r4, r0
    vTaskSuspendAll();
   193b0:	4b05      	ldr	r3, [pc, #20]	; (193c8 <SerialConsoleReadCharacter+0x1c>)
   193b2:	4798      	blx	r3
    int a = circular_buf_get(cbufRx, (uint8_t *)rxChar);
   193b4:	4b05      	ldr	r3, [pc, #20]	; (193cc <SerialConsoleReadCharacter+0x20>)
   193b6:	0021      	movs	r1, r4
   193b8:	6818      	ldr	r0, [r3, #0]
   193ba:	4b05      	ldr	r3, [pc, #20]	; (193d0 <SerialConsoleReadCharacter+0x24>)
   193bc:	4798      	blx	r3
   193be:	0004      	movs	r4, r0
    xTaskResumeAll();
   193c0:	4b04      	ldr	r3, [pc, #16]	; (193d4 <SerialConsoleReadCharacter+0x28>)
   193c2:	4798      	blx	r3
}
   193c4:	0020      	movs	r0, r4
   193c6:	bd10      	pop	{r4, pc}
   193c8:	00018311 	.word	0x00018311
   193cc:	20005100 	.word	0x20005100
   193d0:	00019169 	.word	0x00019169
   193d4:	00018499 	.word	0x00018499

000193d8 <LogMessage>:
{
   193d8:	b40e      	push	{r1, r2, r3}
   193da:	b533      	push	{r0, r1, r4, r5, lr}
    return currentDebugLevel;
   193dc:	4b09      	ldr	r3, [pc, #36]	; (19404 <LogMessage+0x2c>)
    if (getLogLevel() <= level) {
   193de:	781b      	ldrb	r3, [r3, #0]
   193e0:	4283      	cmp	r3, r0
   193e2:	d80a      	bhi.n	193fa <LogMessage+0x22>
        vsnprintf(debugBuffer, 127, format, ap);
   193e4:	4c08      	ldr	r4, [pc, #32]	; (19408 <LogMessage+0x30>)
        va_start(ap, format);
   193e6:	ab06      	add	r3, sp, #24
   193e8:	9301      	str	r3, [sp, #4]
        vsnprintf(debugBuffer, 127, format, ap);
   193ea:	9a05      	ldr	r2, [sp, #20]
   193ec:	217f      	movs	r1, #127	; 0x7f
   193ee:	0020      	movs	r0, r4
   193f0:	4d06      	ldr	r5, [pc, #24]	; (1940c <LogMessage+0x34>)
   193f2:	47a8      	blx	r5
        SerialConsoleWriteString(debugBuffer);
   193f4:	0020      	movs	r0, r4
   193f6:	4b06      	ldr	r3, [pc, #24]	; (19410 <LogMessage+0x38>)
   193f8:	4798      	blx	r3
};
   193fa:	bc33      	pop	{r0, r1, r4, r5}
   193fc:	bc08      	pop	{r3}
   193fe:	b003      	add	sp, #12
   19400:	4718      	bx	r3
   19402:	46c0      	nop			; (mov r8, r8)
   19404:	20003cf8 	.word	0x20003cf8
   19408:	2000504c 	.word	0x2000504c
   1940c:	00023afd 	.word	0x00023afd
   19410:	00019335 	.word	0x00019335

00019414 <LogMessageDebug>:
{
   19414:	b40f      	push	{r0, r1, r2, r3}
   19416:	b510      	push	{r4, lr}
    LogMessage(LOG_DEBUG_LVL, format);
   19418:	9902      	ldr	r1, [sp, #8]
   1941a:	2001      	movs	r0, #1
   1941c:	4b02      	ldr	r3, [pc, #8]	; (19428 <LogMessageDebug+0x14>)
   1941e:	4798      	blx	r3
};
   19420:	bc10      	pop	{r4}
   19422:	bc08      	pop	{r3}
   19424:	b004      	add	sp, #16
   19426:	4718      	bx	r3
   19428:	000193d9 	.word	0x000193d9

0001942c <SDMMC_UNSTUFF_BITS>:
 * \brief Macro function to extract a bits field from a large SD MMC register
 * Used by : CSD, SCR, Switch status
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
   1942c:	b570      	push	{r4, r5, r6, lr}
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
   1942e:	2507      	movs	r5, #7
   19430:	1a8c      	subs	r4, r1, r2
   19432:	3407      	adds	r4, #7
   19434:	17e1      	asrs	r1, r4, #31
   19436:	4029      	ands	r1, r5
   19438:	1909      	adds	r1, r1, r4
   1943a:	10c9      	asrs	r1, r1, #3
   1943c:	1840      	adds	r0, r0, r1
   1943e:	1e41      	subs	r1, r0, #1
   19440:	402a      	ands	r2, r5
   19442:	7809      	ldrb	r1, [r1, #0]
	if (((pos % 8) + size) > 8) {
   19444:	18d6      	adds	r6, r2, r3
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
   19446:	4111      	asrs	r1, r2
	if (((pos % 8) + size) > 8) {
   19448:	2e08      	cmp	r6, #8
   1944a:	dd0d      	ble.n	19468 <SDMMC_UNSTUFF_BITS+0x3c>
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
   1944c:	1e84      	subs	r4, r0, #2
   1944e:	7824      	ldrb	r4, [r4, #0]
   19450:	3501      	adds	r5, #1
   19452:	1aad      	subs	r5, r5, r2
   19454:	40ac      	lsls	r4, r5
   19456:	4321      	orrs	r1, r4
	}
	if (((pos % 8) + size) > 16) {
   19458:	2e10      	cmp	r6, #16
   1945a:	dd05      	ble.n	19468 <SDMMC_UNSTUFF_BITS+0x3c>
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
   1945c:	2410      	movs	r4, #16
   1945e:	3803      	subs	r0, #3
   19460:	7800      	ldrb	r0, [r0, #0]
   19462:	1aa2      	subs	r2, r4, r2
   19464:	4090      	lsls	r0, r2
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
   19466:	4301      	orrs	r1, r0
	}
	value &=  ((uint32_t)1 << size) - 1;
   19468:	2001      	movs	r0, #1
   1946a:	4098      	lsls	r0, r3
   1946c:	3801      	subs	r0, #1
   1946e:	4008      	ands	r0, r1
	return value;
}
   19470:	bd70      	pop	{r4, r5, r6, pc}
	...

00019474 <sd_mmc_configure_slot>:

/**
 * \brief Configures the driver with the selected card configuration
 */
static void sd_mmc_configure_slot(void)
{
   19474:	b510      	push	{r4, lr}
	driver_select_device(sd_mmc_slot_sel, sd_mmc_card->clock,
   19476:	4b06      	ldr	r3, [pc, #24]	; (19490 <sd_mmc_configure_slot+0x1c>)
   19478:	4806      	ldr	r0, [pc, #24]	; (19494 <sd_mmc_configure_slot+0x20>)
   1947a:	6819      	ldr	r1, [r3, #0]
   1947c:	7800      	ldrb	r0, [r0, #0]
   1947e:	7f8b      	ldrb	r3, [r1, #30]
   19480:	4c05      	ldr	r4, [pc, #20]	; (19498 <sd_mmc_configure_slot+0x24>)
   19482:	1e5a      	subs	r2, r3, #1
   19484:	4193      	sbcs	r3, r2
   19486:	7b4a      	ldrb	r2, [r1, #13]
   19488:	b2db      	uxtb	r3, r3
   1948a:	6809      	ldr	r1, [r1, #0]
   1948c:	47a0      	blx	r4
			sd_mmc_card->bus_width, sd_mmc_card->high_speed);
}
   1948e:	bd10      	pop	{r4, pc}
   19490:	20003cfc 	.word	0x20003cfc
   19494:	20003d24 	.word	0x20003d24
   19498:	00019fd1 	.word	0x00019fd1

0001949c <sd_mmc_cmd13>:
{
   1949c:	b570      	push	{r4, r5, r6, lr}
			if (!(driver_get_response() & 0xFF)) {
   1949e:	26ff      	movs	r6, #255	; 0xff
{
   194a0:	4d08      	ldr	r5, [pc, #32]	; (194c4 <sd_mmc_cmd13+0x28>)
			if (!driver_send_cmd(SDMMC_SPI_CMD13_SEND_STATUS, 0)) {
   194a2:	2100      	movs	r1, #0
   194a4:	4808      	ldr	r0, [pc, #32]	; (194c8 <sd_mmc_cmd13+0x2c>)
   194a6:	4b09      	ldr	r3, [pc, #36]	; (194cc <sd_mmc_cmd13+0x30>)
   194a8:	4798      	blx	r3
   194aa:	1e04      	subs	r4, r0, #0
   194ac:	d102      	bne.n	194b4 <sd_mmc_cmd13+0x18>
				return false;
   194ae:	2400      	movs	r4, #0
}
   194b0:	0020      	movs	r0, r4
   194b2:	bd70      	pop	{r4, r5, r6, pc}
			if (!(driver_get_response() & 0xFF)) {
   194b4:	4b06      	ldr	r3, [pc, #24]	; (194d0 <sd_mmc_cmd13+0x34>)
   194b6:	4798      	blx	r3
   194b8:	4230      	tst	r0, r6
   194ba:	d0f9      	beq.n	194b0 <sd_mmc_cmd13+0x14>
   194bc:	3d01      	subs	r5, #1
		if (nec_timeout-- == 0) {
   194be:	2d00      	cmp	r5, #0
   194c0:	d1ef      	bne.n	194a2 <sd_mmc_cmd13+0x6>
   194c2:	e7f4      	b.n	194ae <sd_mmc_cmd13+0x12>
   194c4:	00030d41 	.word	0x00030d41
   194c8:	00001b0d 	.word	0x00001b0d
   194cc:	0001a1dd 	.word	0x0001a1dd
   194d0:	0001a1f1 	.word	0x0001a1f1

000194d4 <sd_mmc_deselect_slot>:

/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
   194d4:	b510      	push	{r4, lr}
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
   194d6:	4b03      	ldr	r3, [pc, #12]	; (194e4 <sd_mmc_deselect_slot+0x10>)
   194d8:	7818      	ldrb	r0, [r3, #0]
   194da:	2800      	cmp	r0, #0
   194dc:	d101      	bne.n	194e2 <sd_mmc_deselect_slot+0xe>
		driver_deselect_device(sd_mmc_slot_sel);
   194de:	4b02      	ldr	r3, [pc, #8]	; (194e8 <sd_mmc_deselect_slot+0x14>)
   194e0:	4798      	blx	r3
	}
}
   194e2:	bd10      	pop	{r4, pc}
   194e4:	20003d24 	.word	0x20003d24
   194e8:	0001a025 	.word	0x0001a025

000194ec <sd_mmc_select_slot>:
{
   194ec:	b510      	push	{r4, lr}
		return SD_MMC_ERR_SLOT;
   194ee:	2304      	movs	r3, #4
	if (slot >= SD_MMC_MEM_CNT) {
   194f0:	2800      	cmp	r0, #0
   194f2:	d117      	bne.n	19524 <sd_mmc_select_slot+0x38>
	if ((sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD)
   194f4:	4c0c      	ldr	r4, [pc, #48]	; (19528 <sd_mmc_select_slot+0x3c>)
			|| (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE)) {
   194f6:	7aa3      	ldrb	r3, [r4, #10]
	if ((sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD)
   194f8:	3b03      	subs	r3, #3
   194fa:	2b01      	cmp	r3, #1
   194fc:	d806      	bhi.n	1950c <sd_mmc_select_slot+0x20>
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
   194fe:	2302      	movs	r3, #2
   19500:	72a3      	strb	r3, [r4, #10]
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
   19502:	4b0a      	ldr	r3, [pc, #40]	; (1952c <sd_mmc_select_slot+0x40>)
		sd_mmc_cards[slot].high_speed = 0;
   19504:	77a0      	strb	r0, [r4, #30]
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
   19506:	6023      	str	r3, [r4, #0]
		sd_mmc_cards[slot].bus_width = 1;
   19508:	2301      	movs	r3, #1
   1950a:	7363      	strb	r3, [r4, #13]
	sd_mmc_slot_sel = slot;
   1950c:	2200      	movs	r2, #0
   1950e:	4b08      	ldr	r3, [pc, #32]	; (19530 <sd_mmc_select_slot+0x44>)
   19510:	701a      	strb	r2, [r3, #0]
	sd_mmc_card = &sd_mmc_cards[slot];
   19512:	4b08      	ldr	r3, [pc, #32]	; (19534 <sd_mmc_select_slot+0x48>)
   19514:	601c      	str	r4, [r3, #0]
	sd_mmc_configure_slot();
   19516:	4b08      	ldr	r3, [pc, #32]	; (19538 <sd_mmc_select_slot+0x4c>)
   19518:	4798      	blx	r3
			SD_MMC_INIT_ONGOING : SD_MMC_OK;
   1951a:	7aa3      	ldrb	r3, [r4, #10]
   1951c:	3b02      	subs	r3, #2
   1951e:	4258      	negs	r0, r3
   19520:	4143      	adcs	r3, r0
   19522:	b2db      	uxtb	r3, r3
}
   19524:	0018      	movs	r0, r3
   19526:	bd10      	pop	{r4, pc}
   19528:	20003d00 	.word	0x20003d00
   1952c:	00061a80 	.word	0x00061a80
   19530:	20003d24 	.word	0x20003d24
   19534:	20003cfc 	.word	0x20003cfc
   19538:	00019475 	.word	0x00019475

0001953c <sd_mmc_cmd9_spi>:
{
   1953c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if (!driver_adtc_start(SDMMC_SPI_CMD9_SEND_CSD, (uint32_t)sd_mmc_card->rca << 16,
   1953e:	2401      	movs	r4, #1
   19540:	4d0b      	ldr	r5, [pc, #44]	; (19570 <sd_mmc_cmd9_spi+0x34>)
   19542:	2210      	movs	r2, #16
   19544:	682b      	ldr	r3, [r5, #0]
   19546:	480b      	ldr	r0, [pc, #44]	; (19574 <sd_mmc_cmd9_spi+0x38>)
   19548:	8919      	ldrh	r1, [r3, #8]
   1954a:	4e0b      	ldr	r6, [pc, #44]	; (19578 <sd_mmc_cmd9_spi+0x3c>)
   1954c:	0409      	lsls	r1, r1, #16
   1954e:	9400      	str	r4, [sp, #0]
   19550:	0023      	movs	r3, r4
   19552:	47b0      	blx	r6
   19554:	2800      	cmp	r0, #0
   19556:	d101      	bne.n	1955c <sd_mmc_cmd9_spi+0x20>
		return false;
   19558:	2000      	movs	r0, #0
}
   1955a:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
	if (!driver_start_read_blocks(sd_mmc_card->csd, 1)) {
   1955c:	6828      	ldr	r0, [r5, #0]
   1955e:	0021      	movs	r1, r4
   19560:	300e      	adds	r0, #14
   19562:	4b06      	ldr	r3, [pc, #24]	; (1957c <sd_mmc_cmd9_spi+0x40>)
   19564:	4798      	blx	r3
   19566:	2800      	cmp	r0, #0
   19568:	d0f6      	beq.n	19558 <sd_mmc_cmd9_spi+0x1c>
	return driver_wait_end_of_read_blocks();
   1956a:	4b05      	ldr	r3, [pc, #20]	; (19580 <sd_mmc_cmd9_spi+0x44>)
   1956c:	4798      	blx	r3
   1956e:	e7f4      	b.n	1955a <sd_mmc_cmd9_spi+0x1e>
   19570:	20003cfc 	.word	0x20003cfc
   19574:	00081109 	.word	0x00081109
   19578:	0001a081 	.word	0x0001a081
   1957c:	0001a26d 	.word	0x0001a26d
   19580:	0001a2d5 	.word	0x0001a2d5

00019584 <sd_mmc_init>:
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
   19584:	2204      	movs	r2, #4
{
   19586:	b510      	push	{r4, lr}
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
   19588:	4b03      	ldr	r3, [pc, #12]	; (19598 <sd_mmc_init+0x14>)
   1958a:	729a      	strb	r2, [r3, #10]
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
   1958c:	4b03      	ldr	r3, [pc, #12]	; (1959c <sd_mmc_init+0x18>)
   1958e:	32fb      	adds	r2, #251	; 0xfb
   19590:	701a      	strb	r2, [r3, #0]
	driver_init();
   19592:	4b03      	ldr	r3, [pc, #12]	; (195a0 <sd_mmc_init+0x1c>)
   19594:	4798      	blx	r3
}
   19596:	bd10      	pop	{r4, pc}
   19598:	20003d00 	.word	0x20003d00
   1959c:	20003d24 	.word	0x20003d24
   195a0:	00019ed9 	.word	0x00019ed9

000195a4 <sd_mmc_check>:
{
	return SD_MMC_MEM_CNT;
}

sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
   195a4:	b5f0      	push	{r4, r5, r6, r7, lr}
	sd_mmc_err_t sd_mmc_err;

	sd_mmc_err = sd_mmc_select_slot(slot);
   195a6:	4bca      	ldr	r3, [pc, #808]	; (198d0 <sd_mmc_check+0x32c>)
{
   195a8:	b089      	sub	sp, #36	; 0x24
	sd_mmc_err = sd_mmc_select_slot(slot);
   195aa:	4798      	blx	r3
   195ac:	9002      	str	r0, [sp, #8]
	if (sd_mmc_err != SD_MMC_INIT_ONGOING) {
   195ae:	2801      	cmp	r0, #1
   195b0:	d004      	beq.n	195bc <sd_mmc_check+0x18>
	// Initialization of the card requested
	if (sd_mmc_is_spi()? sd_mmc_spi_card_init()
			: sd_mmc_mci_card_init()) {
		sd_mmc_debug("SD/MMC card ready\n\r");
		sd_mmc_card->state = SD_MMC_CARD_STATE_READY;
		sd_mmc_deselect_slot();
   195b2:	4bc8      	ldr	r3, [pc, #800]	; (198d4 <sd_mmc_check+0x330>)
   195b4:	4798      	blx	r3
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
	sd_mmc_deselect_slot();
	return SD_MMC_ERR_UNUSABLE;
}
   195b6:	9802      	ldr	r0, [sp, #8]
   195b8:	b009      	add	sp, #36	; 0x24
   195ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
	sd_mmc_card->type = CARD_TYPE_SD;
   195bc:	466a      	mov	r2, sp
	sd_mmc_card->version = CARD_VER_UNKNOWN;
   195be:	2400      	movs	r4, #0
	sd_mmc_card->type = CARD_TYPE_SD;
   195c0:	4dc5      	ldr	r5, [pc, #788]	; (198d8 <sd_mmc_check+0x334>)
   195c2:	7a12      	ldrb	r2, [r2, #8]
   195c4:	682b      	ldr	r3, [r5, #0]
	sd_mmc_card->version = CARD_VER_UNKNOWN;
   195c6:	731c      	strb	r4, [r3, #12]
	sd_mmc_card->rca = 0;
   195c8:	811c      	strh	r4, [r3, #8]
	sd_mmc_card->type = CARD_TYPE_SD;
   195ca:	72da      	strb	r2, [r3, #11]
	driver_send_clock();
   195cc:	4bc3      	ldr	r3, [pc, #780]	; (198dc <sd_mmc_check+0x338>)
   195ce:	4798      	blx	r3
	if (!driver_send_cmd(SDMMC_SPI_CMD0_GO_IDLE_STATE, 0)) {
   195d0:	2088      	movs	r0, #136	; 0x88
   195d2:	0021      	movs	r1, r4
   195d4:	0140      	lsls	r0, r0, #5
   195d6:	4cc2      	ldr	r4, [pc, #776]	; (198e0 <sd_mmc_check+0x33c>)
   195d8:	47a0      	blx	r4
   195da:	2800      	cmp	r0, #0
   195dc:	d012      	beq.n	19604 <sd_mmc_check+0x60>
	if (!driver_send_cmd(SD_CMD8_SEND_IF_COND,
   195de:	26d5      	movs	r6, #213	; 0xd5
   195e0:	0076      	lsls	r6, r6, #1
   195e2:	0031      	movs	r1, r6
   195e4:	48bf      	ldr	r0, [pc, #764]	; (198e4 <sd_mmc_check+0x340>)
   195e6:	47a0      	blx	r4
   195e8:	2800      	cmp	r0, #0
   195ea:	d100      	bne.n	195ee <sd_mmc_check+0x4a>
   195ec:	e1a2      	b.n	19934 <sd_mmc_check+0x390>
	resp = driver_get_response();
   195ee:	4bbe      	ldr	r3, [pc, #760]	; (198e8 <sd_mmc_check+0x344>)
   195f0:	4798      	blx	r3
	if (resp == 0xFFFFFFFF) {
   195f2:	1c43      	adds	r3, r0, #1
   195f4:	d100      	bne.n	195f8 <sd_mmc_check+0x54>
   195f6:	e19d      	b.n	19934 <sd_mmc_check+0x390>
	if ((resp & (SD_CMD8_MASK_PATTERN | SD_CMD8_MASK_VOLTAGE))
   195f8:	0500      	lsls	r0, r0, #20
   195fa:	0d00      	lsrs	r0, r0, #20
	*v2 = 1;
   195fc:	9b02      	ldr	r3, [sp, #8]
	if ((resp & (SD_CMD8_MASK_PATTERN | SD_CMD8_MASK_VOLTAGE))
   195fe:	42b0      	cmp	r0, r6
   19600:	d100      	bne.n	19604 <sd_mmc_check+0x60>
   19602:	e198      	b.n	19936 <sd_mmc_check+0x392>
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
   19604:	2403      	movs	r4, #3
   19606:	4bb4      	ldr	r3, [pc, #720]	; (198d8 <sd_mmc_check+0x334>)
   19608:	681b      	ldr	r3, [r3, #0]
   1960a:	729c      	strb	r4, [r3, #10]
	sd_mmc_deselect_slot();
   1960c:	4bb1      	ldr	r3, [pc, #708]	; (198d4 <sd_mmc_check+0x330>)
   1960e:	4798      	blx	r3
	return SD_MMC_ERR_UNUSABLE;
   19610:	9402      	str	r4, [sp, #8]
   19612:	e7d0      	b.n	195b6 <sd_mmc_check+0x12>
	if (!driver_send_cmd(SDMMC_SPI_CMD58_READ_OCR, 0)) {
   19614:	48b5      	ldr	r0, [pc, #724]	; (198ec <sd_mmc_check+0x348>)
   19616:	47a0      	blx	r4
   19618:	2800      	cmp	r0, #0
   1961a:	d100      	bne.n	1961e <sd_mmc_check+0x7a>
   1961c:	e1a6      	b.n	1996c <sd_mmc_check+0x3c8>
	if ((driver_get_response() & OCR_CCS) != 0) {
   1961e:	47b8      	blx	r7
   19620:	0043      	lsls	r3, r0, #1
   19622:	d504      	bpl.n	1962e <sd_mmc_check+0x8a>
		sd_mmc_card->type |= CARD_TYPE_HC;
   19624:	2308      	movs	r3, #8
   19626:	682a      	ldr	r2, [r5, #0]
   19628:	7ad1      	ldrb	r1, [r2, #11]
   1962a:	430b      	orrs	r3, r1
   1962c:	72d3      	strb	r3, [r2, #11]
		if (!driver_send_cmd(SDMMC_SPI_CMD59_CRC_ON_OFF, 0)) {
   1962e:	2100      	movs	r1, #0
   19630:	48af      	ldr	r0, [pc, #700]	; (198f0 <sd_mmc_check+0x34c>)
   19632:	47a0      	blx	r4
   19634:	2800      	cmp	r0, #0
   19636:	d0e5      	beq.n	19604 <sd_mmc_check+0x60>
	if (sd_mmc_card->type & CARD_TYPE_SD) {
   19638:	682b      	ldr	r3, [r5, #0]
   1963a:	7adb      	ldrb	r3, [r3, #11]
   1963c:	07db      	lsls	r3, r3, #31
   1963e:	d400      	bmi.n	19642 <sd_mmc_check+0x9e>
   19640:	e126      	b.n	19890 <sd_mmc_check+0x2ec>
		if (!sd_mmc_cmd9_spi()) {
   19642:	4bac      	ldr	r3, [pc, #688]	; (198f4 <sd_mmc_check+0x350>)
   19644:	4798      	blx	r3
   19646:	2800      	cmp	r0, #0
   19648:	d0dc      	beq.n	19604 <sd_mmc_check+0x60>
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
   1964a:	682f      	ldr	r7, [r5, #0]
   1964c:	2308      	movs	r3, #8
   1964e:	003e      	movs	r6, r7
   19650:	360e      	adds	r6, #14
   19652:	2260      	movs	r2, #96	; 0x60
   19654:	2180      	movs	r1, #128	; 0x80
   19656:	0030      	movs	r0, r6
   19658:	4da7      	ldr	r5, [pc, #668]	; (198f8 <sd_mmc_check+0x354>)
   1965a:	47a8      	blx	r5
	unit = sd_mmc_trans_units[tran_speed & 0x7];
   1965c:	2307      	movs	r3, #7
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
   1965e:	0642      	lsls	r2, r0, #25
	unit = sd_mmc_trans_units[tran_speed & 0x7];
   19660:	4018      	ands	r0, r3
	sd_mmc_card->clock = unit * mul * 1000;
   19662:	4ba6      	ldr	r3, [pc, #664]	; (198fc <sd_mmc_check+0x358>)
	unit = sd_mmc_trans_units[tran_speed & 0x7];
   19664:	0080      	lsls	r0, r0, #2
	sd_mmc_card->clock = unit * mul * 1000;
   19666:	58c1      	ldr	r1, [r0, r3]
   19668:	23fa      	movs	r3, #250	; 0xfa
   1966a:	009b      	lsls	r3, r3, #2
   1966c:	434b      	muls	r3, r1
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
   1966e:	0f12      	lsrs	r2, r2, #28
	sd_mmc_card->clock = unit * mul * 1000;
   19670:	49a3      	ldr	r1, [pc, #652]	; (19900 <sd_mmc_check+0x35c>)
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
   19672:	0092      	lsls	r2, r2, #2
	sd_mmc_card->clock = unit * mul * 1000;
   19674:	5852      	ldr	r2, [r2, r1]
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
   19676:	0030      	movs	r0, r6
	sd_mmc_card->clock = unit * mul * 1000;
   19678:	4353      	muls	r3, r2
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
   1967a:	2180      	movs	r1, #128	; 0x80
	sd_mmc_card->clock = unit * mul * 1000;
   1967c:	603b      	str	r3, [r7, #0]
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
   1967e:	227e      	movs	r2, #126	; 0x7e
   19680:	2302      	movs	r3, #2
   19682:	47a8      	blx	r5
   19684:	2800      	cmp	r0, #0
   19686:	d100      	bne.n	1968a <sd_mmc_check+0xe6>
   19688:	e0e8      	b.n	1985c <sd_mmc_check+0x2b8>
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
   1968a:	2316      	movs	r3, #22
   1968c:	2230      	movs	r2, #48	; 0x30
   1968e:	2180      	movs	r1, #128	; 0x80
   19690:	0030      	movs	r0, r6
   19692:	47a8      	blx	r5
				* 512;
   19694:	3001      	adds	r0, #1
   19696:	0240      	lsls	r0, r0, #9
		sd_mmc_card->capacity =
   19698:	6078      	str	r0, [r7, #4]
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
   1969a:	8939      	ldrh	r1, [r7, #8]
   1969c:	4899      	ldr	r0, [pc, #612]	; (19904 <sd_mmc_check+0x360>)
   1969e:	0409      	lsls	r1, r1, #16
   196a0:	4b8f      	ldr	r3, [pc, #572]	; (198e0 <sd_mmc_check+0x33c>)
   196a2:	4798      	blx	r3
   196a4:	2800      	cmp	r0, #0
   196a6:	d0ad      	beq.n	19604 <sd_mmc_check+0x60>
	if (!driver_adtc_start(SD_ACMD51_SEND_SCR, 0,
   196a8:	2501      	movs	r5, #1
   196aa:	2208      	movs	r2, #8
   196ac:	9500      	str	r5, [sp, #0]
   196ae:	002b      	movs	r3, r5
   196b0:	2100      	movs	r1, #0
   196b2:	4895      	ldr	r0, [pc, #596]	; (19908 <sd_mmc_check+0x364>)
   196b4:	4c95      	ldr	r4, [pc, #596]	; (1990c <sd_mmc_check+0x368>)
   196b6:	47a0      	blx	r4
   196b8:	2800      	cmp	r0, #0
   196ba:	d0a3      	beq.n	19604 <sd_mmc_check+0x60>
	if (!driver_start_read_blocks(scr, 1)) {
   196bc:	0029      	movs	r1, r5
   196be:	a806      	add	r0, sp, #24
   196c0:	4b93      	ldr	r3, [pc, #588]	; (19910 <sd_mmc_check+0x36c>)
   196c2:	4798      	blx	r3
   196c4:	2800      	cmp	r0, #0
   196c6:	d09d      	beq.n	19604 <sd_mmc_check+0x60>
	if (!driver_wait_end_of_read_blocks()) {
   196c8:	4b92      	ldr	r3, [pc, #584]	; (19914 <sd_mmc_check+0x370>)
   196ca:	4798      	blx	r3
   196cc:	2800      	cmp	r0, #0
   196ce:	d099      	beq.n	19604 <sd_mmc_check+0x60>
	switch (SD_SCR_SD_SPEC(scr)) {
   196d0:	2304      	movs	r3, #4
   196d2:	2238      	movs	r2, #56	; 0x38
   196d4:	2140      	movs	r1, #64	; 0x40
   196d6:	a806      	add	r0, sp, #24
   196d8:	4e87      	ldr	r6, [pc, #540]	; (198f8 <sd_mmc_check+0x354>)
   196da:	47b0      	blx	r6
   196dc:	4c7e      	ldr	r4, [pc, #504]	; (198d8 <sd_mmc_check+0x334>)
   196de:	42a8      	cmp	r0, r5
   196e0:	d100      	bne.n	196e4 <sd_mmc_check+0x140>
   196e2:	e0d2      	b.n	1988a <sd_mmc_check+0x2e6>
   196e4:	2800      	cmp	r0, #0
   196e6:	d002      	beq.n	196ee <sd_mmc_check+0x14a>
   196e8:	2802      	cmp	r0, #2
   196ea:	d100      	bne.n	196ee <sd_mmc_check+0x14a>
   196ec:	e0dc      	b.n	198a8 <sd_mmc_check+0x304>
		sd_mmc_card->version = CARD_VER_SD_1_0;
   196ee:	6823      	ldr	r3, [r4, #0]
   196f0:	2210      	movs	r2, #16
   196f2:	e0cc      	b.n	1988e <sd_mmc_check+0x2ea>
	if (!driver_send_cmd(SDMMC_SPI_CMD58_READ_OCR, 0)) {
   196f4:	487d      	ldr	r0, [pc, #500]	; (198ec <sd_mmc_check+0x348>)
   196f6:	47a0      	blx	r4
   196f8:	2800      	cmp	r0, #0
   196fa:	d083      	beq.n	19604 <sd_mmc_check+0x60>
	if ((driver_get_response() & OCR_ACCESS_MODE_MASK)
   196fc:	47b8      	blx	r7
   196fe:	23c0      	movs	r3, #192	; 0xc0
   19700:	05db      	lsls	r3, r3, #23
   19702:	4018      	ands	r0, r3
   19704:	2380      	movs	r3, #128	; 0x80
   19706:	05db      	lsls	r3, r3, #23
   19708:	4298      	cmp	r0, r3
   1970a:	d104      	bne.n	19716 <sd_mmc_check+0x172>
		sd_mmc_card->type |= CARD_TYPE_HC;
   1970c:	2308      	movs	r3, #8
   1970e:	682a      	ldr	r2, [r5, #0]
   19710:	7ad1      	ldrb	r1, [r2, #11]
   19712:	430b      	orrs	r3, r1
   19714:	72d3      	strb	r3, [r2, #11]
	if (!driver_send_cmd(SDMMC_SPI_CMD59_CRC_ON_OFF, 0)) {
   19716:	2100      	movs	r1, #0
   19718:	4875      	ldr	r0, [pc, #468]	; (198f0 <sd_mmc_check+0x34c>)
   1971a:	47a0      	blx	r4
   1971c:	2800      	cmp	r0, #0
   1971e:	d100      	bne.n	19722 <sd_mmc_check+0x17e>
   19720:	e770      	b.n	19604 <sd_mmc_check+0x60>
	if (!sd_mmc_cmd9_spi()) {
   19722:	4b74      	ldr	r3, [pc, #464]	; (198f4 <sd_mmc_check+0x350>)
   19724:	4798      	blx	r3
   19726:	2800      	cmp	r0, #0
   19728:	d100      	bne.n	1972c <sd_mmc_check+0x188>
   1972a:	e76b      	b.n	19604 <sd_mmc_check+0x60>
	switch (MMC_CSD_SPEC_VERS(sd_mmc_card->csd)) {
   1972c:	682c      	ldr	r4, [r5, #0]
   1972e:	2304      	movs	r3, #4
   19730:	0025      	movs	r5, r4
   19732:	350e      	adds	r5, #14
   19734:	227a      	movs	r2, #122	; 0x7a
   19736:	2180      	movs	r1, #128	; 0x80
   19738:	0028      	movs	r0, r5
   1973a:	4e6f      	ldr	r6, [pc, #444]	; (198f8 <sd_mmc_check+0x354>)
   1973c:	47b0      	blx	r6
   1973e:	3801      	subs	r0, #1
		sd_mmc_card->version = CARD_VER_MMC_1_2;
   19740:	2312      	movs	r3, #18
	switch (MMC_CSD_SPEC_VERS(sd_mmc_card->csd)) {
   19742:	2803      	cmp	r0, #3
   19744:	d804      	bhi.n	19750 <sd_mmc_check+0x1ac>
   19746:	f00c f8af 	bl	258a8 <__gnu_thumb1_case_uqi>
   1974a:	8302      	.short	0x8302
   1974c:	8785      	.short	0x8785
		sd_mmc_card->version = CARD_VER_MMC_1_4;
   1974e:	2314      	movs	r3, #20
		sd_mmc_card->version = CARD_VER_MMC_4;
   19750:	7323      	strb	r3, [r4, #12]
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
   19752:	2260      	movs	r2, #96	; 0x60
   19754:	2308      	movs	r3, #8
   19756:	2180      	movs	r1, #128	; 0x80
   19758:	4f67      	ldr	r7, [pc, #412]	; (198f8 <sd_mmc_check+0x354>)
   1975a:	0028      	movs	r0, r5
   1975c:	47b8      	blx	r7
	unit = sd_mmc_trans_units[tran_speed & 0x7];
   1975e:	2307      	movs	r3, #7
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
   19760:	0642      	lsls	r2, r0, #25
	unit = sd_mmc_trans_units[tran_speed & 0x7];
   19762:	4018      	ands	r0, r3
	sd_mmc_card->clock = unit * mul * 1000;
   19764:	4b65      	ldr	r3, [pc, #404]	; (198fc <sd_mmc_check+0x358>)
	unit = sd_mmc_trans_units[tran_speed & 0x7];
   19766:	0080      	lsls	r0, r0, #2
	sd_mmc_card->clock = unit * mul * 1000;
   19768:	58c1      	ldr	r1, [r0, r3]
   1976a:	23fa      	movs	r3, #250	; 0xfa
   1976c:	009b      	lsls	r3, r3, #2
   1976e:	434b      	muls	r3, r1
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
   19770:	0f12      	lsrs	r2, r2, #28
	sd_mmc_card->clock = unit * mul * 1000;
   19772:	4969      	ldr	r1, [pc, #420]	; (19918 <sd_mmc_check+0x374>)
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
   19774:	0092      	lsls	r2, r2, #2
	sd_mmc_card->clock = unit * mul * 1000;
   19776:	5852      	ldr	r2, [r2, r1]
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
   19778:	0028      	movs	r0, r5
	sd_mmc_card->clock = unit * mul * 1000;
   1977a:	4353      	muls	r3, r2
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
   1977c:	2180      	movs	r1, #128	; 0x80
	sd_mmc_card->clock = unit * mul * 1000;
   1977e:	6023      	str	r3, [r4, #0]
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
   19780:	223e      	movs	r2, #62	; 0x3e
   19782:	230c      	movs	r3, #12
   19784:	47b8      	blx	r7
   19786:	4b65      	ldr	r3, [pc, #404]	; (1991c <sd_mmc_check+0x378>)
   19788:	0006      	movs	r6, r0
   1978a:	4298      	cmp	r0, r3
   1978c:	d00f      	beq.n	197ae <sd_mmc_check+0x20a>
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
   1978e:	2303      	movs	r3, #3
   19790:	222f      	movs	r2, #47	; 0x2f
   19792:	2180      	movs	r1, #128	; 0x80
   19794:	0028      	movs	r0, r5
   19796:	47b8      	blx	r7
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
   19798:	3601      	adds	r6, #1
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
   1979a:	3002      	adds	r0, #2
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
   1979c:	4086      	lsls	r6, r0
			(1 << MMC_CSD_READ_BL_LEN(sd_mmc_card->csd)) / 1024;
   1979e:	2304      	movs	r3, #4
   197a0:	2250      	movs	r2, #80	; 0x50
   197a2:	2180      	movs	r1, #128	; 0x80
   197a4:	0028      	movs	r0, r5
   197a6:	47b8      	blx	r7
		sd_mmc_card->capacity = blocknr *
   197a8:	4086      	lsls	r6, r0
			(1 << MMC_CSD_READ_BL_LEN(sd_mmc_card->csd)) / 1024;
   197aa:	0ab6      	lsrs	r6, r6, #10
		sd_mmc_card->capacity = blocknr *
   197ac:	6066      	str	r6, [r4, #4]
	if (sd_mmc_card->version >= CARD_VER_MMC_4) {
   197ae:	7b23      	ldrb	r3, [r4, #12]
   197b0:	2b3f      	cmp	r3, #63	; 0x3f
   197b2:	d939      	bls.n	19828 <sd_mmc_check+0x284>
	if (!driver_adtc_start(MMC_CMD8_SEND_EXT_CSD, 0,
   197b4:	2100      	movs	r1, #0
   197b6:	2280      	movs	r2, #128	; 0x80
   197b8:	9100      	str	r1, [sp, #0]
   197ba:	2301      	movs	r3, #1
   197bc:	0092      	lsls	r2, r2, #2
   197be:	4858      	ldr	r0, [pc, #352]	; (19920 <sd_mmc_check+0x37c>)
   197c0:	4c52      	ldr	r4, [pc, #328]	; (1990c <sd_mmc_check+0x368>)
   197c2:	47a0      	blx	r4
   197c4:	2800      	cmp	r0, #0
   197c6:	d100      	bne.n	197ca <sd_mmc_check+0x226>
   197c8:	e71c      	b.n	19604 <sd_mmc_check+0x60>
   197ca:	2432      	movs	r4, #50	; 0x32
		if (!driver_read_word(&ext_csd)) {
   197cc:	a805      	add	r0, sp, #20
   197ce:	4d55      	ldr	r5, [pc, #340]	; (19924 <sd_mmc_check+0x380>)
   197d0:	47a8      	blx	r5
   197d2:	2800      	cmp	r0, #0
   197d4:	d100      	bne.n	197d8 <sd_mmc_check+0x234>
   197d6:	e715      	b.n	19604 <sd_mmc_check+0x60>
   197d8:	3c01      	subs	r4, #1
   197da:	b2a4      	uxth	r4, r4
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
   197dc:	2c00      	cmp	r4, #0
   197de:	d1f5      	bne.n	197cc <sd_mmc_check+0x228>
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
   197e0:	4e3d      	ldr	r6, [pc, #244]	; (198d8 <sd_mmc_check+0x334>)
   197e2:	230c      	movs	r3, #12
   197e4:	6830      	ldr	r0, [r6, #0]
   197e6:	4c44      	ldr	r4, [pc, #272]	; (198f8 <sd_mmc_check+0x354>)
   197e8:	300e      	adds	r0, #14
   197ea:	223e      	movs	r2, #62	; 0x3e
   197ec:	2180      	movs	r1, #128	; 0x80
   197ee:	47a0      	blx	r4
   197f0:	4b4a      	ldr	r3, [pc, #296]	; (1991c <sd_mmc_check+0x378>)
   197f2:	2432      	movs	r4, #50	; 0x32
   197f4:	4298      	cmp	r0, r3
   197f6:	d10e      	bne.n	19816 <sd_mmc_check+0x272>
   197f8:	3c2e      	subs	r4, #46	; 0x2e
			if (!driver_read_word(&sec_count)) {
   197fa:	a806      	add	r0, sp, #24
   197fc:	47a8      	blx	r5
   197fe:	2800      	cmp	r0, #0
   19800:	d100      	bne.n	19804 <sd_mmc_check+0x260>
   19802:	e6ff      	b.n	19604 <sd_mmc_check+0x60>
   19804:	3c01      	subs	r4, #1
   19806:	b2a4      	uxth	r4, r4
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
   19808:	2c00      	cmp	r4, #0
   1980a:	d1f6      	bne.n	197fa <sd_mmc_check+0x256>
		sd_mmc_card->capacity = sec_count / 2;
   1980c:	9b06      	ldr	r3, [sp, #24]
   1980e:	6832      	ldr	r2, [r6, #0]
   19810:	085b      	lsrs	r3, r3, #1
   19812:	6053      	str	r3, [r2, #4]
   19814:	3436      	adds	r4, #54	; 0x36
		if (!driver_read_word(&sec_count)) {
   19816:	a806      	add	r0, sp, #24
   19818:	47a8      	blx	r5
   1981a:	2800      	cmp	r0, #0
   1981c:	d100      	bne.n	19820 <sd_mmc_check+0x27c>
   1981e:	e6f1      	b.n	19604 <sd_mmc_check+0x60>
	for (; i < EXT_CSD_BSIZE / 4; i++) {
   19820:	3401      	adds	r4, #1
   19822:	b2a4      	uxth	r4, r4
   19824:	2c80      	cmp	r4, #128	; 0x80
   19826:	d1f6      	bne.n	19816 <sd_mmc_check+0x272>
	if (!driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
   19828:	2180      	movs	r1, #128	; 0x80
   1982a:	483f      	ldr	r0, [pc, #252]	; (19928 <sd_mmc_check+0x384>)
   1982c:	0089      	lsls	r1, r1, #2
   1982e:	4b2c      	ldr	r3, [pc, #176]	; (198e0 <sd_mmc_check+0x33c>)
   19830:	4798      	blx	r3
   19832:	2800      	cmp	r0, #0
   19834:	d100      	bne.n	19838 <sd_mmc_check+0x294>
   19836:	e6e5      	b.n	19604 <sd_mmc_check+0x60>
	if (!sd_mmc_cmd13()) {
   19838:	4b3c      	ldr	r3, [pc, #240]	; (1992c <sd_mmc_check+0x388>)
   1983a:	4798      	blx	r3
   1983c:	2800      	cmp	r0, #0
   1983e:	d100      	bne.n	19842 <sd_mmc_check+0x29e>
   19840:	e6e0      	b.n	19604 <sd_mmc_check+0x60>
	sd_mmc_configure_slot();
   19842:	4b3b      	ldr	r3, [pc, #236]	; (19930 <sd_mmc_check+0x38c>)
   19844:	4798      	blx	r3
		sd_mmc_card->state = SD_MMC_CARD_STATE_READY;
   19846:	2200      	movs	r2, #0
   19848:	4b23      	ldr	r3, [pc, #140]	; (198d8 <sd_mmc_check+0x334>)
   1984a:	681b      	ldr	r3, [r3, #0]
   1984c:	729a      	strb	r2, [r3, #10]
   1984e:	e6b0      	b.n	195b2 <sd_mmc_check+0xe>
		sd_mmc_card->version = CARD_VER_MMC_2_2;
   19850:	2322      	movs	r3, #34	; 0x22
   19852:	e77d      	b.n	19750 <sd_mmc_check+0x1ac>
		sd_mmc_card->version = CARD_VER_MMC_3;
   19854:	2330      	movs	r3, #48	; 0x30
   19856:	e77b      	b.n	19750 <sd_mmc_check+0x1ac>
		sd_mmc_card->version = CARD_VER_MMC_4;
   19858:	2340      	movs	r3, #64	; 0x40
   1985a:	e779      	b.n	19750 <sd_mmc_check+0x1ac>
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
   1985c:	230c      	movs	r3, #12
   1985e:	223e      	movs	r2, #62	; 0x3e
   19860:	2180      	movs	r1, #128	; 0x80
   19862:	0030      	movs	r0, r6
   19864:	47a8      	blx	r5
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
   19866:	2303      	movs	r3, #3
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
   19868:	0004      	movs	r4, r0
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
   1986a:	222f      	movs	r2, #47	; 0x2f
   1986c:	2180      	movs	r1, #128	; 0x80
   1986e:	0030      	movs	r0, r6
   19870:	47a8      	blx	r5
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
   19872:	3401      	adds	r4, #1
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
   19874:	3002      	adds	r0, #2
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
   19876:	4084      	lsls	r4, r0
				(1 << SD_CSD_1_0_READ_BL_LEN(sd_mmc_card->csd))
   19878:	2304      	movs	r3, #4
   1987a:	2250      	movs	r2, #80	; 0x50
   1987c:	2180      	movs	r1, #128	; 0x80
   1987e:	0030      	movs	r0, r6
   19880:	47a8      	blx	r5
		sd_mmc_card->capacity = blocknr *
   19882:	4084      	lsls	r4, r0
				/ 1024;
   19884:	0aa4      	lsrs	r4, r4, #10
		sd_mmc_card->capacity = blocknr *
   19886:	607c      	str	r4, [r7, #4]
   19888:	e707      	b.n	1969a <sd_mmc_check+0xf6>
		sd_mmc_card->version = CARD_VER_SD_1_10;
   1988a:	221a      	movs	r2, #26
   1988c:	6823      	ldr	r3, [r4, #0]
		sd_mmc_card->version = CARD_VER_SD_1_0;
   1988e:	731a      	strb	r2, [r3, #12]
	if ((sd_mmc_card->type & CARD_TYPE_SD) &&
   19890:	2209      	movs	r2, #9
   19892:	4c11      	ldr	r4, [pc, #68]	; (198d8 <sd_mmc_check+0x334>)
   19894:	6823      	ldr	r3, [r4, #0]
   19896:	7adb      	ldrb	r3, [r3, #11]
   19898:	4013      	ands	r3, r2
   1989a:	2b01      	cmp	r3, #1
   1989c:	d00f      	beq.n	198be <sd_mmc_check+0x31a>
	if (sd_mmc_card->type & CARD_TYPE_SD) {
   1989e:	6823      	ldr	r3, [r4, #0]
   198a0:	7adb      	ldrb	r3, [r3, #11]
   198a2:	07db      	lsls	r3, r3, #31
   198a4:	d4c8      	bmi.n	19838 <sd_mmc_check+0x294>
   198a6:	e7cc      	b.n	19842 <sd_mmc_check+0x29e>
		if (SD_SCR_SD_SPEC3(scr) == SD_SCR_SD_SPEC_3_00) {
   198a8:	002b      	movs	r3, r5
   198aa:	222f      	movs	r2, #47	; 0x2f
   198ac:	2140      	movs	r1, #64	; 0x40
   198ae:	a806      	add	r0, sp, #24
   198b0:	47b0      	blx	r6
			sd_mmc_card->version = CARD_VER_SD_3_0;
   198b2:	6823      	ldr	r3, [r4, #0]
   198b4:	2230      	movs	r2, #48	; 0x30
		if (SD_SCR_SD_SPEC3(scr) == SD_SCR_SD_SPEC_3_00) {
   198b6:	2801      	cmp	r0, #1
   198b8:	d0e9      	beq.n	1988e <sd_mmc_check+0x2ea>
			sd_mmc_card->version = CARD_VER_SD_2_0;
   198ba:	2220      	movs	r2, #32
   198bc:	e7e7      	b.n	1988e <sd_mmc_check+0x2ea>
		if (!driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
   198be:	2180      	movs	r1, #128	; 0x80
   198c0:	4819      	ldr	r0, [pc, #100]	; (19928 <sd_mmc_check+0x384>)
   198c2:	0089      	lsls	r1, r1, #2
   198c4:	4b06      	ldr	r3, [pc, #24]	; (198e0 <sd_mmc_check+0x33c>)
   198c6:	4798      	blx	r3
   198c8:	2800      	cmp	r0, #0
   198ca:	d1e8      	bne.n	1989e <sd_mmc_check+0x2fa>
   198cc:	e69a      	b.n	19604 <sd_mmc_check+0x60>
   198ce:	46c0      	nop			; (mov r8, r8)
   198d0:	000194ed 	.word	0x000194ed
   198d4:	000194d5 	.word	0x000194d5
   198d8:	20003cfc 	.word	0x20003cfc
   198dc:	0001a04d 	.word	0x0001a04d
   198e0:	0001a1dd 	.word	0x0001a1dd
   198e4:	00005508 	.word	0x00005508
   198e8:	0001a1f1 	.word	0x0001a1f1
   198ec:	0000053a 	.word	0x0000053a
   198f0:	0000113b 	.word	0x0000113b
   198f4:	0001953d 	.word	0x0001953d
   198f8:	0001942d 	.word	0x0001942d
   198fc:	00029f50 	.word	0x00029f50
   19900:	00029f6c 	.word	0x00029f6c
   19904:	00001137 	.word	0x00001137
   19908:	00081133 	.word	0x00081133
   1990c:	0001a081 	.word	0x0001a081
   19910:	0001a26d 	.word	0x0001a26d
   19914:	0001a2d5 	.word	0x0001a2d5
   19918:	00029f10 	.word	0x00029f10
   1991c:	00000fff 	.word	0x00000fff
   19920:	00081108 	.word	0x00081108
   19924:	0001a1fd 	.word	0x0001a1fd
   19928:	00001110 	.word	0x00001110
   1992c:	0001949d 	.word	0x0001949d
   19930:	00019475 	.word	0x00019475
	*v2 = 0;
   19934:	2300      	movs	r3, #0
	if (sd_mmc_card->type & CARD_TYPE_SD) {
   19936:	682a      	ldr	r2, [r5, #0]
   19938:	7ad2      	ldrb	r2, [r2, #11]
   1993a:	07d2      	lsls	r2, r2, #31
   1993c:	d400      	bmi.n	19940 <sd_mmc_check+0x39c>
   1993e:	e67b      	b.n	19638 <sd_mmc_check+0x94>
   19940:	079b      	lsls	r3, r3, #30
   19942:	4e18      	ldr	r6, [pc, #96]	; (199a4 <sd_mmc_check+0x400>)
   19944:	9303      	str	r3, [sp, #12]
		if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, 0)) {
   19946:	2100      	movs	r1, #0
   19948:	4817      	ldr	r0, [pc, #92]	; (199a8 <sd_mmc_check+0x404>)
   1994a:	47a0      	blx	r4
   1994c:	2800      	cmp	r0, #0
   1994e:	d00d      	beq.n	1996c <sd_mmc_check+0x3c8>
		if (!driver_send_cmd(SD_SPI_ACMD41_SD_SEND_OP_COND, arg)) {
   19950:	9903      	ldr	r1, [sp, #12]
   19952:	4816      	ldr	r0, [pc, #88]	; (199ac <sd_mmc_check+0x408>)
   19954:	47a0      	blx	r4
   19956:	2800      	cmp	r0, #0
   19958:	d008      	beq.n	1996c <sd_mmc_check+0x3c8>
		resp = driver_get_response();
   1995a:	4f15      	ldr	r7, [pc, #84]	; (199b0 <sd_mmc_check+0x40c>)
   1995c:	47b8      	blx	r7
		if (!(resp & R1_SPI_IDLE)) {
   1995e:	2101      	movs	r1, #1
   19960:	4001      	ands	r1, r0
   19962:	d100      	bne.n	19966 <sd_mmc_check+0x3c2>
   19964:	e656      	b.n	19614 <sd_mmc_check+0x70>
   19966:	3e01      	subs	r6, #1
		if (retry-- == 0) {
   19968:	2e00      	cmp	r6, #0
   1996a:	d1ec      	bne.n	19946 <sd_mmc_check+0x3a2>
			sd_mmc_card->type = CARD_TYPE_MMC;
   1996c:	2302      	movs	r3, #2
	if (!driver_send_cmd(SDMMC_SPI_CMD0_GO_IDLE_STATE, 0)) {
   1996e:	2088      	movs	r0, #136	; 0x88
			sd_mmc_card->type = CARD_TYPE_MMC;
   19970:	682a      	ldr	r2, [r5, #0]
	if (!driver_send_cmd(SDMMC_SPI_CMD0_GO_IDLE_STATE, 0)) {
   19972:	2100      	movs	r1, #0
			sd_mmc_card->type = CARD_TYPE_MMC;
   19974:	72d3      	strb	r3, [r2, #11]
	if (!driver_send_cmd(SDMMC_SPI_CMD0_GO_IDLE_STATE, 0)) {
   19976:	0140      	lsls	r0, r0, #5
   19978:	47a0      	blx	r4
   1997a:	2800      	cmp	r0, #0
   1997c:	d100      	bne.n	19980 <sd_mmc_check+0x3dc>
   1997e:	e641      	b.n	19604 <sd_mmc_check+0x60>
   19980:	4e08      	ldr	r6, [pc, #32]	; (199a4 <sd_mmc_check+0x400>)
		if (!driver_send_cmd(MMC_SPI_CMD1_SEND_OP_COND, 0)) {
   19982:	2100      	movs	r1, #0
   19984:	480b      	ldr	r0, [pc, #44]	; (199b4 <sd_mmc_check+0x410>)
   19986:	47a0      	blx	r4
   19988:	2800      	cmp	r0, #0
   1998a:	d100      	bne.n	1998e <sd_mmc_check+0x3ea>
   1998c:	e63a      	b.n	19604 <sd_mmc_check+0x60>
		resp = driver_get_response();
   1998e:	4f08      	ldr	r7, [pc, #32]	; (199b0 <sd_mmc_check+0x40c>)
   19990:	47b8      	blx	r7
		if (!(resp & R1_SPI_IDLE)) {
   19992:	2101      	movs	r1, #1
   19994:	4001      	ands	r1, r0
   19996:	d100      	bne.n	1999a <sd_mmc_check+0x3f6>
   19998:	e6ac      	b.n	196f4 <sd_mmc_check+0x150>
   1999a:	3e01      	subs	r6, #1
		if (retry-- == 0) {
   1999c:	2e00      	cmp	r6, #0
   1999e:	d1f0      	bne.n	19982 <sd_mmc_check+0x3de>
   199a0:	e630      	b.n	19604 <sd_mmc_check+0x60>
   199a2:	46c0      	nop			; (mov r8, r8)
   199a4:	00001bef 	.word	0x00001bef
   199a8:	00001137 	.word	0x00001137
   199ac:	00001129 	.word	0x00001129
   199b0:	0001a1f1 	.word	0x0001a1f1
   199b4:	00001101 	.word	0x00001101

000199b8 <sd_mmc_get_type>:

card_type_t sd_mmc_get_type(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
   199b8:	4b06      	ldr	r3, [pc, #24]	; (199d4 <sd_mmc_get_type+0x1c>)
{
   199ba:	b510      	push	{r4, lr}
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
   199bc:	4798      	blx	r3
		return CARD_TYPE_UNKNOWN;
   199be:	2300      	movs	r3, #0
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
   199c0:	4298      	cmp	r0, r3
   199c2:	d104      	bne.n	199ce <sd_mmc_get_type+0x16>
	}
	sd_mmc_deselect_slot();
   199c4:	4b04      	ldr	r3, [pc, #16]	; (199d8 <sd_mmc_get_type+0x20>)
   199c6:	4798      	blx	r3
	return sd_mmc_card->type;
   199c8:	4b04      	ldr	r3, [pc, #16]	; (199dc <sd_mmc_get_type+0x24>)
   199ca:	681b      	ldr	r3, [r3, #0]
   199cc:	7adb      	ldrb	r3, [r3, #11]
}
   199ce:	0018      	movs	r0, r3
   199d0:	bd10      	pop	{r4, pc}
   199d2:	46c0      	nop			; (mov r8, r8)
   199d4:	000194ed 	.word	0x000194ed
   199d8:	000194d5 	.word	0x000194d5
   199dc:	20003cfc 	.word	0x20003cfc

000199e0 <sd_mmc_get_capacity>:
	return sd_mmc_card->version;
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
   199e0:	4b06      	ldr	r3, [pc, #24]	; (199fc <sd_mmc_get_capacity+0x1c>)
{
   199e2:	b510      	push	{r4, lr}
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
   199e4:	4798      	blx	r3
		return 0;
   199e6:	2300      	movs	r3, #0
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
   199e8:	4298      	cmp	r0, r3
   199ea:	d104      	bne.n	199f6 <sd_mmc_get_capacity+0x16>
	}
	sd_mmc_deselect_slot();
   199ec:	4b04      	ldr	r3, [pc, #16]	; (19a00 <sd_mmc_get_capacity+0x20>)
   199ee:	4798      	blx	r3
	return sd_mmc_card->capacity;
   199f0:	4b04      	ldr	r3, [pc, #16]	; (19a04 <sd_mmc_get_capacity+0x24>)
   199f2:	681b      	ldr	r3, [r3, #0]
   199f4:	685b      	ldr	r3, [r3, #4]
}
   199f6:	0018      	movs	r0, r3
   199f8:	bd10      	pop	{r4, pc}
   199fa:	46c0      	nop			; (mov r8, r8)
   199fc:	000194ed 	.word	0x000194ed
   19a00:	000194d5 	.word	0x000194d5
   19a04:	20003cfc 	.word	0x20003cfc

00019a08 <sd_mmc_is_write_protected>:
			== SD_MMC_0_WP_DETECT_VALUE) {
		return true;
	}
#endif
	return false;
}
   19a08:	2000      	movs	r0, #0
   19a0a:	4770      	bx	lr

00019a0c <sd_mmc_init_read_blocks>:

sd_mmc_err_t sd_mmc_init_read_blocks(uint8_t slot, uint32_t start,
		uint16_t nb_block)
{
   19a0c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	sd_mmc_err_t sd_mmc_err;
	uint32_t cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
   19a0e:	4b14      	ldr	r3, [pc, #80]	; (19a60 <sd_mmc_init_read_blocks+0x54>)
{
   19a10:	000e      	movs	r6, r1
   19a12:	0014      	movs	r4, r2
	sd_mmc_err = sd_mmc_select_slot(slot);
   19a14:	4798      	blx	r3
   19a16:	1e05      	subs	r5, r0, #0
	if (sd_mmc_err != SD_MMC_OK) {
   19a18:	d106      	bne.n	19a28 <sd_mmc_init_read_blocks+0x1c>
		return sd_mmc_err;
	}

	// Wait for data ready status
	if (!sd_mmc_cmd13()) {
   19a1a:	4b12      	ldr	r3, [pc, #72]	; (19a64 <sd_mmc_init_read_blocks+0x58>)
   19a1c:	4798      	blx	r3
   19a1e:	2800      	cmp	r0, #0
   19a20:	d104      	bne.n	19a2c <sd_mmc_init_read_blocks+0x20>
		sd_mmc_deselect_slot();
   19a22:	4b11      	ldr	r3, [pc, #68]	; (19a68 <sd_mmc_init_read_blocks+0x5c>)
   19a24:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
   19a26:	2505      	movs	r5, #5
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
   19a28:	0028      	movs	r0, r5
   19a2a:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
	if (nb_block > 1) {
   19a2c:	2c01      	cmp	r4, #1
   19a2e:	d815      	bhi.n	19a5c <sd_mmc_init_read_blocks+0x50>
		cmd = SDMMC_CMD17_READ_SINGLE_BLOCK;
   19a30:	480e      	ldr	r0, [pc, #56]	; (19a6c <sd_mmc_init_read_blocks+0x60>)
	if (sd_mmc_card->type & CARD_TYPE_HC) {
   19a32:	4b0f      	ldr	r3, [pc, #60]	; (19a70 <sd_mmc_init_read_blocks+0x64>)
   19a34:	681b      	ldr	r3, [r3, #0]
   19a36:	7adb      	ldrb	r3, [r3, #11]
   19a38:	071b      	lsls	r3, r3, #28
   19a3a:	d400      	bmi.n	19a3e <sd_mmc_init_read_blocks+0x32>
		arg = (start * SD_MMC_BLOCK_SIZE);
   19a3c:	0276      	lsls	r6, r6, #9
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
   19a3e:	2301      	movs	r3, #1
   19a40:	2280      	movs	r2, #128	; 0x80
   19a42:	9300      	str	r3, [sp, #0]
   19a44:	0031      	movs	r1, r6
   19a46:	0023      	movs	r3, r4
   19a48:	0092      	lsls	r2, r2, #2
   19a4a:	4e0a      	ldr	r6, [pc, #40]	; (19a74 <sd_mmc_init_read_blocks+0x68>)
   19a4c:	47b0      	blx	r6
   19a4e:	2800      	cmp	r0, #0
   19a50:	d0e7      	beq.n	19a22 <sd_mmc_init_read_blocks+0x16>
	sd_mmc_nb_block_remaining = nb_block;
   19a52:	4b09      	ldr	r3, [pc, #36]	; (19a78 <sd_mmc_init_read_blocks+0x6c>)
   19a54:	801c      	strh	r4, [r3, #0]
	sd_mmc_nb_block_to_tranfer = nb_block;
   19a56:	4b09      	ldr	r3, [pc, #36]	; (19a7c <sd_mmc_init_read_blocks+0x70>)
   19a58:	801c      	strh	r4, [r3, #0]
	return SD_MMC_OK;
   19a5a:	e7e5      	b.n	19a28 <sd_mmc_init_read_blocks+0x1c>
		cmd = SDMMC_CMD18_READ_MULTIPLE_BLOCK;
   19a5c:	4808      	ldr	r0, [pc, #32]	; (19a80 <sd_mmc_init_read_blocks+0x74>)
   19a5e:	e7e8      	b.n	19a32 <sd_mmc_init_read_blocks+0x26>
   19a60:	000194ed 	.word	0x000194ed
   19a64:	0001949d 	.word	0x0001949d
   19a68:	000194d5 	.word	0x000194d5
   19a6c:	00081111 	.word	0x00081111
   19a70:	20003cfc 	.word	0x20003cfc
   19a74:	0001a081 	.word	0x0001a081
   19a78:	20003d20 	.word	0x20003d20
   19a7c:	20003d22 	.word	0x20003d22
   19a80:	00101112 	.word	0x00101112

00019a84 <sd_mmc_start_read_blocks>:

sd_mmc_err_t sd_mmc_start_read_blocks(void *dest, uint16_t nb_block)
{
   19a84:	b510      	push	{r4, lr}
	Assert(sd_mmc_nb_block_remaining >= nb_block);

	if (!driver_start_read_blocks(dest, nb_block)) {
   19a86:	4b07      	ldr	r3, [pc, #28]	; (19aa4 <sd_mmc_start_read_blocks+0x20>)
{
   19a88:	000c      	movs	r4, r1
	if (!driver_start_read_blocks(dest, nb_block)) {
   19a8a:	4798      	blx	r3
   19a8c:	4b06      	ldr	r3, [pc, #24]	; (19aa8 <sd_mmc_start_read_blocks+0x24>)
   19a8e:	2800      	cmp	r0, #0
   19a90:	d102      	bne.n	19a98 <sd_mmc_start_read_blocks+0x14>
		sd_mmc_nb_block_remaining = 0;
   19a92:	8018      	strh	r0, [r3, #0]
		return SD_MMC_ERR_COMM;
   19a94:	3005      	adds	r0, #5
	}
	sd_mmc_nb_block_remaining -= nb_block;
	return SD_MMC_OK;
}
   19a96:	bd10      	pop	{r4, pc}
	sd_mmc_nb_block_remaining -= nb_block;
   19a98:	8819      	ldrh	r1, [r3, #0]
	return SD_MMC_OK;
   19a9a:	2000      	movs	r0, #0
	sd_mmc_nb_block_remaining -= nb_block;
   19a9c:	1b09      	subs	r1, r1, r4
   19a9e:	8019      	strh	r1, [r3, #0]
	return SD_MMC_OK;
   19aa0:	e7f9      	b.n	19a96 <sd_mmc_start_read_blocks+0x12>
   19aa2:	46c0      	nop			; (mov r8, r8)
   19aa4:	0001a26d 	.word	0x0001a26d
   19aa8:	20003d20 	.word	0x20003d20

00019aac <sd_mmc_wait_end_of_read_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(bool abort)
{
   19aac:	b510      	push	{r4, lr}
	if (!driver_wait_end_of_read_blocks()) {
   19aae:	4b11      	ldr	r3, [pc, #68]	; (19af4 <sd_mmc_wait_end_of_read_blocks+0x48>)
{
   19ab0:	0004      	movs	r4, r0
	if (!driver_wait_end_of_read_blocks()) {
   19ab2:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
   19ab4:	2305      	movs	r3, #5
	if (!driver_wait_end_of_read_blocks()) {
   19ab6:	2800      	cmp	r0, #0
   19ab8:	d010      	beq.n	19adc <sd_mmc_wait_end_of_read_blocks+0x30>
   19aba:	4b0f      	ldr	r3, [pc, #60]	; (19af8 <sd_mmc_wait_end_of_read_blocks+0x4c>)
	}
	if (abort) {
   19abc:	2c00      	cmp	r4, #0
   19abe:	d009      	beq.n	19ad4 <sd_mmc_wait_end_of_read_blocks+0x28>
		sd_mmc_nb_block_remaining = 0;
   19ac0:	2200      	movs	r2, #0
   19ac2:	801a      	strh	r2, [r3, #0]
	} else if (sd_mmc_nb_block_remaining) {
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop read operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
   19ac4:	4b0d      	ldr	r3, [pc, #52]	; (19afc <sd_mmc_wait_end_of_read_blocks+0x50>)
   19ac6:	881b      	ldrh	r3, [r3, #0]
   19ac8:	2b01      	cmp	r3, #1
   19aca:	d109      	bne.n	19ae0 <sd_mmc_wait_end_of_read_blocks+0x34>
		// Single block transfer, then nothing to do
		sd_mmc_deselect_slot();
   19acc:	4b0c      	ldr	r3, [pc, #48]	; (19b00 <sd_mmc_wait_end_of_read_blocks+0x54>)
   19ace:	4798      	blx	r3
		return SD_MMC_OK;
   19ad0:	2300      	movs	r3, #0
   19ad2:	e003      	b.n	19adc <sd_mmc_wait_end_of_read_blocks+0x30>
	} else if (sd_mmc_nb_block_remaining) {
   19ad4:	881a      	ldrh	r2, [r3, #0]
		return SD_MMC_OK;
   19ad6:	0023      	movs	r3, r4
	} else if (sd_mmc_nb_block_remaining) {
   19ad8:	2a00      	cmp	r2, #0
   19ada:	d0f3      	beq.n	19ac4 <sd_mmc_wait_end_of_read_blocks+0x18>
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
		driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0);
	}
	sd_mmc_deselect_slot();
	return SD_MMC_OK;
}
   19adc:	0018      	movs	r0, r3
   19ade:	bd10      	pop	{r4, pc}
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
   19ae0:	2100      	movs	r1, #0
   19ae2:	4808      	ldr	r0, [pc, #32]	; (19b04 <sd_mmc_wait_end_of_read_blocks+0x58>)
   19ae4:	4c08      	ldr	r4, [pc, #32]	; (19b08 <sd_mmc_wait_end_of_read_blocks+0x5c>)
   19ae6:	47a0      	blx	r4
   19ae8:	1e01      	subs	r1, r0, #0
   19aea:	d1ef      	bne.n	19acc <sd_mmc_wait_end_of_read_blocks+0x20>
		driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0);
   19aec:	4805      	ldr	r0, [pc, #20]	; (19b04 <sd_mmc_wait_end_of_read_blocks+0x58>)
   19aee:	47a0      	blx	r4
   19af0:	e7ec      	b.n	19acc <sd_mmc_wait_end_of_read_blocks+0x20>
   19af2:	46c0      	nop			; (mov r8, r8)
   19af4:	0001a2d5 	.word	0x0001a2d5
   19af8:	20003d20 	.word	0x20003d20
   19afc:	20003d22 	.word	0x20003d22
   19b00:	000194d5 	.word	0x000194d5
   19b04:	0000310c 	.word	0x0000310c
   19b08:	0001a1dd 	.word	0x0001a1dd

00019b0c <sd_mmc_init_write_blocks>:

sd_mmc_err_t sd_mmc_init_write_blocks(uint8_t slot, uint32_t start,
		uint16_t nb_block)
{
   19b0c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	sd_mmc_err_t sd_mmc_err;
	uint32_t cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
   19b0e:	4b12      	ldr	r3, [pc, #72]	; (19b58 <sd_mmc_init_write_blocks+0x4c>)
{
   19b10:	000e      	movs	r6, r1
   19b12:	0014      	movs	r4, r2
	sd_mmc_err = sd_mmc_select_slot(slot);
   19b14:	4798      	blx	r3
   19b16:	1e05      	subs	r5, r0, #0
	if (sd_mmc_err != SD_MMC_OK) {
   19b18:	d115      	bne.n	19b46 <sd_mmc_init_write_blocks+0x3a>
	if (sd_mmc_is_write_protected(slot)) {
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_WP;
	}

	if (nb_block > 1) {
   19b1a:	2c01      	cmp	r4, #1
   19b1c:	d815      	bhi.n	19b4a <sd_mmc_init_write_blocks+0x3e>
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
	} else {
		cmd = SDMMC_CMD24_WRITE_BLOCK;
   19b1e:	480f      	ldr	r0, [pc, #60]	; (19b5c <sd_mmc_init_write_blocks+0x50>)
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
   19b20:	4b0f      	ldr	r3, [pc, #60]	; (19b60 <sd_mmc_init_write_blocks+0x54>)
   19b22:	681b      	ldr	r3, [r3, #0]
   19b24:	7adb      	ldrb	r3, [r3, #11]
   19b26:	071b      	lsls	r3, r3, #28
   19b28:	d400      	bmi.n	19b2c <sd_mmc_init_write_blocks+0x20>
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
   19b2a:	0276      	lsls	r6, r6, #9
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
   19b2c:	2301      	movs	r3, #1
   19b2e:	2280      	movs	r2, #128	; 0x80
   19b30:	9300      	str	r3, [sp, #0]
   19b32:	0031      	movs	r1, r6
   19b34:	0023      	movs	r3, r4
   19b36:	0092      	lsls	r2, r2, #2
   19b38:	4e0a      	ldr	r6, [pc, #40]	; (19b64 <sd_mmc_init_write_blocks+0x58>)
   19b3a:	47b0      	blx	r6
   19b3c:	2800      	cmp	r0, #0
   19b3e:	d106      	bne.n	19b4e <sd_mmc_init_write_blocks+0x42>
		sd_mmc_deselect_slot();
   19b40:	4b09      	ldr	r3, [pc, #36]	; (19b68 <sd_mmc_init_write_blocks+0x5c>)
   19b42:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
   19b44:	2505      	movs	r5, #5
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
   19b46:	0028      	movs	r0, r5
   19b48:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
   19b4a:	4808      	ldr	r0, [pc, #32]	; (19b6c <sd_mmc_init_write_blocks+0x60>)
   19b4c:	e7e8      	b.n	19b20 <sd_mmc_init_write_blocks+0x14>
	sd_mmc_nb_block_remaining = nb_block;
   19b4e:	4b08      	ldr	r3, [pc, #32]	; (19b70 <sd_mmc_init_write_blocks+0x64>)
   19b50:	801c      	strh	r4, [r3, #0]
	sd_mmc_nb_block_to_tranfer = nb_block;
   19b52:	4b08      	ldr	r3, [pc, #32]	; (19b74 <sd_mmc_init_write_blocks+0x68>)
   19b54:	801c      	strh	r4, [r3, #0]
	return SD_MMC_OK;
   19b56:	e7f6      	b.n	19b46 <sd_mmc_init_write_blocks+0x3a>
   19b58:	000194ed 	.word	0x000194ed
   19b5c:	00089118 	.word	0x00089118
   19b60:	20003cfc 	.word	0x20003cfc
   19b64:	0001a081 	.word	0x0001a081
   19b68:	000194d5 	.word	0x000194d5
   19b6c:	00109119 	.word	0x00109119
   19b70:	20003d20 	.word	0x20003d20
   19b74:	20003d22 	.word	0x20003d22

00019b78 <sd_mmc_start_write_blocks>:

sd_mmc_err_t sd_mmc_start_write_blocks(const void *src, uint16_t nb_block)
{
   19b78:	b510      	push	{r4, lr}
	Assert(sd_mmc_nb_block_remaining >= nb_block);
	if (!driver_start_write_blocks(src, nb_block)) {
   19b7a:	4b07      	ldr	r3, [pc, #28]	; (19b98 <sd_mmc_start_write_blocks+0x20>)
{
   19b7c:	000c      	movs	r4, r1
	if (!driver_start_write_blocks(src, nb_block)) {
   19b7e:	4798      	blx	r3
   19b80:	4b06      	ldr	r3, [pc, #24]	; (19b9c <sd_mmc_start_write_blocks+0x24>)
   19b82:	2800      	cmp	r0, #0
   19b84:	d102      	bne.n	19b8c <sd_mmc_start_write_blocks+0x14>
		sd_mmc_nb_block_remaining = 0;
   19b86:	8018      	strh	r0, [r3, #0]
		return SD_MMC_ERR_COMM;
   19b88:	3005      	adds	r0, #5
	}
	sd_mmc_nb_block_remaining -= nb_block;
	return SD_MMC_OK;
}
   19b8a:	bd10      	pop	{r4, pc}
	sd_mmc_nb_block_remaining -= nb_block;
   19b8c:	8819      	ldrh	r1, [r3, #0]
	return SD_MMC_OK;
   19b8e:	2000      	movs	r0, #0
	sd_mmc_nb_block_remaining -= nb_block;
   19b90:	1b09      	subs	r1, r1, r4
   19b92:	8019      	strh	r1, [r3, #0]
	return SD_MMC_OK;
   19b94:	e7f9      	b.n	19b8a <sd_mmc_start_write_blocks+0x12>
   19b96:	46c0      	nop			; (mov r8, r8)
   19b98:	0001a2d9 	.word	0x0001a2d9
   19b9c:	20003d20 	.word	0x20003d20

00019ba0 <sd_mmc_wait_end_of_write_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(bool abort)
{
   19ba0:	b510      	push	{r4, lr}
	if (!driver_wait_end_of_write_blocks()) {
   19ba2:	4b0a      	ldr	r3, [pc, #40]	; (19bcc <sd_mmc_wait_end_of_write_blocks+0x2c>)
{
   19ba4:	0004      	movs	r4, r0
	if (!driver_wait_end_of_write_blocks()) {
   19ba6:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
   19ba8:	2305      	movs	r3, #5
	if (!driver_wait_end_of_write_blocks()) {
   19baa:	2800      	cmp	r0, #0
   19bac:	d00c      	beq.n	19bc8 <sd_mmc_wait_end_of_write_blocks+0x28>
   19bae:	4b08      	ldr	r3, [pc, #32]	; (19bd0 <sd_mmc_wait_end_of_write_blocks+0x30>)
	}
	if (abort) {
   19bb0:	2c00      	cmp	r4, #0
   19bb2:	d005      	beq.n	19bc0 <sd_mmc_wait_end_of_write_blocks+0x20>
		sd_mmc_nb_block_remaining = 0;
   19bb4:	2200      	movs	r2, #0
   19bb6:	801a      	strh	r2, [r3, #0]
	}

	// All blocks are transfered then stop write operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
		// Single block transfer, then nothing to do
		sd_mmc_deselect_slot();
   19bb8:	4b06      	ldr	r3, [pc, #24]	; (19bd4 <sd_mmc_wait_end_of_write_blocks+0x34>)
   19bba:	4798      	blx	r3
		return SD_MMC_OK;
   19bbc:	2300      	movs	r3, #0
   19bbe:	e003      	b.n	19bc8 <sd_mmc_wait_end_of_write_blocks+0x28>
	} else if (sd_mmc_nb_block_remaining) {
   19bc0:	881a      	ldrh	r2, [r3, #0]
		return SD_MMC_OK;
   19bc2:	0023      	movs	r3, r4
	} else if (sd_mmc_nb_block_remaining) {
   19bc4:	2a00      	cmp	r2, #0
   19bc6:	d0f7      	beq.n	19bb8 <sd_mmc_wait_end_of_write_blocks+0x18>
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_deselect_slot();
	return SD_MMC_OK;
}
   19bc8:	0018      	movs	r0, r3
   19bca:	bd10      	pop	{r4, pc}
   19bcc:	0001a34d 	.word	0x0001a34d
   19bd0:	20003d20 	.word	0x20003d20
   19bd4:	000194d5 	.word	0x000194d5

00019bd8 <sd_mmc_test_unit_ready>:
 */

static bool sd_mmc_ejected[2] = {false, false};

Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
   19bd8:	b570      	push	{r4, r5, r6, lr}
	switch (sd_mmc_check(slot))
   19bda:	4b0e      	ldr	r3, [pc, #56]	; (19c14 <sd_mmc_test_unit_ready+0x3c>)
{
   19bdc:	0005      	movs	r5, r0
	switch (sd_mmc_check(slot))
   19bde:	4798      	blx	r3
		}
		// It is not a memory card
		return CTRL_NO_PRESENT;

	case SD_MMC_INIT_ONGOING:
		return CTRL_BUSY;
   19be0:	2403      	movs	r4, #3
	switch (sd_mmc_check(slot))
   19be2:	2801      	cmp	r0, #1
   19be4:	d013      	beq.n	19c0e <sd_mmc_test_unit_ready+0x36>
   19be6:	2800      	cmp	r0, #0
   19be8:	d007      	beq.n	19bfa <sd_mmc_test_unit_ready+0x22>
	case SD_MMC_ERR_NO_CARD:
		sd_mmc_ejected[slot] = false;
		return CTRL_NO_PRESENT;

	default:
		return CTRL_FAIL;
   19bea:	3c02      	subs	r4, #2
	switch (sd_mmc_check(slot))
   19bec:	2802      	cmp	r0, #2
   19bee:	d10e      	bne.n	19c0e <sd_mmc_test_unit_ready+0x36>
		sd_mmc_ejected[slot] = false;
   19bf0:	2200      	movs	r2, #0
   19bf2:	4b09      	ldr	r3, [pc, #36]	; (19c18 <sd_mmc_test_unit_ready+0x40>)
		return CTRL_NO_PRESENT;
   19bf4:	0004      	movs	r4, r0
		sd_mmc_ejected[slot] = false;
   19bf6:	555a      	strb	r2, [r3, r5]
		return CTRL_NO_PRESENT;
   19bf8:	e009      	b.n	19c0e <sd_mmc_test_unit_ready+0x36>
		if (sd_mmc_ejected[slot]) {
   19bfa:	4b07      	ldr	r3, [pc, #28]	; (19c18 <sd_mmc_test_unit_ready+0x40>)
   19bfc:	5d5c      	ldrb	r4, [r3, r5]
   19bfe:	2c00      	cmp	r4, #0
   19c00:	d104      	bne.n	19c0c <sd_mmc_test_unit_ready+0x34>
		if (sd_mmc_get_type(slot) & (CARD_TYPE_SD | CARD_TYPE_MMC)) {
   19c02:	4b06      	ldr	r3, [pc, #24]	; (19c1c <sd_mmc_test_unit_ready+0x44>)
   19c04:	0028      	movs	r0, r5
   19c06:	4798      	blx	r3
   19c08:	0783      	lsls	r3, r0, #30
   19c0a:	d100      	bne.n	19c0e <sd_mmc_test_unit_ready+0x36>
		return CTRL_NO_PRESENT;
   19c0c:	2402      	movs	r4, #2
	}
}
   19c0e:	0020      	movs	r0, r4
   19c10:	bd70      	pop	{r4, r5, r6, pc}
   19c12:	46c0      	nop			; (mov r8, r8)
   19c14:	000195a5 	.word	0x000195a5
   19c18:	20003d25 	.word	0x20003d25
   19c1c:	000199b9 	.word	0x000199b9

00019c20 <sd_mmc_test_unit_ready_0>:

Ctrl_status sd_mmc_test_unit_ready_0(void)
{
   19c20:	b510      	push	{r4, lr}
	return sd_mmc_test_unit_ready(0);
   19c22:	2000      	movs	r0, #0
   19c24:	4b01      	ldr	r3, [pc, #4]	; (19c2c <sd_mmc_test_unit_ready_0+0xc>)
   19c26:	4798      	blx	r3
}
   19c28:	bd10      	pop	{r4, pc}
   19c2a:	46c0      	nop			; (mov r8, r8)
   19c2c:	00019bd9 	.word	0x00019bd9

00019c30 <sd_mmc_read_capacity>:
{
	return sd_mmc_test_unit_ready(1);
}

Ctrl_status sd_mmc_read_capacity(uint8_t slot, uint32_t *nb_sector)
{
   19c30:	b570      	push	{r4, r5, r6, lr}
	// Return last sector address (-1)
	*nb_sector = (sd_mmc_get_capacity(slot) * 2) - 1;
   19c32:	4b05      	ldr	r3, [pc, #20]	; (19c48 <sd_mmc_read_capacity+0x18>)
{
   19c34:	000d      	movs	r5, r1
   19c36:	0004      	movs	r4, r0
	*nb_sector = (sd_mmc_get_capacity(slot) * 2) - 1;
   19c38:	4798      	blx	r3
   19c3a:	0040      	lsls	r0, r0, #1
   19c3c:	3801      	subs	r0, #1
   19c3e:	6028      	str	r0, [r5, #0]
	return sd_mmc_test_unit_ready(slot);
   19c40:	4b02      	ldr	r3, [pc, #8]	; (19c4c <sd_mmc_read_capacity+0x1c>)
   19c42:	0020      	movs	r0, r4
   19c44:	4798      	blx	r3
}
   19c46:	bd70      	pop	{r4, r5, r6, pc}
   19c48:	000199e1 	.word	0x000199e1
   19c4c:	00019bd9 	.word	0x00019bd9

00019c50 <sd_mmc_read_capacity_0>:

Ctrl_status sd_mmc_read_capacity_0(uint32_t *nb_sector)
{
   19c50:	b510      	push	{r4, lr}
   19c52:	0001      	movs	r1, r0
	return sd_mmc_read_capacity(0, nb_sector);
   19c54:	4b01      	ldr	r3, [pc, #4]	; (19c5c <sd_mmc_read_capacity_0+0xc>)
   19c56:	2000      	movs	r0, #0
   19c58:	4798      	blx	r3
}
   19c5a:	bd10      	pop	{r4, pc}
   19c5c:	00019c31 	.word	0x00019c31

00019c60 <sd_mmc_wr_protect_0>:
{
	return sd_mmc_is_write_protected(slot);
}

bool sd_mmc_wr_protect_0(void)
{
   19c60:	b510      	push	{r4, lr}
	return sd_mmc_is_write_protected(slot);
   19c62:	2000      	movs	r0, #0
   19c64:	4b01      	ldr	r3, [pc, #4]	; (19c6c <sd_mmc_wr_protect_0+0xc>)
   19c66:	4798      	blx	r3
	return sd_mmc_wr_protect(0);
}
   19c68:	bd10      	pop	{r4, pc}
   19c6a:	46c0      	nop			; (mov r8, r8)
   19c6c:	00019a09 	.word	0x00019a09

00019c70 <sd_mmc_mem_2_ram>:
/**
 * \name MEM <-> RAM Interface
 * @{
 */
Ctrl_status sd_mmc_mem_2_ram(uint8_t slot, uint32_t addr, void *ram)
{
   19c70:	b510      	push	{r4, lr}
	switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
   19c72:	4b0c      	ldr	r3, [pc, #48]	; (19ca4 <sd_mmc_mem_2_ram+0x34>)
{
   19c74:	0014      	movs	r4, r2
	switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
   19c76:	2201      	movs	r2, #1
   19c78:	4798      	blx	r3
   19c7a:	2800      	cmp	r0, #0
   19c7c:	d005      	beq.n	19c8a <sd_mmc_mem_2_ram+0x1a>
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
   19c7e:	3802      	subs	r0, #2
   19c80:	4243      	negs	r3, r0
   19c82:	4143      	adcs	r3, r0
   19c84:	3301      	adds	r3, #1
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks(false)) {
		return CTRL_FAIL;
	}
	return CTRL_GOOD;
}
   19c86:	0018      	movs	r0, r3
   19c88:	bd10      	pop	{r4, pc}
	if (SD_MMC_OK != sd_mmc_start_read_blocks(ram, 1)) {
   19c8a:	4b07      	ldr	r3, [pc, #28]	; (19ca8 <sd_mmc_mem_2_ram+0x38>)
   19c8c:	2101      	movs	r1, #1
   19c8e:	0020      	movs	r0, r4
   19c90:	4798      	blx	r3
		return CTRL_FAIL;
   19c92:	2301      	movs	r3, #1
	if (SD_MMC_OK != sd_mmc_start_read_blocks(ram, 1)) {
   19c94:	2800      	cmp	r0, #0
   19c96:	d1f6      	bne.n	19c86 <sd_mmc_mem_2_ram+0x16>
	if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks(false)) {
   19c98:	4b04      	ldr	r3, [pc, #16]	; (19cac <sd_mmc_mem_2_ram+0x3c>)
   19c9a:	4798      	blx	r3
   19c9c:	1e43      	subs	r3, r0, #1
   19c9e:	4198      	sbcs	r0, r3
		return CTRL_NO_PRESENT;
   19ca0:	b2c3      	uxtb	r3, r0
   19ca2:	e7f0      	b.n	19c86 <sd_mmc_mem_2_ram+0x16>
   19ca4:	00019a0d 	.word	0x00019a0d
   19ca8:	00019a85 	.word	0x00019a85
   19cac:	00019aad 	.word	0x00019aad

00019cb0 <sd_mmc_mem_2_ram_0>:

Ctrl_status sd_mmc_mem_2_ram_0(uint32_t addr, void *ram)
{
   19cb0:	b510      	push	{r4, lr}
   19cb2:	000a      	movs	r2, r1
	return sd_mmc_mem_2_ram(0, addr, ram);
   19cb4:	4b02      	ldr	r3, [pc, #8]	; (19cc0 <sd_mmc_mem_2_ram_0+0x10>)
   19cb6:	0001      	movs	r1, r0
   19cb8:	2000      	movs	r0, #0
   19cba:	4798      	blx	r3
}
   19cbc:	bd10      	pop	{r4, pc}
   19cbe:	46c0      	nop			; (mov r8, r8)
   19cc0:	00019c71 	.word	0x00019c71

00019cc4 <sd_mmc_ram_2_mem>:
{
	return sd_mmc_mem_2_ram(1, addr, ram);
}

Ctrl_status sd_mmc_ram_2_mem(uint8_t slot, uint32_t addr, const void *ram)
{
   19cc4:	b510      	push	{r4, lr}
	switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
   19cc6:	4b0c      	ldr	r3, [pc, #48]	; (19cf8 <sd_mmc_ram_2_mem+0x34>)
{
   19cc8:	0014      	movs	r4, r2
	switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
   19cca:	2201      	movs	r2, #1
   19ccc:	4798      	blx	r3
   19cce:	2800      	cmp	r0, #0
   19cd0:	d005      	beq.n	19cde <sd_mmc_ram_2_mem+0x1a>
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
   19cd2:	3802      	subs	r0, #2
   19cd4:	4243      	negs	r3, r0
   19cd6:	4143      	adcs	r3, r0
   19cd8:	3301      	adds	r3, #1
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks(false)) {
		return CTRL_FAIL;
	}
	return CTRL_GOOD;
}
   19cda:	0018      	movs	r0, r3
   19cdc:	bd10      	pop	{r4, pc}
	if (SD_MMC_OK != sd_mmc_start_write_blocks(ram, 1)) {
   19cde:	4b07      	ldr	r3, [pc, #28]	; (19cfc <sd_mmc_ram_2_mem+0x38>)
   19ce0:	2101      	movs	r1, #1
   19ce2:	0020      	movs	r0, r4
   19ce4:	4798      	blx	r3
		return CTRL_FAIL;
   19ce6:	2301      	movs	r3, #1
	if (SD_MMC_OK != sd_mmc_start_write_blocks(ram, 1)) {
   19ce8:	2800      	cmp	r0, #0
   19cea:	d1f6      	bne.n	19cda <sd_mmc_ram_2_mem+0x16>
	if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks(false)) {
   19cec:	4b04      	ldr	r3, [pc, #16]	; (19d00 <sd_mmc_ram_2_mem+0x3c>)
   19cee:	4798      	blx	r3
   19cf0:	1e43      	subs	r3, r0, #1
   19cf2:	4198      	sbcs	r0, r3
		return CTRL_NO_PRESENT;
   19cf4:	b2c3      	uxtb	r3, r0
   19cf6:	e7f0      	b.n	19cda <sd_mmc_ram_2_mem+0x16>
   19cf8:	00019b0d 	.word	0x00019b0d
   19cfc:	00019b79 	.word	0x00019b79
   19d00:	00019ba1 	.word	0x00019ba1

00019d04 <sd_mmc_ram_2_mem_0>:

Ctrl_status sd_mmc_ram_2_mem_0(uint32_t addr, const void *ram)
{
   19d04:	b510      	push	{r4, lr}
   19d06:	000a      	movs	r2, r1
	return sd_mmc_ram_2_mem(0, addr, ram);
   19d08:	4b02      	ldr	r3, [pc, #8]	; (19d14 <sd_mmc_ram_2_mem_0+0x10>)
   19d0a:	0001      	movs	r1, r0
   19d0c:	2000      	movs	r0, #0
   19d0e:	4798      	blx	r3
}
   19d10:	bd10      	pop	{r4, pc}
   19d12:	46c0      	nop			; (mov r8, r8)
   19d14:	00019cc5 	.word	0x00019cc5

00019d18 <sd_mmc_spi_start_write_block>:

/**
 * \brief Sends the correct TOKEN on the line to start a write block transfer
 */
static void sd_mmc_spi_start_write_block(void)
{
   19d18:	b537      	push	{r0, r1, r2, r4, r5, lr}
	uint8_t dummy = 0xFF;
   19d1a:	466b      	mov	r3, sp
   19d1c:	1d99      	adds	r1, r3, #6
   19d1e:	23ff      	movs	r3, #255	; 0xff
	Assert(!(sd_mmc_spi_transfert_pos % sd_mmc_spi_block_size));
	// Delay before start write block:
	// Nwr timing minimum = 8 cylces
	spi_write_buffer_wait(&sd_mmc_master,&dummy, 1);
   19d20:	4d09      	ldr	r5, [pc, #36]	; (19d48 <sd_mmc_spi_start_write_block+0x30>)
   19d22:	2201      	movs	r2, #1
   19d24:	0028      	movs	r0, r5
   19d26:	4c09      	ldr	r4, [pc, #36]	; (19d4c <sd_mmc_spi_start_write_block+0x34>)
	uint8_t dummy = 0xFF;
   19d28:	700b      	strb	r3, [r1, #0]
	spi_write_buffer_wait(&sd_mmc_master,&dummy, 1);
   19d2a:	47a0      	blx	r4
   19d2c:	466a      	mov	r2, sp
	// Send start token
	uint8_t token;
	if (1 == sd_mmc_spi_nb_block) {
   19d2e:	4b08      	ldr	r3, [pc, #32]	; (19d50 <sd_mmc_spi_start_write_block+0x38>)
   19d30:	1dd1      	adds	r1, r2, #7
   19d32:	881b      	ldrh	r3, [r3, #0]
   19d34:	2b01      	cmp	r3, #1
   19d36:	d105      	bne.n	19d44 <sd_mmc_spi_start_write_block+0x2c>
		token = SPI_TOKEN_SINGLE_WRITE;
   19d38:	33fd      	adds	r3, #253	; 0xfd
	} else {
		token = SPI_TOKEN_MULTI_WRITE;
	}
	spi_write_buffer_wait(&sd_mmc_master,&token, 1);
   19d3a:	0028      	movs	r0, r5
   19d3c:	2201      	movs	r2, #1
		token = SPI_TOKEN_MULTI_WRITE;
   19d3e:	700b      	strb	r3, [r1, #0]
	spi_write_buffer_wait(&sd_mmc_master,&token, 1);
   19d40:	47a0      	blx	r4
}
   19d42:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
		token = SPI_TOKEN_MULTI_WRITE;
   19d44:	23fc      	movs	r3, #252	; 0xfc
   19d46:	e7f8      	b.n	19d3a <sd_mmc_spi_start_write_block+0x22>
   19d48:	20003d28 	.word	0x20003d28
   19d4c:	0001db2d 	.word	0x0001db2d
   19d50:	20003d6a 	.word	0x20003d6a

00019d54 <sd_mmc_spi_wait_busy>:
{
   19d54:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	uint8_t line = 0xFF;
   19d56:	466b      	mov	r3, sp
   19d58:	24ff      	movs	r4, #255	; 0xff
	spi_read_buffer_wait(&sd_mmc_master, &line, 1,
   19d5a:	4e0f      	ldr	r6, [pc, #60]	; (19d98 <sd_mmc_spi_wait_busy+0x44>)
	uint8_t line = 0xFF;
   19d5c:	1ddd      	adds	r5, r3, #7
	spi_read_buffer_wait(&sd_mmc_master, &line, 1,
   19d5e:	2201      	movs	r2, #1
   19d60:	0023      	movs	r3, r4
   19d62:	0029      	movs	r1, r5
   19d64:	4f0d      	ldr	r7, [pc, #52]	; (19d9c <sd_mmc_spi_wait_busy+0x48>)
   19d66:	0030      	movs	r0, r6
	uint8_t line = 0xFF;
   19d68:	702c      	strb	r4, [r5, #0]
	spi_read_buffer_wait(&sd_mmc_master, &line, 1,
   19d6a:	47b8      	blx	r7
	spi_read_buffer_wait(&sd_mmc_master, &line, 1,
   19d6c:	0023      	movs	r3, r4
   19d6e:	2201      	movs	r2, #1
   19d70:	0029      	movs	r1, r5
   19d72:	0030      	movs	r0, r6
   19d74:	47b8      	blx	r7
   19d76:	4c0a      	ldr	r4, [pc, #40]	; (19da0 <sd_mmc_spi_wait_busy+0x4c>)
		spi_read_buffer_wait(&sd_mmc_master, &line, 1,
   19d78:	23ff      	movs	r3, #255	; 0xff
   19d7a:	2201      	movs	r2, #1
   19d7c:	0029      	movs	r1, r5
   19d7e:	0030      	movs	r0, r6
   19d80:	4f06      	ldr	r7, [pc, #24]	; (19d9c <sd_mmc_spi_wait_busy+0x48>)
   19d82:	3c01      	subs	r4, #1
   19d84:	47b8      	blx	r7
		if (!(nec_timeout--)) {
   19d86:	2c00      	cmp	r4, #0
   19d88:	d004      	beq.n	19d94 <sd_mmc_spi_wait_busy+0x40>
	} while (line != 0xFF);
   19d8a:	782b      	ldrb	r3, [r5, #0]
   19d8c:	2bff      	cmp	r3, #255	; 0xff
   19d8e:	d1f3      	bne.n	19d78 <sd_mmc_spi_wait_busy+0x24>
	return true;
   19d90:	2001      	movs	r0, #1
}
   19d92:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
			return false;
   19d94:	0020      	movs	r0, r4
   19d96:	e7fc      	b.n	19d92 <sd_mmc_spi_wait_busy+0x3e>
   19d98:	20003d28 	.word	0x20003d28
   19d9c:	0001da21 	.word	0x0001da21
   19da0:	00030d41 	.word	0x00030d41

00019da4 <sd_mmc_spi_start_read_block>:
{
   19da4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	token = 0;
   19da6:	466b      	mov	r3, sp
   19da8:	1ddd      	adds	r5, r3, #7
   19daa:	2300      	movs	r3, #0
		if (SPI_TOKEN_DATA_ERROR_VALID(token)) {
   19dac:	260f      	movs	r6, #15
	token = 0;
   19dae:	4c11      	ldr	r4, [pc, #68]	; (19df4 <sd_mmc_spi_start_read_block+0x50>)
   19db0:	702b      	strb	r3, [r5, #0]
   19db2:	3c01      	subs	r4, #1
		if (i-- == 0) {
   19db4:	2c00      	cmp	r4, #0
   19db6:	d104      	bne.n	19dc2 <sd_mmc_spi_start_read_block+0x1e>
			sd_mmc_spi_err = SD_MMC_SPI_ERR_READ_TIMEOUT;
   19db8:	2204      	movs	r2, #4
			return false;
   19dba:	0020      	movs	r0, r4
			sd_mmc_spi_err = SD_MMC_SPI_ERR_READ_TIMEOUT;
   19dbc:	4b0e      	ldr	r3, [pc, #56]	; (19df8 <sd_mmc_spi_start_read_block+0x54>)
   19dbe:	701a      	strb	r2, [r3, #0]
}
   19dc0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		spi_read_buffer_wait(&sd_mmc_master, &token, 1,
   19dc2:	2201      	movs	r2, #1
   19dc4:	23ff      	movs	r3, #255	; 0xff
   19dc6:	0029      	movs	r1, r5
   19dc8:	480c      	ldr	r0, [pc, #48]	; (19dfc <sd_mmc_spi_start_read_block+0x58>)
   19dca:	4f0d      	ldr	r7, [pc, #52]	; (19e00 <sd_mmc_spi_start_read_block+0x5c>)
   19dcc:	47b8      	blx	r7
		if (SPI_TOKEN_DATA_ERROR_VALID(token)) {
   19dce:	7828      	ldrb	r0, [r5, #0]
   19dd0:	0002      	movs	r2, r0
   19dd2:	43b2      	bics	r2, r6
   19dd4:	d109      	bne.n	19dea <sd_mmc_spi_start_read_block+0x46>
			if (token & (SPI_TOKEN_DATA_ERROR_ERROR
   19dd6:	2107      	movs	r1, #7
   19dd8:	4b07      	ldr	r3, [pc, #28]	; (19df8 <sd_mmc_spi_start_read_block+0x54>)
   19dda:	4008      	ands	r0, r1
   19ddc:	d002      	beq.n	19de4 <sd_mmc_spi_start_read_block+0x40>
				sd_mmc_spi_err = SD_MMC_SPI_ERR_READ_CRC;
   19dde:	7019      	strb	r1, [r3, #0]
			return false;
   19de0:	0010      	movs	r0, r2
   19de2:	e7ed      	b.n	19dc0 <sd_mmc_spi_start_read_block+0x1c>
				sd_mmc_spi_err = SD_MMC_SPI_ERR_OUT_OF_RANGE;
   19de4:	220b      	movs	r2, #11
   19de6:	701a      	strb	r2, [r3, #0]
   19de8:	e7ea      	b.n	19dc0 <sd_mmc_spi_start_read_block+0x1c>
	} while (token != SPI_TOKEN_SINGLE_MULTI_READ);
   19dea:	28fe      	cmp	r0, #254	; 0xfe
   19dec:	d1e1      	bne.n	19db2 <sd_mmc_spi_start_read_block+0xe>
	return true;
   19dee:	38fd      	subs	r0, #253	; 0xfd
   19df0:	e7e6      	b.n	19dc0 <sd_mmc_spi_start_read_block+0x1c>
   19df2:	46c0      	nop			; (mov r8, r8)
   19df4:	0007a121 	.word	0x0007a121
   19df8:	20003d69 	.word	0x20003d69
   19dfc:	20003d28 	.word	0x20003d28
   19e00:	0001da21 	.word	0x0001da21

00019e04 <sd_mmc_spi_stop_write_block>:
 *
 * \return true if success, otherwise false
 *         with a update of \ref sd_mmc_spi_err.
 */
static bool sd_mmc_spi_stop_write_block(void)
{
   19e04:	b537      	push	{r0, r1, r2, r4, r5, lr}
	uint8_t resp;
	uint16_t crc;
	uint16_t dummy = 0xFF;

	// Send CRC
	crc = 0xFFFF; /// CRC is disabled in SPI mode
   19e06:	466b      	mov	r3, sp
   19e08:	1d99      	adds	r1, r3, #6
   19e0a:	2301      	movs	r3, #1
	spi_write_buffer_wait(&sd_mmc_master, (uint8_t *)&crc, 2);
   19e0c:	4d12      	ldr	r5, [pc, #72]	; (19e58 <sd_mmc_spi_stop_write_block+0x54>)
	crc = 0xFFFF; /// CRC is disabled in SPI mode
   19e0e:	425b      	negs	r3, r3
   19e10:	800b      	strh	r3, [r1, #0]
	spi_write_buffer_wait(&sd_mmc_master, (uint8_t *)&crc, 2);
   19e12:	2202      	movs	r2, #2
   19e14:	0028      	movs	r0, r5
   19e16:	4b11      	ldr	r3, [pc, #68]	; (19e5c <sd_mmc_spi_stop_write_block+0x58>)
   19e18:	4798      	blx	r3
	// Receiv data response token
	spi_read_buffer_wait(&sd_mmc_master, &resp, 1,
   19e1a:	466b      	mov	r3, sp
   19e1c:	1d5c      	adds	r4, r3, #5
   19e1e:	0028      	movs	r0, r5
   19e20:	23ff      	movs	r3, #255	; 0xff
   19e22:	2201      	movs	r2, #1
   19e24:	0021      	movs	r1, r4
   19e26:	4d0e      	ldr	r5, [pc, #56]	; (19e60 <sd_mmc_spi_stop_write_block+0x5c>)
   19e28:	47a8      	blx	r5
			dummy);
	if (!SPI_TOKEN_DATA_RESP_VALID(resp)) {
   19e2a:	2011      	movs	r0, #17
   19e2c:	7823      	ldrb	r3, [r4, #0]
   19e2e:	4018      	ands	r0, r3
   19e30:	2801      	cmp	r0, #1
   19e32:	d004      	beq.n	19e3e <sd_mmc_spi_stop_write_block+0x3a>
		sd_mmc_spi_err = SD_MMC_SPI_ERR;
   19e34:	2201      	movs	r2, #1
   19e36:	4b0b      	ldr	r3, [pc, #44]	; (19e64 <sd_mmc_spi_stop_write_block+0x60>)
   19e38:	701a      	strb	r2, [r3, #0]
	case SPI_TOKEN_DATA_RESP_WRITE_ERR:
	default:
		sd_mmc_spi_err = SD_MMC_SPI_ERR_WRITE;
		sd_mmc_spi_debug("%s: Write blocks SD_MMC_SPI_ERR_WR, resp 0x%x\n\r",
				__func__, resp);
		return false;
   19e3a:	2000      	movs	r0, #0
	}
	return true;
}
   19e3c:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
	switch (SPI_TOKEN_DATA_RESP_CODE(resp)) {
   19e3e:	221e      	movs	r2, #30
   19e40:	4013      	ands	r3, r2
   19e42:	2b04      	cmp	r3, #4
   19e44:	d0fa      	beq.n	19e3c <sd_mmc_spi_stop_write_block+0x38>
   19e46:	4a07      	ldr	r2, [pc, #28]	; (19e64 <sd_mmc_spi_stop_write_block+0x60>)
   19e48:	2b0a      	cmp	r3, #10
   19e4a:	d102      	bne.n	19e52 <sd_mmc_spi_stop_write_block+0x4e>
		sd_mmc_spi_err = SD_MMC_SPI_ERR_WRITE_CRC;
   19e4c:	3b02      	subs	r3, #2
		sd_mmc_spi_err = SD_MMC_SPI_ERR_WRITE;
   19e4e:	7013      	strb	r3, [r2, #0]
   19e50:	e7f3      	b.n	19e3a <sd_mmc_spi_stop_write_block+0x36>
   19e52:	230a      	movs	r3, #10
   19e54:	e7fb      	b.n	19e4e <sd_mmc_spi_stop_write_block+0x4a>
   19e56:	46c0      	nop			; (mov r8, r8)
   19e58:	20003d28 	.word	0x20003d28
   19e5c:	0001db2d 	.word	0x0001db2d
   19e60:	0001da21 	.word	0x0001da21
   19e64:	20003d69 	.word	0x20003d69

00019e68 <sd_mmc_spi_stop_multiwrite_block>:
 *
 * \return true if success, otherwise false
 *         with a update of \ref sd_mmc_spi_err.
 */
static bool sd_mmc_spi_stop_multiwrite_block(void)
{
   19e68:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	uint8_t value;

	if (1 == sd_mmc_spi_nb_block) {
   19e6a:	4b13      	ldr	r3, [pc, #76]	; (19eb8 <sd_mmc_spi_stop_multiwrite_block+0x50>)
   19e6c:	881d      	ldrh	r5, [r3, #0]
		return true; // Single block write
   19e6e:	002c      	movs	r4, r5
	if (1 == sd_mmc_spi_nb_block) {
   19e70:	2d01      	cmp	r5, #1
   19e72:	d01f      	beq.n	19eb4 <sd_mmc_spi_stop_multiwrite_block+0x4c>
	}
	if (sd_mmc_spi_nb_block >
		(sd_mmc_spi_transfert_pos / sd_mmc_spi_block_size)) {
   19e74:	4b11      	ldr	r3, [pc, #68]	; (19ebc <sd_mmc_spi_stop_multiwrite_block+0x54>)
		return true; // Single block write
   19e76:	2401      	movs	r4, #1
		(sd_mmc_spi_transfert_pos / sd_mmc_spi_block_size)) {
   19e78:	8819      	ldrh	r1, [r3, #0]
   19e7a:	4b11      	ldr	r3, [pc, #68]	; (19ec0 <sd_mmc_spi_stop_multiwrite_block+0x58>)
   19e7c:	6818      	ldr	r0, [r3, #0]
   19e7e:	4b11      	ldr	r3, [pc, #68]	; (19ec4 <sd_mmc_spi_stop_multiwrite_block+0x5c>)
   19e80:	4798      	blx	r3
	if (sd_mmc_spi_nb_block >
   19e82:	4285      	cmp	r5, r0
   19e84:	d816      	bhi.n	19eb4 <sd_mmc_spi_stop_multiwrite_block+0x4c>
		return true; // It is not the End of multi write
	}

	// Delay before start write block:
	// Nwr timing minimum = 8 cylces
	value = 0xFF;
   19e86:	466b      	mov	r3, sp
   19e88:	1ddd      	adds	r5, r3, #7
   19e8a:	23ff      	movs	r3, #255	; 0xff
	spi_write_buffer_wait(&sd_mmc_master, &value, 1);
   19e8c:	4f0e      	ldr	r7, [pc, #56]	; (19ec8 <sd_mmc_spi_stop_multiwrite_block+0x60>)
   19e8e:	0022      	movs	r2, r4
   19e90:	0029      	movs	r1, r5
   19e92:	4e0e      	ldr	r6, [pc, #56]	; (19ecc <sd_mmc_spi_stop_multiwrite_block+0x64>)
   19e94:	0038      	movs	r0, r7
	value = 0xFF;
   19e96:	702b      	strb	r3, [r5, #0]
	spi_write_buffer_wait(&sd_mmc_master, &value, 1);
   19e98:	47b0      	blx	r6
	// Send stop token
	value = SPI_TOKEN_STOP_TRAN;
   19e9a:	23fd      	movs	r3, #253	; 0xfd
	spi_write_buffer_wait(&sd_mmc_master, &value, 1);
   19e9c:	0022      	movs	r2, r4
   19e9e:	0029      	movs	r1, r5
   19ea0:	0038      	movs	r0, r7
	value = SPI_TOKEN_STOP_TRAN;
   19ea2:	702b      	strb	r3, [r5, #0]
	spi_write_buffer_wait(&sd_mmc_master, &value, 1);
   19ea4:	47b0      	blx	r6
	// Wait busy
	if (!sd_mmc_spi_wait_busy()) {
   19ea6:	4b0a      	ldr	r3, [pc, #40]	; (19ed0 <sd_mmc_spi_stop_multiwrite_block+0x68>)
   19ea8:	4798      	blx	r3
   19eaa:	1e04      	subs	r4, r0, #0
   19eac:	d102      	bne.n	19eb4 <sd_mmc_spi_stop_multiwrite_block+0x4c>
		sd_mmc_spi_err = SD_MMC_SPI_ERR_WRITE_TIMEOUT;
   19eae:	2205      	movs	r2, #5
   19eb0:	4b08      	ldr	r3, [pc, #32]	; (19ed4 <sd_mmc_spi_stop_multiwrite_block+0x6c>)
   19eb2:	701a      	strb	r2, [r3, #0]
		sd_mmc_spi_debug("%s: Stop write blocks timeout\n\r",
				__func__);
		return false;
	}
	return true;
}
   19eb4:	0020      	movs	r0, r4
   19eb6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   19eb8:	20003d6a 	.word	0x20003d6a
   19ebc:	20003d64 	.word	0x20003d64
   19ec0:	20003d70 	.word	0x20003d70
   19ec4:	000258bd 	.word	0x000258bd
   19ec8:	20003d28 	.word	0x20003d28
   19ecc:	0001db2d 	.word	0x0001db2d
   19ed0:	00019d55 	.word	0x00019d55
   19ed4:	20003d69 	.word	0x20003d69

00019ed8 <sd_mmc_spi_init>:
	return sd_mmc_spi_err;
}

void sd_mmc_spi_init(void)
{
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   19ed8:	2100      	movs	r1, #0
   19eda:	4b2d      	ldr	r3, [pc, #180]	; (19f90 <sd_mmc_spi_init+0xb8>)
{
   19edc:	b5f0      	push	{r4, r5, r6, r7, lr}
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   19ede:	7019      	strb	r1, [r3, #0]
	config->generator_source = GCLK_GENERATOR_0;
   19ee0:	230d      	movs	r3, #13
	config->mode             = SPI_MODE_MASTER;
   19ee2:	2501      	movs	r5, #1
{
   19ee4:	b091      	sub	sp, #68	; 0x44
	config->generator_source = GCLK_GENERATOR_0;
   19ee6:	446b      	add	r3, sp
	config->mode             = SPI_MODE_MASTER;
   19ee8:	ac02      	add	r4, sp, #8
	config->generator_source = GCLK_GENERATOR_0;
   19eea:	77d9      	strb	r1, [r3, #31]
	memset(&(config->mode_specific), 0, sizeof(config->mode_specific));
   19eec:	220c      	movs	r2, #12
   19eee:	4b29      	ldr	r3, [pc, #164]	; (19f94 <sd_mmc_spi_init+0xbc>)
   19ef0:	a808      	add	r0, sp, #32
	config->mode             = SPI_MODE_MASTER;
   19ef2:	7025      	strb	r5, [r4, #0]
	config->data_order       = SPI_DATA_ORDER_MSB;
   19ef4:	9103      	str	r1, [sp, #12]
	config->transfer_mode    = SPI_TRANSFER_MODE_0;
   19ef6:	9104      	str	r1, [sp, #16]
	config->character_size   = SPI_CHARACTER_SIZE_8BIT;
   19ef8:	7421      	strb	r1, [r4, #16]
	config->run_in_standby   = false;
   19efa:	7461      	strb	r1, [r4, #17]
	config->receiver_enable  = true;
   19efc:	74a5      	strb	r5, [r4, #18]
	config->select_slave_low_detect_enable= true;
   19efe:	74e5      	strb	r5, [r4, #19]
	config->master_slave_select_enable= false;
   19f00:	7521      	strb	r1, [r4, #20]
	memset(&(config->mode_specific), 0, sizeof(config->mode_specific));
   19f02:	4798      	blx	r3

	// Initialize SPI interface and enable it
	struct spi_config config;
	spi_get_config_defaults(&config);

	config.mux_setting = SD_MMC_SPI_PINMUX_SETTING;
   19f04:	2380      	movs	r3, #128	; 0x80
   19f06:	025b      	lsls	r3, r3, #9
   19f08:	60e3      	str	r3, [r4, #12]
	config.pinmux_pad0 = SD_MMC_SPI_PINMUX_PAD0;
   19f0a:	4b23      	ldr	r3, [pc, #140]	; (19f98 <sd_mmc_spi_init+0xc0>)
	config.pinmux_pad2 = SD_MMC_SPI_PINMUX_PAD2;
	config.pinmux_pad3 = SD_MMC_SPI_PINMUX_PAD3;
	config.generator_source = SD_MMC_SPI_SOURCE_CLOCK;
	config.mode_specific.master.baudrate = SDMMC_CLOCK_INIT;

	spi_init(&sd_mmc_master, SD_MMC_SPI, &config);
   19f0c:	4f23      	ldr	r7, [pc, #140]	; (19f9c <sd_mmc_spi_init+0xc4>)
	config.pinmux_pad0 = SD_MMC_SPI_PINMUX_PAD0;
   19f0e:	62a3      	str	r3, [r4, #40]	; 0x28
	config.pinmux_pad1 = SD_MMC_SPI_PINMUX_PAD1;
   19f10:	2301      	movs	r3, #1
   19f12:	425b      	negs	r3, r3
   19f14:	62e3      	str	r3, [r4, #44]	; 0x2c
	config.pinmux_pad2 = SD_MMC_SPI_PINMUX_PAD2;
   19f16:	4b22      	ldr	r3, [pc, #136]	; (19fa0 <sd_mmc_spi_init+0xc8>)
	spi_init(&sd_mmc_master, SD_MMC_SPI, &config);
   19f18:	0022      	movs	r2, r4
	config.pinmux_pad2 = SD_MMC_SPI_PINMUX_PAD2;
   19f1a:	6323      	str	r3, [r4, #48]	; 0x30
	config.pinmux_pad3 = SD_MMC_SPI_PINMUX_PAD3;
   19f1c:	4b21      	ldr	r3, [pc, #132]	; (19fa4 <sd_mmc_spi_init+0xcc>)
	spi_init(&sd_mmc_master, SD_MMC_SPI, &config);
   19f1e:	4922      	ldr	r1, [pc, #136]	; (19fa8 <sd_mmc_spi_init+0xd0>)
	config.pinmux_pad3 = SD_MMC_SPI_PINMUX_PAD3;
   19f20:	6363      	str	r3, [r4, #52]	; 0x34
	config.mode_specific.master.baudrate = SDMMC_CLOCK_INIT;
   19f22:	4b22      	ldr	r3, [pc, #136]	; (19fac <sd_mmc_spi_init+0xd4>)
	spi_init(&sd_mmc_master, SD_MMC_SPI, &config);
   19f24:	0038      	movs	r0, r7
	config.mode_specific.master.baudrate = SDMMC_CLOCK_INIT;
   19f26:	61a3      	str	r3, [r4, #24]
	spi_init(&sd_mmc_master, SD_MMC_SPI, &config);
   19f28:	4b21      	ldr	r3, [pc, #132]	; (19fb0 <sd_mmc_spi_init+0xd8>)
   19f2a:	4798      	blx	r3
	SercomSpi *const spi_module = &(module->hw->SPI);
   19f2c:	683e      	ldr	r6, [r7, #0]
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
   19f2e:	4b21      	ldr	r3, [pc, #132]	; (19fb4 <sd_mmc_spi_init+0xdc>)
   19f30:	0030      	movs	r0, r6
   19f32:	4798      	blx	r3
   19f34:	231f      	movs	r3, #31
   19f36:	4018      	ands	r0, r3
   19f38:	4085      	lsls	r5, r0
   19f3a:	4b1f      	ldr	r3, [pc, #124]	; (19fb8 <sd_mmc_spi_init+0xe0>)
   19f3c:	601d      	str	r5, [r3, #0]
	SercomSpi *const spi_module = &(module->hw->SPI);
   19f3e:	683b      	ldr	r3, [r7, #0]
	return (spi_module->SYNCBUSY.reg);
   19f40:	69dc      	ldr	r4, [r3, #28]
	while (spi_is_syncing(module)) {
   19f42:	2c00      	cmp	r4, #0
   19f44:	d1fc      	bne.n	19f40 <sd_mmc_spi_init+0x68>
	spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
   19f46:	2302      	movs	r3, #2
	config->input_pull = PORT_PIN_PULL_UP;
   19f48:	2501      	movs	r5, #1
   19f4a:	6832      	ldr	r2, [r6, #0]
   19f4c:	a901      	add	r1, sp, #4
   19f4e:	4313      	orrs	r3, r2
	spi_enable(&sd_mmc_master);

	spi_slave_inst_get_config_defaults(&slave_configs[0]);
	slave_configs[0].ss_pin = ss_pins[0];
   19f50:	4a1a      	ldr	r2, [pc, #104]	; (19fbc <sd_mmc_spi_init+0xe4>)
   19f52:	6033      	str	r3, [r6, #0]
   19f54:	7810      	ldrb	r0, [r2, #0]
	config->address_enabled = false;
   19f56:	4b1a      	ldr	r3, [pc, #104]	; (19fc0 <sd_mmc_spi_init+0xe8>)
	slave->ss_pin          = config->ss_pin;
   19f58:	4e1a      	ldr	r6, [pc, #104]	; (19fc4 <sd_mmc_spi_init+0xec>)
	config->address_enabled = false;
   19f5a:	705c      	strb	r4, [r3, #1]
	config->address         = 0;
   19f5c:	709c      	strb	r4, [r3, #2]
   19f5e:	7018      	strb	r0, [r3, #0]
	slave->ss_pin          = config->ss_pin;
   19f60:	7030      	strb	r0, [r6, #0]
	port_pin_set_config(slave->ss_pin, &pin_conf);
   19f62:	4b19      	ldr	r3, [pc, #100]	; (19fc8 <sd_mmc_spi_init+0xf0>)
	slave->address_enabled = config->address_enabled;
   19f64:	7074      	strb	r4, [r6, #1]
	slave->address         = config->address;
   19f66:	70b4      	strb	r4, [r6, #2]
   19f68:	704d      	strb	r5, [r1, #1]
	config->powersave  = false;
   19f6a:	708c      	strb	r4, [r1, #2]
	pin_conf.direction = PORT_PIN_DIR_OUTPUT;
   19f6c:	700d      	strb	r5, [r1, #0]
	port_pin_set_config(slave->ss_pin, &pin_conf);
   19f6e:	4798      	blx	r3
	port_pin_set_output_level(slave->ss_pin, true);
   19f70:	7832      	ldrb	r2, [r6, #0]
	uint8_t group_index = (gpio_pin / 32);
   19f72:	0953      	lsrs	r3, r2, #5
	if (port_index < PORT_INST_NUM) {
   19f74:	09d1      	lsrs	r1, r2, #7
   19f76:	d108      	bne.n	19f8a <sd_mmc_spi_init+0xb2>
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
   19f78:	311f      	adds	r1, #31
   19f7a:	400a      	ands	r2, r1
   19f7c:	4095      	lsls	r5, r2
		port_base->OUTSET.reg = pin_mask;
   19f7e:	4a13      	ldr	r2, [pc, #76]	; (19fcc <sd_mmc_spi_init+0xf4>)
   19f80:	01db      	lsls	r3, r3, #7
   19f82:	189b      	adds	r3, r3, r2
   19f84:	619d      	str	r5, [r3, #24]
	spi_attach_slave(&sd_mmc_spi_devices[0], &slave_configs[0]);
}
   19f86:	b011      	add	sp, #68	; 0x44
   19f88:	bdf0      	pop	{r4, r5, r6, r7, pc}
   19f8a:	61a4      	str	r4, [r4, #24]
   19f8c:	deff      	udf	#255	; 0xff
   19f8e:	46c0      	nop			; (mov r8, r8)
   19f90:	20003d69 	.word	0x20003d69
   19f94:	00022c47 	.word	0x00022c47
   19f98:	00100002 	.word	0x00100002
   19f9c:	20003d28 	.word	0x20003d28
   19fa0:	00120002 	.word	0x00120002
   19fa4:	00130002 	.word	0x00130002
   19fa8:	42000c00 	.word	0x42000c00
   19fac:	00061a80 	.word	0x00061a80
   19fb0:	0001d859 	.word	0x0001d859
   19fb4:	0001d699 	.word	0x0001d699
   19fb8:	e000e100 	.word	0xe000e100
   19fbc:	200001fc 	.word	0x200001fc
   19fc0:	20003d74 	.word	0x20003d74
   19fc4:	20003d66 	.word	0x20003d66
   19fc8:	0001d0dd 	.word	0x0001d0dd
   19fcc:	41004400 	.word	0x41004400

00019fd0 <sd_mmc_spi_select_device>:
void sd_mmc_spi_select_device(uint8_t slot, uint32_t clock, uint8_t bus_width,
		bool high_speed)
{
	UNUSED(bus_width);
	UNUSED(high_speed);
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   19fd0:	2200      	movs	r2, #0
   19fd2:	4b0e      	ldr	r3, [pc, #56]	; (1a00c <sd_mmc_spi_select_device+0x3c>)
{
   19fd4:	b570      	push	{r4, r5, r6, lr}
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   19fd6:	701a      	strb	r2, [r3, #0]
   19fd8:	4b0d      	ldr	r3, [pc, #52]	; (1a010 <sd_mmc_spi_select_device+0x40>)
{
   19fda:	0006      	movs	r6, r0
   19fdc:	000c      	movs	r4, r1
   19fde:	4299      	cmp	r1, r3
   19fe0:	d900      	bls.n	19fe4 <sd_mmc_spi_select_device+0x14>
   19fe2:	001c      	movs	r4, r3
#ifdef SD_MMC_SPI_MAX_CLOCK
	if (clock > SD_MMC_SPI_MAX_CLOCK) {
		clock = SD_MMC_SPI_MAX_CLOCK;
	}
#endif
	while (STATUS_ERR_INVALID_ARG == spi_set_baudrate(&sd_mmc_master, clock)) {
   19fe4:	4d0b      	ldr	r5, [pc, #44]	; (1a014 <sd_mmc_spi_select_device+0x44>)
   19fe6:	0021      	movs	r1, r4
   19fe8:	0028      	movs	r0, r5
   19fea:	4b0b      	ldr	r3, [pc, #44]	; (1a018 <sd_mmc_spi_select_device+0x48>)
   19fec:	4798      	blx	r3
   19fee:	2817      	cmp	r0, #23
   19ff0:	d008      	beq.n	1a004 <sd_mmc_spi_select_device+0x34>
		clock -= clock / 8;
	}
	spi_select_slave(&sd_mmc_master, &sd_mmc_spi_devices[slot], true);
   19ff2:	2103      	movs	r1, #3
   19ff4:	434e      	muls	r6, r1
   19ff6:	4909      	ldr	r1, [pc, #36]	; (1a01c <sd_mmc_spi_select_device+0x4c>)
   19ff8:	0028      	movs	r0, r5
   19ffa:	1989      	adds	r1, r1, r6
   19ffc:	2201      	movs	r2, #1
   19ffe:	4b08      	ldr	r3, [pc, #32]	; (1a020 <sd_mmc_spi_select_device+0x50>)
   1a000:	4798      	blx	r3
}
   1a002:	bd70      	pop	{r4, r5, r6, pc}
		clock -= clock / 8;
   1a004:	08e3      	lsrs	r3, r4, #3
   1a006:	1ae4      	subs	r4, r4, r3
   1a008:	e7ec      	b.n	19fe4 <sd_mmc_spi_select_device+0x14>
   1a00a:	46c0      	nop			; (mov r8, r8)
   1a00c:	20003d69 	.word	0x20003d69
   1a010:	00989680 	.word	0x00989680
   1a014:	20003d28 	.word	0x20003d28
   1a018:	0001d7cd 	.word	0x0001d7cd
   1a01c:	20003d66 	.word	0x20003d66
   1a020:	0001dab1 	.word	0x0001dab1

0001a024 <sd_mmc_spi_deselect_device>:

void sd_mmc_spi_deselect_device(uint8_t slot)
{
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
	spi_select_slave(&sd_mmc_master, &sd_mmc_spi_devices[slot], false);
   1a024:	2103      	movs	r1, #3
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   1a026:	2200      	movs	r2, #0
{
   1a028:	b510      	push	{r4, lr}
	spi_select_slave(&sd_mmc_master, &sd_mmc_spi_devices[slot], false);
   1a02a:	4348      	muls	r0, r1
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   1a02c:	4b03      	ldr	r3, [pc, #12]	; (1a03c <sd_mmc_spi_deselect_device+0x18>)
	spi_select_slave(&sd_mmc_master, &sd_mmc_spi_devices[slot], false);
   1a02e:	4904      	ldr	r1, [pc, #16]	; (1a040 <sd_mmc_spi_deselect_device+0x1c>)
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   1a030:	701a      	strb	r2, [r3, #0]
	spi_select_slave(&sd_mmc_master, &sd_mmc_spi_devices[slot], false);
   1a032:	1809      	adds	r1, r1, r0
   1a034:	4b03      	ldr	r3, [pc, #12]	; (1a044 <sd_mmc_spi_deselect_device+0x20>)
   1a036:	4804      	ldr	r0, [pc, #16]	; (1a048 <sd_mmc_spi_deselect_device+0x24>)
   1a038:	4798      	blx	r3
}
   1a03a:	bd10      	pop	{r4, pc}
   1a03c:	20003d69 	.word	0x20003d69
   1a040:	20003d66 	.word	0x20003d66
   1a044:	0001dab1 	.word	0x0001dab1
   1a048:	20003d28 	.word	0x20003d28

0001a04c <sd_mmc_spi_send_clock>:

void sd_mmc_spi_send_clock(void)
{
   1a04c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	uint8_t i;
	uint8_t dummy = 0xFF;
   1a04e:	466b      	mov	r3, sp
   1a050:	1ddd      	adds	r5, r3, #7
   1a052:	23ff      	movs	r3, #255	; 0xff

	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   1a054:	2200      	movs	r2, #0
   1a056:	240a      	movs	r4, #10
	uint8_t dummy = 0xFF;
   1a058:	702b      	strb	r3, [r5, #0]
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   1a05a:	4b06      	ldr	r3, [pc, #24]	; (1a074 <sd_mmc_spi_send_clock+0x28>)
   1a05c:	701a      	strb	r2, [r3, #0]
   1a05e:	3c01      	subs	r4, #1
	//! Send 80 cycles
	for (i = 0; i < 10; i++) {
		spi_write_buffer_wait(&sd_mmc_master, &dummy, 1); // 8 cycles
   1a060:	2201      	movs	r2, #1
   1a062:	0029      	movs	r1, r5
   1a064:	4804      	ldr	r0, [pc, #16]	; (1a078 <sd_mmc_spi_send_clock+0x2c>)
   1a066:	4b05      	ldr	r3, [pc, #20]	; (1a07c <sd_mmc_spi_send_clock+0x30>)
   1a068:	b2e4      	uxtb	r4, r4
   1a06a:	4798      	blx	r3
	for (i = 0; i < 10; i++) {
   1a06c:	2c00      	cmp	r4, #0
   1a06e:	d1f6      	bne.n	1a05e <sd_mmc_spi_send_clock+0x12>
	}
}
   1a070:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
   1a072:	46c0      	nop			; (mov r8, r8)
   1a074:	20003d69 	.word	0x20003d69
   1a078:	20003d28 	.word	0x20003d28
   1a07c:	0001db2d 	.word	0x0001db2d

0001a080 <sd_mmc_spi_adtc_start>:
	return sd_mmc_spi_adtc_start(cmd, arg, 0, 0, false);
}

bool sd_mmc_spi_adtc_start(sdmmc_cmd_def_t cmd, uint32_t arg,
		uint16_t block_size, uint16_t nb_block, bool access_block)
{
   1a080:	b5f0      	push	{r4, r5, r6, r7, lr}
   1a082:	b089      	sub	sp, #36	; 0x24
   1a084:	9202      	str	r2, [sp, #8]
	uint8_t dummy = 0xFF;
   1a086:	22ff      	movs	r2, #255	; 0xff
{
   1a088:	9303      	str	r3, [sp, #12]
	uint8_t dummy = 0xFF;
   1a08a:	ab04      	add	r3, sp, #16
   1a08c:	719a      	strb	r2, [r3, #6]
	uint8_t r1; //! R1 response
	uint16_t dummy2 = 0xFF;

	UNUSED(access_block);
	Assert(cmd & SDMMC_RESP_PRESENT); // Always a response in SPI mode
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   1a08e:	2200      	movs	r2, #0

	// Encode SPI command
	cmd_token[0] = SPI_CMD_ENCODE(SDMMC_CMD_GET_INDEX(cmd));
   1a090:	243f      	movs	r4, #63	; 0x3f
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   1a092:	4b49      	ldr	r3, [pc, #292]	; (1a1b8 <sd_mmc_spi_adtc_start+0x138>)
{
   1a094:	9001      	str	r0, [sp, #4]
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   1a096:	701a      	strb	r2, [r3, #0]
	cmd_token[0] = SPI_CMD_ENCODE(SDMMC_CMD_GET_INDEX(cmd));
   1a098:	9b01      	ldr	r3, [sp, #4]
   1a09a:	a806      	add	r0, sp, #24
   1a09c:	401c      	ands	r4, r3
   1a09e:	2340      	movs	r3, #64	; 0x40
   1a0a0:	4323      	orrs	r3, r4
   1a0a2:	7003      	strb	r3, [r0, #0]
	cmd_token[1] = arg >> 24;
   1a0a4:	0e0b      	lsrs	r3, r1, #24
   1a0a6:	7043      	strb	r3, [r0, #1]
	cmd_token[2] = arg >> 16;
   1a0a8:	0c0b      	lsrs	r3, r1, #16
   1a0aa:	7083      	strb	r3, [r0, #2]
	cmd_token[3] = arg >> 8;
   1a0ac:	0a0b      	lsrs	r3, r1, #8
   1a0ae:	70c3      	strb	r3, [r0, #3]
		value = *buf++;
   1a0b0:	2608      	movs	r6, #8
	crc = 0;
   1a0b2:	0013      	movs	r3, r2
				crc ^= 0x09;
   1a0b4:	2709      	movs	r7, #9
	cmd_token[4] = arg;
   1a0b6:	7101      	strb	r1, [r0, #4]
		value = *buf++;
   1a0b8:	0031      	movs	r1, r6
   1a0ba:	5c84      	ldrb	r4, [r0, r2]
			crc <<= 1;
   1a0bc:	005b      	lsls	r3, r3, #1
   1a0be:	b2db      	uxtb	r3, r3
			if ((value & 0x80) ^ (crc & 0x80)) {
   1a0c0:	001d      	movs	r5, r3
   1a0c2:	4065      	eors	r5, r4
   1a0c4:	062d      	lsls	r5, r5, #24
   1a0c6:	d500      	bpl.n	1a0ca <sd_mmc_spi_adtc_start+0x4a>
				crc ^= 0x09;
   1a0c8:	407b      	eors	r3, r7
   1a0ca:	3901      	subs	r1, #1
			value <<= 1;
   1a0cc:	0064      	lsls	r4, r4, #1
   1a0ce:	b2c9      	uxtb	r1, r1
   1a0d0:	b2e4      	uxtb	r4, r4
		for (i = 0; i < 8; i++) {
   1a0d2:	2900      	cmp	r1, #0
   1a0d4:	d1f2      	bne.n	1a0bc <sd_mmc_spi_adtc_start+0x3c>
   1a0d6:	3201      	adds	r2, #1
	while (size--) {
   1a0d8:	2a05      	cmp	r2, #5
   1a0da:	d1ed      	bne.n	1a0b8 <sd_mmc_spi_adtc_start+0x38>
	crc = (crc << 1) | 1;
   1a0dc:	2401      	movs	r4, #1
   1a0de:	005b      	lsls	r3, r3, #1
	cmd_token[5] = sd_mmc_spi_crc7(cmd_token, 5);

	// 8 cycles to respect Ncs timing
	// Note: This byte does not include start bit "0",
	// thus it is ignored by card.
	spi_write_buffer_wait(&sd_mmc_master, &dummy, 1);
   1a0e0:	4f36      	ldr	r7, [pc, #216]	; (1a1bc <sd_mmc_spi_adtc_start+0x13c>)
	crc = (crc << 1) | 1;
   1a0e2:	4323      	orrs	r3, r4
	cmd_token[5] = sd_mmc_spi_crc7(cmd_token, 5);
   1a0e4:	ae06      	add	r6, sp, #24
   1a0e6:	7173      	strb	r3, [r6, #5]
	spi_write_buffer_wait(&sd_mmc_master, &dummy, 1);
   1a0e8:	ab04      	add	r3, sp, #16
   1a0ea:	1d99      	adds	r1, r3, #6
   1a0ec:	0022      	movs	r2, r4
   1a0ee:	4d34      	ldr	r5, [pc, #208]	; (1a1c0 <sd_mmc_spi_adtc_start+0x140>)
   1a0f0:	0038      	movs	r0, r7
   1a0f2:	47a8      	blx	r5
	// Send command
	spi_write_buffer_wait(&sd_mmc_master, cmd_token, sizeof(cmd_token));
   1a0f4:	0031      	movs	r1, r6
   1a0f6:	2206      	movs	r2, #6
   1a0f8:	0038      	movs	r0, r7
   1a0fa:	47a8      	blx	r5

	// Wait for response
	// Two retry will be done to manage the Ncr timing between command and reponse
	// Ncr: Min. 1x8 clock  cycle, Max. 8x8 clock cycles
	// WORKAROUND for no compliance card (Atmel Internal ref. SD13):
	r1 = 0xFF;
   1a0fc:	ab04      	add	r3, sp, #16
   1a0fe:	1dd9      	adds	r1, r3, #7
   1a100:	23ff      	movs	r3, #255	; 0xff
	// Ignore first byte because Ncr min. = 8 clock cylces
	spi_read_buffer_wait(&sd_mmc_master, &r1, 1,
   1a102:	0022      	movs	r2, r4
   1a104:	0038      	movs	r0, r7
   1a106:	4c2f      	ldr	r4, [pc, #188]	; (1a1c4 <sd_mmc_spi_adtc_start+0x144>)
	r1 = 0xFF;
   1a108:	700b      	strb	r3, [r1, #0]
	spi_read_buffer_wait(&sd_mmc_master, &r1, 1,
   1a10a:	47a0      	blx	r4
   1a10c:	2407      	movs	r4, #7
			dummy2);
	ncr_timeout = 7;
	while (1) {
		spi_read_buffer_wait(&sd_mmc_master, &r1, 1,
   1a10e:	ab04      	add	r3, sp, #16
   1a110:	1dde      	adds	r6, r3, #7
   1a112:	2201      	movs	r2, #1
   1a114:	23ff      	movs	r3, #255	; 0xff
   1a116:	0031      	movs	r1, r6
   1a118:	4828      	ldr	r0, [pc, #160]	; (1a1bc <sd_mmc_spi_adtc_start+0x13c>)
   1a11a:	4d2a      	ldr	r5, [pc, #168]	; (1a1c4 <sd_mmc_spi_adtc_start+0x144>)
   1a11c:	47a8      	blx	r5
			dummy2); // 8 cycles
		if ((r1 & R1_SPI_ERROR) == 0) {
   1a11e:	7833      	ldrb	r3, [r6, #0]
   1a120:	b25a      	sxtb	r2, r3
   1a122:	2a00      	cmp	r2, #0
   1a124:	da09      	bge.n	1a13a <sd_mmc_spi_adtc_start+0xba>
   1a126:	3c01      	subs	r4, #1
   1a128:	b2e4      	uxtb	r4, r4
			// Valid R1 response
			break;
		}
		if (--ncr_timeout == 0) {
   1a12a:	2c00      	cmp	r4, #0
   1a12c:	d1ef      	bne.n	1a10e <sd_mmc_spi_adtc_start+0x8e>
			// Here Valid R1 response received
			sd_mmc_spi_debug("%s: cmd %02d, arg 0x%08lX, R1 timeout\n\r",
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), arg);
			sd_mmc_spi_err = SD_MMC_SPI_ERR_RESP_TIMEOUT;
   1a12e:	2202      	movs	r2, #2
	// Manage error in R1
	if (r1 & R1_SPI_COM_CRC) {
		sd_mmc_spi_debug("%s: cmd %02d, arg 0x%08lx, r1 0x%02x, R1_SPI_COM_CRC\n\r",
				__func__, (int)SDMMC_CMD_GET_INDEX(cmd), arg, r1);
		sd_mmc_spi_err = SD_MMC_SPI_ERR_RESP_CRC;
		return false;
   1a130:	2000      	movs	r0, #0
		sd_mmc_spi_err = SD_MMC_SPI_ERR_RESP_CRC;
   1a132:	4b21      	ldr	r3, [pc, #132]	; (1a1b8 <sd_mmc_spi_adtc_start+0x138>)
   1a134:	701a      	strb	r2, [r3, #0]

	sd_mmc_spi_block_size = block_size;
	sd_mmc_spi_nb_block = nb_block;
	sd_mmc_spi_transfert_pos = 0;
	return true; // Command complete
}
   1a136:	b009      	add	sp, #36	; 0x24
   1a138:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (r1 & R1_SPI_COM_CRC) {
   1a13a:	2408      	movs	r4, #8
	sd_mmc_spi_response_32 = r1;
   1a13c:	4e22      	ldr	r6, [pc, #136]	; (1a1c8 <sd_mmc_spi_adtc_start+0x148>)
	if (r1 & R1_SPI_COM_CRC) {
   1a13e:	401c      	ands	r4, r3
	sd_mmc_spi_response_32 = r1;
   1a140:	6033      	str	r3, [r6, #0]
	if (r1 & R1_SPI_COM_CRC) {
   1a142:	d001      	beq.n	1a148 <sd_mmc_spi_adtc_start+0xc8>
		sd_mmc_spi_err = SD_MMC_SPI_ERR_RESP_CRC;
   1a144:	2206      	movs	r2, #6
   1a146:	e7f3      	b.n	1a130 <sd_mmc_spi_adtc_start+0xb0>
	if (r1 & R1_SPI_ILLEGAL_COMMAND) {
   1a148:	2004      	movs	r0, #4
		sd_mmc_spi_err = SD_MMC_SPI_ERR_ILLEGAL_COMMAND;
   1a14a:	2209      	movs	r2, #9
	if (r1 & R1_SPI_ILLEGAL_COMMAND) {
   1a14c:	4018      	ands	r0, r3
   1a14e:	d1ef      	bne.n	1a130 <sd_mmc_spi_adtc_start+0xb0>
	if (r1 & ~R1_SPI_IDLE) {
   1a150:	2201      	movs	r2, #1
   1a152:	4393      	bics	r3, r2
   1a154:	d002      	beq.n	1a15c <sd_mmc_spi_adtc_start+0xdc>
			sd_mmc_spi_err = SD_MMC_SPI_ERR_RESP_BUSY_TIMEOUT;
   1a156:	4b18      	ldr	r3, [pc, #96]	; (1a1b8 <sd_mmc_spi_adtc_start+0x138>)
   1a158:	701a      	strb	r2, [r3, #0]
			return false;
   1a15a:	e7ec      	b.n	1a136 <sd_mmc_spi_adtc_start+0xb6>
	if (cmd & SDMMC_RESP_BUSY) {
   1a15c:	9b01      	ldr	r3, [sp, #4]
   1a15e:	049b      	lsls	r3, r3, #18
   1a160:	d505      	bpl.n	1a16e <sd_mmc_spi_adtc_start+0xee>
		if (!sd_mmc_spi_wait_busy()) {
   1a162:	4b1a      	ldr	r3, [pc, #104]	; (1a1cc <sd_mmc_spi_adtc_start+0x14c>)
   1a164:	4798      	blx	r3
   1a166:	2800      	cmp	r0, #0
   1a168:	d101      	bne.n	1a16e <sd_mmc_spi_adtc_start+0xee>
			sd_mmc_spi_err = SD_MMC_SPI_ERR_RESP_BUSY_TIMEOUT;
   1a16a:	2203      	movs	r2, #3
   1a16c:	e7f3      	b.n	1a156 <sd_mmc_spi_adtc_start+0xd6>
	if (cmd & SDMMC_RESP_8) {
   1a16e:	9b01      	ldr	r3, [sp, #4]
   1a170:	059b      	lsls	r3, r3, #22
   1a172:	d507      	bpl.n	1a184 <sd_mmc_spi_adtc_start+0x104>
		sd_mmc_spi_response_32 = 0;
   1a174:	2300      	movs	r3, #0
		spi_read_buffer_wait(&sd_mmc_master, (uint8_t *)&sd_mmc_spi_response_32, 1,
   1a176:	2201      	movs	r2, #1
		sd_mmc_spi_response_32 = 0;
   1a178:	6033      	str	r3, [r6, #0]
		spi_read_buffer_wait(&sd_mmc_master, (uint8_t *)&sd_mmc_spi_response_32, 1,
   1a17a:	0031      	movs	r1, r6
   1a17c:	33ff      	adds	r3, #255	; 0xff
   1a17e:	480f      	ldr	r0, [pc, #60]	; (1a1bc <sd_mmc_spi_adtc_start+0x13c>)
   1a180:	4c10      	ldr	r4, [pc, #64]	; (1a1c4 <sd_mmc_spi_adtc_start+0x144>)
   1a182:	47a0      	blx	r4
	if (cmd & SDMMC_RESP_32) {
   1a184:	9b01      	ldr	r3, [sp, #4]
   1a186:	055b      	lsls	r3, r3, #21
   1a188:	d509      	bpl.n	1a19e <sd_mmc_spi_adtc_start+0x11e>
		spi_read_buffer_wait(&sd_mmc_master, (uint8_t *)&sd_mmc_spi_response_32, 4,
   1a18a:	4c0f      	ldr	r4, [pc, #60]	; (1a1c8 <sd_mmc_spi_adtc_start+0x148>)
   1a18c:	23ff      	movs	r3, #255	; 0xff
   1a18e:	2204      	movs	r2, #4
   1a190:	0021      	movs	r1, r4
   1a192:	0038      	movs	r0, r7
   1a194:	4d0b      	ldr	r5, [pc, #44]	; (1a1c4 <sd_mmc_spi_adtc_start+0x144>)
   1a196:	47a8      	blx	r5
		sd_mmc_spi_response_32 = be32_to_cpu(sd_mmc_spi_response_32);
   1a198:	6823      	ldr	r3, [r4, #0]
   1a19a:	ba1b      	rev	r3, r3
   1a19c:	6023      	str	r3, [r4, #0]
	sd_mmc_spi_block_size = block_size;
   1a19e:	466a      	mov	r2, sp
   1a1a0:	4b0b      	ldr	r3, [pc, #44]	; (1a1d0 <sd_mmc_spi_adtc_start+0x150>)
   1a1a2:	8912      	ldrh	r2, [r2, #8]
	return true; // Command complete
   1a1a4:	2001      	movs	r0, #1
	sd_mmc_spi_block_size = block_size;
   1a1a6:	801a      	strh	r2, [r3, #0]
	sd_mmc_spi_nb_block = nb_block;
   1a1a8:	466a      	mov	r2, sp
   1a1aa:	4b0a      	ldr	r3, [pc, #40]	; (1a1d4 <sd_mmc_spi_adtc_start+0x154>)
   1a1ac:	8992      	ldrh	r2, [r2, #12]
   1a1ae:	801a      	strh	r2, [r3, #0]
	sd_mmc_spi_transfert_pos = 0;
   1a1b0:	2200      	movs	r2, #0
   1a1b2:	4b09      	ldr	r3, [pc, #36]	; (1a1d8 <sd_mmc_spi_adtc_start+0x158>)
   1a1b4:	601a      	str	r2, [r3, #0]
	return true; // Command complete
   1a1b6:	e7be      	b.n	1a136 <sd_mmc_spi_adtc_start+0xb6>
   1a1b8:	20003d69 	.word	0x20003d69
   1a1bc:	20003d28 	.word	0x20003d28
   1a1c0:	0001db2d 	.word	0x0001db2d
   1a1c4:	0001da21 	.word	0x0001da21
   1a1c8:	20003d6c 	.word	0x20003d6c
   1a1cc:	00019d55 	.word	0x00019d55
   1a1d0:	20003d64 	.word	0x20003d64
   1a1d4:	20003d6a 	.word	0x20003d6a
   1a1d8:	20003d70 	.word	0x20003d70

0001a1dc <sd_mmc_spi_send_cmd>:
	return sd_mmc_spi_adtc_start(cmd, arg, 0, 0, false);
   1a1dc:	2200      	movs	r2, #0
{
   1a1de:	b513      	push	{r0, r1, r4, lr}
	return sd_mmc_spi_adtc_start(cmd, arg, 0, 0, false);
   1a1e0:	0013      	movs	r3, r2
   1a1e2:	9200      	str	r2, [sp, #0]
   1a1e4:	4c01      	ldr	r4, [pc, #4]	; (1a1ec <sd_mmc_spi_send_cmd+0x10>)
   1a1e6:	47a0      	blx	r4
}
   1a1e8:	bd16      	pop	{r1, r2, r4, pc}
   1a1ea:	46c0      	nop			; (mov r8, r8)
   1a1ec:	0001a081 	.word	0x0001a081

0001a1f0 <sd_mmc_spi_get_response>:

uint32_t sd_mmc_spi_get_response(void)
{
	return sd_mmc_spi_response_32;
   1a1f0:	4b01      	ldr	r3, [pc, #4]	; (1a1f8 <sd_mmc_spi_get_response+0x8>)
   1a1f2:	6818      	ldr	r0, [r3, #0]
}
   1a1f4:	4770      	bx	lr
   1a1f6:	46c0      	nop			; (mov r8, r8)
   1a1f8:	20003d6c 	.word	0x20003d6c

0001a1fc <sd_mmc_spi_read_word>:

bool sd_mmc_spi_read_word(uint32_t* value)
{
	uint16_t dummy = 0xFF;

	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   1a1fc:	2200      	movs	r2, #0
{
   1a1fe:	b5f0      	push	{r4, r5, r6, r7, lr}
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   1a200:	4b13      	ldr	r3, [pc, #76]	; (1a250 <sd_mmc_spi_read_word+0x54>)
	Assert(sd_mmc_spi_nb_block >
			(sd_mmc_spi_transfert_pos / sd_mmc_spi_block_size));

	if (!(sd_mmc_spi_transfert_pos % sd_mmc_spi_block_size)) {
   1a202:	4c14      	ldr	r4, [pc, #80]	; (1a254 <sd_mmc_spi_read_word+0x58>)
   1a204:	4e14      	ldr	r6, [pc, #80]	; (1a258 <sd_mmc_spi_read_word+0x5c>)
{
   1a206:	b085      	sub	sp, #20
   1a208:	9001      	str	r0, [sp, #4]
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   1a20a:	701a      	strb	r2, [r3, #0]
	if (!(sd_mmc_spi_transfert_pos % sd_mmc_spi_block_size)) {
   1a20c:	8831      	ldrh	r1, [r6, #0]
   1a20e:	4f13      	ldr	r7, [pc, #76]	; (1a25c <sd_mmc_spi_read_word+0x60>)
   1a210:	6820      	ldr	r0, [r4, #0]
   1a212:	47b8      	blx	r7
   1a214:	2900      	cmp	r1, #0
   1a216:	d00e      	beq.n	1a236 <sd_mmc_spi_read_word+0x3a>
		if (!sd_mmc_spi_start_read_block()) {
			return false;
		}
	}
	// Read data
	spi_read_buffer_wait(&sd_mmc_master, (uint8_t *)&value, 4,
   1a218:	23ff      	movs	r3, #255	; 0xff
   1a21a:	a901      	add	r1, sp, #4
   1a21c:	2204      	movs	r2, #4
   1a21e:	4810      	ldr	r0, [pc, #64]	; (1a260 <sd_mmc_spi_read_word+0x64>)
   1a220:	4d10      	ldr	r5, [pc, #64]	; (1a264 <sd_mmc_spi_read_word+0x68>)
   1a222:	47a8      	blx	r5
			dummy);
	*value = le32_to_cpu(*value);
	sd_mmc_spi_transfert_pos += 4;
   1a224:	6823      	ldr	r3, [r4, #0]

	if (!(sd_mmc_spi_transfert_pos % sd_mmc_spi_block_size)) {
   1a226:	8831      	ldrh	r1, [r6, #0]
	sd_mmc_spi_transfert_pos += 4;
   1a228:	1d18      	adds	r0, r3, #4
   1a22a:	6020      	str	r0, [r4, #0]
	if (!(sd_mmc_spi_transfert_pos % sd_mmc_spi_block_size)) {
   1a22c:	47b8      	blx	r7
   1a22e:	2900      	cmp	r1, #0
   1a230:	d007      	beq.n	1a242 <sd_mmc_spi_read_word+0x46>
		// End of block
		sd_mmc_spi_stop_read_block();
	}
	return true;
   1a232:	2001      	movs	r0, #1
   1a234:	e003      	b.n	1a23e <sd_mmc_spi_read_word+0x42>
		if (!sd_mmc_spi_start_read_block()) {
   1a236:	4b0c      	ldr	r3, [pc, #48]	; (1a268 <sd_mmc_spi_read_word+0x6c>)
   1a238:	4798      	blx	r3
   1a23a:	2800      	cmp	r0, #0
   1a23c:	d1ec      	bne.n	1a218 <sd_mmc_spi_read_word+0x1c>
}
   1a23e:	b005      	add	sp, #20
   1a240:	bdf0      	pop	{r4, r5, r6, r7, pc}
	spi_read_buffer_wait(&sd_mmc_master, crc, 2,
   1a242:	23ff      	movs	r3, #255	; 0xff
   1a244:	2202      	movs	r2, #2
   1a246:	a903      	add	r1, sp, #12
   1a248:	4c06      	ldr	r4, [pc, #24]	; (1a264 <sd_mmc_spi_read_word+0x68>)
   1a24a:	4805      	ldr	r0, [pc, #20]	; (1a260 <sd_mmc_spi_read_word+0x64>)
   1a24c:	47a0      	blx	r4
   1a24e:	e7f0      	b.n	1a232 <sd_mmc_spi_read_word+0x36>
   1a250:	20003d69 	.word	0x20003d69
   1a254:	20003d70 	.word	0x20003d70
   1a258:	20003d64 	.word	0x20003d64
   1a25c:	000259c9 	.word	0x000259c9
   1a260:	20003d28 	.word	0x20003d28
   1a264:	0001da21 	.word	0x0001da21
   1a268:	00019da5 	.word	0x00019da5

0001a26c <sd_mmc_spi_start_read_blocks>:
	}
	return sd_mmc_spi_stop_multiwrite_block();
}

bool sd_mmc_spi_start_read_blocks(void *dest, uint16_t nb_block)
{
   1a26c:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t pos;
	uint16_t dummy = 0xFF;

	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   1a26e:	2400      	movs	r4, #0
{
   1a270:	000d      	movs	r5, r1
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   1a272:	4b12      	ldr	r3, [pc, #72]	; (1a2bc <sd_mmc_spi_start_read_blocks+0x50>)
{
   1a274:	b085      	sub	sp, #20
   1a276:	9001      	str	r0, [sp, #4]
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   1a278:	701c      	strb	r4, [r3, #0]
	pos = 0;
	while (nb_block--) {
   1a27a:	2d00      	cmp	r5, #0
   1a27c:	d102      	bne.n	1a284 <sd_mmc_spi_start_read_blocks+0x18>
		pos += sd_mmc_spi_block_size;
		sd_mmc_spi_transfert_pos += sd_mmc_spi_block_size;

		sd_mmc_spi_stop_read_block();
	}
	return true;
   1a27e:	2001      	movs	r0, #1
}
   1a280:	b005      	add	sp, #20
   1a282:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (!sd_mmc_spi_start_read_block()) {
   1a284:	4b0e      	ldr	r3, [pc, #56]	; (1a2c0 <sd_mmc_spi_start_read_blocks+0x54>)
   1a286:	4798      	blx	r3
   1a288:	3d01      	subs	r5, #1
   1a28a:	b2ad      	uxth	r5, r5
   1a28c:	2800      	cmp	r0, #0
   1a28e:	d0f7      	beq.n	1a280 <sd_mmc_spi_start_read_blocks+0x14>
		spi_read_buffer_wait(&sd_mmc_master, &((uint8_t*)dest)[pos],
   1a290:	4f0c      	ldr	r7, [pc, #48]	; (1a2c4 <sd_mmc_spi_start_read_blocks+0x58>)
   1a292:	9b01      	ldr	r3, [sp, #4]
   1a294:	883a      	ldrh	r2, [r7, #0]
   1a296:	1919      	adds	r1, r3, r4
   1a298:	4e0b      	ldr	r6, [pc, #44]	; (1a2c8 <sd_mmc_spi_start_read_blocks+0x5c>)
   1a29a:	23ff      	movs	r3, #255	; 0xff
   1a29c:	480b      	ldr	r0, [pc, #44]	; (1a2cc <sd_mmc_spi_start_read_blocks+0x60>)
   1a29e:	47b0      	blx	r6
		sd_mmc_spi_transfert_pos += sd_mmc_spi_block_size;
   1a2a0:	4a0b      	ldr	r2, [pc, #44]	; (1a2d0 <sd_mmc_spi_start_read_blocks+0x64>)
		pos += sd_mmc_spi_block_size;
   1a2a2:	883b      	ldrh	r3, [r7, #0]
		sd_mmc_spi_transfert_pos += sd_mmc_spi_block_size;
   1a2a4:	6811      	ldr	r1, [r2, #0]
		pos += sd_mmc_spi_block_size;
   1a2a6:	18e4      	adds	r4, r4, r3
		sd_mmc_spi_transfert_pos += sd_mmc_spi_block_size;
   1a2a8:	18cb      	adds	r3, r1, r3
   1a2aa:	6013      	str	r3, [r2, #0]
	spi_read_buffer_wait(&sd_mmc_master, crc, 2,
   1a2ac:	a903      	add	r1, sp, #12
   1a2ae:	23ff      	movs	r3, #255	; 0xff
   1a2b0:	2202      	movs	r2, #2
   1a2b2:	4e05      	ldr	r6, [pc, #20]	; (1a2c8 <sd_mmc_spi_start_read_blocks+0x5c>)
   1a2b4:	4805      	ldr	r0, [pc, #20]	; (1a2cc <sd_mmc_spi_start_read_blocks+0x60>)
   1a2b6:	47b0      	blx	r6
   1a2b8:	e7df      	b.n	1a27a <sd_mmc_spi_start_read_blocks+0xe>
   1a2ba:	46c0      	nop			; (mov r8, r8)
   1a2bc:	20003d69 	.word	0x20003d69
   1a2c0:	00019da5 	.word	0x00019da5
   1a2c4:	20003d64 	.word	0x20003d64
   1a2c8:	0001da21 	.word	0x0001da21
   1a2cc:	20003d28 	.word	0x20003d28
   1a2d0:	20003d70 	.word	0x20003d70

0001a2d4 <sd_mmc_spi_wait_end_of_read_blocks>:

bool sd_mmc_spi_wait_end_of_read_blocks(void)
{
	return true;
}
   1a2d4:	2001      	movs	r0, #1
   1a2d6:	4770      	bx	lr

0001a2d8 <sd_mmc_spi_start_write_blocks>:

bool sd_mmc_spi_start_write_blocks(const void *src, uint16_t nb_block)
{
   1a2d8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	uint32_t pos;

	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   1a2da:	2400      	movs	r4, #0
   1a2dc:	4d13      	ldr	r5, [pc, #76]	; (1a32c <sd_mmc_spi_start_write_blocks+0x54>)
{
   1a2de:	9001      	str	r0, [sp, #4]
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
   1a2e0:	702c      	strb	r4, [r5, #0]
	pos = 0;
	while (nb_block--) {
   1a2e2:	1e4f      	subs	r7, r1, #1
   1a2e4:	b2bf      	uxth	r7, r7
   1a2e6:	2900      	cmp	r1, #0
   1a2e8:	d101      	bne.n	1a2ee <sd_mmc_spi_start_write_blocks+0x16>
				sd_mmc_spi_debug("%s: Write blocks timeout\n\r", __func__);
				return false;
			}
		}
	}
	return true;
   1a2ea:	2001      	movs	r0, #1
   1a2ec:	e01a      	b.n	1a324 <sd_mmc_spi_start_write_blocks+0x4c>
		sd_mmc_spi_start_write_block();
   1a2ee:	4b10      	ldr	r3, [pc, #64]	; (1a330 <sd_mmc_spi_start_write_blocks+0x58>)
   1a2f0:	4798      	blx	r3
		spi_write_buffer_wait(&sd_mmc_master, &((uint8_t*)src)[pos],
   1a2f2:	4e10      	ldr	r6, [pc, #64]	; (1a334 <sd_mmc_spi_start_write_blocks+0x5c>)
   1a2f4:	9b01      	ldr	r3, [sp, #4]
   1a2f6:	8832      	ldrh	r2, [r6, #0]
   1a2f8:	1919      	adds	r1, r3, r4
   1a2fa:	480f      	ldr	r0, [pc, #60]	; (1a338 <sd_mmc_spi_start_write_blocks+0x60>)
   1a2fc:	4b0f      	ldr	r3, [pc, #60]	; (1a33c <sd_mmc_spi_start_write_blocks+0x64>)
   1a2fe:	4798      	blx	r3
		sd_mmc_spi_transfert_pos += sd_mmc_spi_block_size;
   1a300:	4a0f      	ldr	r2, [pc, #60]	; (1a340 <sd_mmc_spi_start_write_blocks+0x68>)
		pos += sd_mmc_spi_block_size;
   1a302:	8833      	ldrh	r3, [r6, #0]
		sd_mmc_spi_transfert_pos += sd_mmc_spi_block_size;
   1a304:	6811      	ldr	r1, [r2, #0]
		pos += sd_mmc_spi_block_size;
   1a306:	18e4      	adds	r4, r4, r3
		sd_mmc_spi_transfert_pos += sd_mmc_spi_block_size;
   1a308:	18cb      	adds	r3, r1, r3
   1a30a:	6013      	str	r3, [r2, #0]
		if (!sd_mmc_spi_stop_write_block()) {
   1a30c:	4b0d      	ldr	r3, [pc, #52]	; (1a344 <sd_mmc_spi_start_write_blocks+0x6c>)
   1a30e:	4798      	blx	r3
   1a310:	2800      	cmp	r0, #0
   1a312:	d007      	beq.n	1a324 <sd_mmc_spi_start_write_blocks+0x4c>
		if (nb_block) {
   1a314:	2f00      	cmp	r7, #0
   1a316:	d006      	beq.n	1a326 <sd_mmc_spi_start_write_blocks+0x4e>
			if (!sd_mmc_spi_wait_busy()) {
   1a318:	4b0b      	ldr	r3, [pc, #44]	; (1a348 <sd_mmc_spi_start_write_blocks+0x70>)
   1a31a:	4798      	blx	r3
   1a31c:	2800      	cmp	r0, #0
   1a31e:	d102      	bne.n	1a326 <sd_mmc_spi_start_write_blocks+0x4e>
				sd_mmc_spi_err = SD_MMC_SPI_ERR_WRITE_TIMEOUT;
   1a320:	2305      	movs	r3, #5
   1a322:	702b      	strb	r3, [r5, #0]
}
   1a324:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
{
   1a326:	0039      	movs	r1, r7
   1a328:	e7db      	b.n	1a2e2 <sd_mmc_spi_start_write_blocks+0xa>
   1a32a:	46c0      	nop			; (mov r8, r8)
   1a32c:	20003d69 	.word	0x20003d69
   1a330:	00019d19 	.word	0x00019d19
   1a334:	20003d64 	.word	0x20003d64
   1a338:	20003d28 	.word	0x20003d28
   1a33c:	0001db2d 	.word	0x0001db2d
   1a340:	20003d70 	.word	0x20003d70
   1a344:	00019e05 	.word	0x00019e05
   1a348:	00019d55 	.word	0x00019d55

0001a34c <sd_mmc_spi_wait_end_of_write_blocks>:

bool sd_mmc_spi_wait_end_of_write_blocks(void)
{
   1a34c:	b510      	push	{r4, lr}
	// Wait busy due to data programmation of last block writed
	if (!sd_mmc_spi_wait_busy()) {
   1a34e:	4b05      	ldr	r3, [pc, #20]	; (1a364 <sd_mmc_spi_wait_end_of_write_blocks+0x18>)
   1a350:	4798      	blx	r3
   1a352:	2800      	cmp	r0, #0
   1a354:	d103      	bne.n	1a35e <sd_mmc_spi_wait_end_of_write_blocks+0x12>
		sd_mmc_spi_err = SD_MMC_SPI_ERR_WRITE_TIMEOUT;
   1a356:	2205      	movs	r2, #5
   1a358:	4b03      	ldr	r3, [pc, #12]	; (1a368 <sd_mmc_spi_wait_end_of_write_blocks+0x1c>)
   1a35a:	701a      	strb	r2, [r3, #0]
		sd_mmc_spi_debug("%s: Write blocks timeout\n\r", __func__);
		return false;
	}
	return sd_mmc_spi_stop_multiwrite_block();
}
   1a35c:	bd10      	pop	{r4, pc}
	return sd_mmc_spi_stop_multiwrite_block();
   1a35e:	4b03      	ldr	r3, [pc, #12]	; (1a36c <sd_mmc_spi_wait_end_of_write_blocks+0x20>)
   1a360:	4798      	blx	r3
   1a362:	e7fb      	b.n	1a35c <sd_mmc_spi_wait_end_of_write_blocks+0x10>
   1a364:	00019d55 	.word	0x00019d55
   1a368:	20003d69 	.word	0x20003d69
   1a36c:	00019e69 	.word	0x00019e69

0001a370 <delay_init>:
 *
 * This must be called during start up to initialize the delay routine with
 * the current used main clock. It must run any time the main CPU clock is changed.
 */
void delay_init(void)
{
   1a370:	b570      	push	{r4, r5, r6, lr}
	cycles_per_ms = system_gclk_gen_get_hz(0);
   1a372:	4b09      	ldr	r3, [pc, #36]	; (1a398 <delay_init+0x28>)
   1a374:	2000      	movs	r0, #0
   1a376:	4798      	blx	r3
	cycles_per_ms /= 1000;
   1a378:	21fa      	movs	r1, #250	; 0xfa
   1a37a:	4c08      	ldr	r4, [pc, #32]	; (1a39c <delay_init+0x2c>)
   1a37c:	0089      	lsls	r1, r1, #2
	cycles_per_ms = system_gclk_gen_get_hz(0);
   1a37e:	0005      	movs	r5, r0
	cycles_per_ms /= 1000;
   1a380:	47a0      	blx	r4
   1a382:	4b07      	ldr	r3, [pc, #28]	; (1a3a0 <delay_init+0x30>)
	cycles_per_us = cycles_per_ms / 1000;
   1a384:	4907      	ldr	r1, [pc, #28]	; (1a3a4 <delay_init+0x34>)
	cycles_per_ms /= 1000;
   1a386:	6018      	str	r0, [r3, #0]
	cycles_per_us = cycles_per_ms / 1000;
   1a388:	0028      	movs	r0, r5
   1a38a:	47a0      	blx	r4

	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
   1a38c:	2205      	movs	r2, #5
	cycles_per_us = cycles_per_ms / 1000;
   1a38e:	4b06      	ldr	r3, [pc, #24]	; (1a3a8 <delay_init+0x38>)
   1a390:	6018      	str	r0, [r3, #0]
	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
   1a392:	4b06      	ldr	r3, [pc, #24]	; (1a3ac <delay_init+0x3c>)
   1a394:	601a      	str	r2, [r3, #0]
}
   1a396:	bd70      	pop	{r4, r5, r6, pc}
   1a398:	0001e729 	.word	0x0001e729
   1a39c:	000258bd 	.word	0x000258bd
   1a3a0:	20000200 	.word	0x20000200
   1a3a4:	000f4240 	.word	0x000f4240
   1a3a8:	20000204 	.word	0x20000204
   1a3ac:	e000e010 	.word	0xe000e010

0001a3b0 <delay_cycles_ms>:
 *
 * \param n  Number of milliseconds to wait
 */
void delay_cycles_ms(
		uint32_t n)
{
   1a3b0:	b530      	push	{r4, r5, lr}
{
	if (n > 0) {
		SysTick->LOAD = n;
		SysTick->VAL = 0;

		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
   1a3b2:	2480      	movs	r4, #128	; 0x80
		SysTick->VAL = 0;
   1a3b4:	2100      	movs	r1, #0
	while (n--) {
		/* Devide up to blocks of 1ms */
		delay_cycles(cycles_per_ms);
   1a3b6:	4b07      	ldr	r3, [pc, #28]	; (1a3d4 <delay_cycles_ms+0x24>)
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
   1a3b8:	0264      	lsls	r4, r4, #9
   1a3ba:	681a      	ldr	r2, [r3, #0]
		SysTick->LOAD = n;
   1a3bc:	4b06      	ldr	r3, [pc, #24]	; (1a3d8 <delay_cycles_ms+0x28>)
	while (n--) {
   1a3be:	3801      	subs	r0, #1
   1a3c0:	d200      	bcs.n	1a3c4 <delay_cycles_ms+0x14>
	}
}
   1a3c2:	bd30      	pop	{r4, r5, pc}
	if (n > 0) {
   1a3c4:	2a00      	cmp	r2, #0
   1a3c6:	d0fa      	beq.n	1a3be <delay_cycles_ms+0xe>
		SysTick->LOAD = n;
   1a3c8:	605a      	str	r2, [r3, #4]
		SysTick->VAL = 0;
   1a3ca:	6099      	str	r1, [r3, #8]
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
   1a3cc:	681d      	ldr	r5, [r3, #0]
   1a3ce:	4225      	tst	r5, r4
   1a3d0:	d0fc      	beq.n	1a3cc <delay_cycles_ms+0x1c>
   1a3d2:	e7f4      	b.n	1a3be <delay_cycles_ms+0xe>
   1a3d4:	20000200 	.word	0x20000200
   1a3d8:	e000e010 	.word	0xe000e010

0001a3dc <chip_isr>:
#include "conf_winc.h"

static tpfNmBspIsr gpfIsr;

static void chip_isr(void)
{
   1a3dc:	b510      	push	{r4, lr}
	if (gpfIsr) {
   1a3de:	4b03      	ldr	r3, [pc, #12]	; (1a3ec <chip_isr+0x10>)
   1a3e0:	681b      	ldr	r3, [r3, #0]
   1a3e2:	2b00      	cmp	r3, #0
   1a3e4:	d000      	beq.n	1a3e8 <chip_isr+0xc>
		gpfIsr();
   1a3e6:	4798      	blx	r3
	}
}
   1a3e8:	bd10      	pop	{r4, pc}
   1a3ea:	46c0      	nop			; (mov r8, r8)
   1a3ec:	20003d78 	.word	0x20003d78

0001a3f0 <nm_bsp_init>:
 *	@fn		nm_bsp_init
 *	@brief	Initialize BSP
 *	@return	0 in case of success and -1 in case of failure
 */
sint8 nm_bsp_init(void)
{
   1a3f0:	b573      	push	{r0, r1, r4, r5, r6, lr}
	gpfIsr = NULL;
   1a3f2:	2300      	movs	r3, #0
	config->input_pull = PORT_PIN_PULL_UP;
   1a3f4:	2501      	movs	r5, #1
   1a3f6:	ac01      	add	r4, sp, #4
   1a3f8:	4a13      	ldr	r2, [pc, #76]	; (1a448 <nm_bsp_init+0x58>)
	port_pin_set_config(CONF_WINC_PIN_RESET, &pin_conf);
   1a3fa:	4e14      	ldr	r6, [pc, #80]	; (1a44c <nm_bsp_init+0x5c>)
   1a3fc:	0021      	movs	r1, r4
   1a3fe:	201b      	movs	r0, #27
	gpfIsr = NULL;
   1a400:	6013      	str	r3, [r2, #0]
	config->powersave  = false;
   1a402:	70a3      	strb	r3, [r4, #2]
	config->input_pull = PORT_PIN_PULL_UP;
   1a404:	7065      	strb	r5, [r4, #1]
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
   1a406:	7025      	strb	r5, [r4, #0]
	port_pin_set_config(CONF_WINC_PIN_RESET, &pin_conf);
   1a408:	47b0      	blx	r6
	port_pin_set_config(CONF_WINC_PIN_CHIP_ENABLE, &pin_conf);
   1a40a:	0021      	movs	r1, r4
   1a40c:	201c      	movs	r0, #28
   1a40e:	47b0      	blx	r6
	port_pin_set_config(CONF_WINC_PIN_WAKE, &pin_conf);
   1a410:	0021      	movs	r1, r4
   1a412:	2028      	movs	r0, #40	; 0x28
   1a414:	47b0      	blx	r6
		port_base->OUTCLR.reg = pin_mask;
   1a416:	2280      	movs	r2, #128	; 0x80
   1a418:	4b0d      	ldr	r3, [pc, #52]	; (1a450 <nm_bsp_init+0x60>)
   1a41a:	0552      	lsls	r2, r2, #21
   1a41c:	615a      	str	r2, [r3, #20]
   1a41e:	2280      	movs	r2, #128	; 0x80
   1a420:	0512      	lsls	r2, r2, #20
   1a422:	615a      	str	r2, [r3, #20]

	/* Initialize chip IOs. */
	init_chip_pins();

    /* Make sure a 1ms Systick is configured. */
    if (!(SysTick->CTRL & SysTick_CTRL_ENABLE_Msk && SysTick->CTRL & SysTick_CTRL_TICKINT_Msk)) {
   1a424:	4b0b      	ldr	r3, [pc, #44]	; (1a454 <nm_bsp_init+0x64>)
   1a426:	681a      	ldr	r2, [r3, #0]
   1a428:	422a      	tst	r2, r5
   1a42a:	d002      	beq.n	1a432 <nm_bsp_init+0x42>
   1a42c:	681b      	ldr	r3, [r3, #0]
   1a42e:	079b      	lsls	r3, r3, #30
   1a430:	d401      	bmi.n	1a436 <nm_bsp_init+0x46>
	    delay_init();
   1a432:	4b09      	ldr	r3, [pc, #36]	; (1a458 <nm_bsp_init+0x68>)
   1a434:	4798      	blx	r3
	cpu_irq_enable();
   1a436:	2201      	movs	r2, #1
   1a438:	4b08      	ldr	r3, [pc, #32]	; (1a45c <nm_bsp_init+0x6c>)
   1a43a:	701a      	strb	r2, [r3, #0]
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
   1a43c:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   1a440:	b662      	cpsie	i
    }

	system_interrupt_enable_global();

	return M2M_SUCCESS;
}
   1a442:	2000      	movs	r0, #0
   1a444:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
   1a446:	46c0      	nop			; (mov r8, r8)
   1a448:	20003d78 	.word	0x20003d78
   1a44c:	0001d0dd 	.word	0x0001d0dd
   1a450:	41004400 	.word	0x41004400
   1a454:	e000e010 	.word	0xe000e010
   1a458:	0001a371 	.word	0x0001a371
   1a45c:	2000020a 	.word	0x2000020a

0001a460 <nm_bsp_reset>:
 *	@fn		nm_bsp_reset
 *	@brief	Reset NMC1500 SoC by setting CHIP_EN and RESET_N signals low,
 *           CHIP_EN high then RESET_N high
 */
void nm_bsp_reset(void)
{
   1a460:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1a462:	2780      	movs	r7, #128	; 0x80
   1a464:	2580      	movs	r5, #128	; 0x80
   1a466:	4c06      	ldr	r4, [pc, #24]	; (1a480 <nm_bsp_reset+0x20>)
   1a468:	057f      	lsls	r7, r7, #21
   1a46a:	052d      	lsls	r5, r5, #20
   1a46c:	6167      	str	r7, [r4, #20]
 *				Time in milliseconds
 */
void nm_bsp_sleep(uint32 u32TimeMsec)
{
#ifdef __FREERTOS__
	vTaskDelay(u32TimeMsec);
   1a46e:	4e05      	ldr	r6, [pc, #20]	; (1a484 <nm_bsp_reset+0x24>)
   1a470:	6165      	str	r5, [r4, #20]
   1a472:	2001      	movs	r0, #1
   1a474:	47b0      	blx	r6
		port_base->OUTSET.reg = pin_mask;
   1a476:	61a7      	str	r7, [r4, #24]
   1a478:	200a      	movs	r0, #10
   1a47a:	47b0      	blx	r6
   1a47c:	61a5      	str	r5, [r4, #24]
}
   1a47e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1a480:	41004400 	.word	0x41004400
   1a484:	000185ad 	.word	0x000185ad

0001a488 <nm_bsp_sleep>:
{
   1a488:	b510      	push	{r4, lr}
	vTaskDelay(u32TimeMsec);
   1a48a:	4b01      	ldr	r3, [pc, #4]	; (1a490 <nm_bsp_sleep+0x8>)
   1a48c:	4798      	blx	r3
	while (u32TimeMsec--) {
		delay_ms(1);
	}
	
#endif
}
   1a48e:	bd10      	pop	{r4, pc}
   1a490:	000185ad 	.word	0x000185ad

0001a494 <nm_bsp_register_isr>:
 *	@brief	Register interrupt service routine
 *	@param[IN]	pfIsr
 *				Pointer to ISR handler
 */
void nm_bsp_register_isr(tpfNmBspIsr pfIsr)
{
   1a494:	b530      	push	{r4, r5, lr}
	struct extint_chan_conf config_extint_chan;

	gpfIsr = pfIsr;
   1a496:	4b0f      	ldr	r3, [pc, #60]	; (1a4d4 <nm_bsp_register_isr+0x40>)
{
   1a498:	b085      	sub	sp, #20

	extint_chan_get_config_defaults(&config_extint_chan);
   1a49a:	ac01      	add	r4, sp, #4
	gpfIsr = pfIsr;
   1a49c:	6018      	str	r0, [r3, #0]
	extint_chan_get_config_defaults(&config_extint_chan);
   1a49e:	0020      	movs	r0, r4
   1a4a0:	4b0d      	ldr	r3, [pc, #52]	; (1a4d8 <nm_bsp_register_isr+0x44>)
   1a4a2:	4798      	blx	r3
	config_extint_chan.gpio_pin = CONF_WINC_SPI_INT_PIN;
   1a4a4:	2329      	movs	r3, #41	; 0x29
	config_extint_chan.gpio_pin_mux = CONF_WINC_SPI_INT_MUX;
   1a4a6:	2500      	movs	r5, #0
	config_extint_chan.gpio_pin = CONF_WINC_SPI_INT_PIN;
   1a4a8:	9301      	str	r3, [sp, #4]
	config_extint_chan.gpio_pin_pull = EXTINT_PULL_UP;
   1a4aa:	3b28      	subs	r3, #40	; 0x28
   1a4ac:	7223      	strb	r3, [r4, #8]
	config_extint_chan.detection_criteria = EXTINT_DETECT_FALLING;
   1a4ae:	3301      	adds	r3, #1
   1a4b0:	72e3      	strb	r3, [r4, #11]

	extint_chan_set_config(CONF_WINC_SPI_INT_EIC, &config_extint_chan);
   1a4b2:	0021      	movs	r1, r4
   1a4b4:	2009      	movs	r0, #9
   1a4b6:	4b09      	ldr	r3, [pc, #36]	; (1a4dc <nm_bsp_register_isr+0x48>)
	config_extint_chan.gpio_pin_mux = CONF_WINC_SPI_INT_MUX;
   1a4b8:	6065      	str	r5, [r4, #4]
	extint_chan_set_config(CONF_WINC_SPI_INT_EIC, &config_extint_chan);
   1a4ba:	4798      	blx	r3
	extint_register_callback(chip_isr, CONF_WINC_SPI_INT_EIC,
   1a4bc:	002a      	movs	r2, r5
   1a4be:	2109      	movs	r1, #9
   1a4c0:	4b07      	ldr	r3, [pc, #28]	; (1a4e0 <nm_bsp_register_isr+0x4c>)
   1a4c2:	4808      	ldr	r0, [pc, #32]	; (1a4e4 <nm_bsp_register_isr+0x50>)
   1a4c4:	4798      	blx	r3
			EXTINT_CALLBACK_TYPE_DETECT);
	extint_chan_enable_callback(CONF_WINC_SPI_INT_EIC,
   1a4c6:	0029      	movs	r1, r5
   1a4c8:	4b07      	ldr	r3, [pc, #28]	; (1a4e8 <nm_bsp_register_isr+0x54>)
   1a4ca:	2009      	movs	r0, #9
   1a4cc:	4798      	blx	r3
			EXTINT_CALLBACK_TYPE_DETECT);
}
   1a4ce:	b005      	add	sp, #20
   1a4d0:	bd30      	pop	{r4, r5, pc}
   1a4d2:	46c0      	nop			; (mov r8, r8)
   1a4d4:	20003d78 	.word	0x20003d78
   1a4d8:	0001d059 	.word	0x0001d059
   1a4dc:	0001d06d 	.word	0x0001d06d
   1a4e0:	0001cf1d 	.word	0x0001cf1d
   1a4e4:	0001a3dd 	.word	0x0001a3dd
   1a4e8:	0001cf45 	.word	0x0001cf45

0001a4ec <nm_bsp_interrupt_ctrl>:
 *	@brief	Enable/Disable interrupts
 *	@param[IN]	u8Enable
 *				'0' disable interrupts. '1' enable interrupts
 */
void nm_bsp_interrupt_ctrl(uint8 u8Enable)
{
   1a4ec:	b510      	push	{r4, lr}
   1a4ee:	1e01      	subs	r1, r0, #0
	if (u8Enable) {
   1a4f0:	d004      	beq.n	1a4fc <nm_bsp_interrupt_ctrl+0x10>
		extint_chan_enable_callback(CONF_WINC_SPI_INT_EIC,
   1a4f2:	2100      	movs	r1, #0
   1a4f4:	2009      	movs	r0, #9
   1a4f6:	4b03      	ldr	r3, [pc, #12]	; (1a504 <nm_bsp_interrupt_ctrl+0x18>)
				EXTINT_CALLBACK_TYPE_DETECT);
	} else {
		extint_chan_disable_callback(CONF_WINC_SPI_INT_EIC,
   1a4f8:	4798      	blx	r3
				EXTINT_CALLBACK_TYPE_DETECT);
	}
}
   1a4fa:	bd10      	pop	{r4, pc}
		extint_chan_disable_callback(CONF_WINC_SPI_INT_EIC,
   1a4fc:	2009      	movs	r0, #9
   1a4fe:	4b02      	ldr	r3, [pc, #8]	; (1a508 <nm_bsp_interrupt_ctrl+0x1c>)
   1a500:	e7fa      	b.n	1a4f8 <nm_bsp_interrupt_ctrl+0xc>
   1a502:	46c0      	nop			; (mov r8, r8)
   1a504:	0001cf45 	.word	0x0001cf45
   1a508:	0001cf65 	.word	0x0001cf65

0001a50c <nm_bus_init>:
*	@fn		nm_bus_init
*	@brief	Initialize the bus wrapper
*	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
*/
sint8 nm_bus_init(void *pvinit)
{
   1a50c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1a50e:	b08f      	sub	sp, #60	; 0x3c
	config->input_pull = PORT_PIN_PULL_UP;
   1a510:	466b      	mov	r3, sp
	slave->address_enabled = config->address_enabled;
   1a512:	2500      	movs	r5, #0
   1a514:	2401      	movs	r4, #1
	slave->ss_pin          = config->ss_pin;
   1a516:	200e      	movs	r0, #14
   1a518:	4e2d      	ldr	r6, [pc, #180]	; (1a5d0 <nm_bus_init+0xc4>)
   1a51a:	705c      	strb	r4, [r3, #1]
	config->powersave  = false;
   1a51c:	709d      	strb	r5, [r3, #2]
	pin_conf.direction = PORT_PIN_DIR_OUTPUT;
   1a51e:	701c      	strb	r4, [r3, #0]
	port_pin_set_config(slave->ss_pin, &pin_conf);
   1a520:	4669      	mov	r1, sp
   1a522:	4b2c      	ldr	r3, [pc, #176]	; (1a5d4 <nm_bus_init+0xc8>)
	slave->ss_pin          = config->ss_pin;
   1a524:	7030      	strb	r0, [r6, #0]
	slave->address_enabled = config->address_enabled;
   1a526:	7075      	strb	r5, [r6, #1]
	slave->address         = config->address;
   1a528:	70b5      	strb	r5, [r6, #2]
	port_pin_set_config(slave->ss_pin, &pin_conf);
   1a52a:	4798      	blx	r3
	port_pin_set_output_level(slave->ss_pin, true);
   1a52c:	7832      	ldrb	r2, [r6, #0]
	uint8_t group_index = (gpio_pin / 32);
   1a52e:	0953      	lsrs	r3, r2, #5
	if (port_index < PORT_INST_NUM) {
   1a530:	09d1      	lsrs	r1, r2, #7
   1a532:	42a9      	cmp	r1, r5
   1a534:	d149      	bne.n	1a5ca <nm_bus_init+0xbe>
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
   1a536:	271f      	movs	r7, #31
   1a538:	0020      	movs	r0, r4
   1a53a:	403a      	ands	r2, r7
   1a53c:	4090      	lsls	r0, r2
   1a53e:	0002      	movs	r2, r0
		port_base->OUTSET.reg = pin_mask;
   1a540:	4825      	ldr	r0, [pc, #148]	; (1a5d8 <nm_bus_init+0xcc>)
   1a542:	01db      	lsls	r3, r3, #7
   1a544:	181b      	adds	r3, r3, r0
   1a546:	619a      	str	r2, [r3, #24]
	config->mode             = SPI_MODE_MASTER;
   1a548:	466b      	mov	r3, sp
   1a54a:	701c      	strb	r4, [r3, #0]
	config->mux_setting      = SPI_SIGNAL_MUX_SETTING_D;
   1a54c:	23c0      	movs	r3, #192	; 0xc0
   1a54e:	039b      	lsls	r3, r3, #14
   1a550:	9303      	str	r3, [sp, #12]
	config->character_size   = SPI_CHARACTER_SIZE_8BIT;
   1a552:	466b      	mov	r3, sp
   1a554:	7419      	strb	r1, [r3, #16]
	config->run_in_standby   = false;
   1a556:	7459      	strb	r1, [r3, #17]
	config->master_slave_select_enable= false;
   1a558:	7519      	strb	r1, [r3, #20]
	config->receiver_enable  = true;
   1a55a:	749c      	strb	r4, [r3, #18]
	config->select_slave_low_detect_enable= true;
   1a55c:	74dc      	strb	r4, [r3, #19]
	config->generator_source = GCLK_GENERATOR_0;
   1a55e:	3305      	adds	r3, #5
   1a560:	77d9      	strb	r1, [r3, #31]
	memset(&(config->mode_specific), 0, sizeof(config->mode_specific));
   1a562:	220c      	movs	r2, #12
   1a564:	4b1d      	ldr	r3, [pc, #116]	; (1a5dc <nm_bus_init+0xd0>)
   1a566:	a806      	add	r0, sp, #24
	config->data_order       = SPI_DATA_ORDER_MSB;
   1a568:	9101      	str	r1, [sp, #4]
	config->transfer_mode    = SPI_TRANSFER_MODE_0;
   1a56a:	9102      	str	r1, [sp, #8]
	memset(&(config->mode_specific), 0, sizeof(config->mode_specific));
   1a56c:	4798      	blx	r3
	spi_attach_slave(&slave_inst, &slave_config);

	/* Configure the SPI master. */
	spi_get_config_defaults(&config);
	config.mux_setting = CONF_WINC_SPI_SERCOM_MUX;
	config.pinmux_pad0 = CONF_WINC_SPI_PINMUX_PAD0;
   1a56e:	4b1c      	ldr	r3, [pc, #112]	; (1a5e0 <nm_bus_init+0xd4>)
	config.pinmux_pad2 = CONF_WINC_SPI_PINMUX_PAD2;
	config.pinmux_pad3 = CONF_WINC_SPI_PINMUX_PAD3;
	config.master_slave_select_enable = false;
	
	config.mode_specific.master.baudrate = CONF_WINC_SPI_CLOCK;
	if (spi_init(&master, CONF_WINC_SPI_MODULE, &config) != STATUS_OK) {
   1a570:	4e1c      	ldr	r6, [pc, #112]	; (1a5e4 <nm_bus_init+0xd8>)
	config.pinmux_pad0 = CONF_WINC_SPI_PINMUX_PAD0;
   1a572:	930a      	str	r3, [sp, #40]	; 0x28
	config.pinmux_pad1 = CONF_WINC_SPI_PINMUX_PAD1;
   1a574:	4b1c      	ldr	r3, [pc, #112]	; (1a5e8 <nm_bus_init+0xdc>)
	if (spi_init(&master, CONF_WINC_SPI_MODULE, &config) != STATUS_OK) {
   1a576:	466a      	mov	r2, sp
	config.pinmux_pad1 = CONF_WINC_SPI_PINMUX_PAD1;
   1a578:	930b      	str	r3, [sp, #44]	; 0x2c
	config.pinmux_pad2 = CONF_WINC_SPI_PINMUX_PAD2;
   1a57a:	2301      	movs	r3, #1
   1a57c:	425b      	negs	r3, r3
   1a57e:	930c      	str	r3, [sp, #48]	; 0x30
	config.pinmux_pad3 = CONF_WINC_SPI_PINMUX_PAD3;
   1a580:	4b1a      	ldr	r3, [pc, #104]	; (1a5ec <nm_bus_init+0xe0>)
	if (spi_init(&master, CONF_WINC_SPI_MODULE, &config) != STATUS_OK) {
   1a582:	491b      	ldr	r1, [pc, #108]	; (1a5f0 <nm_bus_init+0xe4>)
	config.pinmux_pad3 = CONF_WINC_SPI_PINMUX_PAD3;
   1a584:	930d      	str	r3, [sp, #52]	; 0x34
	config.mode_specific.master.baudrate = CONF_WINC_SPI_CLOCK;
   1a586:	4b1b      	ldr	r3, [pc, #108]	; (1a5f4 <nm_bus_init+0xe8>)
	if (spi_init(&master, CONF_WINC_SPI_MODULE, &config) != STATUS_OK) {
   1a588:	0030      	movs	r0, r6
	config.mode_specific.master.baudrate = CONF_WINC_SPI_CLOCK;
   1a58a:	9306      	str	r3, [sp, #24]
	if (spi_init(&master, CONF_WINC_SPI_MODULE, &config) != STATUS_OK) {
   1a58c:	4b1a      	ldr	r3, [pc, #104]	; (1a5f8 <nm_bus_init+0xec>)
   1a58e:	4798      	blx	r3
   1a590:	42a8      	cmp	r0, r5
   1a592:	d117      	bne.n	1a5c4 <nm_bus_init+0xb8>
	SercomSpi *const spi_module = &(module->hw->SPI);
   1a594:	6835      	ldr	r5, [r6, #0]
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
   1a596:	4b19      	ldr	r3, [pc, #100]	; (1a5fc <nm_bus_init+0xf0>)
   1a598:	0028      	movs	r0, r5
   1a59a:	4798      	blx	r3
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
   1a59c:	4007      	ands	r7, r0
   1a59e:	40bc      	lsls	r4, r7
   1a5a0:	4b17      	ldr	r3, [pc, #92]	; (1a600 <nm_bus_init+0xf4>)
   1a5a2:	601c      	str	r4, [r3, #0]
	SercomSpi *const spi_module = &(module->hw->SPI);
   1a5a4:	6833      	ldr	r3, [r6, #0]
	return (spi_module->SYNCBUSY.reg);
   1a5a6:	69dc      	ldr	r4, [r3, #28]
	while (spi_is_syncing(module)) {
   1a5a8:	2c00      	cmp	r4, #0
   1a5aa:	d1fc      	bne.n	1a5a6 <nm_bus_init+0x9a>
	spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
   1a5ac:	2302      	movs	r3, #2
   1a5ae:	682a      	ldr	r2, [r5, #0]
   1a5b0:	4313      	orrs	r3, r2
   1a5b2:	602b      	str	r3, [r5, #0]
	}

	/* Enable the SPI master. */
	spi_enable(&master);

	nm_bsp_reset();
   1a5b4:	4b13      	ldr	r3, [pc, #76]	; (1a604 <nm_bus_init+0xf8>)
   1a5b6:	4798      	blx	r3
	nm_bsp_sleep(1);
   1a5b8:	2001      	movs	r0, #1
   1a5ba:	4b13      	ldr	r3, [pc, #76]	; (1a608 <nm_bus_init+0xfc>)
   1a5bc:	4798      	blx	r3
#endif
	return result;
   1a5be:	0020      	movs	r0, r4
}
   1a5c0:	b00f      	add	sp, #60	; 0x3c
   1a5c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return M2M_ERR_BUS_FAIL;
   1a5c4:	2006      	movs	r0, #6
   1a5c6:	4240      	negs	r0, r0
   1a5c8:	e7fa      	b.n	1a5c0 <nm_bus_init+0xb4>
   1a5ca:	61ad      	str	r5, [r5, #24]
   1a5cc:	deff      	udf	#255	; 0xff
   1a5ce:	46c0      	nop			; (mov r8, r8)
   1a5d0:	2000550c 	.word	0x2000550c
   1a5d4:	0001d0dd 	.word	0x0001d0dd
   1a5d8:	41004400 	.word	0x41004400
   1a5dc:	00022c47 	.word	0x00022c47
   1a5e0:	000c0002 	.word	0x000c0002
   1a5e4:	20005510 	.word	0x20005510
   1a5e8:	000d0002 	.word	0x000d0002
   1a5ec:	000f0002 	.word	0x000f0002
   1a5f0:	42001000 	.word	0x42001000
   1a5f4:	00124f80 	.word	0x00124f80
   1a5f8:	0001d859 	.word	0x0001d859
   1a5fc:	0001d699 	.word	0x0001d699
   1a600:	e000e100 	.word	0xe000e100
   1a604:	0001a461 	.word	0x0001a461
   1a608:	0001a489 	.word	0x0001a489

0001a60c <nm_bus_ioctl>:
*					Arbitrary parameter depenging on IOCTL
*	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
*	@note	For SPI only, it's important to be able to send/receive at the same time
*/
sint8 nm_bus_ioctl(uint8 u8Cmd, void* pvParameter)
{
   1a60c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1a60e:	b085      	sub	sp, #20
	sint8 s8Ret = 0;
	switch(u8Cmd)
   1a610:	2803      	cmp	r0, #3
   1a612:	d11a      	bne.n	1a64a <nm_bus_ioctl+0x3e>
	uint8 u8Dummy = 0xFF;
   1a614:	22ff      	movs	r2, #255	; 0xff
   1a616:	ab02      	add	r3, sp, #8
		}
		break;
#elif defined CONF_WINC_USE_SPI
		case NM_BUS_IOCTL_RW: {
			tstrNmSpiRw *pstrParam = (tstrNmSpiRw *)pvParameter;
			s8Ret = spi_rw(pstrParam->pu8InBuf, pstrParam->pu8OutBuf, pstrParam->u16Sz);
   1a618:	684e      	ldr	r6, [r1, #4]
	uint8 u8Dummy = 0xFF;
   1a61a:	3307      	adds	r3, #7
			s8Ret = spi_rw(pstrParam->pu8InBuf, pstrParam->pu8OutBuf, pstrParam->u16Sz);
   1a61c:	890c      	ldrh	r4, [r1, #8]
   1a61e:	680d      	ldr	r5, [r1, #0]
	uint8 u8Dummy = 0xFF;
   1a620:	701a      	strb	r2, [r3, #0]
	if(((pu8Miso == NULL) && (pu8Mosi == NULL)) ||(u16Sz == 0)) {
   1a622:	2e00      	cmp	r6, #0
   1a624:	d104      	bne.n	1a630 <nm_bus_ioctl+0x24>
   1a626:	2d00      	cmp	r5, #0
   1a628:	d11b      	bne.n	1a662 <nm_bus_ioctl+0x56>
		return M2M_ERR_INVALID_ARG;
   1a62a:	200f      	movs	r0, #15
		}
		break;
#endif
		default:
			s8Ret = -1;
   1a62c:	4240      	negs	r0, r0
			M2M_ERR("invalide ioclt cmd\n");
			break;
	}

	return s8Ret;
   1a62e:	e062      	b.n	1a6f6 <nm_bus_ioctl+0xea>
	if(((pu8Miso == NULL) && (pu8Mosi == NULL)) ||(u16Sz == 0)) {
   1a630:	2c00      	cmp	r4, #0
   1a632:	d0fa      	beq.n	1a62a <nm_bus_ioctl+0x1e>
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
   1a634:	2700      	movs	r7, #0
	if (pu8Mosi == NULL) {
   1a636:	42bd      	cmp	r5, r7
   1a638:	d101      	bne.n	1a63e <nm_bus_ioctl+0x32>
		pu8Mosi = &u8Dummy;
   1a63a:	001d      	movs	r5, r3
		u8SkipMosi = 1;
   1a63c:	3701      	adds	r7, #1
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
   1a63e:	2300      	movs	r3, #0
   1a640:	9300      	str	r3, [sp, #0]
   1a642:	e014      	b.n	1a66e <nm_bus_ioctl+0x62>

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
   1a644:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1a646:	b2d2      	uxtb	r2, r2
   1a648:	e03c      	b.n	1a6c4 <nm_bus_ioctl+0xb8>
			M2M_ERR("invalide ioclt cmd\n");
   1a64a:	2283      	movs	r2, #131	; 0x83
   1a64c:	492b      	ldr	r1, [pc, #172]	; (1a6fc <nm_bus_ioctl+0xf0>)
   1a64e:	0052      	lsls	r2, r2, #1
   1a650:	4c2b      	ldr	r4, [pc, #172]	; (1a700 <nm_bus_ioctl+0xf4>)
   1a652:	482c      	ldr	r0, [pc, #176]	; (1a704 <nm_bus_ioctl+0xf8>)
   1a654:	47a0      	blx	r4
   1a656:	482c      	ldr	r0, [pc, #176]	; (1a708 <nm_bus_ioctl+0xfc>)
   1a658:	47a0      	blx	r4
   1a65a:	482c      	ldr	r0, [pc, #176]	; (1a70c <nm_bus_ioctl+0x100>)
   1a65c:	47a0      	blx	r4
			s8Ret = -1;
   1a65e:	2001      	movs	r0, #1
   1a660:	e7e4      	b.n	1a62c <nm_bus_ioctl+0x20>
	if(((pu8Miso == NULL) && (pu8Mosi == NULL)) ||(u16Sz == 0)) {
   1a662:	2c00      	cmp	r4, #0
   1a664:	d0e1      	beq.n	1a62a <nm_bus_ioctl+0x1e>
		u8SkipMiso = 1;
   1a666:	2201      	movs	r2, #1
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
   1a668:	0037      	movs	r7, r6
		pu8Miso = &u8Dummy;
   1a66a:	001e      	movs	r6, r3
		u8SkipMiso = 1;
   1a66c:	9200      	str	r2, [sp, #0]
	spi_select_slave(&master, &slave_inst, true);
   1a66e:	4928      	ldr	r1, [pc, #160]	; (1a710 <nm_bus_ioctl+0x104>)
   1a670:	4b28      	ldr	r3, [pc, #160]	; (1a714 <nm_bus_ioctl+0x108>)
   1a672:	2201      	movs	r2, #1
   1a674:	4828      	ldr	r0, [pc, #160]	; (1a718 <nm_bus_ioctl+0x10c>)
   1a676:	4798      	blx	r3
		while (!spi_is_ready_to_write(&master))
   1a678:	2301      	movs	r3, #1
		while (!spi_is_ready_to_read(&master))
   1a67a:	2104      	movs	r1, #4
		while (!spi_is_ready_to_write(&master))
   1a67c:	469c      	mov	ip, r3
		txd_data = *pu8Mosi;
   1a67e:	782b      	ldrb	r3, [r5, #0]
   1a680:	9301      	str	r3, [sp, #4]
	SercomSpi *const spi_module = &(module->hw->SPI);
   1a682:	4b25      	ldr	r3, [pc, #148]	; (1a718 <nm_bus_ioctl+0x10c>)
   1a684:	681b      	ldr	r3, [r3, #0]
		while (!spi_is_ready_to_write(&master))
   1a686:	4662      	mov	r2, ip
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
   1a688:	7e18      	ldrb	r0, [r3, #24]
   1a68a:	4210      	tst	r0, r2
   1a68c:	d0fb      	beq.n	1a686 <nm_bus_ioctl+0x7a>
	if (!spi_is_ready_to_write(module)) {
   1a68e:	4662      	mov	r2, ip
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
   1a690:	7e18      	ldrb	r0, [r3, #24]
	if (!spi_is_ready_to_write(module)) {
   1a692:	4210      	tst	r0, r2
   1a694:	d0fb      	beq.n	1a68e <nm_bus_ioctl+0x82>
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
   1a696:	9a01      	ldr	r2, [sp, #4]
   1a698:	629a      	str	r2, [r3, #40]	; 0x28
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
   1a69a:	7e1a      	ldrb	r2, [r3, #24]
		while (!spi_is_ready_to_read(&master))
   1a69c:	420a      	tst	r2, r1
   1a69e:	d0fc      	beq.n	1a69a <nm_bus_ioctl+0x8e>
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
   1a6a0:	4a1d      	ldr	r2, [pc, #116]	; (1a718 <nm_bus_ioctl+0x10c>)
   1a6a2:	7992      	ldrb	r2, [r2, #6]
   1a6a4:	9201      	str	r2, [sp, #4]
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
   1a6a6:	7e1a      	ldrb	r2, [r3, #24]
	if (!spi_is_ready_to_read(module)) {
   1a6a8:	420a      	tst	r2, r1
   1a6aa:	d0fc      	beq.n	1a6a6 <nm_bus_ioctl+0x9a>
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
   1a6ac:	8b5a      	ldrh	r2, [r3, #26]
	enum status_code retval = STATUS_OK;
   1a6ae:	2000      	movs	r0, #0
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
   1a6b0:	420a      	tst	r2, r1
   1a6b2:	d001      	beq.n	1a6b8 <nm_bus_ioctl+0xac>
		spi_module->STATUS.reg = SERCOM_SPI_STATUS_BUFOVF;
   1a6b4:	8359      	strh	r1, [r3, #26]
		retval = STATUS_ERR_OVERFLOW;
   1a6b6:	301e      	adds	r0, #30
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
   1a6b8:	9a01      	ldr	r2, [sp, #4]
   1a6ba:	2a01      	cmp	r2, #1
   1a6bc:	d1c2      	bne.n	1a644 <nm_bus_ioctl+0x38>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
   1a6be:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1a6c0:	05d2      	lsls	r2, r2, #23
   1a6c2:	0dd2      	lsrs	r2, r2, #23
		while (spi_read(&master, &rxd_data) != STATUS_OK)
   1a6c4:	2800      	cmp	r0, #0
   1a6c6:	d1ee      	bne.n	1a6a6 <nm_bus_ioctl+0x9a>
			pu8Miso++;
   1a6c8:	9b00      	ldr	r3, [sp, #0]
		*pu8Miso = rxd_data;
   1a6ca:	7032      	strb	r2, [r6, #0]
			pu8Miso++;
   1a6cc:	425a      	negs	r2, r3
   1a6ce:	4153      	adcs	r3, r2
   1a6d0:	18f6      	adds	r6, r6, r3
			pu8Mosi++;
   1a6d2:	427b      	negs	r3, r7
   1a6d4:	417b      	adcs	r3, r7
		u16Sz--;
   1a6d6:	3c01      	subs	r4, #1
   1a6d8:	b2a4      	uxth	r4, r4
			pu8Mosi++;
   1a6da:	18ed      	adds	r5, r5, r3
	while (u16Sz) {
   1a6dc:	2c00      	cmp	r4, #0
   1a6de:	d1ce      	bne.n	1a67e <nm_bus_ioctl+0x72>
	while (!spi_is_write_complete(&master))
   1a6e0:	2302      	movs	r3, #2
	SercomSpi *const spi_module = &(module->hw->SPI);
   1a6e2:	480d      	ldr	r0, [pc, #52]	; (1a718 <nm_bus_ioctl+0x10c>)
   1a6e4:	6801      	ldr	r1, [r0, #0]
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
   1a6e6:	7e0a      	ldrb	r2, [r1, #24]
   1a6e8:	421a      	tst	r2, r3
   1a6ea:	d0fc      	beq.n	1a6e6 <nm_bus_ioctl+0xda>
	spi_select_slave(&master, &slave_inst, false);
   1a6ec:	2200      	movs	r2, #0
   1a6ee:	4908      	ldr	r1, [pc, #32]	; (1a710 <nm_bus_ioctl+0x104>)
   1a6f0:	4b08      	ldr	r3, [pc, #32]	; (1a714 <nm_bus_ioctl+0x108>)
   1a6f2:	4798      	blx	r3
	return M2M_SUCCESS;
   1a6f4:	2000      	movs	r0, #0
}
   1a6f6:	b005      	add	sp, #20
   1a6f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1a6fa:	46c0      	nop			; (mov r8, r8)
   1a6fc:	00029fac 	.word	0x00029fac
   1a700:	00019415 	.word	0x00019415
   1a704:	00029fb9 	.word	0x00029fb9
   1a708:	00029fcc 	.word	0x00029fcc
   1a70c:	0002b325 	.word	0x0002b325
   1a710:	2000550c 	.word	0x2000550c
   1a714:	0001dab1 	.word	0x0001dab1
   1a718:	20005510 	.word	0x20005510

0001a71c <nm_bus_deinit>:
	config->direction  = PORT_PIN_DIR_INPUT;
   1a71c:	2300      	movs	r3, #0
/*
*	@fn		nm_bus_deinit
*	@brief	De-initialize the bus wrapper
*/
sint8 nm_bus_deinit(void)
{
   1a71e:	b573      	push	{r0, r1, r4, r5, r6, lr}
	SercomSpi *const spi_module = &(module->hw->SPI);
   1a720:	4e14      	ldr	r6, [pc, #80]	; (1a774 <nm_bus_deinit+0x58>)
   1a722:	ac01      	add	r4, sp, #4
   1a724:	6835      	ldr	r5, [r6, #0]
   1a726:	7023      	strb	r3, [r4, #0]
	config->powersave  = false;
   1a728:	70a3      	strb	r3, [r4, #2]
	struct port_config pin_conf;
		
	port_get_config_defaults(&pin_conf);
	/* Configure control pins as input no pull up. */
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
	pin_conf.input_pull = PORT_PIN_PULL_NONE;
   1a72a:	7063      	strb	r3, [r4, #1]
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
   1a72c:	0028      	movs	r0, r5
   1a72e:	4b12      	ldr	r3, [pc, #72]	; (1a778 <nm_bus_deinit+0x5c>)
   1a730:	4798      	blx	r3
	NVIC->ICER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
   1a732:	231f      	movs	r3, #31
   1a734:	4018      	ands	r0, r3
   1a736:	3b1e      	subs	r3, #30
   1a738:	4083      	lsls	r3, r0
   1a73a:	4a10      	ldr	r2, [pc, #64]	; (1a77c <nm_bus_deinit+0x60>)
   1a73c:	67d3      	str	r3, [r2, #124]	; 0x7c
	SercomSpi *const spi_module = &(module->hw->SPI);
   1a73e:	6833      	ldr	r3, [r6, #0]
	return (spi_module->SYNCBUSY.reg);
   1a740:	69de      	ldr	r6, [r3, #28]
	while (spi_is_syncing(module)) {
   1a742:	2e00      	cmp	r6, #0
   1a744:	d1fc      	bne.n	1a740 <nm_bus_deinit+0x24>
	spi_module->INTENCLR.reg = SERCOM_SPI_INTENCLR_MASK;
   1a746:	238f      	movs	r3, #143	; 0x8f
	spi_module->CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
   1a748:	2202      	movs	r2, #2
	spi_module->INTENCLR.reg = SERCOM_SPI_INTENCLR_MASK;
   1a74a:	752b      	strb	r3, [r5, #20]
	spi_module->INTFLAG.reg = SERCOM_SPI_INTFLAG_MASK;
   1a74c:	762b      	strb	r3, [r5, #24]
	spi_module->CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
   1a74e:	682b      	ldr	r3, [r5, #0]
	port_pin_set_config(CONF_WINC_I2C_SCL, &pin_conf);
	port_pin_set_config(CONF_WINC_I2C_SDA, &pin_conf);
#endif /* CONF_WINC_USE_I2C */
#ifdef CONF_WINC_USE_SPI
	spi_disable(&master);
	port_pin_set_config(CONF_WINC_SPI_MOSI, &pin_conf);
   1a750:	0021      	movs	r1, r4
   1a752:	4393      	bics	r3, r2
   1a754:	602b      	str	r3, [r5, #0]
   1a756:	200c      	movs	r0, #12
   1a758:	4d09      	ldr	r5, [pc, #36]	; (1a780 <nm_bus_deinit+0x64>)
   1a75a:	47a8      	blx	r5
	port_pin_set_config(CONF_WINC_SPI_MISO, &pin_conf);
   1a75c:	0021      	movs	r1, r4
   1a75e:	200f      	movs	r0, #15
   1a760:	47a8      	blx	r5
	port_pin_set_config(CONF_WINC_SPI_SCK,  &pin_conf);
   1a762:	0021      	movs	r1, r4
   1a764:	200d      	movs	r0, #13
   1a766:	47a8      	blx	r5
	port_pin_set_config(CONF_WINC_SPI_SS,   &pin_conf);
   1a768:	0021      	movs	r1, r4
   1a76a:	200e      	movs	r0, #14
   1a76c:	47a8      	blx	r5
	//port_pin_set_output_level(CONF_WINC_SPI_MISO, false);
	//port_pin_set_output_level(CONF_WINC_SPI_SCK,  false);
	//port_pin_set_output_level(CONF_WINC_SPI_SS,   false);
#endif /* CONF_WINC_USE_SPI */
	return result;
}
   1a76e:	0030      	movs	r0, r6
   1a770:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
   1a772:	46c0      	nop			; (mov r8, r8)
   1a774:	20005510 	.word	0x20005510
   1a778:	0001d699 	.word	0x0001d699
   1a77c:	e000e104 	.word	0xe000e104
   1a780:	0001d0dd 	.word	0x0001d0dd

0001a784 <m2m_memcpy>:
 *
 */
#include "common/include/nm_common.h"

void m2m_memcpy(uint8* pDst,uint8* pSrc,uint32 sz)
{
   1a784:	2300      	movs	r3, #0
   1a786:	b510      	push	{r4, lr}
	if(sz == 0) return;
   1a788:	429a      	cmp	r2, r3
   1a78a:	d003      	beq.n	1a794 <m2m_memcpy+0x10>
	do
	{
		*pDst = *pSrc;
   1a78c:	5ccc      	ldrb	r4, [r1, r3]
   1a78e:	54c4      	strb	r4, [r0, r3]
   1a790:	3301      	adds	r3, #1
   1a792:	e7f9      	b.n	1a788 <m2m_memcpy+0x4>
		pDst++;
		pSrc++;
	}while(--sz);
}
   1a794:	bd10      	pop	{r4, pc}

0001a796 <m2m_memset>:

	return cs;
}

void m2m_memset(uint8* pBuf,uint8 val,uint32 sz)
{
   1a796:	1883      	adds	r3, r0, r2
	if(sz == 0) return;
   1a798:	2a00      	cmp	r2, #0
   1a79a:	d003      	beq.n	1a7a4 <m2m_memset+0xe>
	do
	{
		*pBuf = val;
   1a79c:	7001      	strb	r1, [r0, #0]
		pBuf++;
   1a79e:	3001      	adds	r0, #1
	}while(--sz);
   1a7a0:	4298      	cmp	r0, r3
   1a7a2:	d1fb      	bne.n	1a79c <m2m_memset+0x6>
}
   1a7a4:	4770      	bx	lr

0001a7a6 <m2m_strlen>:

uint16 m2m_strlen(uint8 * pcStr)
{
	uint16	u16StrLen = 0;
	while(*pcStr)
   1a7a6:	2300      	movs	r3, #0
   1a7a8:	5cc1      	ldrb	r1, [r0, r3]
   1a7aa:	b29a      	uxth	r2, r3
   1a7ac:	3301      	adds	r3, #1
   1a7ae:	2900      	cmp	r1, #0
   1a7b0:	d1fa      	bne.n	1a7a8 <m2m_strlen+0x2>
	{
		u16StrLen ++;
		pcStr++;
	}
	return u16StrLen;
}
   1a7b2:	0010      	movs	r0, r2
   1a7b4:	4770      	bx	lr
	...

0001a7b8 <isr>:
extern void os_hook_isr(void);
#endif

static void isr(void)
{
	gstrHifCxt.u8Interrupt++;
   1a7b8:	4a02      	ldr	r2, [pc, #8]	; (1a7c4 <isr+0xc>)
   1a7ba:	78d3      	ldrb	r3, [r2, #3]
   1a7bc:	3301      	adds	r3, #1
   1a7be:	b2db      	uxtb	r3, r3
   1a7c0:	70d3      	strb	r3, [r2, #3]
	nm_bsp_interrupt_ctrl(0);
#endif
#ifdef ETH_MODE
	os_hook_isr();
#endif
}
   1a7c2:	4770      	bx	lr
   1a7c4:	2000554c 	.word	0x2000554c

0001a7c8 <m2m_hif_cb>:
*/
static void m2m_hif_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
{


}
   1a7c8:	4770      	bx	lr
	...

0001a7cc <hif_set_rx_done>:
{
   1a7cc:	b507      	push	{r0, r1, r2, lr}
	gstrHifCxt.u8HifRXDone = 0;
   1a7ce:	2200      	movs	r2, #0
   1a7d0:	4b09      	ldr	r3, [pc, #36]	; (1a7f8 <hif_set_rx_done+0x2c>)
	nm_bsp_interrupt_ctrl(1);
   1a7d2:	2001      	movs	r0, #1
	gstrHifCxt.u8HifRXDone = 0;
   1a7d4:	709a      	strb	r2, [r3, #2]
	nm_bsp_interrupt_ctrl(1);
   1a7d6:	4b09      	ldr	r3, [pc, #36]	; (1a7fc <hif_set_rx_done+0x30>)
   1a7d8:	4798      	blx	r3
	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0,&reg);
   1a7da:	a901      	add	r1, sp, #4
   1a7dc:	4808      	ldr	r0, [pc, #32]	; (1a800 <hif_set_rx_done+0x34>)
   1a7de:	4b09      	ldr	r3, [pc, #36]	; (1a804 <hif_set_rx_done+0x38>)
   1a7e0:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
   1a7e2:	2800      	cmp	r0, #0
   1a7e4:	d106      	bne.n	1a7f4 <hif_set_rx_done+0x28>
	reg |= NBIT1;
   1a7e6:	2102      	movs	r1, #2
   1a7e8:	9b01      	ldr	r3, [sp, #4]
	ret = nm_write_reg(WIFI_HOST_RCV_CTRL_0,reg);
   1a7ea:	4805      	ldr	r0, [pc, #20]	; (1a800 <hif_set_rx_done+0x34>)
	reg |= NBIT1;
   1a7ec:	4319      	orrs	r1, r3
	ret = nm_write_reg(WIFI_HOST_RCV_CTRL_0,reg);
   1a7ee:	4b06      	ldr	r3, [pc, #24]	; (1a808 <hif_set_rx_done+0x3c>)
	reg |= NBIT1;
   1a7f0:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(WIFI_HOST_RCV_CTRL_0,reg);
   1a7f2:	4798      	blx	r3
}
   1a7f4:	bd0e      	pop	{r1, r2, r3, pc}
   1a7f6:	46c0      	nop			; (mov r8, r8)
   1a7f8:	2000554c 	.word	0x2000554c
   1a7fc:	0001a4ed 	.word	0x0001a4ed
   1a800:	00001070 	.word	0x00001070
   1a804:	0001b7d9 	.word	0x0001b7d9
   1a808:	0001b7e5 	.word	0x0001b7e5

0001a80c <hif_chip_wake>:
{
	sint8 ret = M2M_SUCCESS;
	if(gstrHifCxt.u8HifRXDone)
	{
		/*chip already wake for the rx not done no need to send wake request*/
		return ret;
   1a80c:	2000      	movs	r0, #0
{
   1a80e:	b510      	push	{r4, lr}
	if(gstrHifCxt.u8HifRXDone)
   1a810:	4c0a      	ldr	r4, [pc, #40]	; (1a83c <hif_chip_wake+0x30>)
   1a812:	78a3      	ldrb	r3, [r4, #2]
   1a814:	4283      	cmp	r3, r0
   1a816:	d107      	bne.n	1a828 <hif_chip_wake+0x1c>
	}
	if(gstrHifCxt.u8ChipSleep == 0)
   1a818:	7863      	ldrb	r3, [r4, #1]
   1a81a:	4283      	cmp	r3, r0
   1a81c:	d005      	beq.n	1a82a <hif_chip_wake+0x1e>
		}
		else
		{
		}
	}
	gstrHifCxt.u8ChipSleep++;
   1a81e:	2000      	movs	r0, #0
   1a820:	7863      	ldrb	r3, [r4, #1]
   1a822:	3301      	adds	r3, #1
   1a824:	b2db      	uxtb	r3, r3
   1a826:	7063      	strb	r3, [r4, #1]
ERR1:
	return ret;
}
   1a828:	bd10      	pop	{r4, pc}
		if(gstrHifCxt.u8ChipMode != M2M_NO_PS)
   1a82a:	7823      	ldrb	r3, [r4, #0]
   1a82c:	2b00      	cmp	r3, #0
   1a82e:	d0f6      	beq.n	1a81e <hif_chip_wake+0x12>
			ret = chip_wake();
   1a830:	4b03      	ldr	r3, [pc, #12]	; (1a840 <hif_chip_wake+0x34>)
   1a832:	4798      	blx	r3
			if(ret != M2M_SUCCESS)goto ERR1;
   1a834:	2800      	cmp	r0, #0
   1a836:	d0f2      	beq.n	1a81e <hif_chip_wake+0x12>
   1a838:	e7f6      	b.n	1a828 <hif_chip_wake+0x1c>
   1a83a:	46c0      	nop			; (mov r8, r8)
   1a83c:	2000554c 	.word	0x2000554c
   1a840:	0001b51d 	.word	0x0001b51d

0001a844 <hif_chip_sleep_sc>:
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_chip_sleep_sc(void)
{
	if(gstrHifCxt.u8ChipSleep >= 1)
   1a844:	4a04      	ldr	r2, [pc, #16]	; (1a858 <hif_chip_sleep_sc+0x14>)
   1a846:	7853      	ldrb	r3, [r2, #1]
   1a848:	2b00      	cmp	r3, #0
   1a84a:	d003      	beq.n	1a854 <hif_chip_sleep_sc+0x10>
	{
		gstrHifCxt.u8ChipSleep--;
   1a84c:	7853      	ldrb	r3, [r2, #1]
   1a84e:	3b01      	subs	r3, #1
   1a850:	b2db      	uxtb	r3, r3
   1a852:	7053      	strb	r3, [r2, #1]
	}
	return M2M_SUCCESS;
}
   1a854:	2000      	movs	r0, #0
   1a856:	4770      	bx	lr
   1a858:	2000554c 	.word	0x2000554c

0001a85c <hif_chip_sleep>:
*	@brief	To make the chip sleep.
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_chip_sleep(void)
{
   1a85c:	b510      	push	{r4, lr}
	sint8 ret = M2M_SUCCESS;

	if(gstrHifCxt.u8ChipSleep >= 1)
   1a85e:	4b09      	ldr	r3, [pc, #36]	; (1a884 <hif_chip_sleep+0x28>)
   1a860:	785a      	ldrb	r2, [r3, #1]
   1a862:	2a00      	cmp	r2, #0
   1a864:	d003      	beq.n	1a86e <hif_chip_sleep+0x12>
	{
		gstrHifCxt.u8ChipSleep--;
   1a866:	785a      	ldrb	r2, [r3, #1]
   1a868:	3a01      	subs	r2, #1
   1a86a:	b2d2      	uxtb	r2, r2
   1a86c:	705a      	strb	r2, [r3, #1]
	sint8 ret = M2M_SUCCESS;
   1a86e:	2000      	movs	r0, #0
	}
	
	if(gstrHifCxt.u8ChipSleep == 0)
   1a870:	785a      	ldrb	r2, [r3, #1]
   1a872:	4282      	cmp	r2, r0
   1a874:	d104      	bne.n	1a880 <hif_chip_sleep+0x24>
	{
		if(gstrHifCxt.u8ChipMode != M2M_NO_PS)
   1a876:	781b      	ldrb	r3, [r3, #0]
   1a878:	4283      	cmp	r3, r0
   1a87a:	d001      	beq.n	1a880 <hif_chip_sleep+0x24>
		{
			ret = chip_sleep();
   1a87c:	4b02      	ldr	r3, [pc, #8]	; (1a888 <hif_chip_sleep+0x2c>)
   1a87e:	4798      	blx	r3
		{
		}
	}
ERR1:
	return ret;
}
   1a880:	bd10      	pop	{r4, pc}
   1a882:	46c0      	nop			; (mov r8, r8)
   1a884:	2000554c 	.word	0x2000554c
   1a888:	0001b4bd 	.word	0x0001b4bd

0001a88c <hif_send>:
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_send(uint8 u8Gid,uint8 u8Opcode,uint8 *pu8CtrlBuf,uint16 u16CtrlBufSize,
			   uint8 *pu8DataBuf,uint16 u16DataSize, uint16 u16DataOffset)
{
   1a88c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1a88e:	b08b      	sub	sp, #44	; 0x2c
   1a890:	001f      	movs	r7, r3
   1a892:	ab10      	add	r3, sp, #64	; 0x40
   1a894:	9202      	str	r2, [sp, #8]
   1a896:	cb04      	ldmia	r3!, {r2}
   1a898:	0006      	movs	r6, r0
   1a89a:	9200      	str	r2, [sp, #0]
	sint8		ret = M2M_ERR_SEND;
	volatile tstrHifHdr	strHif;

	strHif.u8Opcode		= u8Opcode&(~NBIT7);
   1a89c:	227f      	movs	r2, #127	; 0x7f
{
   1a89e:	881b      	ldrh	r3, [r3, #0]
	strHif.u8Opcode		= u8Opcode&(~NBIT7);
   1a8a0:	400a      	ands	r2, r1
{
   1a8a2:	9301      	str	r3, [sp, #4]
   1a8a4:	ab12      	add	r3, sp, #72	; 0x48
   1a8a6:	881b      	ldrh	r3, [r3, #0]
   1a8a8:	000d      	movs	r5, r1
   1a8aa:	9303      	str	r3, [sp, #12]
	strHif.u8Opcode		= u8Opcode&(~NBIT7);
   1a8ac:	ab06      	add	r3, sp, #24
   1a8ae:	705a      	strb	r2, [r3, #1]
	strHif.u8Gid		= u8Gid;
	strHif.u16Length	= M2M_HIF_HDR_OFFSET;
   1a8b0:	2208      	movs	r2, #8
	strHif.u8Gid		= u8Gid;
   1a8b2:	7018      	strb	r0, [r3, #0]
	strHif.u16Length	= M2M_HIF_HDR_OFFSET;
   1a8b4:	805a      	strh	r2, [r3, #2]
	if(pu8DataBuf != NULL)
   1a8b6:	9a00      	ldr	r2, [sp, #0]
   1a8b8:	2a00      	cmp	r2, #0
   1a8ba:	d047      	beq.n	1a94c <hif_send+0xc0>
	{
		strHif.u16Length += u16DataOffset + u16DataSize;
   1a8bc:	9901      	ldr	r1, [sp, #4]
   1a8be:	885a      	ldrh	r2, [r3, #2]
   1a8c0:	1852      	adds	r2, r2, r1
   1a8c2:	9903      	ldr	r1, [sp, #12]
   1a8c4:	188a      	adds	r2, r1, r2
	}
	else
	{
		strHif.u16Length += u16CtrlBufSize;
   1a8c6:	b292      	uxth	r2, r2
   1a8c8:	805a      	strh	r2, [r3, #2]
	}
	ret = hif_chip_wake();
   1a8ca:	4b59      	ldr	r3, [pc, #356]	; (1aa30 <hif_send+0x1a4>)
   1a8cc:	4798      	blx	r3
   1a8ce:	1e04      	subs	r4, r0, #0
	if(ret == M2M_SUCCESS)
   1a8d0:	d000      	beq.n	1a8d4 <hif_send+0x48>
   1a8d2:	e0a1      	b.n	1aa18 <hif_send+0x18c>
	{
		volatile uint32 reg, dma_addr = 0;
		volatile uint16 cnt = 0;
   1a8d4:	ab04      	add	r3, sp, #16
		volatile uint32 reg, dma_addr = 0;
   1a8d6:	9008      	str	r0, [sp, #32]
		volatile uint16 cnt = 0;
   1a8d8:	80d8      	strh	r0, [r3, #6]
//#define OPTIMIZE_BUS 
/*please define in firmware also*/
#ifndef OPTIMIZE_BUS
		reg = 0UL;
   1a8da:	9007      	str	r0, [sp, #28]
		reg |= (uint32)u8Gid;
   1a8dc:	9b07      	ldr	r3, [sp, #28]
		reg |= ((uint32)u8Opcode<<8);
   1a8de:	022d      	lsls	r5, r5, #8
		reg |= (uint32)u8Gid;
   1a8e0:	431e      	orrs	r6, r3
   1a8e2:	9607      	str	r6, [sp, #28]
		reg |= ((uint32)u8Opcode<<8);
   1a8e4:	9b07      	ldr	r3, [sp, #28]
		reg |= ((uint32)strHif.u16Length<<16);
		ret = nm_write_reg(NMI_STATE_REG,reg);
   1a8e6:	4853      	ldr	r0, [pc, #332]	; (1aa34 <hif_send+0x1a8>)
		reg |= ((uint32)u8Opcode<<8);
   1a8e8:	431d      	orrs	r5, r3
   1a8ea:	9507      	str	r5, [sp, #28]
		reg |= ((uint32)strHif.u16Length<<16);
   1a8ec:	ab06      	add	r3, sp, #24
   1a8ee:	885b      	ldrh	r3, [r3, #2]
   1a8f0:	9a07      	ldr	r2, [sp, #28]
   1a8f2:	041b      	lsls	r3, r3, #16
   1a8f4:	4313      	orrs	r3, r2
   1a8f6:	9307      	str	r3, [sp, #28]
		ret = nm_write_reg(NMI_STATE_REG,reg);
   1a8f8:	9907      	ldr	r1, [sp, #28]
   1a8fa:	4d4f      	ldr	r5, [pc, #316]	; (1aa38 <hif_send+0x1ac>)
   1a8fc:	47a8      	blx	r5
   1a8fe:	1e04      	subs	r4, r0, #0
		if(M2M_SUCCESS != ret) goto ERR1;
   1a900:	d144      	bne.n	1a98c <hif_send+0x100>

		reg = 0UL;
		reg |= NBIT1;
   1a902:	2302      	movs	r3, #2
		reg = 0UL;
   1a904:	9007      	str	r0, [sp, #28]
		reg |= NBIT1;
   1a906:	9a07      	ldr	r2, [sp, #28]
		ret = nm_write_reg(WIFI_HOST_RCV_CTRL_2, reg);
   1a908:	484c      	ldr	r0, [pc, #304]	; (1aa3c <hif_send+0x1b0>)
		reg |= NBIT1;
   1a90a:	4313      	orrs	r3, r2
   1a90c:	9307      	str	r3, [sp, #28]
		ret = nm_write_reg(WIFI_HOST_RCV_CTRL_2, reg);
   1a90e:	9907      	ldr	r1, [sp, #28]
   1a910:	47a8      	blx	r5
   1a912:	1e04      	subs	r4, r0, #0
		if(M2M_SUCCESS != ret) goto ERR1;
   1a914:	d13a      	bne.n	1a98c <hif_send+0x100>
			/*
			 * If it takes too long to get a response, the slow down to 
			 * avoid back-to-back register read operations.
			 */
			if(cnt >= 500) {
				if(cnt < 501) {
   1a916:	26fa      	movs	r6, #250	; 0xfa
		for(cnt = 0; cnt < 1000; cnt ++)
   1a918:	ab04      	add	r3, sp, #16
		dma_addr = 0;
   1a91a:	9008      	str	r0, [sp, #32]
				if(cnt < 501) {
   1a91c:	0076      	lsls	r6, r6, #1
		for(cnt = 0; cnt < 1000; cnt ++)
   1a91e:	80d8      	strh	r0, [r3, #6]
   1a920:	ab04      	add	r3, sp, #16
   1a922:	1d9c      	adds	r4, r3, #6
   1a924:	8822      	ldrh	r2, [r4, #0]
   1a926:	4b46      	ldr	r3, [pc, #280]	; (1aa40 <hif_send+0x1b4>)
   1a928:	429a      	cmp	r2, r3
   1a92a:	d805      	bhi.n	1a938 <hif_send+0xac>
			ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_2,(uint32 *)&reg);
   1a92c:	a907      	add	r1, sp, #28
   1a92e:	4843      	ldr	r0, [pc, #268]	; (1aa3c <hif_send+0x1b0>)
   1a930:	4b44      	ldr	r3, [pc, #272]	; (1aa44 <hif_send+0x1b8>)
   1a932:	4798      	blx	r3
			if(ret != M2M_SUCCESS) break;
   1a934:	2800      	cmp	r0, #0
   1a936:	d00c      	beq.n	1a952 <hif_send+0xc6>
				/*in case of success break */
				break;
			}
		}

		if (dma_addr != 0)
   1a938:	9b08      	ldr	r3, [sp, #32]
   1a93a:	2b00      	cmp	r3, #0
   1a93c:	d12e      	bne.n	1a99c <hif_send+0x110>
			ret = nm_write_reg(WIFI_HOST_RCV_CTRL_3, reg);
			if(M2M_SUCCESS != ret) goto ERR1;
		}
		else
		{
			ret = hif_chip_sleep();
   1a93e:	4b42      	ldr	r3, [pc, #264]	; (1aa48 <hif_send+0x1bc>)
			M2M_DBG("Failed to alloc rx size %d\r",ret);
			ret = M2M_ERR_MEM_ALLOC;
   1a940:	2403      	movs	r4, #3
			ret = hif_chip_sleep();
   1a942:	4798      	blx	r3
			ret = M2M_ERR_MEM_ALLOC;
   1a944:	4264      	negs	r4, r4
	/*reset the count but no actual sleep as it already bus error*/
	hif_chip_sleep_sc();
ERR2:
	/*logical error*/
	return ret;
}
   1a946:	0020      	movs	r0, r4
   1a948:	b00b      	add	sp, #44	; 0x2c
   1a94a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		strHif.u16Length += u16CtrlBufSize;
   1a94c:	885a      	ldrh	r2, [r3, #2]
   1a94e:	19d2      	adds	r2, r2, r7
   1a950:	e7b9      	b.n	1a8c6 <hif_send+0x3a>
			if(cnt >= 500) {
   1a952:	23f4      	movs	r3, #244	; 0xf4
   1a954:	8822      	ldrh	r2, [r4, #0]
   1a956:	33ff      	adds	r3, #255	; 0xff
   1a958:	429a      	cmp	r2, r3
   1a95a:	d90c      	bls.n	1a976 <hif_send+0xea>
				if(cnt < 501) {
   1a95c:	8823      	ldrh	r3, [r4, #0]
   1a95e:	42b3      	cmp	r3, r6
   1a960:	d806      	bhi.n	1a970 <hif_send+0xe4>
					M2M_INFO("Slowing down...\n");
   1a962:	483a      	ldr	r0, [pc, #232]	; (1aa4c <hif_send+0x1c0>)
   1a964:	4d3a      	ldr	r5, [pc, #232]	; (1aa50 <hif_send+0x1c4>)
   1a966:	47a8      	blx	r5
   1a968:	483a      	ldr	r0, [pc, #232]	; (1aa54 <hif_send+0x1c8>)
   1a96a:	47a8      	blx	r5
   1a96c:	483a      	ldr	r0, [pc, #232]	; (1aa58 <hif_send+0x1cc>)
   1a96e:	47a8      	blx	r5
				nm_bsp_sleep(1);
   1a970:	2001      	movs	r0, #1
   1a972:	4b3a      	ldr	r3, [pc, #232]	; (1aa5c <hif_send+0x1d0>)
   1a974:	4798      	blx	r3
			if (!(reg & NBIT1))
   1a976:	2302      	movs	r3, #2
   1a978:	9d07      	ldr	r5, [sp, #28]
   1a97a:	401d      	ands	r5, r3
   1a97c:	d109      	bne.n	1a992 <hif_send+0x106>
				ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_4,(uint32 *)&dma_addr);
   1a97e:	a908      	add	r1, sp, #32
   1a980:	4837      	ldr	r0, [pc, #220]	; (1aa60 <hif_send+0x1d4>)
   1a982:	4b30      	ldr	r3, [pc, #192]	; (1aa44 <hif_send+0x1b8>)
   1a984:	4798      	blx	r3
   1a986:	1e04      	subs	r4, r0, #0
				if(ret != M2M_SUCCESS) {
   1a988:	d0d6      	beq.n	1a938 <hif_send+0xac>
					dma_addr = 0;
   1a98a:	9508      	str	r5, [sp, #32]
	hif_chip_sleep_sc();
   1a98c:	4b35      	ldr	r3, [pc, #212]	; (1aa64 <hif_send+0x1d8>)
   1a98e:	4798      	blx	r3
   1a990:	e7d9      	b.n	1a946 <hif_send+0xba>
		for(cnt = 0; cnt < 1000; cnt ++)
   1a992:	8823      	ldrh	r3, [r4, #0]
   1a994:	3301      	adds	r3, #1
   1a996:	b29b      	uxth	r3, r3
   1a998:	8023      	strh	r3, [r4, #0]
   1a99a:	e7c1      	b.n	1a920 <hif_send+0x94>
			u32CurrAddr = dma_addr;
   1a99c:	9b08      	ldr	r3, [sp, #32]
			strHif.u16Length=NM_BSP_B_L_16(strHif.u16Length);
   1a99e:	a906      	add	r1, sp, #24
			u32CurrAddr = dma_addr;
   1a9a0:	9309      	str	r3, [sp, #36]	; 0x24
			strHif.u16Length=NM_BSP_B_L_16(strHif.u16Length);
   1a9a2:	884b      	ldrh	r3, [r1, #2]
			ret = nm_write_block(u32CurrAddr, (uint8*)&strHif, M2M_HIF_HDR_OFFSET);
   1a9a4:	2208      	movs	r2, #8
			strHif.u16Length=NM_BSP_B_L_16(strHif.u16Length);
   1a9a6:	b29b      	uxth	r3, r3
   1a9a8:	804b      	strh	r3, [r1, #2]
			ret = nm_write_block(u32CurrAddr, (uint8*)&strHif, M2M_HIF_HDR_OFFSET);
   1a9aa:	9809      	ldr	r0, [sp, #36]	; 0x24
   1a9ac:	4d2e      	ldr	r5, [pc, #184]	; (1aa68 <hif_send+0x1dc>)
   1a9ae:	47a8      	blx	r5
   1a9b0:	1e04      	subs	r4, r0, #0
			if(M2M_SUCCESS != ret) goto ERR1;
   1a9b2:	d1eb      	bne.n	1a98c <hif_send+0x100>
			u32CurrAddr += M2M_HIF_HDR_OFFSET;
   1a9b4:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1a9b6:	3308      	adds	r3, #8
   1a9b8:	9309      	str	r3, [sp, #36]	; 0x24
			if(pu8CtrlBuf != NULL)
   1a9ba:	9b02      	ldr	r3, [sp, #8]
   1a9bc:	2b00      	cmp	r3, #0
   1a9be:	d008      	beq.n	1a9d2 <hif_send+0x146>
				ret = nm_write_block(u32CurrAddr, pu8CtrlBuf, u16CtrlBufSize);
   1a9c0:	9809      	ldr	r0, [sp, #36]	; 0x24
   1a9c2:	003a      	movs	r2, r7
   1a9c4:	0019      	movs	r1, r3
   1a9c6:	47a8      	blx	r5
   1a9c8:	1e04      	subs	r4, r0, #0
				if(M2M_SUCCESS != ret) goto ERR1;
   1a9ca:	d1df      	bne.n	1a98c <hif_send+0x100>
				u32CurrAddr += u16CtrlBufSize;
   1a9cc:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1a9ce:	18fb      	adds	r3, r7, r3
   1a9d0:	9309      	str	r3, [sp, #36]	; 0x24
			if(pu8DataBuf != NULL)
   1a9d2:	9b00      	ldr	r3, [sp, #0]
   1a9d4:	2b00      	cmp	r3, #0
   1a9d6:	d00e      	beq.n	1a9f6 <hif_send+0x16a>
				u32CurrAddr += (u16DataOffset - u16CtrlBufSize);
   1a9d8:	9b03      	ldr	r3, [sp, #12]
   1a9da:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1a9dc:	1bdb      	subs	r3, r3, r7
   1a9de:	189b      	adds	r3, r3, r2
   1a9e0:	9309      	str	r3, [sp, #36]	; 0x24
				ret = nm_write_block(u32CurrAddr, pu8DataBuf, u16DataSize);
   1a9e2:	9809      	ldr	r0, [sp, #36]	; 0x24
   1a9e4:	9a01      	ldr	r2, [sp, #4]
   1a9e6:	9900      	ldr	r1, [sp, #0]
   1a9e8:	47a8      	blx	r5
   1a9ea:	1e04      	subs	r4, r0, #0
				if(M2M_SUCCESS != ret) goto ERR1;
   1a9ec:	d1ce      	bne.n	1a98c <hif_send+0x100>
				u32CurrAddr += u16DataSize;
   1a9ee:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1a9f0:	9a01      	ldr	r2, [sp, #4]
   1a9f2:	18d3      	adds	r3, r2, r3
   1a9f4:	9309      	str	r3, [sp, #36]	; 0x24
			reg = dma_addr << 2;
   1a9f6:	9b08      	ldr	r3, [sp, #32]
			ret = nm_write_reg(WIFI_HOST_RCV_CTRL_3, reg);
   1a9f8:	481c      	ldr	r0, [pc, #112]	; (1aa6c <hif_send+0x1e0>)
			reg = dma_addr << 2;
   1a9fa:	009b      	lsls	r3, r3, #2
   1a9fc:	9307      	str	r3, [sp, #28]
			reg |= NBIT1;
   1a9fe:	2302      	movs	r3, #2
   1aa00:	9a07      	ldr	r2, [sp, #28]
   1aa02:	4313      	orrs	r3, r2
   1aa04:	9307      	str	r3, [sp, #28]
			ret = nm_write_reg(WIFI_HOST_RCV_CTRL_3, reg);
   1aa06:	9907      	ldr	r1, [sp, #28]
   1aa08:	4b0b      	ldr	r3, [pc, #44]	; (1aa38 <hif_send+0x1ac>)
   1aa0a:	4798      	blx	r3
   1aa0c:	1e04      	subs	r4, r0, #0
			if(M2M_SUCCESS != ret) goto ERR1;
   1aa0e:	d1bd      	bne.n	1a98c <hif_send+0x100>
 	ret = hif_chip_sleep();
   1aa10:	4b0d      	ldr	r3, [pc, #52]	; (1aa48 <hif_send+0x1bc>)
   1aa12:	4798      	blx	r3
   1aa14:	0004      	movs	r4, r0
	return ret;
   1aa16:	e796      	b.n	1a946 <hif_send+0xba>
		M2M_ERR("(HIF)Fail to wakup the chip\n");
   1aa18:	2298      	movs	r2, #152	; 0x98
   1aa1a:	4915      	ldr	r1, [pc, #84]	; (1aa70 <hif_send+0x1e4>)
   1aa1c:	32ff      	adds	r2, #255	; 0xff
   1aa1e:	4d0c      	ldr	r5, [pc, #48]	; (1aa50 <hif_send+0x1c4>)
   1aa20:	4814      	ldr	r0, [pc, #80]	; (1aa74 <hif_send+0x1e8>)
   1aa22:	47a8      	blx	r5
   1aa24:	4814      	ldr	r0, [pc, #80]	; (1aa78 <hif_send+0x1ec>)
   1aa26:	47a8      	blx	r5
   1aa28:	480b      	ldr	r0, [pc, #44]	; (1aa58 <hif_send+0x1cc>)
   1aa2a:	47a8      	blx	r5
		goto ERR2;
   1aa2c:	e78b      	b.n	1a946 <hif_send+0xba>
   1aa2e:	46c0      	nop			; (mov r8, r8)
   1aa30:	0001a80d 	.word	0x0001a80d
   1aa34:	0000108c 	.word	0x0000108c
   1aa38:	0001b7e5 	.word	0x0001b7e5
   1aa3c:	00001078 	.word	0x00001078
   1aa40:	000003e7 	.word	0x000003e7
   1aa44:	0001b7d9 	.word	0x0001b7d9
   1aa48:	0001a85d 	.word	0x0001a85d
   1aa4c:	0002a2b4 	.word	0x0002a2b4
   1aa50:	00019415 	.word	0x00019415
   1aa54:	0002a2c0 	.word	0x0002a2c0
   1aa58:	0002b325 	.word	0x0002b325
   1aa5c:	0001a489 	.word	0x0001a489
   1aa60:	00150400 	.word	0x00150400
   1aa64:	0001a845 	.word	0x0001a845
   1aa68:	0001b831 	.word	0x0001b831
   1aa6c:	0000106c 	.word	0x0000106c
   1aa70:	00029fe0 	.word	0x00029fe0
   1aa74:	00029fb9 	.word	0x00029fb9
   1aa78:	0002a2d1 	.word	0x0002a2d1

0001aa7c <hif_handle_isr>:

sint8 hif_handle_isr(void)
{
	sint8 ret = M2M_SUCCESS;	
	
	gstrHifCxt.u8Yield = 0;
   1aa7c:	2300      	movs	r3, #0
{
   1aa7e:	b5f0      	push	{r4, r5, r6, r7, lr}
	gstrHifCxt.u8Yield = 0;
   1aa80:	4d92      	ldr	r5, [pc, #584]	; (1accc <hif_handle_isr+0x250>)
{
   1aa82:	b089      	sub	sp, #36	; 0x24
	gstrHifCxt.u8Yield = 0;
   1aa84:	712b      	strb	r3, [r5, #4]
	while (gstrHifCxt.u8Interrupt && !gstrHifCxt.u8Yield) {
   1aa86:	78eb      	ldrb	r3, [r5, #3]
   1aa88:	2b00      	cmp	r3, #0
   1aa8a:	d002      	beq.n	1aa92 <hif_handle_isr+0x16>
   1aa8c:	792b      	ldrb	r3, [r5, #4]
   1aa8e:	2b00      	cmp	r3, #0
   1aa90:	d002      	beq.n	1aa98 <hif_handle_isr+0x1c>
			}
		}
	}

	return ret;
}
   1aa92:	2000      	movs	r0, #0
   1aa94:	b009      	add	sp, #36	; 0x24
   1aa96:	bdf0      	pop	{r4, r5, r6, r7, pc}
		gstrHifCxt.u8Interrupt--;
   1aa98:	78eb      	ldrb	r3, [r5, #3]
   1aa9a:	3b01      	subs	r3, #1
   1aa9c:	b2db      	uxtb	r3, r3
   1aa9e:	70eb      	strb	r3, [r5, #3]
	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0, &reg);
   1aaa0:	a905      	add	r1, sp, #20
   1aaa2:	488b      	ldr	r0, [pc, #556]	; (1acd0 <hif_handle_isr+0x254>)
   1aaa4:	4c8b      	ldr	r4, [pc, #556]	; (1acd4 <hif_handle_isr+0x258>)
   1aaa6:	47a0      	blx	r4
   1aaa8:	1e06      	subs	r6, r0, #0
	if(M2M_SUCCESS == ret)
   1aaaa:	d000      	beq.n	1aaae <hif_handle_isr+0x32>
   1aaac:	e104      	b.n	1acb8 <hif_handle_isr+0x23c>
		if(reg & 0x1)	/* New interrupt has been received */
   1aaae:	2701      	movs	r7, #1
   1aab0:	9b05      	ldr	r3, [sp, #20]
   1aab2:	423b      	tst	r3, r7
   1aab4:	d100      	bne.n	1aab8 <hif_handle_isr+0x3c>
   1aab6:	e0f3      	b.n	1aca0 <hif_handle_isr+0x224>
			nm_bsp_interrupt_ctrl(0);
   1aab8:	4b87      	ldr	r3, [pc, #540]	; (1acd8 <hif_handle_isr+0x25c>)
   1aaba:	4798      	blx	r3
			reg &= ~NBIT0;
   1aabc:	9905      	ldr	r1, [sp, #20]
			ret = nm_write_reg(WIFI_HOST_RCV_CTRL_0,reg);
   1aabe:	4884      	ldr	r0, [pc, #528]	; (1acd0 <hif_handle_isr+0x254>)
			reg &= ~NBIT0;
   1aac0:	43b9      	bics	r1, r7
			ret = nm_write_reg(WIFI_HOST_RCV_CTRL_0,reg);
   1aac2:	4b86      	ldr	r3, [pc, #536]	; (1acdc <hif_handle_isr+0x260>)
			reg &= ~NBIT0;
   1aac4:	9105      	str	r1, [sp, #20]
			ret = nm_write_reg(WIFI_HOST_RCV_CTRL_0,reg);
   1aac6:	4798      	blx	r3
   1aac8:	1e06      	subs	r6, r0, #0
			if(ret != M2M_SUCCESS)goto ERR1;
   1aaca:	d119      	bne.n	1ab00 <hif_handle_isr+0x84>
			size = (uint16)((reg >> 2) & 0xfff);
   1aacc:	9b05      	ldr	r3, [sp, #20]
			gstrHifCxt.u8HifRXDone = 1;
   1aace:	70af      	strb	r7, [r5, #2]
			size = (uint16)((reg >> 2) & 0xfff);
   1aad0:	049b      	lsls	r3, r3, #18
   1aad2:	0d1b      	lsrs	r3, r3, #20
   1aad4:	9303      	str	r3, [sp, #12]
			if (size > 0) {
   1aad6:	d100      	bne.n	1aada <hif_handle_isr+0x5e>
   1aad8:	e0d7      	b.n	1ac8a <hif_handle_isr+0x20e>
				uint32 address = 0;
   1aada:	9007      	str	r0, [sp, #28]
				ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_1, &address);
   1aadc:	a907      	add	r1, sp, #28
   1aade:	4880      	ldr	r0, [pc, #512]	; (1ace0 <hif_handle_isr+0x264>)
   1aae0:	47a0      	blx	r4
   1aae2:	1e06      	subs	r6, r0, #0
				if(M2M_SUCCESS != ret)
   1aae4:	d017      	beq.n	1ab16 <hif_handle_isr+0x9a>
					M2M_ERR("(hif) WIFI_HOST_RCV_CTRL_1 bus fail\n");
   1aae6:	22e4      	movs	r2, #228	; 0xe4
   1aae8:	487e      	ldr	r0, [pc, #504]	; (1ace4 <hif_handle_isr+0x268>)
   1aaea:	0052      	lsls	r2, r2, #1
   1aaec:	497e      	ldr	r1, [pc, #504]	; (1ace8 <hif_handle_isr+0x26c>)
   1aaee:	4c7f      	ldr	r4, [pc, #508]	; (1acec <hif_handle_isr+0x270>)
   1aaf0:	47a0      	blx	r4
   1aaf2:	487f      	ldr	r0, [pc, #508]	; (1acf0 <hif_handle_isr+0x274>)
					M2M_ERR("(hif) address bus fail\n");
   1aaf4:	47a0      	blx	r4
   1aaf6:	487f      	ldr	r0, [pc, #508]	; (1acf4 <hif_handle_isr+0x278>)
   1aaf8:	47a0      	blx	r4
					nm_bsp_interrupt_ctrl(1);
   1aafa:	0038      	movs	r0, r7
   1aafc:	4b76      	ldr	r3, [pc, #472]	; (1acd8 <hif_handle_isr+0x25c>)
   1aafe:	4798      	blx	r3
				M2M_ERR("(HIF) Fail to handle interrupt %d try Again..\n",ret);
   1ab00:	4a7d      	ldr	r2, [pc, #500]	; (1acf8 <hif_handle_isr+0x27c>)
   1ab02:	4c7a      	ldr	r4, [pc, #488]	; (1acec <hif_handle_isr+0x270>)
   1ab04:	497d      	ldr	r1, [pc, #500]	; (1acfc <hif_handle_isr+0x280>)
   1ab06:	4877      	ldr	r0, [pc, #476]	; (1ace4 <hif_handle_isr+0x268>)
   1ab08:	47a0      	blx	r4
   1ab0a:	0031      	movs	r1, r6
   1ab0c:	487c      	ldr	r0, [pc, #496]	; (1ad00 <hif_handle_isr+0x284>)
   1ab0e:	47a0      	blx	r4
   1ab10:	4878      	ldr	r0, [pc, #480]	; (1acf4 <hif_handle_isr+0x278>)
   1ab12:	47a0      	blx	r4
			ret = hif_isr();
   1ab14:	e7c4      	b.n	1aaa0 <hif_handle_isr+0x24>
				gstrHifCxt.u32RxAddr = address;
   1ab16:	9b07      	ldr	r3, [sp, #28]
				ret = nm_read_block(address, (uint8*)&strHif, sizeof(tstrHifHdr));
   1ab18:	ac06      	add	r4, sp, #24
				gstrHifCxt.u32RxAddr = address;
   1ab1a:	60ab      	str	r3, [r5, #8]
				gstrHifCxt.u32RxSize = size;
   1ab1c:	9b03      	ldr	r3, [sp, #12]
				ret = nm_read_block(address, (uint8*)&strHif, sizeof(tstrHifHdr));
   1ab1e:	2204      	movs	r2, #4
				gstrHifCxt.u32RxSize = size;
   1ab20:	60eb      	str	r3, [r5, #12]
				ret = nm_read_block(address, (uint8*)&strHif, sizeof(tstrHifHdr));
   1ab22:	0021      	movs	r1, r4
   1ab24:	4b77      	ldr	r3, [pc, #476]	; (1ad04 <hif_handle_isr+0x288>)
   1ab26:	9807      	ldr	r0, [sp, #28]
   1ab28:	4798      	blx	r3
				strHif.u16Length = NM_BSP_B_L_16(strHif.u16Length);
   1ab2a:	8863      	ldrh	r3, [r4, #2]
				ret = nm_read_block(address, (uint8*)&strHif, sizeof(tstrHifHdr));
   1ab2c:	0006      	movs	r6, r0
				strHif.u16Length = NM_BSP_B_L_16(strHif.u16Length);
   1ab2e:	b29b      	uxth	r3, r3
   1ab30:	8063      	strh	r3, [r4, #2]
				if(M2M_SUCCESS != ret)
   1ab32:	2800      	cmp	r0, #0
   1ab34:	d007      	beq.n	1ab46 <hif_handle_isr+0xca>
					M2M_ERR("(hif) address bus fail\n");
   1ab36:	22e9      	movs	r2, #233	; 0xe9
   1ab38:	486a      	ldr	r0, [pc, #424]	; (1ace4 <hif_handle_isr+0x268>)
   1ab3a:	0052      	lsls	r2, r2, #1
   1ab3c:	496a      	ldr	r1, [pc, #424]	; (1ace8 <hif_handle_isr+0x26c>)
   1ab3e:	4c6b      	ldr	r4, [pc, #428]	; (1acec <hif_handle_isr+0x270>)
   1ab40:	47a0      	blx	r4
   1ab42:	4871      	ldr	r0, [pc, #452]	; (1ad08 <hif_handle_isr+0x28c>)
   1ab44:	e7d6      	b.n	1aaf4 <hif_handle_isr+0x78>
				if(strHif.u16Length != size)
   1ab46:	8863      	ldrh	r3, [r4, #2]
   1ab48:	9a03      	ldr	r2, [sp, #12]
   1ab4a:	429a      	cmp	r2, r3
   1ab4c:	d01a      	beq.n	1ab84 <hif_handle_isr+0x108>
					if((size - strHif.u16Length) > 4)
   1ab4e:	8863      	ldrh	r3, [r4, #2]
   1ab50:	1ad3      	subs	r3, r2, r3
   1ab52:	2b04      	cmp	r3, #4
   1ab54:	dd16      	ble.n	1ab84 <hif_handle_isr+0x108>
						M2M_ERR("(hif) Corrupted packet Size = %u <L = %u, G = %u, OP = %02X>\n",
   1ab56:	22dc      	movs	r2, #220	; 0xdc
   1ab58:	4e64      	ldr	r6, [pc, #400]	; (1acec <hif_handle_isr+0x270>)
   1ab5a:	32ff      	adds	r2, #255	; 0xff
   1ab5c:	4962      	ldr	r1, [pc, #392]	; (1ace8 <hif_handle_isr+0x26c>)
   1ab5e:	4861      	ldr	r0, [pc, #388]	; (1ace4 <hif_handle_isr+0x268>)
   1ab60:	47b0      	blx	r6
   1ab62:	8862      	ldrh	r2, [r4, #2]
   1ab64:	7823      	ldrb	r3, [r4, #0]
   1ab66:	7861      	ldrb	r1, [r4, #1]
   1ab68:	b2db      	uxtb	r3, r3
   1ab6a:	b292      	uxth	r2, r2
   1ab6c:	9100      	str	r1, [sp, #0]
   1ab6e:	4867      	ldr	r0, [pc, #412]	; (1ad0c <hif_handle_isr+0x290>)
   1ab70:	9903      	ldr	r1, [sp, #12]
   1ab72:	47b0      	blx	r6
   1ab74:	485f      	ldr	r0, [pc, #380]	; (1acf4 <hif_handle_isr+0x278>)
   1ab76:	47b0      	blx	r6
						nm_bsp_interrupt_ctrl(1);
   1ab78:	0038      	movs	r0, r7
   1ab7a:	4b57      	ldr	r3, [pc, #348]	; (1acd8 <hif_handle_isr+0x25c>)
   1ab7c:	4798      	blx	r3
					ret = M2M_ERR_BUS_FAIL;
   1ab7e:	2606      	movs	r6, #6
			ret = M2M_ERR_FAIL;
   1ab80:	4276      	negs	r6, r6
   1ab82:	e7bd      	b.n	1ab00 <hif_handle_isr+0x84>
				if(M2M_REQ_GROUP_WIFI == strHif.u8Gid)
   1ab84:	7823      	ldrb	r3, [r4, #0]
   1ab86:	2b01      	cmp	r3, #1
   1ab88:	d12d      	bne.n	1abe6 <hif_handle_isr+0x16a>
					if(gstrHifCxt.pfWifiCb)
   1ab8a:	692b      	ldr	r3, [r5, #16]
   1ab8c:	2b00      	cmp	r3, #0
   1ab8e:	d01f      	beq.n	1abd0 <hif_handle_isr+0x154>
						gstrHifCxt.pfWifiCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
   1ab90:	692b      	ldr	r3, [r5, #16]
						gstrHifCxt.pfIpCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
   1ab92:	7860      	ldrb	r0, [r4, #1]
   1ab94:	8861      	ldrh	r1, [r4, #2]
   1ab96:	9a07      	ldr	r2, [sp, #28]
   1ab98:	3908      	subs	r1, #8
   1ab9a:	b2c0      	uxtb	r0, r0
   1ab9c:	3208      	adds	r2, #8
   1ab9e:	b289      	uxth	r1, r1
   1aba0:	4798      	blx	r3
				if(gstrHifCxt.u8HifRXDone)
   1aba2:	78ab      	ldrb	r3, [r5, #2]
   1aba4:	2b00      	cmp	r3, #0
   1aba6:	d100      	bne.n	1abaa <hif_handle_isr+0x12e>
   1aba8:	e76d      	b.n	1aa86 <hif_handle_isr+0xa>
					M2M_ERR("(hif) host app didn't set RX Done <%u><%X>\n", strHif.u8Gid, strHif.u8Opcode);
   1abaa:	4e50      	ldr	r6, [pc, #320]	; (1acec <hif_handle_isr+0x270>)
   1abac:	4a58      	ldr	r2, [pc, #352]	; (1ad10 <hif_handle_isr+0x294>)
   1abae:	494e      	ldr	r1, [pc, #312]	; (1ace8 <hif_handle_isr+0x26c>)
   1abb0:	484c      	ldr	r0, [pc, #304]	; (1ace4 <hif_handle_isr+0x268>)
   1abb2:	47b0      	blx	r6
   1abb4:	7821      	ldrb	r1, [r4, #0]
   1abb6:	7862      	ldrb	r2, [r4, #1]
   1abb8:	b2c9      	uxtb	r1, r1
   1abba:	b2d2      	uxtb	r2, r2
   1abbc:	4855      	ldr	r0, [pc, #340]	; (1ad14 <hif_handle_isr+0x298>)
   1abbe:	47b0      	blx	r6
   1abc0:	484c      	ldr	r0, [pc, #304]	; (1acf4 <hif_handle_isr+0x278>)
   1abc2:	47b0      	blx	r6
					ret = hif_set_rx_done();
   1abc4:	4b54      	ldr	r3, [pc, #336]	; (1ad18 <hif_handle_isr+0x29c>)
   1abc6:	4798      	blx	r3
   1abc8:	1e06      	subs	r6, r0, #0
					if(ret != M2M_SUCCESS) goto ERR1;
   1abca:	d100      	bne.n	1abce <hif_handle_isr+0x152>
   1abcc:	e75b      	b.n	1aa86 <hif_handle_isr+0xa>
   1abce:	e797      	b.n	1ab00 <hif_handle_isr+0x84>
						M2M_ERR("WIFI callback is not registered\n");
   1abd0:	22e8      	movs	r2, #232	; 0xe8
   1abd2:	4844      	ldr	r0, [pc, #272]	; (1ace4 <hif_handle_isr+0x268>)
   1abd4:	32ff      	adds	r2, #255	; 0xff
   1abd6:	4944      	ldr	r1, [pc, #272]	; (1ace8 <hif_handle_isr+0x26c>)
   1abd8:	4e44      	ldr	r6, [pc, #272]	; (1acec <hif_handle_isr+0x270>)
   1abda:	47b0      	blx	r6
   1abdc:	484f      	ldr	r0, [pc, #316]	; (1ad1c <hif_handle_isr+0x2a0>)
						M2M_ERR("Sigma callback is not registered\n");
   1abde:	47b0      	blx	r6
   1abe0:	4844      	ldr	r0, [pc, #272]	; (1acf4 <hif_handle_isr+0x278>)
   1abe2:	47b0      	blx	r6
   1abe4:	e7dd      	b.n	1aba2 <hif_handle_isr+0x126>
				else if(M2M_REQ_GROUP_IP == strHif.u8Gid)
   1abe6:	7823      	ldrb	r3, [r4, #0]
   1abe8:	2b02      	cmp	r3, #2
   1abea:	d10c      	bne.n	1ac06 <hif_handle_isr+0x18a>
					if(gstrHifCxt.pfIpCb)
   1abec:	696b      	ldr	r3, [r5, #20]
   1abee:	2b00      	cmp	r3, #0
   1abf0:	d001      	beq.n	1abf6 <hif_handle_isr+0x17a>
						gstrHifCxt.pfIpCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
   1abf2:	696b      	ldr	r3, [r5, #20]
   1abf4:	e7cd      	b.n	1ab92 <hif_handle_isr+0x116>
						M2M_ERR("Scoket callback is not registered\n");
   1abf6:	22f0      	movs	r2, #240	; 0xf0
   1abf8:	483a      	ldr	r0, [pc, #232]	; (1ace4 <hif_handle_isr+0x268>)
   1abfa:	32ff      	adds	r2, #255	; 0xff
   1abfc:	493a      	ldr	r1, [pc, #232]	; (1ace8 <hif_handle_isr+0x26c>)
   1abfe:	4e3b      	ldr	r6, [pc, #236]	; (1acec <hif_handle_isr+0x270>)
   1ac00:	47b0      	blx	r6
   1ac02:	4847      	ldr	r0, [pc, #284]	; (1ad20 <hif_handle_isr+0x2a4>)
   1ac04:	e7eb      	b.n	1abde <hif_handle_isr+0x162>
				else if(M2M_REQ_GROUP_OTA == strHif.u8Gid)
   1ac06:	7823      	ldrb	r3, [r4, #0]
   1ac08:	2b04      	cmp	r3, #4
   1ac0a:	d10c      	bne.n	1ac26 <hif_handle_isr+0x1aa>
					if(gstrHifCxt.pfOtaCb)
   1ac0c:	69ab      	ldr	r3, [r5, #24]
   1ac0e:	2b00      	cmp	r3, #0
   1ac10:	d001      	beq.n	1ac16 <hif_handle_isr+0x19a>
						gstrHifCxt.pfOtaCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
   1ac12:	69ab      	ldr	r3, [r5, #24]
   1ac14:	e7bd      	b.n	1ab92 <hif_handle_isr+0x116>
						M2M_ERR("Ota callback is not registered\n");
   1ac16:	22f8      	movs	r2, #248	; 0xf8
   1ac18:	4832      	ldr	r0, [pc, #200]	; (1ace4 <hif_handle_isr+0x268>)
   1ac1a:	32ff      	adds	r2, #255	; 0xff
   1ac1c:	4932      	ldr	r1, [pc, #200]	; (1ace8 <hif_handle_isr+0x26c>)
   1ac1e:	4e33      	ldr	r6, [pc, #204]	; (1acec <hif_handle_isr+0x270>)
   1ac20:	47b0      	blx	r6
   1ac22:	4840      	ldr	r0, [pc, #256]	; (1ad24 <hif_handle_isr+0x2a8>)
   1ac24:	e7db      	b.n	1abde <hif_handle_isr+0x162>
				else if(M2M_REQ_GROUP_CRYPTO == strHif.u8Gid)
   1ac26:	7823      	ldrb	r3, [r4, #0]
   1ac28:	2b06      	cmp	r3, #6
   1ac2a:	d10c      	bne.n	1ac46 <hif_handle_isr+0x1ca>
					if(gstrHifCxt.pfCryptoCb)
   1ac2c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   1ac2e:	2b00      	cmp	r3, #0
   1ac30:	d001      	beq.n	1ac36 <hif_handle_isr+0x1ba>
						gstrHifCxt.pfCryptoCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
   1ac32:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   1ac34:	e7ad      	b.n	1ab92 <hif_handle_isr+0x116>
						M2M_ERR("Crypto callback is not registered\n");
   1ac36:	2280      	movs	r2, #128	; 0x80
   1ac38:	482a      	ldr	r0, [pc, #168]	; (1ace4 <hif_handle_isr+0x268>)
   1ac3a:	0092      	lsls	r2, r2, #2
   1ac3c:	492a      	ldr	r1, [pc, #168]	; (1ace8 <hif_handle_isr+0x26c>)
   1ac3e:	4e2b      	ldr	r6, [pc, #172]	; (1acec <hif_handle_isr+0x270>)
   1ac40:	47b0      	blx	r6
   1ac42:	4839      	ldr	r0, [pc, #228]	; (1ad28 <hif_handle_isr+0x2ac>)
   1ac44:	e7cb      	b.n	1abde <hif_handle_isr+0x162>
				else if(M2M_REQ_GROUP_SIGMA == strHif.u8Gid)
   1ac46:	7823      	ldrb	r3, [r4, #0]
   1ac48:	2b07      	cmp	r3, #7
   1ac4a:	d10b      	bne.n	1ac64 <hif_handle_isr+0x1e8>
					if(gstrHifCxt.pfSigmaCb)
   1ac4c:	69eb      	ldr	r3, [r5, #28]
   1ac4e:	2b00      	cmp	r3, #0
   1ac50:	d001      	beq.n	1ac56 <hif_handle_isr+0x1da>
						gstrHifCxt.pfSigmaCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
   1ac52:	69eb      	ldr	r3, [r5, #28]
   1ac54:	e79d      	b.n	1ab92 <hif_handle_isr+0x116>
						M2M_ERR("Sigma callback is not registered\n");
   1ac56:	4823      	ldr	r0, [pc, #140]	; (1ace4 <hif_handle_isr+0x268>)
   1ac58:	4a34      	ldr	r2, [pc, #208]	; (1ad2c <hif_handle_isr+0x2b0>)
   1ac5a:	4923      	ldr	r1, [pc, #140]	; (1ace8 <hif_handle_isr+0x26c>)
   1ac5c:	4e23      	ldr	r6, [pc, #140]	; (1acec <hif_handle_isr+0x270>)
   1ac5e:	47b0      	blx	r6
   1ac60:	4833      	ldr	r0, [pc, #204]	; (1ad30 <hif_handle_isr+0x2b4>)
   1ac62:	e7bc      	b.n	1abde <hif_handle_isr+0x162>
				else if(M2M_REQ_GROUP_SSL == strHif.u8Gid)
   1ac64:	7823      	ldrb	r3, [r4, #0]
   1ac66:	2b05      	cmp	r3, #5
   1ac68:	d104      	bne.n	1ac74 <hif_handle_isr+0x1f8>
				    if(gstrHifCxt.pfSslCb)
   1ac6a:	6aab      	ldr	r3, [r5, #40]	; 0x28
   1ac6c:	2b00      	cmp	r3, #0
   1ac6e:	d098      	beq.n	1aba2 <hif_handle_isr+0x126>
						gstrHifCxt.pfSslCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
   1ac70:	6aab      	ldr	r3, [r5, #40]	; 0x28
   1ac72:	e78e      	b.n	1ab92 <hif_handle_isr+0x116>
					M2M_ERR("(hif) invalid group ID\n");
   1ac74:	2284      	movs	r2, #132	; 0x84
   1ac76:	491c      	ldr	r1, [pc, #112]	; (1ace8 <hif_handle_isr+0x26c>)
   1ac78:	0092      	lsls	r2, r2, #2
   1ac7a:	4c1c      	ldr	r4, [pc, #112]	; (1acec <hif_handle_isr+0x270>)
   1ac7c:	4819      	ldr	r0, [pc, #100]	; (1ace4 <hif_handle_isr+0x268>)
   1ac7e:	47a0      	blx	r4
   1ac80:	482c      	ldr	r0, [pc, #176]	; (1ad34 <hif_handle_isr+0x2b8>)
   1ac82:	47a0      	blx	r4
   1ac84:	481b      	ldr	r0, [pc, #108]	; (1acf4 <hif_handle_isr+0x278>)
   1ac86:	47a0      	blx	r4
   1ac88:	e779      	b.n	1ab7e <hif_handle_isr+0x102>
				M2M_ERR("(hif) Wrong Size\n");
   1ac8a:	4a2b      	ldr	r2, [pc, #172]	; (1ad38 <hif_handle_isr+0x2bc>)
   1ac8c:	4916      	ldr	r1, [pc, #88]	; (1ace8 <hif_handle_isr+0x26c>)
   1ac8e:	4c17      	ldr	r4, [pc, #92]	; (1acec <hif_handle_isr+0x270>)
   1ac90:	4814      	ldr	r0, [pc, #80]	; (1ace4 <hif_handle_isr+0x268>)
   1ac92:	47a0      	blx	r4
   1ac94:	4829      	ldr	r0, [pc, #164]	; (1ad3c <hif_handle_isr+0x2c0>)
   1ac96:	47a0      	blx	r4
   1ac98:	4816      	ldr	r0, [pc, #88]	; (1acf4 <hif_handle_isr+0x278>)
   1ac9a:	47a0      	blx	r4
				ret = M2M_ERR_RCV;
   1ac9c:	2602      	movs	r6, #2
   1ac9e:	e76f      	b.n	1ab80 <hif_handle_isr+0x104>
			M2M_ERR("(hif) False interrupt %lx",reg);
   1aca0:	4a27      	ldr	r2, [pc, #156]	; (1ad40 <hif_handle_isr+0x2c4>)
   1aca2:	4c12      	ldr	r4, [pc, #72]	; (1acec <hif_handle_isr+0x270>)
   1aca4:	4910      	ldr	r1, [pc, #64]	; (1ace8 <hif_handle_isr+0x26c>)
   1aca6:	480f      	ldr	r0, [pc, #60]	; (1ace4 <hif_handle_isr+0x268>)
   1aca8:	47a0      	blx	r4
   1acaa:	9905      	ldr	r1, [sp, #20]
   1acac:	4825      	ldr	r0, [pc, #148]	; (1ad44 <hif_handle_isr+0x2c8>)
   1acae:	47a0      	blx	r4
   1acb0:	4810      	ldr	r0, [pc, #64]	; (1acf4 <hif_handle_isr+0x278>)
   1acb2:	47a0      	blx	r4
			ret = M2M_ERR_FAIL;
   1acb4:	260c      	movs	r6, #12
   1acb6:	e763      	b.n	1ab80 <hif_handle_isr+0x104>
		M2M_ERR("(hif) Fail to Read interrupt reg\n");
   1acb8:	4a23      	ldr	r2, [pc, #140]	; (1ad48 <hif_handle_isr+0x2cc>)
   1acba:	490b      	ldr	r1, [pc, #44]	; (1ace8 <hif_handle_isr+0x26c>)
   1acbc:	4c0b      	ldr	r4, [pc, #44]	; (1acec <hif_handle_isr+0x270>)
   1acbe:	4809      	ldr	r0, [pc, #36]	; (1ace4 <hif_handle_isr+0x268>)
   1acc0:	47a0      	blx	r4
   1acc2:	4822      	ldr	r0, [pc, #136]	; (1ad4c <hif_handle_isr+0x2d0>)
   1acc4:	47a0      	blx	r4
   1acc6:	480b      	ldr	r0, [pc, #44]	; (1acf4 <hif_handle_isr+0x278>)
   1acc8:	47a0      	blx	r4
   1acca:	e719      	b.n	1ab00 <hif_handle_isr+0x84>
   1accc:	2000554c 	.word	0x2000554c
   1acd0:	00001070 	.word	0x00001070
   1acd4:	0001b7d9 	.word	0x0001b7d9
   1acd8:	0001a4ed 	.word	0x0001a4ed
   1acdc:	0001b7e5 	.word	0x0001b7e5
   1ace0:	00001084 	.word	0x00001084
   1ace4:	00029fb9 	.word	0x00029fb9
   1ace8:	00029fe9 	.word	0x00029fe9
   1acec:	00019415 	.word	0x00019415
   1acf0:	0002a01c 	.word	0x0002a01c
   1acf4:	0002b325 	.word	0x0002b325
   1acf8:	00000257 	.word	0x00000257
   1acfc:	00029ff1 	.word	0x00029ff1
   1ad00:	0002a1d2 	.word	0x0002a1d2
   1ad04:	0001b7f1 	.word	0x0001b7f1
   1ad08:	0002a041 	.word	0x0002a041
   1ad0c:	0002a059 	.word	0x0002a059
   1ad10:	00000216 	.word	0x00000216
   1ad14:	0002a158 	.word	0x0002a158
   1ad18:	0001a7cd 	.word	0x0001a7cd
   1ad1c:	0002a097 	.word	0x0002a097
   1ad20:	0002a0b8 	.word	0x0002a0b8
   1ad24:	0002a0db 	.word	0x0002a0db
   1ad28:	0002a0fb 	.word	0x0002a0fb
   1ad2c:	00000207 	.word	0x00000207
   1ad30:	0002a11e 	.word	0x0002a11e
   1ad34:	0002a140 	.word	0x0002a140
   1ad38:	0000021d 	.word	0x0000021d
   1ad3c:	0002a184 	.word	0x0002a184
   1ad40:	00000225 	.word	0x00000225
   1ad44:	0002a196 	.word	0x0002a196
   1ad48:	0000022e 	.word	0x0000022e
   1ad4c:	0002a1b0 	.word	0x0002a1b0

0001ad50 <hif_receive>:
*	@param [in]	isDone
*				If you don't need any more packets send True otherwise send false
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/
sint8 hif_receive(uint32 u32Addr, uint8 *pu8Buf, uint16 u16Sz, uint8 isDone)
{
   1ad50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1ad52:	0017      	movs	r7, r2
   1ad54:	001d      	movs	r5, r3
	sint8 ret = M2M_SUCCESS;
	if((u32Addr == 0)||(pu8Buf == NULL) || (u16Sz == 0))
   1ad56:	2800      	cmp	r0, #0
   1ad58:	d003      	beq.n	1ad62 <hif_receive+0x12>
   1ad5a:	2900      	cmp	r1, #0
   1ad5c:	d001      	beq.n	1ad62 <hif_receive+0x12>
   1ad5e:	2a00      	cmp	r2, #0
   1ad60:	d10f      	bne.n	1ad82 <hif_receive+0x32>
	{
		if(isDone)
   1ad62:	2d00      	cmp	r5, #0
   1ad64:	d002      	beq.n	1ad6c <hif_receive+0x1c>

	/* check if this is the last packet */
	if((((gstrHifCxt.u32RxAddr + gstrHifCxt.u32RxSize) - (u32Addr + u16Sz)) <= 0) || isDone)
	{
		/* set RX done */
		ret = hif_set_rx_done();
   1ad66:	4b1f      	ldr	r3, [pc, #124]	; (1ade4 <hif_receive+0x94>)
   1ad68:	4798      	blx	r3
   1ad6a:	e01c      	b.n	1ada6 <hif_receive+0x56>
			M2M_ERR(" hif_receive: Invalid argument\n");
   1ad6c:	229e      	movs	r2, #158	; 0x9e
   1ad6e:	481e      	ldr	r0, [pc, #120]	; (1ade8 <hif_receive+0x98>)
   1ad70:	0092      	lsls	r2, r2, #2
   1ad72:	491e      	ldr	r1, [pc, #120]	; (1adec <hif_receive+0x9c>)
   1ad74:	4c1e      	ldr	r4, [pc, #120]	; (1adf0 <hif_receive+0xa0>)
   1ad76:	47a0      	blx	r4
   1ad78:	481e      	ldr	r0, [pc, #120]	; (1adf4 <hif_receive+0xa4>)
		M2M_ERR("APP Requested Address beyond the recived buffer address and length\n");
   1ad7a:	47a0      	blx	r4
   1ad7c:	481e      	ldr	r0, [pc, #120]	; (1adf8 <hif_receive+0xa8>)
   1ad7e:	47a0      	blx	r4
   1ad80:	e00f      	b.n	1ada2 <hif_receive+0x52>
	if(u16Sz > gstrHifCxt.u32RxSize)
   1ad82:	4c1e      	ldr	r4, [pc, #120]	; (1adfc <hif_receive+0xac>)
   1ad84:	68e3      	ldr	r3, [r4, #12]
   1ad86:	429a      	cmp	r2, r3
   1ad88:	d90e      	bls.n	1ada8 <hif_receive+0x58>
		M2M_ERR("APP Requested Size is larger than the recived buffer size <%u><%lu>\n",u16Sz, gstrHifCxt.u32RxSize);
   1ad8a:	22a0      	movs	r2, #160	; 0xa0
   1ad8c:	4917      	ldr	r1, [pc, #92]	; (1adec <hif_receive+0x9c>)
   1ad8e:	0092      	lsls	r2, r2, #2
   1ad90:	4815      	ldr	r0, [pc, #84]	; (1ade8 <hif_receive+0x98>)
   1ad92:	4d17      	ldr	r5, [pc, #92]	; (1adf0 <hif_receive+0xa0>)
   1ad94:	47a8      	blx	r5
   1ad96:	481a      	ldr	r0, [pc, #104]	; (1ae00 <hif_receive+0xb0>)
   1ad98:	68e2      	ldr	r2, [r4, #12]
   1ad9a:	0039      	movs	r1, r7
   1ad9c:	47a8      	blx	r5
   1ad9e:	4816      	ldr	r0, [pc, #88]	; (1adf8 <hif_receive+0xa8>)
   1ada0:	47a8      	blx	r5
		ret = M2M_ERR_FAIL;
   1ada2:	200c      	movs	r0, #12
   1ada4:	4240      	negs	r0, r0
	}

ERR1:
	return ret;
}
   1ada6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if((u32Addr < gstrHifCxt.u32RxAddr)||((u32Addr + u16Sz)>(gstrHifCxt.u32RxAddr + gstrHifCxt.u32RxSize)))
   1ada8:	68a3      	ldr	r3, [r4, #8]
   1adaa:	4298      	cmp	r0, r3
   1adac:	d305      	bcc.n	1adba <hif_receive+0x6a>
   1adae:	68a3      	ldr	r3, [r4, #8]
   1adb0:	1886      	adds	r6, r0, r2
   1adb2:	68e2      	ldr	r2, [r4, #12]
   1adb4:	189b      	adds	r3, r3, r2
   1adb6:	429e      	cmp	r6, r3
   1adb8:	d906      	bls.n	1adc8 <hif_receive+0x78>
		M2M_ERR("APP Requested Address beyond the recived buffer address and length\n");
   1adba:	480b      	ldr	r0, [pc, #44]	; (1ade8 <hif_receive+0x98>)
   1adbc:	4a11      	ldr	r2, [pc, #68]	; (1ae04 <hif_receive+0xb4>)
   1adbe:	490b      	ldr	r1, [pc, #44]	; (1adec <hif_receive+0x9c>)
   1adc0:	4c0b      	ldr	r4, [pc, #44]	; (1adf0 <hif_receive+0xa0>)
   1adc2:	47a0      	blx	r4
   1adc4:	4810      	ldr	r0, [pc, #64]	; (1ae08 <hif_receive+0xb8>)
   1adc6:	e7d8      	b.n	1ad7a <hif_receive+0x2a>
	ret = nm_read_block(u32Addr, pu8Buf, u16Sz);
   1adc8:	003a      	movs	r2, r7
   1adca:	4b10      	ldr	r3, [pc, #64]	; (1ae0c <hif_receive+0xbc>)
   1adcc:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
   1adce:	2800      	cmp	r0, #0
   1add0:	d1e9      	bne.n	1ada6 <hif_receive+0x56>
	if((((gstrHifCxt.u32RxAddr + gstrHifCxt.u32RxSize) - (u32Addr + u16Sz)) <= 0) || isDone)
   1add2:	68a3      	ldr	r3, [r4, #8]
   1add4:	68e2      	ldr	r2, [r4, #12]
   1add6:	189b      	adds	r3, r3, r2
   1add8:	429e      	cmp	r6, r3
   1adda:	d0c4      	beq.n	1ad66 <hif_receive+0x16>
   1addc:	2d00      	cmp	r5, #0
   1adde:	d1c2      	bne.n	1ad66 <hif_receive+0x16>
   1ade0:	e7e1      	b.n	1ada6 <hif_receive+0x56>
   1ade2:	46c0      	nop			; (mov r8, r8)
   1ade4:	0001a7cd 	.word	0x0001a7cd
   1ade8:	00029fb9 	.word	0x00029fb9
   1adec:	0002a000 	.word	0x0002a000
   1adf0:	00019415 	.word	0x00019415
   1adf4:	0002a201 	.word	0x0002a201
   1adf8:	0002b325 	.word	0x0002b325
   1adfc:	2000554c 	.word	0x2000554c
   1ae00:	0002a221 	.word	0x0002a221
   1ae04:	00000286 	.word	0x00000286
   1ae08:	0002a266 	.word	0x0002a266
   1ae0c:	0001b7f1 	.word	0x0001b7f1

0001ae10 <hif_register_cb>:
*				function to be set
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
   1ae10:	b570      	push	{r4, r5, r6, lr}
   1ae12:	0005      	movs	r5, r0
	sint8 ret = M2M_SUCCESS;
	switch(u8Grp)
   1ae14:	3801      	subs	r0, #1
   1ae16:	2806      	cmp	r0, #6
   1ae18:	d815      	bhi.n	1ae46 <hif_register_cb+0x36>
   1ae1a:	4b11      	ldr	r3, [pc, #68]	; (1ae60 <hif_register_cb+0x50>)
   1ae1c:	f00a fd44 	bl	258a8 <__gnu_thumb1_case_uqi>
   1ae20:	090b0407 	.word	0x090b0407
   1ae24:	0d11      	.short	0x0d11
   1ae26:	0f          	.byte	0x0f
   1ae27:	00          	.byte	0x00
	{
		case M2M_REQ_GROUP_IP:
			gstrHifCxt.pfIpCb = fn;
   1ae28:	6159      	str	r1, [r3, #20]
	sint8 ret = M2M_SUCCESS;
   1ae2a:	2000      	movs	r0, #0
			M2M_ERR("GRp ? %d\n",u8Grp);
			ret = M2M_ERR_FAIL;
			break;
	}
	return ret;
}
   1ae2c:	bd70      	pop	{r4, r5, r6, pc}
			gstrHifCxt.pfWifiCb = fn;
   1ae2e:	6119      	str	r1, [r3, #16]
   1ae30:	e7fb      	b.n	1ae2a <hif_register_cb+0x1a>
			gstrHifCxt.pfOtaCb = fn;
   1ae32:	6199      	str	r1, [r3, #24]
   1ae34:	e7f9      	b.n	1ae2a <hif_register_cb+0x1a>
			gstrHifCxt.pfHifCb = fn;
   1ae36:	6219      	str	r1, [r3, #32]
   1ae38:	e7f7      	b.n	1ae2a <hif_register_cb+0x1a>
			gstrHifCxt.pfCryptoCb = fn;
   1ae3a:	6259      	str	r1, [r3, #36]	; 0x24
   1ae3c:	e7f5      	b.n	1ae2a <hif_register_cb+0x1a>
			gstrHifCxt.pfSigmaCb = fn;
   1ae3e:	61d9      	str	r1, [r3, #28]
   1ae40:	e7f3      	b.n	1ae2a <hif_register_cb+0x1a>
			gstrHifCxt.pfSslCb = fn;
   1ae42:	6299      	str	r1, [r3, #40]	; 0x28
   1ae44:	e7f1      	b.n	1ae2a <hif_register_cb+0x1a>
			M2M_ERR("GRp ? %d\n",u8Grp);
   1ae46:	4a07      	ldr	r2, [pc, #28]	; (1ae64 <hif_register_cb+0x54>)
   1ae48:	4c07      	ldr	r4, [pc, #28]	; (1ae68 <hif_register_cb+0x58>)
   1ae4a:	4908      	ldr	r1, [pc, #32]	; (1ae6c <hif_register_cb+0x5c>)
   1ae4c:	4808      	ldr	r0, [pc, #32]	; (1ae70 <hif_register_cb+0x60>)
   1ae4e:	47a0      	blx	r4
   1ae50:	0029      	movs	r1, r5
   1ae52:	4808      	ldr	r0, [pc, #32]	; (1ae74 <hif_register_cb+0x64>)
   1ae54:	47a0      	blx	r4
   1ae56:	4808      	ldr	r0, [pc, #32]	; (1ae78 <hif_register_cb+0x68>)
   1ae58:	47a0      	blx	r4
			ret = M2M_ERR_FAIL;
   1ae5a:	200c      	movs	r0, #12
   1ae5c:	4240      	negs	r0, r0
			break;
   1ae5e:	e7e5      	b.n	1ae2c <hif_register_cb+0x1c>
   1ae60:	2000554c 	.word	0x2000554c
   1ae64:	000002be 	.word	0x000002be
   1ae68:	00019415 	.word	0x00019415
   1ae6c:	0002a00c 	.word	0x0002a00c
   1ae70:	00029fb9 	.word	0x00029fb9
   1ae74:	0002a2aa 	.word	0x0002a2aa
   1ae78:	0002b325 	.word	0x0002b325

0001ae7c <hif_init>:
{
   1ae7c:	b510      	push	{r4, lr}
	m2m_memset((uint8*)&gstrHifCxt,0,sizeof(tstrHifContext));
   1ae7e:	222c      	movs	r2, #44	; 0x2c
   1ae80:	2100      	movs	r1, #0
   1ae82:	4806      	ldr	r0, [pc, #24]	; (1ae9c <hif_init+0x20>)
   1ae84:	4b06      	ldr	r3, [pc, #24]	; (1aea0 <hif_init+0x24>)
   1ae86:	4798      	blx	r3
	nm_bsp_register_isr(isr);
   1ae88:	4806      	ldr	r0, [pc, #24]	; (1aea4 <hif_init+0x28>)
   1ae8a:	4b07      	ldr	r3, [pc, #28]	; (1aea8 <hif_init+0x2c>)
   1ae8c:	4798      	blx	r3
	hif_register_cb(M2M_REQ_GROUP_HIF,m2m_hif_cb);
   1ae8e:	4907      	ldr	r1, [pc, #28]	; (1aeac <hif_init+0x30>)
   1ae90:	2003      	movs	r0, #3
   1ae92:	4b07      	ldr	r3, [pc, #28]	; (1aeb0 <hif_init+0x34>)
   1ae94:	4798      	blx	r3
}
   1ae96:	2000      	movs	r0, #0
   1ae98:	bd10      	pop	{r4, pc}
   1ae9a:	46c0      	nop			; (mov r8, r8)
   1ae9c:	2000554c 	.word	0x2000554c
   1aea0:	0001a797 	.word	0x0001a797
   1aea4:	0001a7b9 	.word	0x0001a7b9
   1aea8:	0001a495 	.word	0x0001a495
   1aeac:	0001a7c9 	.word	0x0001a7c9
   1aeb0:	0001ae11 	.word	0x0001ae11

0001aeb4 <m2m_wifi_cb>:
*	@author
*	@date
*	@version	1.0
*/
static void m2m_wifi_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
{
   1aeb4:	b5f0      	push	{r4, r5, r6, r7, lr}
   1aeb6:	0004      	movs	r4, r0
   1aeb8:	b09d      	sub	sp, #116	; 0x74
   1aeba:	0015      	movs	r5, r2
	uint8 rx_buf[8];
	if (u8OpCode == M2M_WIFI_RESP_CON_STATE_CHANGED)
   1aebc:	282c      	cmp	r0, #44	; 0x2c
   1aebe:	d102      	bne.n	1aec6 <m2m_wifi_cb+0x12>
				gpfAppWifiCb(M2M_WIFI_RESP_CURRENT_RSSI, rx_buf);
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_CLIENT_INFO)
	{
		if (hif_receive(u32Addr, rx_buf, 4, 0) == M2M_SUCCESS)
   1aec0:	2300      	movs	r3, #0
		}
	}
	else if(u8OpCode == M2M_WIFI_RESP_DEFAULT_CONNECT)
	{
		tstrM2MDefaultConnResp	strResp;
		if(hif_receive(u32Addr, (uint8*)&strResp, sizeof(tstrM2MDefaultConnResp), 1) == M2M_SUCCESS)
   1aec2:	2204      	movs	r2, #4
   1aec4:	e003      	b.n	1aece <m2m_wifi_cb+0x1a>
	else if (u8OpCode == M2M_WIFI_RESP_GET_SYS_TIME)
   1aec6:	281b      	cmp	r0, #27
   1aec8:	d10e      	bne.n	1aee8 <m2m_wifi_cb+0x34>
		if (hif_receive(u32Addr, (uint8*) &strSysTime,sizeof(tstrSystemTime), 0) == M2M_SUCCESS)
   1aeca:	2300      	movs	r3, #0
   1aecc:	2208      	movs	r2, #8
		if(hif_receive(u32Addr, (uint8*)&strResp, sizeof(tstrM2MDefaultConnResp), 1) == M2M_SUCCESS)
   1aece:	0028      	movs	r0, r5
   1aed0:	a903      	add	r1, sp, #12
   1aed2:	4d55      	ldr	r5, [pc, #340]	; (1b028 <m2m_wifi_cb+0x174>)
   1aed4:	47a8      	blx	r5
   1aed6:	2800      	cmp	r0, #0
   1aed8:	d104      	bne.n	1aee4 <m2m_wifi_cb+0x30>
		{
			if(gpfAppWifiCb)
   1aeda:	4b54      	ldr	r3, [pc, #336]	; (1b02c <m2m_wifi_cb+0x178>)
				gpfAppWifiCb(M2M_WIFI_RESP_DEFAULT_CONNECT, &strResp);
   1aedc:	a903      	add	r1, sp, #12
			if(gpfAppWifiCb)
   1aede:	681b      	ldr	r3, [r3, #0]
   1aee0:	2b00      	cmp	r3, #0
   1aee2:	d136      	bne.n	1af52 <m2m_wifi_cb+0x9e>
#endif
	else
	{
		M2M_ERR("REQ Not defined %d\n",u8OpCode);
	}
}
   1aee4:	b01d      	add	sp, #116	; 0x74
   1aee6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	else if(u8OpCode == M2M_WIFI_RESP_CONN_INFO)
   1aee8:	2806      	cmp	r0, #6
   1aeea:	d102      	bne.n	1aef2 <m2m_wifi_cb+0x3e>
		if(hif_receive(u32Addr, (uint8*)&strConnInfo, sizeof(tstrM2MConnInfo), 1) == M2M_SUCCESS)
   1aeec:	2301      	movs	r3, #1
   1aeee:	2230      	movs	r2, #48	; 0x30
   1aef0:	e7ed      	b.n	1aece <m2m_wifi_cb+0x1a>
	else if (u8OpCode == M2M_WIFI_RESP_MEMORY_RECOVER)
   1aef2:	280e      	cmp	r0, #14
   1aef4:	d0f6      	beq.n	1aee4 <m2m_wifi_cb+0x30>
	else if (u8OpCode == M2M_WIFI_REQ_DHCP_CONF)
   1aef6:	2832      	cmp	r0, #50	; 0x32
   1aef8:	d102      	bne.n	1af00 <m2m_wifi_cb+0x4c>
		if (hif_receive(u32Addr, (uint8 *)&strIpConfig, sizeof(tstrM2MIPConfig), 0) == M2M_SUCCESS)
   1aefa:	2300      	movs	r3, #0
   1aefc:	2218      	movs	r2, #24
   1aefe:	e7e6      	b.n	1aece <m2m_wifi_cb+0x1a>
	else if (u8OpCode == M2M_WIFI_REQ_WPS)
   1af00:	282f      	cmp	r0, #47	; 0x2f
   1af02:	d107      	bne.n	1af14 <m2m_wifi_cb+0x60>
		m2m_memset((uint8*)&strWps,0,sizeof(tstrM2MWPSInfo));
   1af04:	4b4a      	ldr	r3, [pc, #296]	; (1b030 <m2m_wifi_cb+0x17c>)
   1af06:	2264      	movs	r2, #100	; 0x64
   1af08:	2100      	movs	r1, #0
   1af0a:	a803      	add	r0, sp, #12
   1af0c:	4798      	blx	r3
		if(hif_receive(u32Addr, (uint8*)&strWps, sizeof(tstrM2MWPSInfo), 0) == M2M_SUCCESS)
   1af0e:	2300      	movs	r3, #0
		if(hif_receive(u32Addr, (uint8*)&strProvInfo, sizeof(tstrM2MProvisionInfo), 1) == M2M_SUCCESS)
   1af10:	2264      	movs	r2, #100	; 0x64
   1af12:	e7dc      	b.n	1aece <m2m_wifi_cb+0x1a>
	else if (u8OpCode == M2M_WIFI_RESP_IP_CONFLICT)
   1af14:	2834      	cmp	r0, #52	; 0x34
   1af16:	d11e      	bne.n	1af56 <m2m_wifi_cb+0xa2>
		if(hif_receive(u32Addr, (uint8 *)&u32ConflictedIP, sizeof(u32ConflictedIP), 0) == M2M_SUCCESS)
   1af18:	0028      	movs	r0, r5
   1af1a:	2300      	movs	r3, #0
   1af1c:	2204      	movs	r2, #4
   1af1e:	a903      	add	r1, sp, #12
   1af20:	4d41      	ldr	r5, [pc, #260]	; (1b028 <m2m_wifi_cb+0x174>)
   1af22:	47a8      	blx	r5
   1af24:	1e06      	subs	r6, r0, #0
   1af26:	d1dd      	bne.n	1aee4 <m2m_wifi_cb+0x30>
			M2M_INFO("Conflicted IP \" %u.%u.%u.%u \" \n", 
   1af28:	27ff      	movs	r7, #255	; 0xff
   1af2a:	4842      	ldr	r0, [pc, #264]	; (1b034 <m2m_wifi_cb+0x180>)
   1af2c:	4d42      	ldr	r5, [pc, #264]	; (1b038 <m2m_wifi_cb+0x184>)
   1af2e:	47a8      	blx	r5
   1af30:	9803      	ldr	r0, [sp, #12]
   1af32:	0a03      	lsrs	r3, r0, #8
   1af34:	0c02      	lsrs	r2, r0, #16
   1af36:	0e01      	lsrs	r1, r0, #24
   1af38:	4038      	ands	r0, r7
   1af3a:	9000      	str	r0, [sp, #0]
   1af3c:	403b      	ands	r3, r7
   1af3e:	483f      	ldr	r0, [pc, #252]	; (1b03c <m2m_wifi_cb+0x188>)
   1af40:	403a      	ands	r2, r7
   1af42:	47a8      	blx	r5
   1af44:	483e      	ldr	r0, [pc, #248]	; (1b040 <m2m_wifi_cb+0x18c>)
   1af46:	47a8      	blx	r5
				if(gpfAppWifiCb)
   1af48:	4b38      	ldr	r3, [pc, #224]	; (1b02c <m2m_wifi_cb+0x178>)
   1af4a:	681b      	ldr	r3, [r3, #0]
   1af4c:	2b00      	cmp	r3, #0
   1af4e:	d0c9      	beq.n	1aee4 <m2m_wifi_cb+0x30>
					gpfAppWifiCb(M2M_WIFI_RESP_GET_PRNG,&strPrng);
   1af50:	0031      	movs	r1, r6
   1af52:	0020      	movs	r0, r4
   1af54:	e015      	b.n	1af82 <m2m_wifi_cb+0xce>
	else if (u8OpCode == M2M_WIFI_RESP_SCAN_DONE)
   1af56:	2811      	cmp	r0, #17
   1af58:	d115      	bne.n	1af86 <m2m_wifi_cb+0xd2>
		gu8scanInProgress = 0;
   1af5a:	2300      	movs	r3, #0
   1af5c:	4a39      	ldr	r2, [pc, #228]	; (1b044 <m2m_wifi_cb+0x190>)
		if(hif_receive(u32Addr, (uint8*)&strState, sizeof(tstrM2mScanDone), 0) == M2M_SUCCESS)
   1af5e:	ac03      	add	r4, sp, #12
		gu8scanInProgress = 0;
   1af60:	7013      	strb	r3, [r2, #0]
		if(hif_receive(u32Addr, (uint8*)&strState, sizeof(tstrM2mScanDone), 0) == M2M_SUCCESS)
   1af62:	0028      	movs	r0, r5
   1af64:	2204      	movs	r2, #4
   1af66:	0021      	movs	r1, r4
   1af68:	4d2f      	ldr	r5, [pc, #188]	; (1b028 <m2m_wifi_cb+0x174>)
   1af6a:	47a8      	blx	r5
   1af6c:	2800      	cmp	r0, #0
   1af6e:	d1b9      	bne.n	1aee4 <m2m_wifi_cb+0x30>
			gu8ChNum = strState.u8NumofCh;
   1af70:	4b35      	ldr	r3, [pc, #212]	; (1b048 <m2m_wifi_cb+0x194>)
   1af72:	7822      	ldrb	r2, [r4, #0]
   1af74:	701a      	strb	r2, [r3, #0]
			if (gpfAppWifiCb)
   1af76:	4b2d      	ldr	r3, [pc, #180]	; (1b02c <m2m_wifi_cb+0x178>)
   1af78:	681b      	ldr	r3, [r3, #0]
   1af7a:	2b00      	cmp	r3, #0
   1af7c:	d0b2      	beq.n	1aee4 <m2m_wifi_cb+0x30>
				gpfAppWifiCb(M2M_WIFI_RESP_SCAN_DONE, &strState);
   1af7e:	0021      	movs	r1, r4
   1af80:	3011      	adds	r0, #17
					gpfAppWifiCb(M2M_WIFI_RESP_GET_PRNG,&strPrng);
   1af82:	4798      	blx	r3
   1af84:	e7ae      	b.n	1aee4 <m2m_wifi_cb+0x30>
	else if (u8OpCode == M2M_WIFI_RESP_SCAN_RESULT)
   1af86:	2813      	cmp	r0, #19
   1af88:	d10e      	bne.n	1afa8 <m2m_wifi_cb+0xf4>
		if(hif_receive(u32Addr, (uint8*)&strScanResult, sizeof(tstrM2mWifiscanResult), 0) == M2M_SUCCESS)
   1af8a:	2300      	movs	r3, #0
   1af8c:	222c      	movs	r2, #44	; 0x2c
   1af8e:	a903      	add	r1, sp, #12
   1af90:	0028      	movs	r0, r5
   1af92:	4c25      	ldr	r4, [pc, #148]	; (1b028 <m2m_wifi_cb+0x174>)
   1af94:	47a0      	blx	r4
   1af96:	2800      	cmp	r0, #0
   1af98:	d1a4      	bne.n	1aee4 <m2m_wifi_cb+0x30>
			if (gpfAppWifiCb)
   1af9a:	4b24      	ldr	r3, [pc, #144]	; (1b02c <m2m_wifi_cb+0x178>)
   1af9c:	681b      	ldr	r3, [r3, #0]
   1af9e:	2b00      	cmp	r3, #0
   1afa0:	d0a0      	beq.n	1aee4 <m2m_wifi_cb+0x30>
				gpfAppWifiCb(M2M_WIFI_RESP_SCAN_RESULT, &strScanResult);
   1afa2:	a903      	add	r1, sp, #12
   1afa4:	3013      	adds	r0, #19
   1afa6:	e7ec      	b.n	1af82 <m2m_wifi_cb+0xce>
	else if (u8OpCode == M2M_WIFI_RESP_CURRENT_RSSI)
   1afa8:	2804      	cmp	r0, #4
   1afaa:	d110      	bne.n	1afce <m2m_wifi_cb+0x11a>
		if (hif_receive(u32Addr, rx_buf, 4, 0) == M2M_SUCCESS)
   1afac:	2300      	movs	r3, #0
   1afae:	2204      	movs	r2, #4
   1afb0:	a903      	add	r1, sp, #12
   1afb2:	0028      	movs	r0, r5
   1afb4:	4c1c      	ldr	r4, [pc, #112]	; (1b028 <m2m_wifi_cb+0x174>)
   1afb6:	47a0      	blx	r4
   1afb8:	2800      	cmp	r0, #0
   1afba:	d000      	beq.n	1afbe <m2m_wifi_cb+0x10a>
   1afbc:	e792      	b.n	1aee4 <m2m_wifi_cb+0x30>
			if (gpfAppWifiCb)
   1afbe:	4b1b      	ldr	r3, [pc, #108]	; (1b02c <m2m_wifi_cb+0x178>)
   1afc0:	681b      	ldr	r3, [r3, #0]
   1afc2:	2b00      	cmp	r3, #0
   1afc4:	d100      	bne.n	1afc8 <m2m_wifi_cb+0x114>
   1afc6:	e78d      	b.n	1aee4 <m2m_wifi_cb+0x30>
				gpfAppWifiCb(M2M_WIFI_RESP_CURRENT_RSSI, rx_buf);
   1afc8:	a903      	add	r1, sp, #12
   1afca:	3004      	adds	r0, #4
   1afcc:	e7d9      	b.n	1af82 <m2m_wifi_cb+0xce>
	else if (u8OpCode == M2M_WIFI_RESP_CLIENT_INFO)
   1afce:	2865      	cmp	r0, #101	; 0x65
   1afd0:	d100      	bne.n	1afd4 <m2m_wifi_cb+0x120>
   1afd2:	e775      	b.n	1aec0 <m2m_wifi_cb+0xc>
	else if(u8OpCode == M2M_WIFI_RESP_PROVISION_INFO)
   1afd4:	2809      	cmp	r0, #9
   1afd6:	d101      	bne.n	1afdc <m2m_wifi_cb+0x128>
		if(hif_receive(u32Addr, (uint8*)&strProvInfo, sizeof(tstrM2MProvisionInfo), 1) == M2M_SUCCESS)
   1afd8:	2301      	movs	r3, #1
   1afda:	e799      	b.n	1af10 <m2m_wifi_cb+0x5c>
	else if(u8OpCode == M2M_WIFI_RESP_DEFAULT_CONNECT)
   1afdc:	282a      	cmp	r0, #42	; 0x2a
   1afde:	d101      	bne.n	1afe4 <m2m_wifi_cb+0x130>
		if(hif_receive(u32Addr, (uint8*)&strResp, sizeof(tstrM2MDefaultConnResp), 1) == M2M_SUCCESS)
   1afe0:	2301      	movs	r3, #1
   1afe2:	e76e      	b.n	1aec2 <m2m_wifi_cb+0xe>
	else if(u8OpCode == M2M_WIFI_RESP_GET_PRNG)
   1afe4:	2820      	cmp	r0, #32
   1afe6:	d112      	bne.n	1b00e <m2m_wifi_cb+0x15a>
		if(hif_receive(u32Addr, (uint8*)&strPrng,sizeof(tstrPrng), 0) == M2M_SUCCESS)
   1afe8:	ae03      	add	r6, sp, #12
   1afea:	2300      	movs	r3, #0
   1afec:	2208      	movs	r2, #8
   1afee:	0031      	movs	r1, r6
   1aff0:	0028      	movs	r0, r5
   1aff2:	4f0d      	ldr	r7, [pc, #52]	; (1b028 <m2m_wifi_cb+0x174>)
   1aff4:	47b8      	blx	r7
   1aff6:	2800      	cmp	r0, #0
   1aff8:	d000      	beq.n	1affc <m2m_wifi_cb+0x148>
   1affa:	e773      	b.n	1aee4 <m2m_wifi_cb+0x30>
			if(hif_receive(u32Addr + sizeof(tstrPrng),strPrng.pu8RngBuff,strPrng.u16PrngSize, 1) == M2M_SUCCESS)
   1affc:	0028      	movs	r0, r5
   1affe:	88b2      	ldrh	r2, [r6, #4]
   1b000:	3008      	adds	r0, #8
   1b002:	2301      	movs	r3, #1
   1b004:	9903      	ldr	r1, [sp, #12]
   1b006:	47b8      	blx	r7
   1b008:	2800      	cmp	r0, #0
   1b00a:	d09d      	beq.n	1af48 <m2m_wifi_cb+0x94>
   1b00c:	e76a      	b.n	1aee4 <m2m_wifi_cb+0x30>
		M2M_ERR("REQ Not defined %d\n",u8OpCode);
   1b00e:	2224      	movs	r2, #36	; 0x24
   1b010:	4d09      	ldr	r5, [pc, #36]	; (1b038 <m2m_wifi_cb+0x184>)
   1b012:	32ff      	adds	r2, #255	; 0xff
   1b014:	490d      	ldr	r1, [pc, #52]	; (1b04c <m2m_wifi_cb+0x198>)
   1b016:	480e      	ldr	r0, [pc, #56]	; (1b050 <m2m_wifi_cb+0x19c>)
   1b018:	47a8      	blx	r5
   1b01a:	0021      	movs	r1, r4
   1b01c:	480d      	ldr	r0, [pc, #52]	; (1b054 <m2m_wifi_cb+0x1a0>)
   1b01e:	47a8      	blx	r5
   1b020:	4807      	ldr	r0, [pc, #28]	; (1b040 <m2m_wifi_cb+0x18c>)
   1b022:	47a8      	blx	r5
}
   1b024:	e75e      	b.n	1aee4 <m2m_wifi_cb+0x30>
   1b026:	46c0      	nop			; (mov r8, r8)
   1b028:	0001ad51 	.word	0x0001ad51
   1b02c:	20003d7c 	.word	0x20003d7c
   1b030:	0001a797 	.word	0x0001a797
   1b034:	0002a2b4 	.word	0x0002a2b4
   1b038:	00019415 	.word	0x00019415
   1b03c:	0002a31c 	.word	0x0002a31c
   1b040:	0002b325 	.word	0x0002b325
   1b044:	20003d81 	.word	0x20003d81
   1b048:	20003d80 	.word	0x20003d80
   1b04c:	0002a2ee 	.word	0x0002a2ee
   1b050:	00029fb9 	.word	0x00029fb9
   1b054:	0002a33c 	.word	0x0002a33c

0001b058 <m2m_wifi_init>:

sint8 m2m_wifi_init(tstrWifiInitParam * param)
{
	tstrM2mRev strtmp;
	sint8 ret = M2M_SUCCESS;
	uint8 u8WifiMode = M2M_WIFI_MODE_NORMAL;
   1b058:	230f      	movs	r3, #15
{
   1b05a:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8 u8WifiMode = M2M_WIFI_MODE_NORMAL;
   1b05c:	2601      	movs	r6, #1
{
   1b05e:	b08f      	sub	sp, #60	; 0x3c
	uint8 u8WifiMode = M2M_WIFI_MODE_NORMAL;
   1b060:	446b      	add	r3, sp
   1b062:	701e      	strb	r6, [r3, #0]
	
	if(param == NULL) {
   1b064:	2800      	cmp	r0, #0
   1b066:	d05d      	beq.n	1b124 <m2m_wifi_init+0xcc>
#endif /* ETH_MODE */

#ifdef CONF_MGMT
	gpfAppMonCb  = param->pfAppMonCb;
#endif
	gu8scanInProgress = 0;
   1b068:	2400      	movs	r4, #0
	gpfAppWifiCb = param->pfAppWifiCb;
   1b06a:	6801      	ldr	r1, [r0, #0]
   1b06c:	4a2f      	ldr	r2, [pc, #188]	; (1b12c <m2m_wifi_init+0xd4>)
	/* Apply device specific initialization. */
	ret = nm_drv_init(&u8WifiMode);
   1b06e:	0018      	movs	r0, r3
	gpfAppWifiCb = param->pfAppWifiCb;
   1b070:	6011      	str	r1, [r2, #0]
	gu8scanInProgress = 0;
   1b072:	4a2f      	ldr	r2, [pc, #188]	; (1b130 <m2m_wifi_init+0xd8>)
	ret = nm_drv_init(&u8WifiMode);
   1b074:	4b2f      	ldr	r3, [pc, #188]	; (1b134 <m2m_wifi_init+0xdc>)
	gu8scanInProgress = 0;
   1b076:	7014      	strb	r4, [r2, #0]
	ret = nm_drv_init(&u8WifiMode);
   1b078:	4798      	blx	r3
   1b07a:	0005      	movs	r5, r0
	if(ret != M2M_SUCCESS) 	goto _EXIT0;
   1b07c:	42a0      	cmp	r0, r4
   1b07e:	d14a      	bne.n	1b116 <m2m_wifi_init+0xbe>
	/* Initialize host interface module */
	ret = hif_init(NULL);
   1b080:	4b2d      	ldr	r3, [pc, #180]	; (1b138 <m2m_wifi_init+0xe0>)
   1b082:	4798      	blx	r3
   1b084:	0005      	movs	r5, r0
	if(ret != M2M_SUCCESS) 	goto _EXIT1;
   1b086:	42a0      	cmp	r0, r4
   1b088:	d148      	bne.n	1b11c <m2m_wifi_init+0xc4>

	hif_register_cb(M2M_REQ_GROUP_WIFI,m2m_wifi_cb);
   1b08a:	492c      	ldr	r1, [pc, #176]	; (1b13c <m2m_wifi_init+0xe4>)
   1b08c:	0030      	movs	r0, r6
   1b08e:	4b2c      	ldr	r3, [pc, #176]	; (1b140 <m2m_wifi_init+0xe8>)

	ret = nm_get_firmware_full_info(&strtmp);
   1b090:	ae04      	add	r6, sp, #16
	hif_register_cb(M2M_REQ_GROUP_WIFI,m2m_wifi_cb);
   1b092:	4798      	blx	r3
	ret = nm_get_firmware_full_info(&strtmp);
   1b094:	4b2b      	ldr	r3, [pc, #172]	; (1b144 <m2m_wifi_init+0xec>)
   1b096:	0030      	movs	r0, r6
   1b098:	4798      	blx	r3

	M2M_INFO("Firmware ver   : %u.%u.%u Svnrev %u\n", strtmp.u8FirmwareMajor, strtmp.u8FirmwareMinor, strtmp.u8FirmwarePatch,strtmp.u16FirmwareSvnNum);
   1b09a:	4c2b      	ldr	r4, [pc, #172]	; (1b148 <m2m_wifi_init+0xf0>)
	ret = nm_get_firmware_full_info(&strtmp);
   1b09c:	0005      	movs	r5, r0
	M2M_INFO("Firmware ver   : %u.%u.%u Svnrev %u\n", strtmp.u8FirmwareMajor, strtmp.u8FirmwareMinor, strtmp.u8FirmwarePatch,strtmp.u16FirmwareSvnNum);
   1b09e:	482b      	ldr	r0, [pc, #172]	; (1b14c <m2m_wifi_init+0xf4>)
   1b0a0:	47a0      	blx	r4
   1b0a2:	8c30      	ldrh	r0, [r6, #32]
   1b0a4:	79b3      	ldrb	r3, [r6, #6]
   1b0a6:	7972      	ldrb	r2, [r6, #5]
   1b0a8:	7931      	ldrb	r1, [r6, #4]
   1b0aa:	9000      	str	r0, [sp, #0]
   1b0ac:	4828      	ldr	r0, [pc, #160]	; (1b150 <m2m_wifi_init+0xf8>)
   1b0ae:	47a0      	blx	r4
   1b0b0:	4f28      	ldr	r7, [pc, #160]	; (1b154 <m2m_wifi_init+0xfc>)
   1b0b2:	0038      	movs	r0, r7
   1b0b4:	47a0      	blx	r4
	M2M_INFO("Firmware Build %s Time %s\n",strtmp.BuildDate,strtmp.BuildTime);
   1b0b6:	4825      	ldr	r0, [pc, #148]	; (1b14c <m2m_wifi_init+0xf4>)
   1b0b8:	47a0      	blx	r4
   1b0ba:	2226      	movs	r2, #38	; 0x26
   1b0bc:	211a      	movs	r1, #26
   1b0be:	446a      	add	r2, sp
   1b0c0:	4469      	add	r1, sp
   1b0c2:	4825      	ldr	r0, [pc, #148]	; (1b158 <m2m_wifi_init+0x100>)
   1b0c4:	47a0      	blx	r4
   1b0c6:	0038      	movs	r0, r7
   1b0c8:	47a0      	blx	r4
	M2M_INFO("Firmware Min driver ver : %u.%u.%u\n", strtmp.u8DriverMajor, strtmp.u8DriverMinor, strtmp.u8DriverPatch);
   1b0ca:	4820      	ldr	r0, [pc, #128]	; (1b14c <m2m_wifi_init+0xf4>)
   1b0cc:	47a0      	blx	r4
   1b0ce:	7a73      	ldrb	r3, [r6, #9]
   1b0d0:	7a32      	ldrb	r2, [r6, #8]
   1b0d2:	79f1      	ldrb	r1, [r6, #7]
   1b0d4:	4821      	ldr	r0, [pc, #132]	; (1b15c <m2m_wifi_init+0x104>)
   1b0d6:	47a0      	blx	r4
   1b0d8:	0038      	movs	r0, r7
   1b0da:	47a0      	blx	r4
	M2M_INFO("Driver ver: %u.%u.%u\n", M2M_RELEASE_VERSION_MAJOR_NO, M2M_RELEASE_VERSION_MINOR_NO, M2M_RELEASE_VERSION_PATCH_NO);
   1b0dc:	481b      	ldr	r0, [pc, #108]	; (1b14c <m2m_wifi_init+0xf4>)
   1b0de:	47a0      	blx	r4
   1b0e0:	2304      	movs	r3, #4
   1b0e2:	2205      	movs	r2, #5
   1b0e4:	2113      	movs	r1, #19
   1b0e6:	481e      	ldr	r0, [pc, #120]	; (1b160 <m2m_wifi_init+0x108>)
   1b0e8:	47a0      	blx	r4
   1b0ea:	0038      	movs	r0, r7
   1b0ec:	47a0      	blx	r4
	M2M_INFO("Driver built at %s\t%s\n",__DATE__,__TIME__);
   1b0ee:	4817      	ldr	r0, [pc, #92]	; (1b14c <m2m_wifi_init+0xf4>)
   1b0f0:	47a0      	blx	r4
   1b0f2:	4a1c      	ldr	r2, [pc, #112]	; (1b164 <m2m_wifi_init+0x10c>)
   1b0f4:	491c      	ldr	r1, [pc, #112]	; (1b168 <m2m_wifi_init+0x110>)
   1b0f6:	481d      	ldr	r0, [pc, #116]	; (1b16c <m2m_wifi_init+0x114>)
   1b0f8:	47a0      	blx	r4
   1b0fa:	0038      	movs	r0, r7
   1b0fc:	47a0      	blx	r4
	if(M2M_ERR_FW_VER_MISMATCH == ret)
   1b0fe:	002b      	movs	r3, r5
   1b100:	330d      	adds	r3, #13
   1b102:	d108      	bne.n	1b116 <m2m_wifi_init+0xbe>
	{
		M2M_ERR("Mismatch Firmawre Version\n");
   1b104:	22e8      	movs	r2, #232	; 0xe8
   1b106:	491a      	ldr	r1, [pc, #104]	; (1b170 <m2m_wifi_init+0x118>)
   1b108:	32ff      	adds	r2, #255	; 0xff
   1b10a:	481a      	ldr	r0, [pc, #104]	; (1b174 <m2m_wifi_init+0x11c>)
   1b10c:	47a0      	blx	r4
   1b10e:	481a      	ldr	r0, [pc, #104]	; (1b178 <m2m_wifi_init+0x120>)
   1b110:	47a0      	blx	r4
   1b112:	0038      	movs	r0, r7
   1b114:	47a0      	blx	r4

_EXIT1:
	nm_drv_deinit(NULL);
_EXIT0:
	return ret;
}
   1b116:	0028      	movs	r0, r5
   1b118:	b00f      	add	sp, #60	; 0x3c
   1b11a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	nm_drv_deinit(NULL);
   1b11c:	0020      	movs	r0, r4
   1b11e:	4b17      	ldr	r3, [pc, #92]	; (1b17c <m2m_wifi_init+0x124>)
   1b120:	4798      	blx	r3
   1b122:	e7f8      	b.n	1b116 <m2m_wifi_init+0xbe>
		ret = M2M_ERR_FAIL;
   1b124:	250c      	movs	r5, #12
   1b126:	426d      	negs	r5, r5
   1b128:	e7f5      	b.n	1b116 <m2m_wifi_init+0xbe>
   1b12a:	46c0      	nop			; (mov r8, r8)
   1b12c:	20003d7c 	.word	0x20003d7c
   1b130:	20003d81 	.word	0x20003d81
   1b134:	0001b935 	.word	0x0001b935
   1b138:	0001ae7d 	.word	0x0001ae7d
   1b13c:	0001aeb5 	.word	0x0001aeb5
   1b140:	0001ae11 	.word	0x0001ae11
   1b144:	0001b871 	.word	0x0001b871
   1b148:	00019415 	.word	0x00019415
   1b14c:	0002a2b4 	.word	0x0002a2b4
   1b150:	0002a3f0 	.word	0x0002a3f0
   1b154:	0002b325 	.word	0x0002b325
   1b158:	0002a415 	.word	0x0002a415
   1b15c:	0002a430 	.word	0x0002a430
   1b160:	0002a454 	.word	0x0002a454
   1b164:	0002a46a 	.word	0x0002a46a
   1b168:	0002a473 	.word	0x0002a473
   1b16c:	0002a47f 	.word	0x0002a47f
   1b170:	0002a2fa 	.word	0x0002a2fa
   1b174:	00029fb9 	.word	0x00029fb9
   1b178:	0002a496 	.word	0x0002a496
   1b17c:	0001b9f9 	.word	0x0001b9f9

0001b180 <m2m_wifi_handle_events>:
{
	hif_yield();
}

sint8 m2m_wifi_handle_events(void * arg)
{
   1b180:	b510      	push	{r4, lr}
	return hif_handle_isr();
   1b182:	4b01      	ldr	r3, [pc, #4]	; (1b188 <m2m_wifi_handle_events+0x8>)
   1b184:	4798      	blx	r3
}
   1b186:	bd10      	pop	{r4, pc}
   1b188:	0001aa7d 	.word	0x0001aa7d

0001b18c <m2m_wifi_connect_sc>:
sint8 m2m_wifi_connect(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch)
{
	return m2m_wifi_connect_sc(pcSsid, u8SsidLen, u8SecType, pvAuthInfo,  u16Ch,0);
}
sint8 m2m_wifi_connect_sc(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch, uint8 u8NoSaveCred)
{
   1b18c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1b18e:	b0a5      	sub	sp, #148	; 0x94
   1b190:	001c      	movs	r4, r3
   1b192:	ab2a      	add	r3, sp, #168	; 0xa8
   1b194:	881b      	ldrh	r3, [r3, #0]
   1b196:	9006      	str	r0, [sp, #24]
   1b198:	9305      	str	r3, [sp, #20]
   1b19a:	ab2b      	add	r3, sp, #172	; 0xac
   1b19c:	781b      	ldrb	r3, [r3, #0]
   1b19e:	000f      	movs	r7, r1
   1b1a0:	0016      	movs	r6, r2
   1b1a2:	9307      	str	r3, [sp, #28]
	sint8				ret = M2M_SUCCESS;
	tstrM2mWifiConnect	strConnect;
	tstrM2MWifiSecInfo	*pstrAuthInfo;

	if(u8SecType != M2M_WIFI_SEC_OPEN)
   1b1a4:	2a01      	cmp	r2, #1
   1b1a6:	d10a      	bne.n	1b1be <m2m_wifi_connect_sc+0x32>
				}
				i++;
			}
		}
	}
	if((u8SsidLen<=0)||(u8SsidLen>=M2M_MAX_SSID_LEN))
   1b1a8:	1e7b      	subs	r3, r7, #1
   1b1aa:	2b1f      	cmp	r3, #31
   1b1ac:	d936      	bls.n	1b21c <m2m_wifi_connect_sc+0x90>
	{
		M2M_ERR("SSID LEN INVALID\n");
   1b1ae:	228c      	movs	r2, #140	; 0x8c
   1b1b0:	485c      	ldr	r0, [pc, #368]	; (1b324 <m2m_wifi_connect_sc+0x198>)
   1b1b2:	0092      	lsls	r2, r2, #2
   1b1b4:	495c      	ldr	r1, [pc, #368]	; (1b328 <m2m_wifi_connect_sc+0x19c>)
   1b1b6:	4c5d      	ldr	r4, [pc, #372]	; (1b32c <m2m_wifi_connect_sc+0x1a0>)
   1b1b8:	47a0      	blx	r4
   1b1ba:	485d      	ldr	r0, [pc, #372]	; (1b330 <m2m_wifi_connect_sc+0x1a4>)
   1b1bc:	e007      	b.n	1b1ce <m2m_wifi_connect_sc+0x42>
		if(pvAuthInfo == NULL)
   1b1be:	2c00      	cmp	r4, #0
   1b1c0:	d10c      	bne.n	1b1dc <m2m_wifi_connect_sc+0x50>
			M2M_ERR("Key is not valid\n");
   1b1c2:	4858      	ldr	r0, [pc, #352]	; (1b324 <m2m_wifi_connect_sc+0x198>)
   1b1c4:	4a5b      	ldr	r2, [pc, #364]	; (1b334 <m2m_wifi_connect_sc+0x1a8>)
   1b1c6:	4958      	ldr	r1, [pc, #352]	; (1b328 <m2m_wifi_connect_sc+0x19c>)
   1b1c8:	4c58      	ldr	r4, [pc, #352]	; (1b32c <m2m_wifi_connect_sc+0x1a0>)
   1b1ca:	47a0      	blx	r4
   1b1cc:	485a      	ldr	r0, [pc, #360]	; (1b338 <m2m_wifi_connect_sc+0x1ac>)
					M2M_ERR("Invalid Key\n");
   1b1ce:	47a0      	blx	r4
   1b1d0:	485a      	ldr	r0, [pc, #360]	; (1b33c <m2m_wifi_connect_sc+0x1b0>)
   1b1d2:	47a0      	blx	r4
					ret = M2M_ERR_FAIL;
   1b1d4:	200c      	movs	r0, #12
   1b1d6:	4240      	negs	r0, r0

	ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_CONNECT, (uint8*)&strConnect, sizeof(tstrM2mWifiConnect),NULL, 0,0);

ERR1:
	return ret;
}
   1b1d8:	b025      	add	sp, #148	; 0x94
   1b1da:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if((u8SecType == M2M_WIFI_SEC_WPA_PSK) && (m2m_strlen(pvAuthInfo) == (M2M_MAX_PSK_LEN-1)))
   1b1dc:	2a02      	cmp	r2, #2
   1b1de:	d1e3      	bne.n	1b1a8 <m2m_wifi_connect_sc+0x1c>
   1b1e0:	0020      	movs	r0, r4
   1b1e2:	4b57      	ldr	r3, [pc, #348]	; (1b340 <m2m_wifi_connect_sc+0x1b4>)
   1b1e4:	4798      	blx	r3
   1b1e6:	2840      	cmp	r0, #64	; 0x40
   1b1e8:	d1de      	bne.n	1b1a8 <m2m_wifi_connect_sc+0x1c>
   1b1ea:	0021      	movs	r1, r4
   1b1ec:	0022      	movs	r2, r4
   1b1ee:	3140      	adds	r1, #64	; 0x40
				if(pu8Psk[i]<'0' || (pu8Psk[i]>'9' && pu8Psk[i] < 'A')|| (pu8Psk[i]>'F' && pu8Psk[i] < 'a') || pu8Psk[i] > 'f')
   1b1f0:	7813      	ldrb	r3, [r2, #0]
   1b1f2:	0018      	movs	r0, r3
   1b1f4:	3830      	subs	r0, #48	; 0x30
   1b1f6:	2836      	cmp	r0, #54	; 0x36
   1b1f8:	d805      	bhi.n	1b206 <m2m_wifi_connect_sc+0x7a>
   1b1fa:	380a      	subs	r0, #10
   1b1fc:	2806      	cmp	r0, #6
   1b1fe:	d902      	bls.n	1b206 <m2m_wifi_connect_sc+0x7a>
   1b200:	3b47      	subs	r3, #71	; 0x47
   1b202:	2b19      	cmp	r3, #25
   1b204:	d806      	bhi.n	1b214 <m2m_wifi_connect_sc+0x88>
					M2M_ERR("Invalid Key\n");
   1b206:	4847      	ldr	r0, [pc, #284]	; (1b324 <m2m_wifi_connect_sc+0x198>)
   1b208:	4a4e      	ldr	r2, [pc, #312]	; (1b344 <m2m_wifi_connect_sc+0x1b8>)
   1b20a:	4947      	ldr	r1, [pc, #284]	; (1b328 <m2m_wifi_connect_sc+0x19c>)
   1b20c:	4c47      	ldr	r4, [pc, #284]	; (1b32c <m2m_wifi_connect_sc+0x1a0>)
   1b20e:	47a0      	blx	r4
   1b210:	484d      	ldr	r0, [pc, #308]	; (1b348 <m2m_wifi_connect_sc+0x1bc>)
   1b212:	e7dc      	b.n	1b1ce <m2m_wifi_connect_sc+0x42>
   1b214:	3201      	adds	r2, #1
			while(i < (M2M_MAX_PSK_LEN-1))
   1b216:	428a      	cmp	r2, r1
   1b218:	d1ea      	bne.n	1b1f0 <m2m_wifi_connect_sc+0x64>
   1b21a:	e7c5      	b.n	1b1a8 <m2m_wifi_connect_sc+0x1c>
	if(u16Ch < M2M_WIFI_CH_1|| u16Ch > M2M_WIFI_CH_14)
   1b21c:	9b05      	ldr	r3, [sp, #20]
   1b21e:	3b01      	subs	r3, #1
   1b220:	2b0d      	cmp	r3, #13
   1b222:	d909      	bls.n	1b238 <m2m_wifi_connect_sc+0xac>
		if(u16Ch!=M2M_WIFI_CH_ALL)
   1b224:	9b05      	ldr	r3, [sp, #20]
   1b226:	2bff      	cmp	r3, #255	; 0xff
   1b228:	d006      	beq.n	1b238 <m2m_wifi_connect_sc+0xac>
			M2M_ERR("CH INVALID\n");
   1b22a:	483e      	ldr	r0, [pc, #248]	; (1b324 <m2m_wifi_connect_sc+0x198>)
   1b22c:	4a47      	ldr	r2, [pc, #284]	; (1b34c <m2m_wifi_connect_sc+0x1c0>)
   1b22e:	493e      	ldr	r1, [pc, #248]	; (1b328 <m2m_wifi_connect_sc+0x19c>)
   1b230:	4c3e      	ldr	r4, [pc, #248]	; (1b32c <m2m_wifi_connect_sc+0x1a0>)
   1b232:	47a0      	blx	r4
   1b234:	4846      	ldr	r0, [pc, #280]	; (1b350 <m2m_wifi_connect_sc+0x1c4>)
   1b236:	e7ca      	b.n	1b1ce <m2m_wifi_connect_sc+0x42>
	m2m_memcpy(strConnect.au8SSID, (uint8*)pcSsid, u8SsidLen);
   1b238:	205a      	movs	r0, #90	; 0x5a
   1b23a:	ab04      	add	r3, sp, #16
   1b23c:	ad09      	add	r5, sp, #36	; 0x24
   1b23e:	003a      	movs	r2, r7
   1b240:	9906      	ldr	r1, [sp, #24]
   1b242:	18c0      	adds	r0, r0, r3
	strConnect.au8SSID[u8SsidLen]	= 0;
   1b244:	19ef      	adds	r7, r5, r7
	m2m_memcpy(strConnect.au8SSID, (uint8*)pcSsid, u8SsidLen);
   1b246:	4b43      	ldr	r3, [pc, #268]	; (1b354 <m2m_wifi_connect_sc+0x1c8>)
   1b248:	4798      	blx	r3
	strConnect.au8SSID[u8SsidLen]	= 0;
   1b24a:	003b      	movs	r3, r7
   1b24c:	2700      	movs	r7, #0
   1b24e:	3346      	adds	r3, #70	; 0x46
   1b250:	701f      	strb	r7, [r3, #0]
	strConnect.u16Ch				= NM_BSP_B_L_16(u16Ch);
   1b252:	231a      	movs	r3, #26
   1b254:	aa04      	add	r2, sp, #16
   1b256:	189b      	adds	r3, r3, r2
   1b258:	466a      	mov	r2, sp
   1b25a:	8a92      	ldrh	r2, [r2, #20]
	strConnect.u8NoSaveCred 			= u8NoSaveCred ? 1:0;
   1b25c:	a904      	add	r1, sp, #16
	strConnect.u16Ch				= NM_BSP_B_L_16(u16Ch);
   1b25e:	87da      	strh	r2, [r3, #62]	; 0x3e
	strConnect.u8NoSaveCred 			= u8NoSaveCred ? 1:0;
   1b260:	9b07      	ldr	r3, [sp, #28]
   1b262:	1e5a      	subs	r2, r3, #1
   1b264:	4193      	sbcs	r3, r2
   1b266:	227b      	movs	r2, #123	; 0x7b
   1b268:	1852      	adds	r2, r2, r1
   1b26a:	7013      	strb	r3, [r2, #0]
	pstrAuthInfo->u8SecType		= u8SecType;
   1b26c:	2355      	movs	r3, #85	; 0x55
   1b26e:	185b      	adds	r3, r3, r1
   1b270:	701e      	strb	r6, [r3, #0]
	if(u8SecType == M2M_WIFI_SEC_WEP)
   1b272:	2e03      	cmp	r6, #3
   1b274:	d133      	bne.n	1b2de <m2m_wifi_connect_sc+0x152>
		pstrWep->u8KeyIndx =pstrWepParams->u8KeyIndx-1;
   1b276:	7823      	ldrb	r3, [r4, #0]
   1b278:	3b01      	subs	r3, #1
   1b27a:	b2db      	uxtb	r3, r3
   1b27c:	702b      	strb	r3, [r5, #0]
		if(pstrWep->u8KeyIndx >= WEP_KEY_MAX_INDEX)
   1b27e:	2b03      	cmp	r3, #3
   1b280:	d909      	bls.n	1b296 <m2m_wifi_connect_sc+0x10a>
			M2M_ERR("Invalid Wep key index %d\n", pstrWep->u8KeyIndx);
   1b282:	2294      	movs	r2, #148	; 0x94
   1b284:	4928      	ldr	r1, [pc, #160]	; (1b328 <m2m_wifi_connect_sc+0x19c>)
   1b286:	4827      	ldr	r0, [pc, #156]	; (1b324 <m2m_wifi_connect_sc+0x198>)
   1b288:	0092      	lsls	r2, r2, #2
   1b28a:	4c28      	ldr	r4, [pc, #160]	; (1b32c <m2m_wifi_connect_sc+0x1a0>)
   1b28c:	47a0      	blx	r4
   1b28e:	7829      	ldrb	r1, [r5, #0]
   1b290:	4831      	ldr	r0, [pc, #196]	; (1b358 <m2m_wifi_connect_sc+0x1cc>)
			M2M_ERR("Invalid Wep key length %d\n", pstrWep->u8KeySz);
   1b292:	47a0      	blx	r4
   1b294:	e79c      	b.n	1b1d0 <m2m_wifi_connect_sc+0x44>
		pstrWep->u8KeySz = pstrWepParams->u8KeySz-1;
   1b296:	7862      	ldrb	r2, [r4, #1]
   1b298:	1e53      	subs	r3, r2, #1
   1b29a:	706b      	strb	r3, [r5, #1]
		if ((pstrWep->u8KeySz != WEP_40_KEY_STRING_SIZE)&& (pstrWep->u8KeySz != WEP_104_KEY_STRING_SIZE))
   1b29c:	0011      	movs	r1, r2
   1b29e:	2310      	movs	r3, #16
   1b2a0:	4399      	bics	r1, r3
   1b2a2:	290b      	cmp	r1, #11
   1b2a4:	d007      	beq.n	1b2b6 <m2m_wifi_connect_sc+0x12a>
			M2M_ERR("Invalid Wep key length %d\n", pstrWep->u8KeySz);
   1b2a6:	4920      	ldr	r1, [pc, #128]	; (1b328 <m2m_wifi_connect_sc+0x19c>)
   1b2a8:	481e      	ldr	r0, [pc, #120]	; (1b324 <m2m_wifi_connect_sc+0x198>)
   1b2aa:	4a2c      	ldr	r2, [pc, #176]	; (1b35c <m2m_wifi_connect_sc+0x1d0>)
   1b2ac:	4c1f      	ldr	r4, [pc, #124]	; (1b32c <m2m_wifi_connect_sc+0x1a0>)
   1b2ae:	47a0      	blx	r4
   1b2b0:	7869      	ldrb	r1, [r5, #1]
   1b2b2:	482b      	ldr	r0, [pc, #172]	; (1b360 <m2m_wifi_connect_sc+0x1d4>)
   1b2b4:	e7ed      	b.n	1b292 <m2m_wifi_connect_sc+0x106>
		m2m_memcpy((uint8*)pstrWep->au8WepKey,(uint8*)pstrWepParams->au8WepKey, pstrWepParams->u8KeySz);
   1b2b6:	2016      	movs	r0, #22
   1b2b8:	ab04      	add	r3, sp, #16
   1b2ba:	18c0      	adds	r0, r0, r3
   1b2bc:	1ca1      	adds	r1, r4, #2
   1b2be:	4b25      	ldr	r3, [pc, #148]	; (1b354 <m2m_wifi_connect_sc+0x1c8>)
   1b2c0:	4798      	blx	r3
		pstrWep->au8WepKey[pstrWepParams->u8KeySz] = 0;
   1b2c2:	7863      	ldrb	r3, [r4, #1]
   1b2c4:	18eb      	adds	r3, r5, r3
   1b2c6:	709f      	strb	r7, [r3, #2]
	ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_CONNECT, (uint8*)&strConnect, sizeof(tstrM2mWifiConnect),NULL, 0,0);
   1b2c8:	2300      	movs	r3, #0
   1b2ca:	002a      	movs	r2, r5
   1b2cc:	9302      	str	r3, [sp, #8]
   1b2ce:	9301      	str	r3, [sp, #4]
   1b2d0:	9300      	str	r3, [sp, #0]
   1b2d2:	2128      	movs	r1, #40	; 0x28
   1b2d4:	336c      	adds	r3, #108	; 0x6c
   1b2d6:	4c23      	ldr	r4, [pc, #140]	; (1b364 <m2m_wifi_connect_sc+0x1d8>)
   1b2d8:	2001      	movs	r0, #1
   1b2da:	47a0      	blx	r4
   1b2dc:	e77c      	b.n	1b1d8 <m2m_wifi_connect_sc+0x4c>
	else if(u8SecType == M2M_WIFI_SEC_WPA_PSK)
   1b2de:	2e02      	cmp	r6, #2
   1b2e0:	d10e      	bne.n	1b300 <m2m_wifi_connect_sc+0x174>
		uint16	u16KeyLen = m2m_strlen((uint8*)pvAuthInfo);
   1b2e2:	4b17      	ldr	r3, [pc, #92]	; (1b340 <m2m_wifi_connect_sc+0x1b4>)
   1b2e4:	0020      	movs	r0, r4
   1b2e6:	4798      	blx	r3
		if((u16KeyLen <= 0)||(u16KeyLen >= M2M_MAX_PSK_LEN))
   1b2e8:	1e43      	subs	r3, r0, #1
   1b2ea:	b29b      	uxth	r3, r3
		m2m_memcpy(pstrAuthInfo->uniAuth.au8PSK, (uint8*)pvAuthInfo, u16KeyLen + 1);
   1b2ec:	1c42      	adds	r2, r0, #1
		if((u16KeyLen <= 0)||(u16KeyLen >= M2M_MAX_PSK_LEN))
   1b2ee:	2b3f      	cmp	r3, #63	; 0x3f
   1b2f0:	d909      	bls.n	1b306 <m2m_wifi_connect_sc+0x17a>
			M2M_ERR("Incorrect PSK key length\n");
   1b2f2:	480c      	ldr	r0, [pc, #48]	; (1b324 <m2m_wifi_connect_sc+0x198>)
   1b2f4:	4a1c      	ldr	r2, [pc, #112]	; (1b368 <m2m_wifi_connect_sc+0x1dc>)
   1b2f6:	490c      	ldr	r1, [pc, #48]	; (1b328 <m2m_wifi_connect_sc+0x19c>)
   1b2f8:	4c0c      	ldr	r4, [pc, #48]	; (1b32c <m2m_wifi_connect_sc+0x1a0>)
   1b2fa:	47a0      	blx	r4
   1b2fc:	481b      	ldr	r0, [pc, #108]	; (1b36c <m2m_wifi_connect_sc+0x1e0>)
   1b2fe:	e766      	b.n	1b1ce <m2m_wifi_connect_sc+0x42>
	else if(u8SecType == M2M_WIFI_SEC_802_1X)
   1b300:	2e04      	cmp	r6, #4
   1b302:	d105      	bne.n	1b310 <m2m_wifi_connect_sc+0x184>
		m2m_memcpy((uint8*)&pstrAuthInfo->uniAuth.strCred1x, (uint8*)pvAuthInfo, sizeof(tstr1xAuthCredentials));
   1b304:	223e      	movs	r2, #62	; 0x3e
   1b306:	0021      	movs	r1, r4
   1b308:	0028      	movs	r0, r5
   1b30a:	4b12      	ldr	r3, [pc, #72]	; (1b354 <m2m_wifi_connect_sc+0x1c8>)
   1b30c:	4798      	blx	r3
   1b30e:	e7db      	b.n	1b2c8 <m2m_wifi_connect_sc+0x13c>
	else if(u8SecType == M2M_WIFI_SEC_OPEN)
   1b310:	2e01      	cmp	r6, #1
   1b312:	d0d9      	beq.n	1b2c8 <m2m_wifi_connect_sc+0x13c>
		M2M_ERR("undefined sec type\n");
   1b314:	4803      	ldr	r0, [pc, #12]	; (1b324 <m2m_wifi_connect_sc+0x198>)
   1b316:	4a16      	ldr	r2, [pc, #88]	; (1b370 <m2m_wifi_connect_sc+0x1e4>)
   1b318:	4903      	ldr	r1, [pc, #12]	; (1b328 <m2m_wifi_connect_sc+0x19c>)
   1b31a:	4c04      	ldr	r4, [pc, #16]	; (1b32c <m2m_wifi_connect_sc+0x1a0>)
   1b31c:	47a0      	blx	r4
   1b31e:	4815      	ldr	r0, [pc, #84]	; (1b374 <m2m_wifi_connect_sc+0x1e8>)
   1b320:	e755      	b.n	1b1ce <m2m_wifi_connect_sc+0x42>
   1b322:	46c0      	nop			; (mov r8, r8)
   1b324:	00029fb9 	.word	0x00029fb9
   1b328:	0002a308 	.word	0x0002a308
   1b32c:	00019415 	.word	0x00019415
   1b330:	0002a36f 	.word	0x0002a36f
   1b334:	0000021a 	.word	0x0000021a
   1b338:	0002a350 	.word	0x0002a350
   1b33c:	0002b325 	.word	0x0002b325
   1b340:	0001a7a7 	.word	0x0001a7a7
   1b344:	00000226 	.word	0x00000226
   1b348:	0002a362 	.word	0x0002a362
   1b34c:	00000239 	.word	0x00000239
   1b350:	0002a381 	.word	0x0002a381
   1b354:	0001a785 	.word	0x0001a785
   1b358:	0002a38d 	.word	0x0002a38d
   1b35c:	00000257 	.word	0x00000257
   1b360:	0002a3a7 	.word	0x0002a3a7
   1b364:	0001a88d 	.word	0x0001a88d
   1b368:	00000266 	.word	0x00000266
   1b36c:	0002a3c2 	.word	0x0002a3c2
   1b370:	00000276 	.word	0x00000276
   1b374:	0002a3dc 	.word	0x0002a3dc

0001b378 <m2m_wifi_connect>:
{
   1b378:	b537      	push	{r0, r1, r2, r4, r5, lr}
	return m2m_wifi_connect_sc(pcSsid, u8SsidLen, u8SecType, pvAuthInfo,  u16Ch,0);
   1b37a:	2500      	movs	r5, #0
{
   1b37c:	ac06      	add	r4, sp, #24
   1b37e:	8824      	ldrh	r4, [r4, #0]
	return m2m_wifi_connect_sc(pcSsid, u8SsidLen, u8SecType, pvAuthInfo,  u16Ch,0);
   1b380:	9501      	str	r5, [sp, #4]
   1b382:	9400      	str	r4, [sp, #0]
   1b384:	4c01      	ldr	r4, [pc, #4]	; (1b38c <m2m_wifi_connect+0x14>)
   1b386:	47a0      	blx	r4
}
   1b388:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
   1b38a:	46c0      	nop			; (mov r8, r8)
   1b38c:	0001b18d 	.word	0x0001b18d

0001b390 <m2m_wifi_request_dhcp_client>:

sint8 m2m_wifi_request_dhcp_client(void)
{
	/*legacy API should be removed */
	return 0;
}
   1b390:	2000      	movs	r0, #0
   1b392:	4770      	bx	lr

0001b394 <chip_apply_conf>:

#define TIMEOUT						(0xfffffffful)
#define WAKUP_TRAILS_TIMEOUT		(4)

sint8 chip_apply_conf(uint32 u32Conf)
{
   1b394:	b537      	push	{r0, r1, r2, r4, r5, lr}
#endif
#if defined CONF_WINC_XO_XTALGM2_DIS
	val32 |= rHAVE_XO_XTALGM2_DIS_BIT;
#endif

	val32 |= rHAVE_RESERVED1_BIT;
   1b396:	2480      	movs	r4, #128	; 0x80
	do  {
		nm_write_reg(rNMI_GP_REG_1, val32);
   1b398:	25a5      	movs	r5, #165	; 0xa5
	val32 |= rHAVE_RESERVED1_BIT;
   1b39a:	0064      	lsls	r4, r4, #1
   1b39c:	4304      	orrs	r4, r0
		nm_write_reg(rNMI_GP_REG_1, val32);
   1b39e:	016d      	lsls	r5, r5, #5
   1b3a0:	0021      	movs	r1, r4
   1b3a2:	4b07      	ldr	r3, [pc, #28]	; (1b3c0 <chip_apply_conf+0x2c>)
   1b3a4:	0028      	movs	r0, r5
   1b3a6:	4798      	blx	r3
		if(val32 != 0) {		
			uint32 reg = 0;
   1b3a8:	2300      	movs	r3, #0
			ret = nm_read_reg_with_ret(rNMI_GP_REG_1, &reg);
   1b3aa:	a901      	add	r1, sp, #4
			uint32 reg = 0;
   1b3ac:	9301      	str	r3, [sp, #4]
			ret = nm_read_reg_with_ret(rNMI_GP_REG_1, &reg);
   1b3ae:	0028      	movs	r0, r5
   1b3b0:	4b04      	ldr	r3, [pc, #16]	; (1b3c4 <chip_apply_conf+0x30>)
   1b3b2:	4798      	blx	r3
			if(ret == M2M_SUCCESS) {
   1b3b4:	2800      	cmp	r0, #0
   1b3b6:	d1f3      	bne.n	1b3a0 <chip_apply_conf+0xc>
				if(reg == val32)
   1b3b8:	9b01      	ldr	r3, [sp, #4]
   1b3ba:	429c      	cmp	r4, r3
   1b3bc:	d1f0      	bne.n	1b3a0 <chip_apply_conf+0xc>
			break;
		}
	} while(1);

	return M2M_SUCCESS;
}
   1b3be:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
   1b3c0:	0001b7e5 	.word	0x0001b7e5
   1b3c4:	0001b7d9 	.word	0x0001b7d9

0001b3c8 <enable_interrupts>:
	}
}

sint8 enable_interrupts(void)
{
	uint32 reg = 0;
   1b3c8:	2300      	movs	r3, #0
{
   1b3ca:	b537      	push	{r0, r1, r2, r4, r5, lr}
	sint8 ret = M2M_SUCCESS;
	/**
	interrupt pin mux select
	**/
	ret = nm_read_reg_with_ret(NMI_PIN_MUX_0, &reg);
   1b3cc:	480f      	ldr	r0, [pc, #60]	; (1b40c <enable_interrupts+0x44>)
   1b3ce:	a901      	add	r1, sp, #4
   1b3d0:	4d0f      	ldr	r5, [pc, #60]	; (1b410 <enable_interrupts+0x48>)
	uint32 reg = 0;
   1b3d2:	9301      	str	r3, [sp, #4]
	ret = nm_read_reg_with_ret(NMI_PIN_MUX_0, &reg);
   1b3d4:	47a8      	blx	r5
	if (M2M_SUCCESS != ret) goto ERR1;
   1b3d6:	2800      	cmp	r0, #0
   1b3d8:	d117      	bne.n	1b40a <enable_interrupts+0x42>
	
	reg |= ((uint32) 1 << 8);
   1b3da:	2180      	movs	r1, #128	; 0x80
   1b3dc:	9b01      	ldr	r3, [sp, #4]
   1b3de:	0049      	lsls	r1, r1, #1
   1b3e0:	4319      	orrs	r1, r3
	ret = nm_write_reg(NMI_PIN_MUX_0, reg);
   1b3e2:	480a      	ldr	r0, [pc, #40]	; (1b40c <enable_interrupts+0x44>)
   1b3e4:	4c0b      	ldr	r4, [pc, #44]	; (1b414 <enable_interrupts+0x4c>)
	reg |= ((uint32) 1 << 8);
   1b3e6:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(NMI_PIN_MUX_0, reg);
   1b3e8:	47a0      	blx	r4
	if (M2M_SUCCESS != ret) goto ERR1;
   1b3ea:	2800      	cmp	r0, #0
   1b3ec:	d10d      	bne.n	1b40a <enable_interrupts+0x42>
	
	/**
	interrupt enable
	**/
	ret = nm_read_reg_with_ret(NMI_INTR_ENABLE, &reg);
   1b3ee:	20d0      	movs	r0, #208	; 0xd0
   1b3f0:	a901      	add	r1, sp, #4
   1b3f2:	0140      	lsls	r0, r0, #5
   1b3f4:	47a8      	blx	r5
	if (M2M_SUCCESS != ret) goto ERR1;
   1b3f6:	2800      	cmp	r0, #0
   1b3f8:	d107      	bne.n	1b40a <enable_interrupts+0x42>
	
	reg |= ((uint32) 1 << 16);
   1b3fa:	2180      	movs	r1, #128	; 0x80
	ret = nm_write_reg(NMI_INTR_ENABLE, reg);
   1b3fc:	20d0      	movs	r0, #208	; 0xd0
	reg |= ((uint32) 1 << 16);
   1b3fe:	9b01      	ldr	r3, [sp, #4]
   1b400:	0249      	lsls	r1, r1, #9
   1b402:	4319      	orrs	r1, r3
	ret = nm_write_reg(NMI_INTR_ENABLE, reg);
   1b404:	0140      	lsls	r0, r0, #5
	reg |= ((uint32) 1 << 16);
   1b406:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(NMI_INTR_ENABLE, reg);
   1b408:	47a0      	blx	r4
	if (M2M_SUCCESS != ret) goto ERR1;
ERR1:	
	return ret;
}
   1b40a:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
   1b40c:	00001408 	.word	0x00001408
   1b410:	0001b7d9 	.word	0x0001b7d9
   1b414:	0001b7e5 	.word	0x0001b7e5

0001b418 <nmi_get_chipid>:
	nm_bsp_sleep(1);
	return ret;
}

uint32 nmi_get_chipid(void)
{
   1b418:	b573      	push	{r0, r1, r4, r5, r6, lr}
	static uint32 chipid = 0;

	if (chipid == 0) {
   1b41a:	4c1e      	ldr	r4, [pc, #120]	; (1b494 <nmi_get_chipid+0x7c>)
   1b41c:	6825      	ldr	r5, [r4, #0]
   1b41e:	2d00      	cmp	r5, #0
   1b420:	d11f      	bne.n	1b462 <nmi_get_chipid+0x4a>
		uint32 rfrevid;
		
		if((nm_read_reg_with_ret(0x1000, &chipid)) != M2M_SUCCESS) {
   1b422:	2080      	movs	r0, #128	; 0x80
   1b424:	0021      	movs	r1, r4
   1b426:	0140      	lsls	r0, r0, #5
   1b428:	4e1b      	ldr	r6, [pc, #108]	; (1b498 <nmi_get_chipid+0x80>)
   1b42a:	47b0      	blx	r6
   1b42c:	2800      	cmp	r0, #0
   1b42e:	d003      	beq.n	1b438 <nmi_get_chipid+0x20>
			chipid = 0;
   1b430:	2300      	movs	r3, #0
   1b432:	6023      	str	r3, [r4, #0]
		chipid &= ~(0x0f0000);
		chipid |= 0x050000;
#endif /* PROBE_FLASH */
	}
	return chipid;
}
   1b434:	0028      	movs	r0, r5
   1b436:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
		if((nm_read_reg_with_ret(0x13f4, &rfrevid)) != M2M_SUCCESS) {
   1b438:	a901      	add	r1, sp, #4
   1b43a:	4818      	ldr	r0, [pc, #96]	; (1b49c <nmi_get_chipid+0x84>)
   1b43c:	47b0      	blx	r6
   1b43e:	2800      	cmp	r0, #0
   1b440:	d1f6      	bne.n	1b430 <nmi_get_chipid+0x18>
		if (chipid == 0x1002a0)  {
   1b442:	6823      	ldr	r3, [r4, #0]
   1b444:	4a16      	ldr	r2, [pc, #88]	; (1b4a0 <nmi_get_chipid+0x88>)
   1b446:	4293      	cmp	r3, r2
   1b448:	d10d      	bne.n	1b466 <nmi_get_chipid+0x4e>
			if (rfrevid == 0x1) { /* 1002A0 */
   1b44a:	9b01      	ldr	r3, [sp, #4]
   1b44c:	2b01      	cmp	r3, #1
   1b44e:	d001      	beq.n	1b454 <nmi_get_chipid+0x3c>
				chipid = 0x1002a1;
   1b450:	4b14      	ldr	r3, [pc, #80]	; (1b4a4 <nmi_get_chipid+0x8c>)
				chipid = 0x1002b1;
   1b452:	6023      	str	r3, [r4, #0]
		chipid &= ~(0x0f0000);
   1b454:	6823      	ldr	r3, [r4, #0]
   1b456:	4a14      	ldr	r2, [pc, #80]	; (1b4a8 <nmi_get_chipid+0x90>)
   1b458:	401a      	ands	r2, r3
		chipid |= 0x050000;
   1b45a:	23a0      	movs	r3, #160	; 0xa0
   1b45c:	02db      	lsls	r3, r3, #11
   1b45e:	4313      	orrs	r3, r2
   1b460:	6023      	str	r3, [r4, #0]
	return chipid;
   1b462:	6825      	ldr	r5, [r4, #0]
   1b464:	e7e6      	b.n	1b434 <nmi_get_chipid+0x1c>
		} else if(chipid == 0x1002b0) {
   1b466:	4a11      	ldr	r2, [pc, #68]	; (1b4ac <nmi_get_chipid+0x94>)
   1b468:	4293      	cmp	r3, r2
   1b46a:	d108      	bne.n	1b47e <nmi_get_chipid+0x66>
			if(rfrevid == 3) { /* 1002B0 */
   1b46c:	9b01      	ldr	r3, [sp, #4]
   1b46e:	2b03      	cmp	r3, #3
   1b470:	d0f0      	beq.n	1b454 <nmi_get_chipid+0x3c>
			} else if(rfrevid == 4) { /* 1002B1 */
   1b472:	2b04      	cmp	r3, #4
   1b474:	d101      	bne.n	1b47a <nmi_get_chipid+0x62>
				chipid = 0x1002b1;
   1b476:	4b0e      	ldr	r3, [pc, #56]	; (1b4b0 <nmi_get_chipid+0x98>)
   1b478:	e7eb      	b.n	1b452 <nmi_get_chipid+0x3a>
				chipid = 0x1002b2;
   1b47a:	4b0e      	ldr	r3, [pc, #56]	; (1b4b4 <nmi_get_chipid+0x9c>)
   1b47c:	e7e9      	b.n	1b452 <nmi_get_chipid+0x3a>
		}else if(chipid == 0x1000F0) { 
   1b47e:	4a0e      	ldr	r2, [pc, #56]	; (1b4b8 <nmi_get_chipid+0xa0>)
   1b480:	4293      	cmp	r3, r2
   1b482:	d1e7      	bne.n	1b454 <nmi_get_chipid+0x3c>
			if((nm_read_reg_with_ret(0x3B0000, &chipid)) != M2M_SUCCESS) {
   1b484:	20ec      	movs	r0, #236	; 0xec
   1b486:	0021      	movs	r1, r4
   1b488:	0380      	lsls	r0, r0, #14
   1b48a:	47b0      	blx	r6
   1b48c:	2800      	cmp	r0, #0
   1b48e:	d1cf      	bne.n	1b430 <nmi_get_chipid+0x18>
   1b490:	e7e0      	b.n	1b454 <nmi_get_chipid+0x3c>
   1b492:	46c0      	nop			; (mov r8, r8)
   1b494:	20003d84 	.word	0x20003d84
   1b498:	0001b7d9 	.word	0x0001b7d9
   1b49c:	000013f4 	.word	0x000013f4
   1b4a0:	001002a0 	.word	0x001002a0
   1b4a4:	001002a1 	.word	0x001002a1
   1b4a8:	fff0ffff 	.word	0xfff0ffff
   1b4ac:	001002b0 	.word	0x001002b0
   1b4b0:	001002b1 	.word	0x001002b1
   1b4b4:	001002b2 	.word	0x001002b2
   1b4b8:	001000f0 	.word	0x001000f0

0001b4bc <chip_sleep>:

	/* Do PLL update */
	nmi_update_pll();
}
sint8 chip_sleep(void)
{
   1b4bc:	b537      	push	{r0, r1, r2, r4, r5, lr}
	
	while(1)
	{
		ret = nm_read_reg_with_ret(CORT_HOST_COMM,&reg);
		if(ret != M2M_SUCCESS) goto ERR1;
		if((reg & NBIT0) == 0) break;
   1b4be:	2501      	movs	r5, #1
		ret = nm_read_reg_with_ret(CORT_HOST_COMM,&reg);
   1b4c0:	a901      	add	r1, sp, #4
   1b4c2:	2010      	movs	r0, #16
   1b4c4:	4c13      	ldr	r4, [pc, #76]	; (1b514 <chip_sleep+0x58>)
   1b4c6:	47a0      	blx	r4
		if(ret != M2M_SUCCESS) goto ERR1;
   1b4c8:	2800      	cmp	r0, #0
   1b4ca:	d110      	bne.n	1b4ee <chip_sleep+0x32>
		if((reg & NBIT0) == 0) break;
   1b4cc:	9b01      	ldr	r3, [sp, #4]
   1b4ce:	422b      	tst	r3, r5
   1b4d0:	d1f6      	bne.n	1b4c0 <chip_sleep+0x4>
	}
	
	/* Clear bit 1 */
	ret = nm_read_reg_with_ret(WAKE_CLK_REG, &reg);
   1b4d2:	a901      	add	r1, sp, #4
   1b4d4:	3001      	adds	r0, #1
   1b4d6:	47a0      	blx	r4
	if(ret != M2M_SUCCESS)goto ERR1;
   1b4d8:	2800      	cmp	r0, #0
   1b4da:	d108      	bne.n	1b4ee <chip_sleep+0x32>
	if(reg & NBIT1)
   1b4dc:	2302      	movs	r3, #2
   1b4de:	9901      	ldr	r1, [sp, #4]
   1b4e0:	4219      	tst	r1, r3
   1b4e2:	d105      	bne.n	1b4f0 <chip_sleep+0x34>
		reg &=~NBIT1;
		ret = nm_write_reg(WAKE_CLK_REG, reg);
		if(ret != M2M_SUCCESS)goto ERR1;
	}
	
	ret = nm_read_reg_with_ret(HOST_CORT_COMM, &reg);
   1b4e4:	a901      	add	r1, sp, #4
   1b4e6:	200b      	movs	r0, #11
   1b4e8:	47a0      	blx	r4
	if(ret != M2M_SUCCESS)goto ERR1;
   1b4ea:	2800      	cmp	r0, #0
   1b4ec:	d008      	beq.n	1b500 <chip_sleep+0x44>
		if(ret != M2M_SUCCESS)goto ERR1;
	}

ERR1:
	return ret;
}
   1b4ee:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
		reg &=~NBIT1;
   1b4f0:	4399      	bics	r1, r3
		ret = nm_write_reg(WAKE_CLK_REG, reg);
   1b4f2:	2001      	movs	r0, #1
   1b4f4:	4b08      	ldr	r3, [pc, #32]	; (1b518 <chip_sleep+0x5c>)
		reg &=~NBIT1;
   1b4f6:	9101      	str	r1, [sp, #4]
		ret = nm_write_reg(WAKE_CLK_REG, reg);
   1b4f8:	4798      	blx	r3
		if(ret != M2M_SUCCESS)goto ERR1;
   1b4fa:	2800      	cmp	r0, #0
   1b4fc:	d0f2      	beq.n	1b4e4 <chip_sleep+0x28>
   1b4fe:	e7f6      	b.n	1b4ee <chip_sleep+0x32>
	if(reg & NBIT0)
   1b500:	2301      	movs	r3, #1
   1b502:	9901      	ldr	r1, [sp, #4]
   1b504:	4219      	tst	r1, r3
   1b506:	d0f2      	beq.n	1b4ee <chip_sleep+0x32>
		reg &= ~NBIT0;
   1b508:	4399      	bics	r1, r3
		ret = nm_write_reg(HOST_CORT_COMM, reg);
   1b50a:	200b      	movs	r0, #11
   1b50c:	4b02      	ldr	r3, [pc, #8]	; (1b518 <chip_sleep+0x5c>)
		reg &= ~NBIT0;
   1b50e:	9101      	str	r1, [sp, #4]
		ret = nm_write_reg(HOST_CORT_COMM, reg);
   1b510:	4798      	blx	r3
   1b512:	e7ec      	b.n	1b4ee <chip_sleep+0x32>
   1b514:	0001b7d9 	.word	0x0001b7d9
   1b518:	0001b7e5 	.word	0x0001b7e5

0001b51c <chip_wake>:
sint8 chip_wake(void)
{
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, clk_status_reg = 0,trials = 0;
   1b51c:	2300      	movs	r3, #0
{
   1b51e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}

	ret = nm_read_reg_with_ret(HOST_CORT_COMM, &reg);
   1b520:	200b      	movs	r0, #11
   1b522:	4669      	mov	r1, sp
   1b524:	4d27      	ldr	r5, [pc, #156]	; (1b5c4 <chip_wake+0xa8>)
	uint32 reg = 0, clk_status_reg = 0,trials = 0;
   1b526:	9300      	str	r3, [sp, #0]
   1b528:	9301      	str	r3, [sp, #4]
	ret = nm_read_reg_with_ret(HOST_CORT_COMM, &reg);
   1b52a:	47a8      	blx	r5
   1b52c:	1e04      	subs	r4, r0, #0
	if(ret != M2M_SUCCESS)goto _WAKE_EXIT;
   1b52e:	d108      	bne.n	1b542 <chip_wake+0x26>
	
	if(!(reg & NBIT0))
   1b530:	2101      	movs	r1, #1
   1b532:	9b00      	ldr	r3, [sp, #0]
   1b534:	420b      	tst	r3, r1
   1b536:	d006      	beq.n	1b546 <chip_wake+0x2a>
		/*USE bit 0 to indicate host wakeup*/
		ret = nm_write_reg(HOST_CORT_COMM, reg|NBIT0);
		if(ret != M2M_SUCCESS)goto _WAKE_EXIT;
	}
		
	ret = nm_read_reg_with_ret(WAKE_CLK_REG, &reg);
   1b538:	4669      	mov	r1, sp
   1b53a:	2001      	movs	r0, #1
   1b53c:	47a8      	blx	r5
   1b53e:	1e04      	subs	r4, r0, #0
	if(ret != M2M_SUCCESS)goto _WAKE_EXIT;
   1b540:	d008      	beq.n	1b554 <chip_wake+0x38>
	/*workaround sometimes spi fail to read clock regs after reading/writing clockless registers*/
	nm_bus_reset();
	
_WAKE_EXIT:
	return ret;
}
   1b542:	0020      	movs	r0, r4
   1b544:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		ret = nm_write_reg(HOST_CORT_COMM, reg|NBIT0);
   1b546:	4319      	orrs	r1, r3
   1b548:	200b      	movs	r0, #11
   1b54a:	4b1f      	ldr	r3, [pc, #124]	; (1b5c8 <chip_wake+0xac>)
   1b54c:	4798      	blx	r3
   1b54e:	1e04      	subs	r4, r0, #0
		if(ret != M2M_SUCCESS)goto _WAKE_EXIT;
   1b550:	d0f2      	beq.n	1b538 <chip_wake+0x1c>
   1b552:	e7f6      	b.n	1b542 <chip_wake+0x26>
	if(!(reg & NBIT1))
   1b554:	2102      	movs	r1, #2
   1b556:	9b00      	ldr	r3, [sp, #0]
   1b558:	420b      	tst	r3, r1
   1b55a:	d013      	beq.n	1b584 <chip_wake+0x68>
{
   1b55c:	2605      	movs	r6, #5
		if(clk_status_reg & NBIT2) {
   1b55e:	2704      	movs	r7, #4
		ret = nm_read_reg_with_ret(CLOCKS_EN_REG, &clk_status_reg);
   1b560:	a901      	add	r1, sp, #4
   1b562:	200f      	movs	r0, #15
   1b564:	47a8      	blx	r5
   1b566:	1e04      	subs	r4, r0, #0
		if(ret != M2M_SUCCESS) {
   1b568:	d013      	beq.n	1b592 <chip_wake+0x76>
			M2M_ERR("Bus error (5).%d %lx\n",ret,clk_status_reg);
   1b56a:	22a8      	movs	r2, #168	; 0xa8
   1b56c:	4d17      	ldr	r5, [pc, #92]	; (1b5cc <chip_wake+0xb0>)
   1b56e:	0052      	lsls	r2, r2, #1
   1b570:	4917      	ldr	r1, [pc, #92]	; (1b5d0 <chip_wake+0xb4>)
   1b572:	4818      	ldr	r0, [pc, #96]	; (1b5d4 <chip_wake+0xb8>)
   1b574:	47a8      	blx	r5
   1b576:	9a01      	ldr	r2, [sp, #4]
   1b578:	0021      	movs	r1, r4
   1b57a:	4817      	ldr	r0, [pc, #92]	; (1b5d8 <chip_wake+0xbc>)
   1b57c:	47a8      	blx	r5
   1b57e:	4817      	ldr	r0, [pc, #92]	; (1b5dc <chip_wake+0xc0>)
   1b580:	47a8      	blx	r5
			goto _WAKE_EXIT;
   1b582:	e7de      	b.n	1b542 <chip_wake+0x26>
		ret = nm_write_reg(WAKE_CLK_REG, reg | NBIT1);
   1b584:	4319      	orrs	r1, r3
   1b586:	2001      	movs	r0, #1
   1b588:	4b0f      	ldr	r3, [pc, #60]	; (1b5c8 <chip_wake+0xac>)
   1b58a:	4798      	blx	r3
   1b58c:	1e04      	subs	r4, r0, #0
		if(ret != M2M_SUCCESS) goto _WAKE_EXIT;	
   1b58e:	d0e5      	beq.n	1b55c <chip_wake+0x40>
   1b590:	e7d7      	b.n	1b542 <chip_wake+0x26>
		if(clk_status_reg & NBIT2) {
   1b592:	9b01      	ldr	r3, [sp, #4]
   1b594:	423b      	tst	r3, r7
   1b596:	d112      	bne.n	1b5be <chip_wake+0xa2>
		nm_bsp_sleep(2);
   1b598:	2002      	movs	r0, #2
   1b59a:	4b11      	ldr	r3, [pc, #68]	; (1b5e0 <chip_wake+0xc4>)
   1b59c:	3e01      	subs	r6, #1
   1b59e:	4798      	blx	r3
		if(trials > WAKUP_TRAILS_TIMEOUT)
   1b5a0:	2e00      	cmp	r6, #0
   1b5a2:	d1dd      	bne.n	1b560 <chip_wake+0x44>
			M2M_ERR("Failed to wakup the chip\n");
   1b5a4:	22ad      	movs	r2, #173	; 0xad
   1b5a6:	4c09      	ldr	r4, [pc, #36]	; (1b5cc <chip_wake+0xb0>)
   1b5a8:	0052      	lsls	r2, r2, #1
   1b5aa:	4909      	ldr	r1, [pc, #36]	; (1b5d0 <chip_wake+0xb4>)
   1b5ac:	4809      	ldr	r0, [pc, #36]	; (1b5d4 <chip_wake+0xb8>)
   1b5ae:	47a0      	blx	r4
   1b5b0:	480c      	ldr	r0, [pc, #48]	; (1b5e4 <chip_wake+0xc8>)
   1b5b2:	47a0      	blx	r4
   1b5b4:	4809      	ldr	r0, [pc, #36]	; (1b5dc <chip_wake+0xc0>)
   1b5b6:	47a0      	blx	r4
			ret = M2M_ERR_TIME_OUT;
   1b5b8:	2404      	movs	r4, #4
   1b5ba:	4264      	negs	r4, r4
			goto _WAKE_EXIT;
   1b5bc:	e7c1      	b.n	1b542 <chip_wake+0x26>
	nm_bus_reset();
   1b5be:	4b0a      	ldr	r3, [pc, #40]	; (1b5e8 <chip_wake+0xcc>)
   1b5c0:	4798      	blx	r3
   1b5c2:	e7be      	b.n	1b542 <chip_wake+0x26>
   1b5c4:	0001b7d9 	.word	0x0001b7d9
   1b5c8:	0001b7e5 	.word	0x0001b7e5
   1b5cc:	00019415 	.word	0x00019415
   1b5d0:	0002a4b1 	.word	0x0002a4b1
   1b5d4:	00029fb9 	.word	0x00029fb9
   1b5d8:	0002a4e0 	.word	0x0002a4e0
   1b5dc:	0002b325 	.word	0x0002b325
   1b5e0:	0001a489 	.word	0x0001a489
   1b5e4:	0002a4f6 	.word	0x0002a4f6
   1b5e8:	0001b7c1 	.word	0x0001b7c1

0001b5ec <wait_for_bootrom>:
	nm_bsp_sleep(50);
	return ret;
}

sint8 wait_for_bootrom(uint8 arg)
{
   1b5ec:	b570      	push	{r4, r5, r6, lr}
   1b5ee:	0005      	movs	r5, r0
				M2M_MIN_REQ_DRV_VERSION_PATCH_NO);


	reg = 0;
	while(1) {
		reg = nm_read_reg(0x1014);	/* wait for efuse loading done */
   1b5f0:	4824      	ldr	r0, [pc, #144]	; (1b684 <wait_for_bootrom+0x98>)
   1b5f2:	4c25      	ldr	r4, [pc, #148]	; (1b688 <wait_for_bootrom+0x9c>)
   1b5f4:	47a0      	blx	r4
		if (reg & 0x80000000) {
   1b5f6:	2800      	cmp	r0, #0
   1b5f8:	db03      	blt.n	1b602 <wait_for_bootrom+0x16>
			break;
		}
		nm_bsp_sleep(1); /* TODO: Why bus error if this delay is not here. */
   1b5fa:	2001      	movs	r0, #1
   1b5fc:	4b23      	ldr	r3, [pc, #140]	; (1b68c <wait_for_bootrom+0xa0>)
   1b5fe:	4798      	blx	r3
		reg = nm_read_reg(0x1014);	/* wait for efuse loading done */
   1b600:	e7f6      	b.n	1b5f0 <wait_for_bootrom+0x4>
	}
	reg = nm_read_reg(M2M_WAIT_FOR_HOST_REG);
   1b602:	4823      	ldr	r0, [pc, #140]	; (1b690 <wait_for_bootrom+0xa4>)
   1b604:	47a0      	blx	r4
	reg &= 0x1;

	/* check if waiting for the host will be skipped or not */
	if(reg == 0)
   1b606:	07c3      	lsls	r3, r0, #31
   1b608:	d50b      	bpl.n	1b622 <wait_for_bootrom+0x36>
   1b60a:	4c22      	ldr	r4, [pc, #136]	; (1b694 <wait_for_bootrom+0xa8>)
				goto ERR2;
			}
		}
	}
	
	if(M2M_WIFI_MODE_ATE_HIGH == arg) {
   1b60c:	2d02      	cmp	r5, #2
   1b60e:	d111      	bne.n	1b634 <wait_for_bootrom+0x48>
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
   1b610:	4921      	ldr	r1, [pc, #132]	; (1b698 <wait_for_bootrom+0xac>)
   1b612:	4822      	ldr	r0, [pc, #136]	; (1b69c <wait_for_bootrom+0xb0>)
   1b614:	47a0      	blx	r4
		nm_write_reg(NMI_STATE_REG, NBIT20);
   1b616:	2180      	movs	r1, #128	; 0x80
   1b618:	0349      	lsls	r1, r1, #13
	}else if(M2M_WIFI_MODE_ATE_LOW == arg) {
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
		nm_write_reg(NMI_STATE_REG, 0);
   1b61a:	4821      	ldr	r0, [pc, #132]	; (1b6a0 <wait_for_bootrom+0xb4>)
	}else if(M2M_WIFI_MODE_ETHERNET == arg){
		u32GpReg1 = rHAVE_ETHERNET_MODE_BIT;
		nm_write_reg(NMI_STATE_REG, u32DriverVerInfo);
	} else {
		/*bypass this step*/
		nm_write_reg(NMI_STATE_REG, u32DriverVerInfo);
   1b61c:	47a0      	blx	r4
	uint32 u32GpReg1 = 0;
   1b61e:	2500      	movs	r5, #0
   1b620:	e015      	b.n	1b64e <wait_for_bootrom+0x62>
			nm_bsp_sleep(1);
   1b622:	4b1a      	ldr	r3, [pc, #104]	; (1b68c <wait_for_bootrom+0xa0>)
   1b624:	2001      	movs	r0, #1
   1b626:	4798      	blx	r3
			reg = nm_read_reg(BOOTROM_REG);
   1b628:	481e      	ldr	r0, [pc, #120]	; (1b6a4 <wait_for_bootrom+0xb8>)
   1b62a:	47a0      	blx	r4
		while(reg != M2M_FINISH_BOOT_ROM)
   1b62c:	4b1e      	ldr	r3, [pc, #120]	; (1b6a8 <wait_for_bootrom+0xbc>)
   1b62e:	4298      	cmp	r0, r3
   1b630:	d1f7      	bne.n	1b622 <wait_for_bootrom+0x36>
   1b632:	e7ea      	b.n	1b60a <wait_for_bootrom+0x1e>
	}else if(M2M_WIFI_MODE_ATE_LOW == arg) {
   1b634:	2d03      	cmp	r5, #3
   1b636:	d104      	bne.n	1b642 <wait_for_bootrom+0x56>
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
   1b638:	4917      	ldr	r1, [pc, #92]	; (1b698 <wait_for_bootrom+0xac>)
   1b63a:	4818      	ldr	r0, [pc, #96]	; (1b69c <wait_for_bootrom+0xb0>)
   1b63c:	47a0      	blx	r4
		nm_write_reg(NMI_STATE_REG, 0);
   1b63e:	2100      	movs	r1, #0
   1b640:	e7eb      	b.n	1b61a <wait_for_bootrom+0x2e>
		nm_write_reg(NMI_STATE_REG, u32DriverVerInfo);
   1b642:	491a      	ldr	r1, [pc, #104]	; (1b6ac <wait_for_bootrom+0xc0>)
   1b644:	4816      	ldr	r0, [pc, #88]	; (1b6a0 <wait_for_bootrom+0xb4>)
	}else if(M2M_WIFI_MODE_ETHERNET == arg){
   1b646:	2d04      	cmp	r5, #4
   1b648:	d1e8      	bne.n	1b61c <wait_for_bootrom+0x30>
		nm_write_reg(NMI_STATE_REG, u32DriverVerInfo);
   1b64a:	47a0      	blx	r4
		u32GpReg1 = rHAVE_ETHERNET_MODE_BIT;
   1b64c:	357c      	adds	r5, #124	; 0x7c
	}

	if(REV(nmi_get_chipid()) >= REV_3A0){
   1b64e:	4b18      	ldr	r3, [pc, #96]	; (1b6b0 <wait_for_bootrom+0xc4>)
   1b650:	4798      	blx	r3
   1b652:	4a18      	ldr	r2, [pc, #96]	; (1b6b4 <wait_for_bootrom+0xc8>)
   1b654:	0500      	lsls	r0, r0, #20
   1b656:	0d00      	lsrs	r0, r0, #20
   1b658:	4b17      	ldr	r3, [pc, #92]	; (1b6b8 <wait_for_bootrom+0xcc>)
   1b65a:	4290      	cmp	r0, r2
   1b65c:	d90f      	bls.n	1b67e <wait_for_bootrom+0x92>
		chip_apply_conf(u32GpReg1 | rHAVE_USE_PMU_BIT);
   1b65e:	2002      	movs	r0, #2
   1b660:	4328      	orrs	r0, r5
	} else {
		chip_apply_conf(u32GpReg1);
   1b662:	4798      	blx	r3
	}
	M2M_INFO("DriverVerInfo: 0x%08lx\n",u32DriverVerInfo);
   1b664:	4d15      	ldr	r5, [pc, #84]	; (1b6bc <wait_for_bootrom+0xd0>)
   1b666:	4816      	ldr	r0, [pc, #88]	; (1b6c0 <wait_for_bootrom+0xd4>)
   1b668:	47a8      	blx	r5
   1b66a:	4910      	ldr	r1, [pc, #64]	; (1b6ac <wait_for_bootrom+0xc0>)
   1b66c:	4815      	ldr	r0, [pc, #84]	; (1b6c4 <wait_for_bootrom+0xd8>)
   1b66e:	47a8      	blx	r5
   1b670:	4815      	ldr	r0, [pc, #84]	; (1b6c8 <wait_for_bootrom+0xdc>)
   1b672:	47a8      	blx	r5

	nm_write_reg(BOOTROM_REG,M2M_START_FIRMWARE);
   1b674:	4915      	ldr	r1, [pc, #84]	; (1b6cc <wait_for_bootrom+0xe0>)
   1b676:	480b      	ldr	r0, [pc, #44]	; (1b6a4 <wait_for_bootrom+0xb8>)
   1b678:	47a0      	blx	r4
	rom_test();
#endif /* __ROM_TEST__ */

ERR2:
	return ret;
}
   1b67a:	2000      	movs	r0, #0
   1b67c:	bd70      	pop	{r4, r5, r6, pc}
		chip_apply_conf(u32GpReg1);
   1b67e:	0028      	movs	r0, r5
   1b680:	e7ef      	b.n	1b662 <wait_for_bootrom+0x76>
   1b682:	46c0      	nop			; (mov r8, r8)
   1b684:	00001014 	.word	0x00001014
   1b688:	0001b7cd 	.word	0x0001b7cd
   1b68c:	0001a489 	.word	0x0001a489
   1b690:	000207bc 	.word	0x000207bc
   1b694:	0001b7e5 	.word	0x0001b7e5
   1b698:	3c1cd57d 	.word	0x3c1cd57d
   1b69c:	000207ac 	.word	0x000207ac
   1b6a0:	0000108c 	.word	0x0000108c
   1b6a4:	000c000c 	.word	0x000c000c
   1b6a8:	10add09e 	.word	0x10add09e
   1b6ac:	13301354 	.word	0x13301354
   1b6b0:	0001b419 	.word	0x0001b419
   1b6b4:	0000039f 	.word	0x0000039f
   1b6b8:	0001b395 	.word	0x0001b395
   1b6bc:	00019415 	.word	0x00019415
   1b6c0:	0002a2b4 	.word	0x0002a2b4
   1b6c4:	0002a510 	.word	0x0002a510
   1b6c8:	0002b325 	.word	0x0002b325
   1b6cc:	ef522f61 	.word	0xef522f61

0001b6d0 <wait_for_firmware_start>:

sint8 wait_for_firmware_start(uint8 arg)
{
   1b6d0:	b537      	push	{r0, r1, r2, r4, r5, lr}
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, cnt = 0;
	uint32 u32Timeout = TIMEOUT;
	volatile uint32 regAddress = NMI_STATE_REG;
   1b6d2:	4b13      	ldr	r3, [pc, #76]	; (1b720 <wait_for_firmware_start+0x50>)
	volatile uint32 checkValue = M2M_FINISH_INIT_STATE;
   1b6d4:	4c13      	ldr	r4, [pc, #76]	; (1b724 <wait_for_firmware_start+0x54>)
	
	if((M2M_WIFI_MODE_ATE_HIGH == arg)||(M2M_WIFI_MODE_ATE_LOW == arg)) {
   1b6d6:	3802      	subs	r0, #2
	volatile uint32 regAddress = NMI_STATE_REG;
   1b6d8:	9300      	str	r3, [sp, #0]
	volatile uint32 checkValue = M2M_FINISH_INIT_STATE;
   1b6da:	9401      	str	r4, [sp, #4]
	if((M2M_WIFI_MODE_ATE_HIGH == arg)||(M2M_WIFI_MODE_ATE_LOW == arg)) {
   1b6dc:	2801      	cmp	r0, #1
   1b6de:	d803      	bhi.n	1b6e8 <wait_for_firmware_start+0x18>
		regAddress = NMI_REV_REG;
   1b6e0:	4b11      	ldr	r3, [pc, #68]	; (1b728 <wait_for_firmware_start+0x58>)
   1b6e2:	9300      	str	r3, [sp, #0]
		checkValue = M2M_ATE_FW_IS_UP_VALUE;
   1b6e4:	4b11      	ldr	r3, [pc, #68]	; (1b72c <wait_for_firmware_start+0x5c>)
   1b6e6:	9301      	str	r3, [sp, #4]
{
   1b6e8:	2501      	movs	r5, #1
   1b6ea:	2000      	movs	r0, #0
   1b6ec:	426d      	negs	r5, r5
	} else {
		/*bypass this step*/
	}
	
	
	while (checkValue != reg)
   1b6ee:	9b01      	ldr	r3, [sp, #4]
   1b6f0:	4298      	cmp	r0, r3
   1b6f2:	d109      	bne.n	1b708 <wait_for_firmware_start+0x38>
			M2M_DBG("Time out for wait firmware Run\n");
			ret = M2M_ERR_INIT;
			goto ERR;
		}
	}
	if(M2M_FINISH_INIT_STATE == checkValue)
   1b6f4:	9b01      	ldr	r3, [sp, #4]
	sint8 ret = M2M_SUCCESS;
   1b6f6:	2500      	movs	r5, #0
	if(M2M_FINISH_INIT_STATE == checkValue)
   1b6f8:	42a3      	cmp	r3, r4
   1b6fa:	d103      	bne.n	1b704 <wait_for_firmware_start+0x34>
	{
		nm_write_reg(NMI_STATE_REG, 0);
   1b6fc:	0029      	movs	r1, r5
   1b6fe:	4808      	ldr	r0, [pc, #32]	; (1b720 <wait_for_firmware_start+0x50>)
   1b700:	4b0b      	ldr	r3, [pc, #44]	; (1b730 <wait_for_firmware_start+0x60>)
   1b702:	4798      	blx	r3
	}
ERR:
	return ret;
}
   1b704:	0028      	movs	r0, r5
   1b706:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
		nm_bsp_sleep(2); /* TODO: Why bus error if this delay is not here. */
   1b708:	2002      	movs	r0, #2
   1b70a:	4b0a      	ldr	r3, [pc, #40]	; (1b734 <wait_for_firmware_start+0x64>)
   1b70c:	4798      	blx	r3
   1b70e:	3d01      	subs	r5, #1
		reg = nm_read_reg(regAddress);
   1b710:	9800      	ldr	r0, [sp, #0]
   1b712:	4b09      	ldr	r3, [pc, #36]	; (1b738 <wait_for_firmware_start+0x68>)
   1b714:	4798      	blx	r3
		if(++cnt >= u32Timeout)
   1b716:	2d00      	cmp	r5, #0
   1b718:	d1e9      	bne.n	1b6ee <wait_for_firmware_start+0x1e>
			ret = M2M_ERR_INIT;
   1b71a:	2505      	movs	r5, #5
   1b71c:	426d      	negs	r5, r5
   1b71e:	e7f1      	b.n	1b704 <wait_for_firmware_start+0x34>
   1b720:	0000108c 	.word	0x0000108c
   1b724:	02532636 	.word	0x02532636
   1b728:	000207ac 	.word	0x000207ac
   1b72c:	d75dc1c3 	.word	0xd75dc1c3
   1b730:	0001b7e5 	.word	0x0001b7e5
   1b734:	0001a489 	.word	0x0001a489
   1b738:	0001b7cd 	.word	0x0001b7cd

0001b73c <chip_deinit>:

sint8 chip_deinit(void)
{
   1b73c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	uint32 reg = 0;
   1b73e:	2300      	movs	r3, #0
	sint8 ret;

	/**
	stop the firmware, need a re-download
	**/
	ret = nm_read_reg_with_ret(NMI_GLB_RESET_0, &reg);
   1b740:	20a0      	movs	r0, #160	; 0xa0
	uint32 reg = 0;
   1b742:	9301      	str	r3, [sp, #4]
	ret = nm_read_reg_with_ret(NMI_GLB_RESET_0, &reg);
   1b744:	a901      	add	r1, sp, #4
   1b746:	0140      	lsls	r0, r0, #5
   1b748:	4b0d      	ldr	r3, [pc, #52]	; (1b780 <chip_deinit+0x44>)
   1b74a:	4798      	blx	r3
   1b74c:	1e04      	subs	r4, r0, #0
	if (ret != M2M_SUCCESS) {
   1b74e:	d00a      	beq.n	1b766 <chip_deinit+0x2a>
		M2M_ERR("failed to de-initialize\n");
   1b750:	4a0c      	ldr	r2, [pc, #48]	; (1b784 <chip_deinit+0x48>)
		goto ERR1;
	}
	reg &= ~(1 << 10);
	ret = nm_write_reg(NMI_GLB_RESET_0, reg);
	if (ret != M2M_SUCCESS) {
		M2M_ERR("failed to de-initialize\n");
   1b752:	490d      	ldr	r1, [pc, #52]	; (1b788 <chip_deinit+0x4c>)
   1b754:	480d      	ldr	r0, [pc, #52]	; (1b78c <chip_deinit+0x50>)
   1b756:	4d0e      	ldr	r5, [pc, #56]	; (1b790 <chip_deinit+0x54>)
   1b758:	47a8      	blx	r5
   1b75a:	480e      	ldr	r0, [pc, #56]	; (1b794 <chip_deinit+0x58>)
   1b75c:	47a8      	blx	r5
   1b75e:	480e      	ldr	r0, [pc, #56]	; (1b798 <chip_deinit+0x5c>)
   1b760:	47a8      	blx	r5
		goto ERR1;
	}

ERR1:
	return ret;
}
   1b762:	0020      	movs	r0, r4
   1b764:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
	ret = nm_write_reg(NMI_GLB_RESET_0, reg);
   1b766:	20a0      	movs	r0, #160	; 0xa0
	reg &= ~(1 << 10);
   1b768:	9b01      	ldr	r3, [sp, #4]
   1b76a:	490c      	ldr	r1, [pc, #48]	; (1b79c <chip_deinit+0x60>)
	ret = nm_write_reg(NMI_GLB_RESET_0, reg);
   1b76c:	0140      	lsls	r0, r0, #5
	reg &= ~(1 << 10);
   1b76e:	4019      	ands	r1, r3
	ret = nm_write_reg(NMI_GLB_RESET_0, reg);
   1b770:	4b0b      	ldr	r3, [pc, #44]	; (1b7a0 <chip_deinit+0x64>)
	reg &= ~(1 << 10);
   1b772:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(NMI_GLB_RESET_0, reg);
   1b774:	4798      	blx	r3
   1b776:	1e04      	subs	r4, r0, #0
	if (ret != M2M_SUCCESS) {
   1b778:	d0f3      	beq.n	1b762 <chip_deinit+0x26>
		M2M_ERR("failed to de-initialize\n");
   1b77a:	4a0a      	ldr	r2, [pc, #40]	; (1b7a4 <chip_deinit+0x68>)
   1b77c:	e7e9      	b.n	1b752 <chip_deinit+0x16>
   1b77e:	46c0      	nop			; (mov r8, r8)
   1b780:	0001b7d9 	.word	0x0001b7d9
   1b784:	00000201 	.word	0x00000201
   1b788:	0002a4bb 	.word	0x0002a4bb
   1b78c:	00029fb9 	.word	0x00029fb9
   1b790:	00019415 	.word	0x00019415
   1b794:	0002a4c7 	.word	0x0002a4c7
   1b798:	0002b325 	.word	0x0002b325
   1b79c:	fffffbff 	.word	0xfffffbff
   1b7a0:	0001b7e5 	.word	0x0001b7e5
   1b7a4:	00000207 	.word	0x00000207

0001b7a8 <nm_bus_iface_init>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_bus_iface_init(void *pvInitVal)
{
   1b7a8:	b510      	push	{r4, lr}
	sint8 ret = M2M_SUCCESS;
	ret = nm_bus_init(pvInitVal);
   1b7aa:	4b01      	ldr	r3, [pc, #4]	; (1b7b0 <nm_bus_iface_init+0x8>)
   1b7ac:	4798      	blx	r3
	return ret;
}
   1b7ae:	bd10      	pop	{r4, pc}
   1b7b0:	0001a50d 	.word	0x0001a50d

0001b7b4 <nm_bus_iface_deinit>:
*	@author	Samer Sarhan
*	@date	07 April 2014
*	@version	1.0
*/
sint8 nm_bus_iface_deinit(void)
{
   1b7b4:	b510      	push	{r4, lr}
	sint8 ret = M2M_SUCCESS;
	ret = nm_bus_deinit();
   1b7b6:	4b01      	ldr	r3, [pc, #4]	; (1b7bc <nm_bus_iface_deinit+0x8>)
   1b7b8:	4798      	blx	r3

	return ret;
}
   1b7ba:	bd10      	pop	{r4, pc}
   1b7bc:	0001a71d 	.word	0x0001a71d

0001b7c0 <nm_bus_reset>:
*	@brief	reset bus interface
*	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
*	@version	1.0
*/
sint8 nm_bus_reset(void)
{
   1b7c0:	b510      	push	{r4, lr}
	sint8 ret = M2M_SUCCESS;
#ifdef CONF_WINC_USE_UART
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_reset();
   1b7c2:	4b01      	ldr	r3, [pc, #4]	; (1b7c8 <nm_bus_reset+0x8>)
   1b7c4:	4798      	blx	r3
#else
#error "Plesae define bus usage"
#endif

	return ret;
}
   1b7c6:	bd10      	pop	{r4, pc}
   1b7c8:	0001c185 	.word	0x0001c185

0001b7cc <nm_read_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
uint32 nm_read_reg(uint32 u32Addr)
{
   1b7cc:	b510      	push	{r4, lr}
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_reg(u32Addr);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_reg(u32Addr);
   1b7ce:	4b01      	ldr	r3, [pc, #4]	; (1b7d4 <nm_read_reg+0x8>)
   1b7d0:	4798      	blx	r3
	return nm_i2c_read_reg(u32Addr);
#else
#error "Plesae define bus usage"
#endif

}
   1b7d2:	bd10      	pop	{r4, pc}
   1b7d4:	0001c1a9 	.word	0x0001c1a9

0001b7d8 <nm_read_reg_with_ret>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_read_reg_with_ret(uint32 u32Addr, uint32* pu32RetVal)
{
   1b7d8:	b510      	push	{r4, lr}
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_reg_with_ret(u32Addr,pu32RetVal);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_reg_with_ret(u32Addr,pu32RetVal);
   1b7da:	4b01      	ldr	r3, [pc, #4]	; (1b7e0 <nm_read_reg_with_ret+0x8>)
   1b7dc:	4798      	blx	r3
#elif defined (CONF_WINC_USE_I2C)
	return nm_i2c_read_reg_with_ret(u32Addr,pu32RetVal);
#else
#error "Plesae define bus usage"
#endif
}
   1b7de:	bd10      	pop	{r4, pc}
   1b7e0:	0001c1b9 	.word	0x0001c1b9

0001b7e4 <nm_write_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_write_reg(uint32 u32Addr, uint32 u32Val)
{
   1b7e4:	b510      	push	{r4, lr}
#ifdef CONF_WINC_USE_UART
	return nm_uart_write_reg(u32Addr,u32Val);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_write_reg(u32Addr,u32Val);
   1b7e6:	4b01      	ldr	r3, [pc, #4]	; (1b7ec <nm_write_reg+0x8>)
   1b7e8:	4798      	blx	r3
#elif defined (CONF_WINC_USE_I2C)
	return nm_i2c_write_reg(u32Addr,u32Val);
#else
#error "Plesae define bus usage"
#endif
}
   1b7ea:	bd10      	pop	{r4, pc}
   1b7ec:	0001c1d1 	.word	0x0001c1d1

0001b7f0 <nm_read_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/ 
sint8 nm_read_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
   1b7f0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1b7f2:	0007      	movs	r7, r0
   1b7f4:	0015      	movs	r5, r2
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
   1b7f6:	0006      	movs	r6, r0
   1b7f8:	4b0b      	ldr	r3, [pc, #44]	; (1b828 <nm_read_block+0x38>)
{
   1b7fa:	9101      	str	r1, [sp, #4]
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
   1b7fc:	881c      	ldrh	r4, [r3, #0]
   1b7fe:	3c08      	subs	r4, #8
   1b800:	b2a4      	uxth	r4, r4
   1b802:	9b01      	ldr	r3, [sp, #4]
   1b804:	1bf1      	subs	r1, r6, r7
   1b806:	1859      	adds	r1, r3, r1
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
   1b808:	42a5      	cmp	r5, r4
   1b80a:	d804      	bhi.n	1b816 <nm_read_block+0x26>
	return nm_spi_read_block(u32Addr,puBuf,u16Sz);
   1b80c:	b2aa      	uxth	r2, r5
   1b80e:	0030      	movs	r0, r6
   1b810:	4b06      	ldr	r3, [pc, #24]	; (1b82c <nm_read_block+0x3c>)
   1b812:	4798      	blx	r3
			u32Addr += u16MaxTrxSz;
		}
	}

	return s8Ret;
}
   1b814:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	return nm_spi_read_block(u32Addr,puBuf,u16Sz);
   1b816:	0022      	movs	r2, r4
   1b818:	0030      	movs	r0, r6
   1b81a:	4b04      	ldr	r3, [pc, #16]	; (1b82c <nm_read_block+0x3c>)
   1b81c:	4798      	blx	r3
			if(M2M_SUCCESS != s8Ret) break;
   1b81e:	2800      	cmp	r0, #0
   1b820:	d1f8      	bne.n	1b814 <nm_read_block+0x24>
   1b822:	1b2d      	subs	r5, r5, r4
   1b824:	1936      	adds	r6, r6, r4
		if(u32Sz <= u16MaxTrxSz)
   1b826:	e7ec      	b.n	1b802 <nm_read_block+0x12>
   1b828:	20000208 	.word	0x20000208
   1b82c:	0001c2e9 	.word	0x0001c2e9

0001b830 <nm_write_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/ 
sint8 nm_write_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
   1b830:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1b832:	0007      	movs	r7, r0
   1b834:	0015      	movs	r5, r2
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
   1b836:	0006      	movs	r6, r0
   1b838:	4b0b      	ldr	r3, [pc, #44]	; (1b868 <nm_write_block+0x38>)
{
   1b83a:	9101      	str	r1, [sp, #4]
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
   1b83c:	881c      	ldrh	r4, [r3, #0]
   1b83e:	3c08      	subs	r4, #8
   1b840:	b2a4      	uxth	r4, r4
   1b842:	9b01      	ldr	r3, [sp, #4]
   1b844:	1bf1      	subs	r1, r6, r7
   1b846:	1859      	adds	r1, r3, r1
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
   1b848:	42a5      	cmp	r5, r4
   1b84a:	d804      	bhi.n	1b856 <nm_write_block+0x26>
	return nm_spi_write_block(u32Addr,puBuf,u16Sz);
   1b84c:	b2aa      	uxth	r2, r5
   1b84e:	0030      	movs	r0, r6
   1b850:	4b06      	ldr	r3, [pc, #24]	; (1b86c <nm_write_block+0x3c>)
   1b852:	4798      	blx	r3
			u32Addr += u16MaxTrxSz;
		}
	}

	return s8Ret;
}
   1b854:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	return nm_spi_write_block(u32Addr,puBuf,u16Sz);
   1b856:	0022      	movs	r2, r4
   1b858:	0030      	movs	r0, r6
   1b85a:	4b04      	ldr	r3, [pc, #16]	; (1b86c <nm_write_block+0x3c>)
   1b85c:	4798      	blx	r3
			if(M2M_SUCCESS != s8Ret) break;
   1b85e:	2800      	cmp	r0, #0
   1b860:	d1f8      	bne.n	1b854 <nm_write_block+0x24>
   1b862:	1b2d      	subs	r5, r5, r4
   1b864:	1936      	adds	r6, r6, r4
		if(u32Sz <= u16MaxTrxSz)
   1b866:	e7ec      	b.n	1b842 <nm_write_block+0x12>
   1b868:	20000208 	.word	0x20000208
   1b86c:	0001c38d 	.word	0x0001c38d

0001b870 <nm_get_firmware_full_info>:
*	@param [out]	M2mRev
*			    pointer holds address of structure "tstrM2mRev" that contains the firmware version parameters
*	@version	1.0
*/
sint8 nm_get_firmware_full_info(tstrM2mRev* pstrRev)
{
   1b870:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	uint16  curr_drv_ver, min_req_drv_ver,curr_firm_ver;
	uint32	reg = 0;
   1b872:	2500      	movs	r5, #0
{
   1b874:	0004      	movs	r4, r0
	sint8	ret = M2M_SUCCESS;
	tstrGpRegs strgp = {0};
   1b876:	2208      	movs	r2, #8
   1b878:	0029      	movs	r1, r5
   1b87a:	a802      	add	r0, sp, #8
   1b87c:	4b26      	ldr	r3, [pc, #152]	; (1b918 <nm_get_firmware_full_info+0xa8>)
	uint32	reg = 0;
   1b87e:	9501      	str	r5, [sp, #4]
	tstrGpRegs strgp = {0};
   1b880:	4798      	blx	r3
	if (pstrRev != NULL)
   1b882:	42ac      	cmp	r4, r5
   1b884:	d102      	bne.n	1b88c <nm_get_firmware_full_info+0x1c>
	sint8	ret = M2M_SUCCESS;
   1b886:	2000      	movs	r0, #0
			}
		}
	}
EXIT:
	return ret;
}
   1b888:	b004      	add	sp, #16
   1b88a:	bd70      	pop	{r4, r5, r6, pc}
		m2m_memset((uint8*)pstrRev,0,sizeof(tstrM2mRev));
   1b88c:	0029      	movs	r1, r5
   1b88e:	0020      	movs	r0, r4
   1b890:	4b22      	ldr	r3, [pc, #136]	; (1b91c <nm_get_firmware_full_info+0xac>)
   1b892:	2228      	movs	r2, #40	; 0x28
   1b894:	4798      	blx	r3
		ret = nm_read_reg_with_ret(rNMI_GP_REG_2, &reg);
   1b896:	a901      	add	r1, sp, #4
   1b898:	4821      	ldr	r0, [pc, #132]	; (1b920 <nm_get_firmware_full_info+0xb0>)
   1b89a:	4b22      	ldr	r3, [pc, #136]	; (1b924 <nm_get_firmware_full_info+0xb4>)
   1b89c:	4798      	blx	r3
		if(ret == M2M_SUCCESS)
   1b89e:	2800      	cmp	r0, #0
   1b8a0:	d1f2      	bne.n	1b888 <nm_get_firmware_full_info+0x18>
			if(reg != 0)
   1b8a2:	9801      	ldr	r0, [sp, #4]
   1b8a4:	2800      	cmp	r0, #0
   1b8a6:	d102      	bne.n	1b8ae <nm_get_firmware_full_info+0x3e>
				ret = M2M_ERR_FAIL;
   1b8a8:	200c      	movs	r0, #12
								ret = M2M_ERR_FW_VER_MISMATCH;
   1b8aa:	4240      	negs	r0, r0
   1b8ac:	e7ec      	b.n	1b888 <nm_get_firmware_full_info+0x18>
				ret = nm_read_block(reg|0x30000,(uint8*)&strgp,sizeof(tstrGpRegs));
   1b8ae:	25c0      	movs	r5, #192	; 0xc0
   1b8b0:	02ad      	lsls	r5, r5, #10
   1b8b2:	4328      	orrs	r0, r5
   1b8b4:	2208      	movs	r2, #8
   1b8b6:	a902      	add	r1, sp, #8
   1b8b8:	4e1b      	ldr	r6, [pc, #108]	; (1b928 <nm_get_firmware_full_info+0xb8>)
   1b8ba:	47b0      	blx	r6
				if(ret == M2M_SUCCESS)
   1b8bc:	2800      	cmp	r0, #0
   1b8be:	d1e3      	bne.n	1b888 <nm_get_firmware_full_info+0x18>
					reg &= 0x0000ffff;
   1b8c0:	9803      	ldr	r0, [sp, #12]
   1b8c2:	b280      	uxth	r0, r0
   1b8c4:	9001      	str	r0, [sp, #4]
					if(reg != 0)
   1b8c6:	2800      	cmp	r0, #0
   1b8c8:	d0ee      	beq.n	1b8a8 <nm_get_firmware_full_info+0x38>
						ret = nm_read_block(reg|0x30000,(uint8*)pstrRev,sizeof(tstrM2mRev));
   1b8ca:	4328      	orrs	r0, r5
   1b8cc:	2228      	movs	r2, #40	; 0x28
   1b8ce:	0021      	movs	r1, r4
   1b8d0:	47b0      	blx	r6
						if(ret == M2M_SUCCESS)
   1b8d2:	2800      	cmp	r0, #0
   1b8d4:	d1d8      	bne.n	1b888 <nm_get_firmware_full_info+0x18>
							curr_firm_ver   = M2M_MAKE_VERSION(pstrRev->u8FirmwareMajor, pstrRev->u8FirmwareMinor,pstrRev->u8FirmwarePatch);
   1b8d6:	210f      	movs	r1, #15
   1b8d8:	25ff      	movs	r5, #255	; 0xff
   1b8da:	7922      	ldrb	r2, [r4, #4]
   1b8dc:	79a3      	ldrb	r3, [r4, #6]
   1b8de:	7960      	ldrb	r0, [r4, #5]
   1b8e0:	0212      	lsls	r2, r2, #8
   1b8e2:	400b      	ands	r3, r1
   1b8e4:	4313      	orrs	r3, r2
   1b8e6:	0100      	lsls	r0, r0, #4
							min_req_drv_ver = M2M_MAKE_VERSION(pstrRev->u8DriverMajor, pstrRev->u8DriverMinor,pstrRev->u8DriverPatch);
   1b8e8:	7a62      	ldrb	r2, [r4, #9]
							curr_firm_ver   = M2M_MAKE_VERSION(pstrRev->u8FirmwareMajor, pstrRev->u8FirmwareMinor,pstrRev->u8FirmwarePatch);
   1b8ea:	4028      	ands	r0, r5
							min_req_drv_ver = M2M_MAKE_VERSION(pstrRev->u8DriverMajor, pstrRev->u8DriverMinor,pstrRev->u8DriverPatch);
   1b8ec:	400a      	ands	r2, r1
							curr_firm_ver   = M2M_MAKE_VERSION(pstrRev->u8FirmwareMajor, pstrRev->u8FirmwareMinor,pstrRev->u8FirmwarePatch);
   1b8ee:	4303      	orrs	r3, r0
							min_req_drv_ver = M2M_MAKE_VERSION(pstrRev->u8DriverMajor, pstrRev->u8DriverMinor,pstrRev->u8DriverPatch);
   1b8f0:	7a21      	ldrb	r1, [r4, #8]
   1b8f2:	79e0      	ldrb	r0, [r4, #7]
   1b8f4:	0109      	lsls	r1, r1, #4
   1b8f6:	0200      	lsls	r0, r0, #8
   1b8f8:	4302      	orrs	r2, r0
   1b8fa:	4029      	ands	r1, r5
   1b8fc:	430a      	orrs	r2, r1
							if((curr_firm_ver == 0)||(min_req_drv_ver == 0)||(min_req_drv_ver == 0)){
   1b8fe:	2b00      	cmp	r3, #0
   1b900:	d0d2      	beq.n	1b8a8 <nm_get_firmware_full_info+0x38>
   1b902:	2a00      	cmp	r2, #0
   1b904:	d0d0      	beq.n	1b8a8 <nm_get_firmware_full_info+0x38>
							if(curr_drv_ver <  min_req_drv_ver) {
   1b906:	4909      	ldr	r1, [pc, #36]	; (1b92c <nm_get_firmware_full_info+0xbc>)
   1b908:	428a      	cmp	r2, r1
   1b90a:	d802      	bhi.n	1b912 <nm_get_firmware_full_info+0xa2>
							if(curr_drv_ver >  curr_firm_ver) {
   1b90c:	4a08      	ldr	r2, [pc, #32]	; (1b930 <nm_get_firmware_full_info+0xc0>)
   1b90e:	4293      	cmp	r3, r2
   1b910:	d8b9      	bhi.n	1b886 <nm_get_firmware_full_info+0x16>
								ret = M2M_ERR_FW_VER_MISMATCH;
   1b912:	200d      	movs	r0, #13
   1b914:	e7c9      	b.n	1b8aa <nm_get_firmware_full_info+0x3a>
   1b916:	46c0      	nop			; (mov r8, r8)
   1b918:	00022c47 	.word	0x00022c47
   1b91c:	0001a797 	.word	0x0001a797
   1b920:	000c0008 	.word	0x000c0008
   1b924:	0001b7d9 	.word	0x0001b7d9
   1b928:	0001b7f1 	.word	0x0001b7f1
   1b92c:	00001354 	.word	0x00001354
   1b930:	00001353 	.word	0x00001353

0001b934 <nm_drv_init>:
*	@author	M. Abdelmawla
*	@date	15 July 2012
*	@version	1.0
*/
sint8 nm_drv_init(void * arg)
{
   1b934:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		u8Mode = *((uint8 *)arg);
		if((u8Mode < M2M_WIFI_MODE_NORMAL)||(u8Mode >= M2M_WIFI_MODE_MAX)) {
			u8Mode = M2M_WIFI_MODE_NORMAL;
		}
	} else {
		u8Mode = M2M_WIFI_MODE_NORMAL;
   1b936:	2501      	movs	r5, #1
	if(NULL != arg) {
   1b938:	2800      	cmp	r0, #0
   1b93a:	d004      	beq.n	1b946 <nm_drv_init+0x12>
		u8Mode = *((uint8 *)arg);
   1b93c:	7805      	ldrb	r5, [r0, #0]
		if((u8Mode < M2M_WIFI_MODE_NORMAL)||(u8Mode >= M2M_WIFI_MODE_MAX)) {
   1b93e:	1e6b      	subs	r3, r5, #1
   1b940:	2b03      	cmp	r3, #3
   1b942:	d900      	bls.n	1b946 <nm_drv_init+0x12>
		u8Mode = M2M_WIFI_MODE_NORMAL;
   1b944:	2501      	movs	r5, #1
	}
	
	ret = nm_bus_iface_init(NULL);
   1b946:	2000      	movs	r0, #0
   1b948:	4b1c      	ldr	r3, [pc, #112]	; (1b9bc <nm_drv_init+0x88>)
   1b94a:	4798      	blx	r3
   1b94c:	4c1c      	ldr	r4, [pc, #112]	; (1b9c0 <nm_drv_init+0x8c>)
   1b94e:	1e06      	subs	r6, r0, #0
   1b950:	4f1c      	ldr	r7, [pc, #112]	; (1b9c4 <nm_drv_init+0x90>)
	if (M2M_SUCCESS != ret) {
   1b952:	d00a      	beq.n	1b96a <nm_drv_init+0x36>
		M2M_ERR("[nmi start]: fail init bus\n");
   1b954:	2290      	movs	r2, #144	; 0x90
   1b956:	491c      	ldr	r1, [pc, #112]	; (1b9c8 <nm_drv_init+0x94>)
   1b958:	0052      	lsls	r2, r2, #1
   1b95a:	481c      	ldr	r0, [pc, #112]	; (1b9cc <nm_drv_init+0x98>)
   1b95c:	47a0      	blx	r4
   1b95e:	481c      	ldr	r0, [pc, #112]	; (1b9d0 <nm_drv_init+0x9c>)
   1b960:	47a0      	blx	r4
   1b962:	0038      	movs	r0, r7
   1b964:	47a0      	blx	r4
	return ret;
ERR2:
	nm_bus_iface_deinit();
ERR1:
	return ret;
}
   1b966:	0030      	movs	r0, r6
   1b968:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	M2M_INFO("Chip ID %lx\n", nmi_get_chipid());
   1b96a:	481a      	ldr	r0, [pc, #104]	; (1b9d4 <nm_drv_init+0xa0>)
   1b96c:	47a0      	blx	r4
   1b96e:	4b1a      	ldr	r3, [pc, #104]	; (1b9d8 <nm_drv_init+0xa4>)
   1b970:	4798      	blx	r3
   1b972:	0001      	movs	r1, r0
   1b974:	4819      	ldr	r0, [pc, #100]	; (1b9dc <nm_drv_init+0xa8>)
   1b976:	47a0      	blx	r4
   1b978:	0038      	movs	r0, r7
   1b97a:	47a0      	blx	r4
	nm_spi_init();
   1b97c:	4b18      	ldr	r3, [pc, #96]	; (1b9e0 <nm_drv_init+0xac>)
   1b97e:	4798      	blx	r3
	ret = wait_for_bootrom(u8Mode);
   1b980:	0028      	movs	r0, r5
   1b982:	4b18      	ldr	r3, [pc, #96]	; (1b9e4 <nm_drv_init+0xb0>)
   1b984:	4798      	blx	r3
   1b986:	1e06      	subs	r6, r0, #0
	if (M2M_SUCCESS != ret) {
   1b988:	d115      	bne.n	1b9b6 <nm_drv_init+0x82>
	ret = wait_for_firmware_start(u8Mode);
   1b98a:	0028      	movs	r0, r5
   1b98c:	4b16      	ldr	r3, [pc, #88]	; (1b9e8 <nm_drv_init+0xb4>)
   1b98e:	4798      	blx	r3
   1b990:	1e06      	subs	r6, r0, #0
	if (M2M_SUCCESS != ret) {
   1b992:	d110      	bne.n	1b9b6 <nm_drv_init+0x82>
	if((M2M_WIFI_MODE_ATE_HIGH == u8Mode)||(M2M_WIFI_MODE_ATE_LOW == u8Mode)) {
   1b994:	3d02      	subs	r5, #2
   1b996:	2d01      	cmp	r5, #1
   1b998:	d9e5      	bls.n	1b966 <nm_drv_init+0x32>
	ret = enable_interrupts();
   1b99a:	4b14      	ldr	r3, [pc, #80]	; (1b9ec <nm_drv_init+0xb8>)
   1b99c:	4798      	blx	r3
   1b99e:	1e05      	subs	r5, r0, #0
	if (M2M_SUCCESS != ret) {
   1b9a0:	d0e1      	beq.n	1b966 <nm_drv_init+0x32>
		M2M_ERR("failed to enable interrupts..\n");
   1b9a2:	22a7      	movs	r2, #167	; 0xa7
   1b9a4:	4908      	ldr	r1, [pc, #32]	; (1b9c8 <nm_drv_init+0x94>)
   1b9a6:	0052      	lsls	r2, r2, #1
   1b9a8:	4808      	ldr	r0, [pc, #32]	; (1b9cc <nm_drv_init+0x98>)
   1b9aa:	47a0      	blx	r4
   1b9ac:	4810      	ldr	r0, [pc, #64]	; (1b9f0 <nm_drv_init+0xbc>)
   1b9ae:	47a0      	blx	r4
   1b9b0:	0038      	movs	r0, r7
   1b9b2:	47a0      	blx	r4
		goto ERR2;
   1b9b4:	002e      	movs	r6, r5
	nm_bus_iface_deinit();
   1b9b6:	4b0f      	ldr	r3, [pc, #60]	; (1b9f4 <nm_drv_init+0xc0>)
   1b9b8:	4798      	blx	r3
   1b9ba:	e7d4      	b.n	1b966 <nm_drv_init+0x32>
   1b9bc:	0001b7a9 	.word	0x0001b7a9
   1b9c0:	00019415 	.word	0x00019415
   1b9c4:	0002b325 	.word	0x0002b325
   1b9c8:	0002a528 	.word	0x0002a528
   1b9cc:	00029fb9 	.word	0x00029fb9
   1b9d0:	0002a5be 	.word	0x0002a5be
   1b9d4:	0002a2b4 	.word	0x0002a2b4
   1b9d8:	0001b419 	.word	0x0001b419
   1b9dc:	0002a5da 	.word	0x0002a5da
   1b9e0:	0001c1e9 	.word	0x0001c1e9
   1b9e4:	0001b5ed 	.word	0x0001b5ed
   1b9e8:	0001b6d1 	.word	0x0001b6d1
   1b9ec:	0001b3c9 	.word	0x0001b3c9
   1b9f0:	0002a59f 	.word	0x0002a59f
   1b9f4:	0001b7b5 	.word	0x0001b7b5

0001b9f8 <nm_drv_deinit>:
*	@author	M. Abdelmawla
*	@date	17 July 2012
*	@version	1.0
*/
sint8 nm_drv_deinit(void * arg)
{
   1b9f8:	b570      	push	{r4, r5, r6, lr}
	sint8 ret;

	ret = chip_deinit();
   1b9fa:	4b15      	ldr	r3, [pc, #84]	; (1ba50 <nm_drv_deinit+0x58>)
   1b9fc:	4798      	blx	r3
   1b9fe:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
   1ba00:	d00b      	beq.n	1ba1a <nm_drv_deinit+0x22>
		M2M_ERR("[nmi stop]: chip_deinit fail\n");
   1ba02:	2266      	movs	r2, #102	; 0x66
   1ba04:	4813      	ldr	r0, [pc, #76]	; (1ba54 <nm_drv_deinit+0x5c>)
   1ba06:	32ff      	adds	r2, #255	; 0xff
   1ba08:	4913      	ldr	r1, [pc, #76]	; (1ba58 <nm_drv_deinit+0x60>)
   1ba0a:	4d14      	ldr	r5, [pc, #80]	; (1ba5c <nm_drv_deinit+0x64>)
   1ba0c:	47a8      	blx	r5
   1ba0e:	4814      	ldr	r0, [pc, #80]	; (1ba60 <nm_drv_deinit+0x68>)
	}
	
	/* Disable SPI flash to save power when the chip is off */
	ret = spi_flash_enable(0);
	if (M2M_SUCCESS != ret) {
		M2M_ERR("[nmi stop]: SPI flash disable fail\n");
   1ba10:	47a8      	blx	r5
   1ba12:	4814      	ldr	r0, [pc, #80]	; (1ba64 <nm_drv_deinit+0x6c>)
   1ba14:	47a8      	blx	r5
	nm_spi_deinit();
#endif

ERR1:
	return ret;
}
   1ba16:	0020      	movs	r0, r4
   1ba18:	bd70      	pop	{r4, r5, r6, pc}
	ret = spi_flash_enable(0);
   1ba1a:	4b13      	ldr	r3, [pc, #76]	; (1ba68 <nm_drv_deinit+0x70>)
   1ba1c:	4798      	blx	r3
   1ba1e:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
   1ba20:	d007      	beq.n	1ba32 <nm_drv_deinit+0x3a>
		M2M_ERR("[nmi stop]: SPI flash disable fail\n");
   1ba22:	22b6      	movs	r2, #182	; 0xb6
   1ba24:	480b      	ldr	r0, [pc, #44]	; (1ba54 <nm_drv_deinit+0x5c>)
   1ba26:	0052      	lsls	r2, r2, #1
   1ba28:	490b      	ldr	r1, [pc, #44]	; (1ba58 <nm_drv_deinit+0x60>)
   1ba2a:	4d0c      	ldr	r5, [pc, #48]	; (1ba5c <nm_drv_deinit+0x64>)
   1ba2c:	47a8      	blx	r5
   1ba2e:	480f      	ldr	r0, [pc, #60]	; (1ba6c <nm_drv_deinit+0x74>)
   1ba30:	e7ee      	b.n	1ba10 <nm_drv_deinit+0x18>
	ret = nm_bus_iface_deinit();
   1ba32:	4b0f      	ldr	r3, [pc, #60]	; (1ba70 <nm_drv_deinit+0x78>)
   1ba34:	4798      	blx	r3
   1ba36:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
   1ba38:	d007      	beq.n	1ba4a <nm_drv_deinit+0x52>
		M2M_ERR("[nmi stop]: fail init bus\n");
   1ba3a:	22b9      	movs	r2, #185	; 0xb9
   1ba3c:	4805      	ldr	r0, [pc, #20]	; (1ba54 <nm_drv_deinit+0x5c>)
   1ba3e:	0052      	lsls	r2, r2, #1
   1ba40:	4905      	ldr	r1, [pc, #20]	; (1ba58 <nm_drv_deinit+0x60>)
   1ba42:	4d06      	ldr	r5, [pc, #24]	; (1ba5c <nm_drv_deinit+0x64>)
   1ba44:	47a8      	blx	r5
   1ba46:	480b      	ldr	r0, [pc, #44]	; (1ba74 <nm_drv_deinit+0x7c>)
   1ba48:	e7e2      	b.n	1ba10 <nm_drv_deinit+0x18>
	nm_spi_deinit();
   1ba4a:	4b0b      	ldr	r3, [pc, #44]	; (1ba78 <nm_drv_deinit+0x80>)
   1ba4c:	4798      	blx	r3
   1ba4e:	e7e2      	b.n	1ba16 <nm_drv_deinit+0x1e>
   1ba50:	0001b73d 	.word	0x0001b73d
   1ba54:	00029fb9 	.word	0x00029fb9
   1ba58:	0002a534 	.word	0x0002a534
   1ba5c:	00019415 	.word	0x00019415
   1ba60:	0002a542 	.word	0x0002a542
   1ba64:	0002b325 	.word	0x0002b325
   1ba68:	0001cd2d 	.word	0x0001cd2d
   1ba6c:	0002a560 	.word	0x0002a560
   1ba70:	0001b7b5 	.word	0x0001b7b5
   1ba74:	0002a584 	.word	0x0002a584
   1ba78:	0001c19d 	.word	0x0001c19d

0001ba7c <nmi_spi_write>:
	spi.u16Sz = sz;
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
}

static sint8 nmi_spi_write(uint8* b, uint16 sz)
{
   1ba7c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	tstrNmSpiRw spi;
	spi.pu8InBuf = b;
	spi.pu8OutBuf = NULL;
   1ba7e:	2200      	movs	r2, #0
	spi.pu8InBuf = b;
   1ba80:	ab01      	add	r3, sp, #4
   1ba82:	9001      	str	r0, [sp, #4]
	spi.u16Sz = sz;
   1ba84:	8119      	strh	r1, [r3, #8]
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
   1ba86:	2003      	movs	r0, #3
   1ba88:	0019      	movs	r1, r3
   1ba8a:	4b02      	ldr	r3, [pc, #8]	; (1ba94 <nmi_spi_write+0x18>)
	spi.pu8OutBuf = NULL;
   1ba8c:	9202      	str	r2, [sp, #8]
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
   1ba8e:	4798      	blx	r3
}
   1ba90:	b005      	add	sp, #20
   1ba92:	bd00      	pop	{pc}
   1ba94:	0001a60d 	.word	0x0001a60d

0001ba98 <nmi_spi_read>:
{
   1ba98:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	spi.pu8InBuf = NULL;
   1ba9a:	2200      	movs	r2, #0
   1ba9c:	ab01      	add	r3, sp, #4
	spi.pu8OutBuf = b;
   1ba9e:	9002      	str	r0, [sp, #8]
	spi.u16Sz = sz;
   1baa0:	8119      	strh	r1, [r3, #8]
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
   1baa2:	2003      	movs	r0, #3
   1baa4:	0019      	movs	r1, r3
   1baa6:	4b02      	ldr	r3, [pc, #8]	; (1bab0 <nmi_spi_read+0x18>)
	spi.pu8InBuf = NULL;
   1baa8:	9201      	str	r2, [sp, #4]
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
   1baaa:	4798      	blx	r3
}
   1baac:	b005      	add	sp, #20
   1baae:	bd00      	pop	{pc}
   1bab0:	0001a60d 	.word	0x0001a60d

0001bab4 <spi_cmd_rsp.constprop.1>:
_fail_:

	return result;
}

static sint8 spi_cmd_rsp(uint8 cmd)
   1bab4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
		Command/Control response
	**/
	if ((cmd == CMD_RESET) ||
		 (cmd == CMD_TERMINATE) ||
		 (cmd == CMD_REPEAT)) {
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
   1bab6:	466b      	mov	r3, sp
   1bab8:	1ddd      	adds	r5, r3, #7
   1baba:	2101      	movs	r1, #1
   1babc:	0028      	movs	r0, r5
   1babe:	4e1d      	ldr	r6, [pc, #116]	; (1bb34 <spi_cmd_rsp.constprop.1+0x80>)
   1bac0:	47b0      	blx	r6
   1bac2:	1e04      	subs	r4, r0, #0
   1bac4:	d128      	bne.n	1bb18 <spi_cmd_rsp.constprop.1+0x64>
   1bac6:	270b      	movs	r7, #11

	/* wait for response */
	s8RetryCnt = SPI_RESP_RETRY_COUNT;
	do
	{
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
   1bac8:	2101      	movs	r1, #1
   1baca:	0028      	movs	r0, r5
   1bacc:	47b0      	blx	r6
   1bace:	2800      	cmp	r0, #0
   1bad0:	d00b      	beq.n	1baea <spi_cmd_rsp.constprop.1+0x36>
			M2M_ERR("[nmi spi]: Failed cmd response read, bus error...\n");
   1bad2:	225c      	movs	r2, #92	; 0x5c
   1bad4:	4918      	ldr	r1, [pc, #96]	; (1bb38 <spi_cmd_rsp.constprop.1+0x84>)
   1bad6:	32ff      	adds	r2, #255	; 0xff
   1bad8:	4818      	ldr	r0, [pc, #96]	; (1bb3c <spi_cmd_rsp.constprop.1+0x88>)
   1bada:	4d19      	ldr	r5, [pc, #100]	; (1bb40 <spi_cmd_rsp.constprop.1+0x8c>)
   1badc:	47a8      	blx	r5
   1bade:	4819      	ldr	r0, [pc, #100]	; (1bb44 <spi_cmd_rsp.constprop.1+0x90>)
   1bae0:	47a8      	blx	r5
   1bae2:	4819      	ldr	r0, [pc, #100]	; (1bb48 <spi_cmd_rsp.constprop.1+0x94>)
   1bae4:	47a8      	blx	r5
	} while((rsp != 0x00) && (s8RetryCnt-- >0));

_fail_:

	return result;
}
   1bae6:	0020      	movs	r0, r4
   1bae8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	} while((rsp != cmd) && (s8RetryCnt-- >0));
   1baea:	782b      	ldrb	r3, [r5, #0]
   1baec:	2bcf      	cmp	r3, #207	; 0xcf
   1baee:	d003      	beq.n	1baf8 <spi_cmd_rsp.constprop.1+0x44>
   1baf0:	3f01      	subs	r7, #1
   1baf2:	b2ff      	uxtb	r7, r7
   1baf4:	2f00      	cmp	r7, #0
   1baf6:	d1e7      	bne.n	1bac8 <spi_cmd_rsp.constprop.1+0x14>
   1baf8:	240b      	movs	r4, #11
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
   1bafa:	2101      	movs	r1, #1
   1bafc:	0028      	movs	r0, r5
   1bafe:	47b0      	blx	r6
   1bb00:	2800      	cmp	r0, #0
   1bb02:	d00b      	beq.n	1bb1c <spi_cmd_rsp.constprop.1+0x68>
			M2M_ERR("[nmi spi]: Failed cmd response read, bus error...\n");
   1bb04:	226a      	movs	r2, #106	; 0x6a
   1bb06:	490c      	ldr	r1, [pc, #48]	; (1bb38 <spi_cmd_rsp.constprop.1+0x84>)
   1bb08:	32ff      	adds	r2, #255	; 0xff
   1bb0a:	480c      	ldr	r0, [pc, #48]	; (1bb3c <spi_cmd_rsp.constprop.1+0x88>)
   1bb0c:	4c0c      	ldr	r4, [pc, #48]	; (1bb40 <spi_cmd_rsp.constprop.1+0x8c>)
   1bb0e:	47a0      	blx	r4
   1bb10:	480c      	ldr	r0, [pc, #48]	; (1bb44 <spi_cmd_rsp.constprop.1+0x90>)
   1bb12:	47a0      	blx	r4
   1bb14:	480c      	ldr	r0, [pc, #48]	; (1bb48 <spi_cmd_rsp.constprop.1+0x94>)
   1bb16:	47a0      	blx	r4
			result = N_FAIL;
   1bb18:	2400      	movs	r4, #0
   1bb1a:	e7e4      	b.n	1bae6 <spi_cmd_rsp.constprop.1+0x32>
	} while((rsp != 0x00) && (s8RetryCnt-- >0));
   1bb1c:	782b      	ldrb	r3, [r5, #0]
   1bb1e:	2b00      	cmp	r3, #0
   1bb20:	d005      	beq.n	1bb2e <spi_cmd_rsp.constprop.1+0x7a>
   1bb22:	3c01      	subs	r4, #1
   1bb24:	b2e4      	uxtb	r4, r4
   1bb26:	2c00      	cmp	r4, #0
   1bb28:	d1e7      	bne.n	1bafa <spi_cmd_rsp.constprop.1+0x46>
	sint8 result = N_OK;
   1bb2a:	3401      	adds	r4, #1
   1bb2c:	e7db      	b.n	1bae6 <spi_cmd_rsp.constprop.1+0x32>
   1bb2e:	2401      	movs	r4, #1
   1bb30:	e7d9      	b.n	1bae6 <spi_cmd_rsp.constprop.1+0x32>
   1bb32:	46c0      	nop			; (mov r8, r8)
   1bb34:	0001ba99 	.word	0x0001ba99
   1bb38:	0002a603 	.word	0x0002a603
   1bb3c:	00029fb9 	.word	0x00029fb9
   1bb40:	00019415 	.word	0x00019415
   1bb44:	0002ab87 	.word	0x0002ab87
   1bb48:	0002b325 	.word	0x0002b325

0001bb4c <spi_cmd_complete>:
#ifndef USE_OLD_SPI_SW
static int spi_cmd_complete(uint8_t cmd, uint32_t adr, uint8_t *b, uint32_t sz, uint8_t clockless)
{
   1bb4c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1bb4e:	b097      	sub	sp, #92	; 0x5c
   1bb50:	9301      	str	r3, [sp, #4]
   1bb52:	ab1c      	add	r3, sp, #112	; 0x70
   1bb54:	781c      	ldrb	r4, [r3, #0]
	uint32_t len2;
	uint8_t rsp;
	int len = 0;
	int result = N_OK;

	wb[0] = cmd;
   1bb56:	ab06      	add	r3, sp, #24
{
   1bb58:	0005      	movs	r5, r0
	wb[0] = cmd;
   1bb5a:	7018      	strb	r0, [r3, #0]
	switch (cmd) {
   1bb5c:	38c1      	subs	r0, #193	; 0xc1
{
   1bb5e:	9200      	str	r2, [sp, #0]
	switch (cmd) {
   1bb60:	280e      	cmp	r0, #14
   1bb62:	d900      	bls.n	1bb66 <spi_cmd_complete+0x1a>
   1bb64:	e0cd      	b.n	1bd02 <spi_cmd_complete+0x1b6>
   1bb66:	f009 fe9f 	bl	258a8 <__gnu_thumb1_case_uqi>
   1bb6a:	2929      	.short	0x2929
   1bb6c:	23231646 	.word	0x23231646
   1bb70:	085c3636 	.word	0x085c3636
   1bb74:	cccccccc 	.word	0xcccccccc
   1bb78:	27          	.byte	0x27
   1bb79:	00          	.byte	0x00
	case CMD_SINGLE_READ:				/* single word (4 bytes) read */
		wb[1] = (uint8_t)(adr >> 16);
   1bb7a:	0c0a      	lsrs	r2, r1, #16
   1bb7c:	705a      	strb	r2, [r3, #1]
		wb[2] = (uint8_t)(adr >> 8);
   1bb7e:	0a0a      	lsrs	r2, r1, #8
   1bb80:	709a      	strb	r2, [r3, #2]
		wb[3] = (uint8_t)adr;
   1bb82:	70d9      	strb	r1, [r3, #3]
		break;
	case CMD_RESET:							/* reset */
		wb[1] = 0xff;
		wb[2] = 0xff;
		wb[3] = 0xff;
		len = 5;
   1bb84:	2405      	movs	r4, #5

	if (result != N_OK) {
		return result;
	}

	if (!gu8Crc_off) {
   1bb86:	4ac0      	ldr	r2, [pc, #768]	; (1be88 <spi_cmd_complete+0x33c>)
   1bb88:	7811      	ldrb	r1, [r2, #0]
   1bb8a:	1e62      	subs	r2, r4, #1
   1bb8c:	4694      	mov	ip, r2
   1bb8e:	2900      	cmp	r1, #0
   1bb90:	d05a      	beq.n	1bc48 <spi_cmd_complete+0xfc>
		wb[len-1] = (crc7(0x7f, (const uint8_t *)&wb[0], len-1)) << 1;
	} else {
		len -=1;
   1bb92:	4664      	mov	r4, ip
   1bb94:	e061      	b.n	1bc5a <spi_cmd_complete+0x10e>
		wb[1] = (uint8_t)(adr >> 8);
   1bb96:	0a0a      	lsrs	r2, r1, #8
   1bb98:	b2d2      	uxtb	r2, r2
		if(clockless == 1)  wb[1] |= (1 << 7);
   1bb9a:	2c01      	cmp	r4, #1
   1bb9c:	d004      	beq.n	1bba8 <spi_cmd_complete+0x5c>
   1bb9e:	705a      	strb	r2, [r3, #1]
		wb[3] = 0x00;
   1bba0:	2200      	movs	r2, #0
		wb[2] = (uint8_t)adr;
   1bba2:	7099      	strb	r1, [r3, #2]
		wb[3] = 0xff;
   1bba4:	70da      	strb	r2, [r3, #3]
   1bba6:	e7ed      	b.n	1bb84 <spi_cmd_complete+0x38>
		if(clockless == 1)  wb[1] |= (1 << 7);
   1bba8:	2080      	movs	r0, #128	; 0x80
   1bbaa:	4240      	negs	r0, r0
   1bbac:	4302      	orrs	r2, r0
   1bbae:	e7f6      	b.n	1bb9e <spi_cmd_complete+0x52>
		wb[1] = 0x00;
   1bbb0:	2200      	movs	r2, #0
		wb[1] = 0xff;
   1bbb2:	705a      	strb	r2, [r3, #1]
		wb[2] = 0xff;
   1bbb4:	709a      	strb	r2, [r3, #2]
   1bbb6:	e7f5      	b.n	1bba4 <spi_cmd_complete+0x58>
		wb[1] = 0xff;
   1bbb8:	22ff      	movs	r2, #255	; 0xff
   1bbba:	e7fa      	b.n	1bbb2 <spi_cmd_complete+0x66>
		wb[1] = (uint8_t)(adr >> 16);
   1bbbc:	0c0a      	lsrs	r2, r1, #16
   1bbbe:	705a      	strb	r2, [r3, #1]
		wb[2] = (uint8_t)(adr >> 8);
   1bbc0:	0a0a      	lsrs	r2, r1, #8
   1bbc2:	709a      	strb	r2, [r3, #2]
		wb[4] = (uint8_t)(sz >> 8);
   1bbc4:	9a01      	ldr	r2, [sp, #4]
		wb[3] = (uint8_t)adr;
   1bbc6:	70d9      	strb	r1, [r3, #3]
		wb[4] = (uint8_t)(sz >> 8);
   1bbc8:	0a12      	lsrs	r2, r2, #8
   1bbca:	711a      	strb	r2, [r3, #4]
		wb[5] = (uint8_t)(sz);
   1bbcc:	466a      	mov	r2, sp
   1bbce:	7912      	ldrb	r2, [r2, #4]
		len = 7;
   1bbd0:	2407      	movs	r4, #7
		wb[5] = (uint8_t)(sz);
   1bbd2:	715a      	strb	r2, [r3, #5]
		break;
   1bbd4:	e7d7      	b.n	1bb86 <spi_cmd_complete+0x3a>
		wb[1] = (uint8_t)(adr >> 16);
   1bbd6:	0c0a      	lsrs	r2, r1, #16
   1bbd8:	705a      	strb	r2, [r3, #1]
		wb[2] = (uint8_t)(adr >> 8);
   1bbda:	0a0a      	lsrs	r2, r1, #8
   1bbdc:	709a      	strb	r2, [r3, #2]
		wb[4] = (uint8_t)(sz >> 16);
   1bbde:	9a01      	ldr	r2, [sp, #4]
		wb[3] = (uint8_t)adr;
   1bbe0:	70d9      	strb	r1, [r3, #3]
		wb[4] = (uint8_t)(sz >> 16);
   1bbe2:	0c12      	lsrs	r2, r2, #16
   1bbe4:	711a      	strb	r2, [r3, #4]
		wb[5] = (uint8_t)(sz >> 8);
   1bbe6:	9a01      	ldr	r2, [sp, #4]
   1bbe8:	0a12      	lsrs	r2, r2, #8
   1bbea:	715a      	strb	r2, [r3, #5]
		wb[6] = (uint8_t)(sz);
   1bbec:	466a      	mov	r2, sp
   1bbee:	7912      	ldrb	r2, [r2, #4]
		wb[6] = b[0];
   1bbf0:	719a      	strb	r2, [r3, #6]
		len = 8;
   1bbf2:	2408      	movs	r4, #8
		break;
   1bbf4:	e7c7      	b.n	1bb86 <spi_cmd_complete+0x3a>
		wb[1] = (uint8_t)(adr >> 8);
   1bbf6:	0a0a      	lsrs	r2, r1, #8
   1bbf8:	b2d2      	uxtb	r2, r2
		if(clockless == 1)  wb[1] |= (1 << 7);
   1bbfa:	2c01      	cmp	r4, #1
   1bbfc:	d00d      	beq.n	1bc1a <spi_cmd_complete+0xce>
   1bbfe:	705a      	strb	r2, [r3, #1]
		wb[3] = b[3];
   1bc00:	9a00      	ldr	r2, [sp, #0]
		wb[2] = (uint8_t)(adr);
   1bc02:	7099      	strb	r1, [r3, #2]
		wb[3] = b[3];
   1bc04:	78d2      	ldrb	r2, [r2, #3]
   1bc06:	70da      	strb	r2, [r3, #3]
		wb[4] = b[2];
   1bc08:	9a00      	ldr	r2, [sp, #0]
   1bc0a:	7892      	ldrb	r2, [r2, #2]
   1bc0c:	711a      	strb	r2, [r3, #4]
		wb[5] = b[1];
   1bc0e:	9a00      	ldr	r2, [sp, #0]
   1bc10:	7852      	ldrb	r2, [r2, #1]
   1bc12:	715a      	strb	r2, [r3, #5]
		wb[6] = b[0];
   1bc14:	9a00      	ldr	r2, [sp, #0]
   1bc16:	7812      	ldrb	r2, [r2, #0]
   1bc18:	e7ea      	b.n	1bbf0 <spi_cmd_complete+0xa4>
		if(clockless == 1)  wb[1] |= (1 << 7);
   1bc1a:	2080      	movs	r0, #128	; 0x80
   1bc1c:	4240      	negs	r0, r0
   1bc1e:	4302      	orrs	r2, r0
   1bc20:	e7ed      	b.n	1bbfe <spi_cmd_complete+0xb2>
		wb[1] = (uint8_t)(adr >> 16);
   1bc22:	0c0a      	lsrs	r2, r1, #16
   1bc24:	705a      	strb	r2, [r3, #1]
		wb[2] = (uint8_t)(adr >> 8);
   1bc26:	0a0a      	lsrs	r2, r1, #8
   1bc28:	709a      	strb	r2, [r3, #2]
		wb[4] = b[3];
   1bc2a:	9a00      	ldr	r2, [sp, #0]
		wb[3] = (uint8_t)(adr);
   1bc2c:	70d9      	strb	r1, [r3, #3]
		wb[4] = b[3];
   1bc2e:	78d2      	ldrb	r2, [r2, #3]
		len = 9;
   1bc30:	2409      	movs	r4, #9
		wb[4] = b[3];
   1bc32:	711a      	strb	r2, [r3, #4]
		wb[5] = b[2];
   1bc34:	9a00      	ldr	r2, [sp, #0]
   1bc36:	7892      	ldrb	r2, [r2, #2]
   1bc38:	715a      	strb	r2, [r3, #5]
		wb[6] = b[1];
   1bc3a:	9a00      	ldr	r2, [sp, #0]
   1bc3c:	7852      	ldrb	r2, [r2, #1]
   1bc3e:	719a      	strb	r2, [r3, #6]
		wb[7] = b[0];
   1bc40:	9a00      	ldr	r2, [sp, #0]
   1bc42:	7812      	ldrb	r2, [r2, #0]
   1bc44:	71da      	strb	r2, [r3, #7]
		break;
   1bc46:	e79e      	b.n	1bb86 <spi_cmd_complete+0x3a>
		wb[len-1] = (crc7(0x7f, (const uint8_t *)&wb[0], len-1)) << 1;
   1bc48:	0008      	movs	r0, r1
   1bc4a:	227f      	movs	r2, #127	; 0x7f
   1bc4c:	ae06      	add	r6, sp, #24
   1bc4e:	1c47      	adds	r7, r0, #1
	while (len--)
   1bc50:	42bc      	cmp	r4, r7
   1bc52:	d123      	bne.n	1bc9c <spi_cmd_complete+0x150>
		wb[len-1] = (crc7(0x7f, (const uint8_t *)&wb[0], len-1)) << 1;
   1bc54:	4660      	mov	r0, ip
   1bc56:	0052      	lsls	r2, r2, #1
   1bc58:	5432      	strb	r2, [r6, r0]
#define NUM_DATA_HDR_BYTES (1)
#define NUM_DATA_BYTES (4)
#define NUM_CRC_BYTES (2)
#define NUM_DUMMY_BYTES (3)

	if ((cmd == CMD_RESET) ||
   1bc5a:	2dcf      	cmp	r5, #207	; 0xcf
   1bc5c:	d004      	beq.n	1bc68 <spi_cmd_complete+0x11c>
   1bc5e:	002a      	movs	r2, r5
   1bc60:	323b      	adds	r2, #59	; 0x3b
   1bc62:	b2d2      	uxtb	r2, r2
   1bc64:	2a01      	cmp	r2, #1
   1bc66:	d820      	bhi.n	1bcaa <spi_cmd_complete+0x15e>
		(cmd == CMD_TERMINATE) ||
		(cmd == CMD_REPEAT)) {
			len2 = len + (NUM_SKIP_BYTES + NUM_RSP_BYTES + NUM_DUMMY_BYTES);
   1bc68:	1da6      	adds	r6, r4, #6
			len2, (sizeof(wb)/sizeof(wb[0])));
		result = N_FAIL;
		return result;
	}
	/* zero spi write buffers. */
	for(wix = len; wix< len2; wix++) {
   1bc6a:	b2e4      	uxtb	r4, r4
   1bc6c:	0022      	movs	r2, r4
		wb[wix] = 0;
   1bc6e:	2000      	movs	r0, #0
   1bc70:	a906      	add	r1, sp, #24
	for(wix = len; wix< len2; wix++) {
   1bc72:	4296      	cmp	r6, r2
   1bc74:	d824      	bhi.n	1bcc0 <spi_cmd_complete+0x174>
	spi.pu8InBuf = bin;
   1bc76:	a903      	add	r1, sp, #12
   1bc78:	9303      	str	r3, [sp, #12]
	spi.pu8OutBuf = bout;
   1bc7a:	ab0e      	add	r3, sp, #56	; 0x38
   1bc7c:	604b      	str	r3, [r1, #4]
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);	
   1bc7e:	2003      	movs	r0, #3
   1bc80:	4b82      	ldr	r3, [pc, #520]	; (1be8c <spi_cmd_complete+0x340>)
	spi.u16Sz = sz;
   1bc82:	810e      	strh	r6, [r1, #8]
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);	
   1bc84:	4798      	blx	r3
	}
	rix = len;

	if (nmi_spi_rw(wb, rb, len2) != M2M_SUCCESS) {
   1bc86:	2800      	cmp	r0, #0
   1bc88:	d01e      	beq.n	1bcc8 <spi_cmd_complete+0x17c>
		M2M_ERR("[nmi spi]: Failed cmd write, bus error...\n");
   1bc8a:	22fa      	movs	r2, #250	; 0xfa
   1bc8c:	4880      	ldr	r0, [pc, #512]	; (1be90 <spi_cmd_complete+0x344>)
   1bc8e:	32ff      	adds	r2, #255	; 0xff
   1bc90:	4980      	ldr	r1, [pc, #512]	; (1be94 <spi_cmd_complete+0x348>)
   1bc92:	4c81      	ldr	r4, [pc, #516]	; (1be98 <spi_cmd_complete+0x34c>)
   1bc94:	47a0      	blx	r4
   1bc96:	4881      	ldr	r0, [pc, #516]	; (1be9c <spi_cmd_complete+0x350>)
					/**
					Read Crc
					**/
					if (!gu8Crc_off) {
						if (nmi_spi_read(crc, 2) != M2M_SUCCESS) {
							M2M_ERR("[nmi spi]: Failed data block crc read, bus error...\n");
   1bc98:	47a0      	blx	r4
   1bc9a:	e030      	b.n	1bcfe <spi_cmd_complete+0x1b2>
	return crc7_syndrome_table[(crc << 1) ^ data];
   1bc9c:	5c30      	ldrb	r0, [r6, r0]
   1bc9e:	0052      	lsls	r2, r2, #1
   1bca0:	4042      	eors	r2, r0
   1bca2:	487f      	ldr	r0, [pc, #508]	; (1bea0 <spi_cmd_complete+0x354>)
   1bca4:	5c82      	ldrb	r2, [r0, r2]
		crc = crc7_byte(crc, *buffer++);
   1bca6:	0038      	movs	r0, r7
   1bca8:	e7d1      	b.n	1bc4e <spi_cmd_complete+0x102>
	} else if ((cmd == CMD_INTERNAL_READ) || (cmd == CMD_SINGLE_READ)) {
   1bcaa:	2dc4      	cmp	r5, #196	; 0xc4
   1bcac:	d002      	beq.n	1bcb4 <spi_cmd_complete+0x168>
		len2 = len + (NUM_RSP_BYTES + NUM_DUMMY_BYTES);
   1bcae:	1d66      	adds	r6, r4, #5
	} else if ((cmd == CMD_INTERNAL_READ) || (cmd == CMD_SINGLE_READ)) {
   1bcb0:	2dca      	cmp	r5, #202	; 0xca
   1bcb2:	d1da      	bne.n	1bc6a <spi_cmd_complete+0x11e>
			len2 = len + (NUM_RSP_BYTES + NUM_DATA_HDR_BYTES + NUM_DATA_BYTES 
   1bcb4:	0026      	movs	r6, r4
   1bcb6:	360a      	adds	r6, #10
		if (!gu8Crc_off) {
   1bcb8:	2900      	cmp	r1, #0
   1bcba:	d1d6      	bne.n	1bc6a <spi_cmd_complete+0x11e>
			len2 = len + (NUM_RSP_BYTES + NUM_DATA_HDR_BYTES + NUM_DATA_BYTES 
   1bcbc:	3602      	adds	r6, #2
   1bcbe:	e7d4      	b.n	1bc6a <spi_cmd_complete+0x11e>
		wb[wix] = 0;
   1bcc0:	5488      	strb	r0, [r1, r2]
	for(wix = len; wix< len2; wix++) {
   1bcc2:	3201      	adds	r2, #1
   1bcc4:	b2d2      	uxtb	r2, r2
   1bcc6:	e7d4      	b.n	1bc72 <spi_cmd_complete+0x126>
	if ((cmd == CMD_RESET) ||
   1bcc8:	2dcf      	cmp	r5, #207	; 0xcf
   1bcca:	d004      	beq.n	1bcd6 <spi_cmd_complete+0x18a>
   1bccc:	002b      	movs	r3, r5
   1bcce:	333b      	adds	r3, #59	; 0x3b
   1bcd0:	b2db      	uxtb	r3, r3
   1bcd2:	2b01      	cmp	r3, #1
   1bcd4:	d801      	bhi.n	1bcda <spi_cmd_complete+0x18e>
			rix++; /* skip 1 byte */
   1bcd6:	3401      	adds	r4, #1
   1bcd8:	b2e4      	uxtb	r4, r4
	rsp = rb[rix++];
   1bcda:	2230      	movs	r2, #48	; 0x30
   1bcdc:	ab02      	add	r3, sp, #8
   1bcde:	189b      	adds	r3, r3, r2
   1bce0:	5d1b      	ldrb	r3, [r3, r4]
   1bce2:	aa02      	add	r2, sp, #8
   1bce4:	1cd7      	adds	r7, r2, #3
   1bce6:	703b      	strb	r3, [r7, #0]
	if (rsp != cmd) {
   1bce8:	429d      	cmp	r5, r3
   1bcea:	d00c      	beq.n	1bd06 <spi_cmd_complete+0x1ba>
		M2M_ERR("[nmi spi]: Failed cmd response, cmd (%02x), resp (%02x)\n", cmd, rsp);
   1bcec:	4a6d      	ldr	r2, [pc, #436]	; (1bea4 <spi_cmd_complete+0x358>)
   1bcee:	4969      	ldr	r1, [pc, #420]	; (1be94 <spi_cmd_complete+0x348>)
   1bcf0:	4867      	ldr	r0, [pc, #412]	; (1be90 <spi_cmd_complete+0x344>)
   1bcf2:	4c69      	ldr	r4, [pc, #420]	; (1be98 <spi_cmd_complete+0x34c>)
   1bcf4:	47a0      	blx	r4
   1bcf6:	783a      	ldrb	r2, [r7, #0]
   1bcf8:	0029      	movs	r1, r5
   1bcfa:	486b      	ldr	r0, [pc, #428]	; (1bea8 <spi_cmd_complete+0x35c>)
   1bcfc:	47a0      	blx	r4
							M2M_ERR("[nmi spi]: Failed data block crc read, bus error...\n");
   1bcfe:	486b      	ldr	r0, [pc, #428]	; (1beac <spi_cmd_complete+0x360>)
   1bd00:	47a0      	blx	r4
	switch (cmd) {
   1bd02:	2000      	movs	r0, #0
   1bd04:	e031      	b.n	1bd6a <spi_cmd_complete+0x21e>
	rsp = rb[rix++];
   1bd06:	2130      	movs	r1, #48	; 0x30
	rsp = rb[rix++];
   1bd08:	1c63      	adds	r3, r4, #1
	rsp = rb[rix++];
   1bd0a:	aa02      	add	r2, sp, #8
   1bd0c:	b2db      	uxtb	r3, r3
   1bd0e:	1852      	adds	r2, r2, r1
   1bd10:	5cd2      	ldrb	r2, [r2, r3]
   1bd12:	703a      	strb	r2, [r7, #0]
	if (rsp != 0x00) {
   1bd14:	2a00      	cmp	r2, #0
   1bd16:	d008      	beq.n	1bd2a <spi_cmd_complete+0x1de>
		M2M_ERR("[nmi spi]: Failed cmd state response state (%02x)\n", rsp);
   1bd18:	4a65      	ldr	r2, [pc, #404]	; (1beb0 <spi_cmd_complete+0x364>)
   1bd1a:	495e      	ldr	r1, [pc, #376]	; (1be94 <spi_cmd_complete+0x348>)
   1bd1c:	485c      	ldr	r0, [pc, #368]	; (1be90 <spi_cmd_complete+0x344>)
   1bd1e:	4c5e      	ldr	r4, [pc, #376]	; (1be98 <spi_cmd_complete+0x34c>)
   1bd20:	47a0      	blx	r4
   1bd22:	7839      	ldrb	r1, [r7, #0]
   1bd24:	4863      	ldr	r0, [pc, #396]	; (1beb4 <spi_cmd_complete+0x368>)
   1bd26:	47a0      	blx	r4
   1bd28:	e7e9      	b.n	1bcfe <spi_cmd_complete+0x1b2>
	if ((cmd == CMD_INTERNAL_READ) || (cmd == CMD_SINGLE_READ)
   1bd2a:	002b      	movs	r3, r5
   1bd2c:	21fb      	movs	r1, #251	; 0xfb
   1bd2e:	333c      	adds	r3, #60	; 0x3c
   1bd30:	420b      	tst	r3, r1
   1bd32:	d11c      	bne.n	1bd6e <spi_cmd_complete+0x222>
   1bd34:	2101      	movs	r1, #1
	rsp = rb[rix++];
   1bd36:	3402      	adds	r4, #2
   1bd38:	b2e3      	uxtb	r3, r4
   1bd3a:	270a      	movs	r7, #10
   1bd3c:	2400      	movs	r4, #0
   1bd3e:	468c      	mov	ip, r1
					rsp = rb[rix++];
   1bd40:	a80e      	add	r0, sp, #56	; 0x38
				if(rix < len2) { 
   1bd42:	429e      	cmp	r6, r3
   1bd44:	d81a      	bhi.n	1bd7c <spi_cmd_complete+0x230>
   1bd46:	2c00      	cmp	r4, #0
   1bd48:	d001      	beq.n	1bd4e <spi_cmd_complete+0x202>
   1bd4a:	ab02      	add	r3, sp, #8
   1bd4c:	70da      	strb	r2, [r3, #3]
				M2M_ERR("[nmi spi]: Error, data read response (%02x)\n", rsp);
   1bd4e:	2295      	movs	r2, #149	; 0x95
   1bd50:	4c51      	ldr	r4, [pc, #324]	; (1be98 <spi_cmd_complete+0x34c>)
   1bd52:	0092      	lsls	r2, r2, #2
   1bd54:	494f      	ldr	r1, [pc, #316]	; (1be94 <spi_cmd_complete+0x348>)
   1bd56:	484e      	ldr	r0, [pc, #312]	; (1be90 <spi_cmd_complete+0x344>)
   1bd58:	47a0      	blx	r4
   1bd5a:	ab02      	add	r3, sp, #8
   1bd5c:	78d9      	ldrb	r1, [r3, #3]
   1bd5e:	4856      	ldr	r0, [pc, #344]	; (1beb8 <spi_cmd_complete+0x36c>)
   1bd60:	47a0      	blx	r4
   1bd62:	4852      	ldr	r0, [pc, #328]	; (1beac <spi_cmd_complete+0x360>)
   1bd64:	47a0      	blx	r4
				return result;
   1bd66:	2001      	movs	r0, #1
   1bd68:	4240      	negs	r0, r0
				}
			}
	}
_error_:
	return result;
}
   1bd6a:	b017      	add	sp, #92	; 0x5c
   1bd6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		|| (cmd == CMD_DMA_READ) || (cmd == CMD_DMA_EXT_READ)) {
   1bd6e:	2308      	movs	r3, #8
   1bd70:	0029      	movs	r1, r5
   1bd72:	4399      	bics	r1, r3
   1bd74:	29c2      	cmp	r1, #194	; 0xc2
   1bd76:	d0dd      	beq.n	1bd34 <spi_cmd_complete+0x1e8>
							result = N_FAIL;
   1bd78:	2001      	movs	r0, #1
   1bd7a:	e7f6      	b.n	1bd6a <spi_cmd_complete+0x21e>
					rsp = rb[rix++];
   1bd7c:	5cc2      	ldrb	r2, [r0, r3]
   1bd7e:	1c59      	adds	r1, r3, #1
   1bd80:	b2c9      	uxtb	r1, r1
				if (((rsp >> 4) & 0xf) == 0xf)
   1bd82:	0914      	lsrs	r4, r2, #4
   1bd84:	2c0f      	cmp	r4, #15
   1bd86:	d004      	beq.n	1bd92 <spi_cmd_complete+0x246>
   1bd88:	4664      	mov	r4, ip
			} while (retry--);
   1bd8a:	3f01      	subs	r7, #1
   1bd8c:	d3dd      	bcc.n	1bd4a <spi_cmd_complete+0x1fe>
					rsp = rb[rix++];
   1bd8e:	000b      	movs	r3, r1
   1bd90:	e7d7      	b.n	1bd42 <spi_cmd_complete+0x1f6>
   1bd92:	ac02      	add	r4, sp, #8
   1bd94:	70e2      	strb	r2, [r4, #3]
			if (retry <= 0) {
   1bd96:	2f00      	cmp	r7, #0
   1bd98:	d0d9      	beq.n	1bd4e <spi_cmd_complete+0x202>
			if ((cmd == CMD_INTERNAL_READ) || (cmd == CMD_SINGLE_READ)) {
   1bd9a:	2dc4      	cmp	r5, #196	; 0xc4
   1bd9c:	d001      	beq.n	1bda2 <spi_cmd_complete+0x256>
   1bd9e:	2dca      	cmp	r5, #202	; 0xca
   1bda0:	d138      	bne.n	1be14 <spi_cmd_complete+0x2c8>
				if((rix+3) < len2) { 
   1bda2:	1cca      	adds	r2, r1, #3
   1bda4:	4296      	cmp	r6, r2
   1bda6:	d92e      	bls.n	1be06 <spi_cmd_complete+0x2ba>
					b[0] = rb[rix++];
   1bda8:	2030      	movs	r0, #48	; 0x30
   1bdaa:	aa02      	add	r2, sp, #8
   1bdac:	1812      	adds	r2, r2, r0
   1bdae:	5c52      	ldrb	r2, [r2, r1]
   1bdb0:	9900      	ldr	r1, [sp, #0]
   1bdb2:	700a      	strb	r2, [r1, #0]
   1bdb4:	1c9a      	adds	r2, r3, #2
					b[1] = rb[rix++];
   1bdb6:	a902      	add	r1, sp, #8
   1bdb8:	1809      	adds	r1, r1, r0
   1bdba:	b2d2      	uxtb	r2, r2
   1bdbc:	5c8a      	ldrb	r2, [r1, r2]
   1bdbe:	9900      	ldr	r1, [sp, #0]
   1bdc0:	704a      	strb	r2, [r1, #1]
   1bdc2:	1cda      	adds	r2, r3, #3
					b[2] = rb[rix++];
   1bdc4:	a902      	add	r1, sp, #8
   1bdc6:	1809      	adds	r1, r1, r0
   1bdc8:	b2d2      	uxtb	r2, r2
   1bdca:	5c8a      	ldrb	r2, [r1, r2]
   1bdcc:	9900      	ldr	r1, [sp, #0]
   1bdce:	708a      	strb	r2, [r1, #2]
   1bdd0:	1d1a      	adds	r2, r3, #4
					b[3] = rb[rix++];
   1bdd2:	a902      	add	r1, sp, #8
   1bdd4:	1809      	adds	r1, r1, r0
   1bdd6:	b2d2      	uxtb	r2, r2
   1bdd8:	5c8a      	ldrb	r2, [r1, r2]
   1bdda:	9900      	ldr	r1, [sp, #0]
   1bddc:	70ca      	strb	r2, [r1, #3]
				if (!gu8Crc_off) {						
   1bdde:	4a2a      	ldr	r2, [pc, #168]	; (1be88 <spi_cmd_complete+0x33c>)
   1bde0:	7814      	ldrb	r4, [r2, #0]
   1bde2:	2c00      	cmp	r4, #0
   1bde4:	d1c8      	bne.n	1bd78 <spi_cmd_complete+0x22c>
					b[3] = rb[rix++];
   1bde6:	3305      	adds	r3, #5
					if((rix+1) < len2) { 
   1bde8:	b2db      	uxtb	r3, r3
   1bdea:	3301      	adds	r3, #1
   1bdec:	429e      	cmp	r6, r3
   1bdee:	d8c3      	bhi.n	1bd78 <spi_cmd_complete+0x22c>
						M2M_ERR("[nmi spi]: buffer overrun when reading crc.\n");
   1bdf0:	229c      	movs	r2, #156	; 0x9c
   1bdf2:	4827      	ldr	r0, [pc, #156]	; (1be90 <spi_cmd_complete+0x344>)
   1bdf4:	0092      	lsls	r2, r2, #2
   1bdf6:	4927      	ldr	r1, [pc, #156]	; (1be94 <spi_cmd_complete+0x348>)
   1bdf8:	4d27      	ldr	r5, [pc, #156]	; (1be98 <spi_cmd_complete+0x34c>)
   1bdfa:	47a8      	blx	r5
   1bdfc:	482f      	ldr	r0, [pc, #188]	; (1bebc <spi_cmd_complete+0x370>)
							M2M_ERR("[nmi spi]: Failed data block crc read, bus error...\n");
   1bdfe:	47a8      	blx	r5
   1be00:	482a      	ldr	r0, [pc, #168]	; (1beac <spi_cmd_complete+0x360>)
   1be02:	47a8      	blx	r5
   1be04:	e77d      	b.n	1bd02 <spi_cmd_complete+0x1b6>
					M2M_ERR("[nmi spi]: buffer overrun when reading data.\n");
   1be06:	4822      	ldr	r0, [pc, #136]	; (1be90 <spi_cmd_complete+0x344>)
   1be08:	4a2d      	ldr	r2, [pc, #180]	; (1bec0 <spi_cmd_complete+0x374>)
   1be0a:	4922      	ldr	r1, [pc, #136]	; (1be94 <spi_cmd_complete+0x348>)
   1be0c:	4c22      	ldr	r4, [pc, #136]	; (1be98 <spi_cmd_complete+0x34c>)
   1be0e:	47a0      	blx	r4
   1be10:	482c      	ldr	r0, [pc, #176]	; (1bec4 <spi_cmd_complete+0x378>)
   1be12:	e741      	b.n	1bc98 <spi_cmd_complete+0x14c>
			} else if((cmd == CMD_DMA_READ) || (cmd == CMD_DMA_EXT_READ)) {
   1be14:	2dc2      	cmp	r5, #194	; 0xc2
   1be16:	d001      	beq.n	1be1c <spi_cmd_complete+0x2d0>
   1be18:	2dc8      	cmp	r5, #200	; 0xc8
   1be1a:	d1ad      	bne.n	1bd78 <spi_cmd_complete+0x22c>
   1be1c:	2700      	movs	r7, #0
   1be1e:	19cb      	adds	r3, r1, r7
   1be20:	b2db      	uxtb	r3, r3
				for(ix=0; (rix < len2) && (ix < sz);) {
   1be22:	429e      	cmp	r6, r3
   1be24:	d902      	bls.n	1be2c <spi_cmd_complete+0x2e0>
   1be26:	9a01      	ldr	r2, [sp, #4]
   1be28:	42ba      	cmp	r2, r7
   1be2a:	d116      	bne.n	1be5a <spi_cmd_complete+0x30e>
				sz -= ix;
   1be2c:	9b01      	ldr	r3, [sp, #4]
   1be2e:	1bdc      	subs	r4, r3, r7
				if(sz > 0) {
   1be30:	d0a2      	beq.n	1bd78 <spi_cmd_complete+0x22c>
					if (sz <= (DATA_PKT_SZ-ix)) {
   1be32:	2580      	movs	r5, #128	; 0x80
   1be34:	01ad      	lsls	r5, r5, #6
   1be36:	1bed      	subs	r5, r5, r7
   1be38:	42ac      	cmp	r4, r5
   1be3a:	d800      	bhi.n	1be3e <spi_cmd_complete+0x2f2>
						nbytes = sz;
   1be3c:	0025      	movs	r5, r4
					if (nmi_spi_read(&b[ix], nbytes) != M2M_SUCCESS) {
   1be3e:	9b00      	ldr	r3, [sp, #0]
   1be40:	b2a9      	uxth	r1, r5
   1be42:	19d8      	adds	r0, r3, r7
   1be44:	4e20      	ldr	r6, [pc, #128]	; (1bec8 <spi_cmd_complete+0x37c>)
   1be46:	47b0      	blx	r6
   1be48:	2800      	cmp	r0, #0
   1be4a:	d00b      	beq.n	1be64 <spi_cmd_complete+0x318>
						M2M_ERR("[nmi spi]: Failed data block read, bus error...\n");
   1be4c:	4a1f      	ldr	r2, [pc, #124]	; (1becc <spi_cmd_complete+0x380>)
						M2M_ERR("[nmi spi]: Failed data block read, bus error...\n");
   1be4e:	4810      	ldr	r0, [pc, #64]	; (1be90 <spi_cmd_complete+0x344>)
   1be50:	4910      	ldr	r1, [pc, #64]	; (1be94 <spi_cmd_complete+0x348>)
   1be52:	4c11      	ldr	r4, [pc, #68]	; (1be98 <spi_cmd_complete+0x34c>)
   1be54:	47a0      	blx	r4
   1be56:	481e      	ldr	r0, [pc, #120]	; (1bed0 <spi_cmd_complete+0x384>)
   1be58:	e71e      	b.n	1bc98 <spi_cmd_complete+0x14c>
					b[ix++] = rb[rix++];				
   1be5a:	5cc3      	ldrb	r3, [r0, r3]
   1be5c:	9a00      	ldr	r2, [sp, #0]
   1be5e:	55d3      	strb	r3, [r2, r7]
   1be60:	3701      	adds	r7, #1
   1be62:	e7dc      	b.n	1be1e <spi_cmd_complete+0x2d2>
					if (!gu8Crc_off) {
   1be64:	4b08      	ldr	r3, [pc, #32]	; (1be88 <spi_cmd_complete+0x33c>)
   1be66:	781b      	ldrb	r3, [r3, #0]
   1be68:	2b00      	cmp	r3, #0
   1be6a:	d135      	bne.n	1bed8 <spi_cmd_complete+0x38c>
						if (nmi_spi_read(crc, 2) != M2M_SUCCESS) {
   1be6c:	2102      	movs	r1, #2
   1be6e:	a803      	add	r0, sp, #12
   1be70:	47b0      	blx	r6
   1be72:	2800      	cmp	r0, #0
   1be74:	d030      	beq.n	1bed8 <spi_cmd_complete+0x38c>
							M2M_ERR("[nmi spi]: Failed data block crc read, bus error...\n");
   1be76:	22a6      	movs	r2, #166	; 0xa6
   1be78:	4805      	ldr	r0, [pc, #20]	; (1be90 <spi_cmd_complete+0x344>)
   1be7a:	0092      	lsls	r2, r2, #2
   1be7c:	4905      	ldr	r1, [pc, #20]	; (1be94 <spi_cmd_complete+0x348>)
   1be7e:	4c06      	ldr	r4, [pc, #24]	; (1be98 <spi_cmd_complete+0x34c>)
   1be80:	47a0      	blx	r4
   1be82:	4814      	ldr	r0, [pc, #80]	; (1bed4 <spi_cmd_complete+0x388>)
   1be84:	e708      	b.n	1bc98 <spi_cmd_complete+0x14c>
   1be86:	46c0      	nop			; (mov r8, r8)
   1be88:	20003d88 	.word	0x20003d88
   1be8c:	0001a60d 	.word	0x0001a60d
   1be90:	00029fb9 	.word	0x00029fb9
   1be94:	0002a60f 	.word	0x0002a60f
   1be98:	00019415 	.word	0x00019415
   1be9c:	0002a9ce 	.word	0x0002a9ce
   1bea0:	0002a66f 	.word	0x0002a66f
   1bea4:	0000022f 	.word	0x0000022f
   1bea8:	0002a9f9 	.word	0x0002a9f9
   1beac:	0002b325 	.word	0x0002b325
   1beb0:	00000239 	.word	0x00000239
   1beb4:	0002aa32 	.word	0x0002aa32
   1beb8:	0002aa65 	.word	0x0002aa65
   1bebc:	0002aac0 	.word	0x0002aac0
   1bec0:	00000263 	.word	0x00000263
   1bec4:	0002aa92 	.word	0x0002aa92
   1bec8:	0001ba99 	.word	0x0001ba99
   1becc:	0000028e 	.word	0x0000028e
   1bed0:	0002aaed 	.word	0x0002aaed
   1bed4:	0002ab1e 	.word	0x0002ab1e
					ix += nbytes;
   1bed8:	197b      	adds	r3, r7, r5
   1beda:	9301      	str	r3, [sp, #4]
					sz -= nbytes;
   1bedc:	1b65      	subs	r5, r4, r5
				while(sz > 0) {
   1bede:	2d00      	cmp	r5, #0
   1bee0:	d100      	bne.n	1bee4 <spi_cmd_complete+0x398>
   1bee2:	e749      	b.n	1bd78 <spi_cmd_complete+0x22c>
   1bee4:	2380      	movs	r3, #128	; 0x80
   1bee6:	002f      	movs	r7, r5
   1bee8:	019b      	lsls	r3, r3, #6
   1beea:	429d      	cmp	r5, r3
   1beec:	d900      	bls.n	1bef0 <spi_cmd_complete+0x3a4>
   1beee:	001f      	movs	r7, r3
   1bef0:	240b      	movs	r4, #11
						if (nmi_spi_read(&rsp, 1) != M2M_SUCCESS) {
   1bef2:	ab02      	add	r3, sp, #8
   1bef4:	1cd8      	adds	r0, r3, #3
   1bef6:	2101      	movs	r1, #1
   1bef8:	4b19      	ldr	r3, [pc, #100]	; (1bf60 <spi_cmd_complete+0x414>)
   1befa:	4798      	blx	r3
   1befc:	2800      	cmp	r0, #0
   1befe:	d007      	beq.n	1bf10 <spi_cmd_complete+0x3c4>
							M2M_ERR("[nmi spi]: Failed data response read, bus error...\n");
   1bf00:	22ae      	movs	r2, #174	; 0xae
   1bf02:	4818      	ldr	r0, [pc, #96]	; (1bf64 <spi_cmd_complete+0x418>)
   1bf04:	0092      	lsls	r2, r2, #2
   1bf06:	4918      	ldr	r1, [pc, #96]	; (1bf68 <spi_cmd_complete+0x41c>)
   1bf08:	4c18      	ldr	r4, [pc, #96]	; (1bf6c <spi_cmd_complete+0x420>)
   1bf0a:	47a0      	blx	r4
   1bf0c:	4818      	ldr	r0, [pc, #96]	; (1bf70 <spi_cmd_complete+0x424>)
   1bf0e:	e6c3      	b.n	1bc98 <spi_cmd_complete+0x14c>
						if (((rsp >> 4) & 0xf) == 0xf)
   1bf10:	ab02      	add	r3, sp, #8
   1bf12:	78db      	ldrb	r3, [r3, #3]
   1bf14:	091b      	lsrs	r3, r3, #4
   1bf16:	2b0f      	cmp	r3, #15
   1bf18:	d002      	beq.n	1bf20 <spi_cmd_complete+0x3d4>
   1bf1a:	3c01      	subs	r4, #1
					} while (retry--);
   1bf1c:	2c00      	cmp	r4, #0
   1bf1e:	d1e8      	bne.n	1bef2 <spi_cmd_complete+0x3a6>
					if (nmi_spi_read(&b[ix], nbytes) != M2M_SUCCESS) {
   1bf20:	9b00      	ldr	r3, [sp, #0]
   1bf22:	9a01      	ldr	r2, [sp, #4]
   1bf24:	b2b9      	uxth	r1, r7
   1bf26:	1898      	adds	r0, r3, r2
   1bf28:	47b0      	blx	r6
   1bf2a:	2800      	cmp	r0, #0
   1bf2c:	d002      	beq.n	1bf34 <spi_cmd_complete+0x3e8>
						M2M_ERR("[nmi spi]: Failed data block read, bus error...\n");
   1bf2e:	22b2      	movs	r2, #178	; 0xb2
   1bf30:	0092      	lsls	r2, r2, #2
   1bf32:	e78c      	b.n	1be4e <spi_cmd_complete+0x302>
					if (!gu8Crc_off) {
   1bf34:	4b0f      	ldr	r3, [pc, #60]	; (1bf74 <spi_cmd_complete+0x428>)
   1bf36:	781c      	ldrb	r4, [r3, #0]
   1bf38:	2c00      	cmp	r4, #0
   1bf3a:	d10b      	bne.n	1bf54 <spi_cmd_complete+0x408>
						if (nmi_spi_read(crc, 2) != M2M_SUCCESS) {
   1bf3c:	2102      	movs	r1, #2
   1bf3e:	a803      	add	r0, sp, #12
   1bf40:	47b0      	blx	r6
   1bf42:	2800      	cmp	r0, #0
   1bf44:	d006      	beq.n	1bf54 <spi_cmd_complete+0x408>
							M2M_ERR("[nmi spi]: Failed data block crc read, bus error...\n");
   1bf46:	4807      	ldr	r0, [pc, #28]	; (1bf64 <spi_cmd_complete+0x418>)
   1bf48:	4a0b      	ldr	r2, [pc, #44]	; (1bf78 <spi_cmd_complete+0x42c>)
   1bf4a:	4907      	ldr	r1, [pc, #28]	; (1bf68 <spi_cmd_complete+0x41c>)
   1bf4c:	4d07      	ldr	r5, [pc, #28]	; (1bf6c <spi_cmd_complete+0x420>)
   1bf4e:	47a8      	blx	r5
   1bf50:	480a      	ldr	r0, [pc, #40]	; (1bf7c <spi_cmd_complete+0x430>)
   1bf52:	e754      	b.n	1bdfe <spi_cmd_complete+0x2b2>
					ix += nbytes;
   1bf54:	9b01      	ldr	r3, [sp, #4]
					sz -= nbytes;
   1bf56:	1bed      	subs	r5, r5, r7
					ix += nbytes;
   1bf58:	19db      	adds	r3, r3, r7
   1bf5a:	9301      	str	r3, [sp, #4]
   1bf5c:	e7bf      	b.n	1bede <spi_cmd_complete+0x392>
   1bf5e:	46c0      	nop			; (mov r8, r8)
   1bf60:	0001ba99 	.word	0x0001ba99
   1bf64:	00029fb9 	.word	0x00029fb9
   1bf68:	0002a60f 	.word	0x0002a60f
   1bf6c:	00019415 	.word	0x00019415
   1bf70:	0002ab53 	.word	0x0002ab53
   1bf74:	20003d88 	.word	0x20003d88
   1bf78:	000002d2 	.word	0x000002d2
   1bf7c:	0002ab1e 	.word	0x0002ab1e

0001bf80 <spi_cmd.constprop.2>:
static sint8 spi_cmd(uint8 cmd, uint32 adr, uint32 u32data, uint32 sz,uint8 clockless)
   1bf80:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	bc[0] = cmd;
   1bf82:	23cf      	movs	r3, #207	; 0xcf
   1bf84:	a801      	add	r0, sp, #4
   1bf86:	7003      	strb	r3, [r0, #0]
		bc[1] = 0xff;
   1bf88:	3330      	adds	r3, #48	; 0x30
   1bf8a:	7043      	strb	r3, [r0, #1]
		bc[2] = 0xff;
   1bf8c:	7083      	strb	r3, [r0, #2]
		bc[3] = 0xff;
   1bf8e:	70c3      	strb	r3, [r0, #3]
		if (!gu8Crc_off)
   1bf90:	4b12      	ldr	r3, [pc, #72]	; (1bfdc <spi_cmd.constprop.2+0x5c>)
			len-=1;
   1bf92:	2104      	movs	r1, #4
		if (!gu8Crc_off)
   1bf94:	781a      	ldrb	r2, [r3, #0]
   1bf96:	2a00      	cmp	r2, #0
   1bf98:	d10b      	bne.n	1bfb2 <spi_cmd.constprop.2+0x32>
   1bf9a:	237f      	movs	r3, #127	; 0x7f
	return crc7_syndrome_table[(crc << 1) ^ data];
   1bf9c:	4910      	ldr	r1, [pc, #64]	; (1bfe0 <spi_cmd.constprop.2+0x60>)
   1bf9e:	5c84      	ldrb	r4, [r0, r2]
   1bfa0:	005b      	lsls	r3, r3, #1
   1bfa2:	4063      	eors	r3, r4
   1bfa4:	3201      	adds	r2, #1
   1bfa6:	5ccb      	ldrb	r3, [r1, r3]
	while (len--)
   1bfa8:	2a04      	cmp	r2, #4
   1bfaa:	d1f8      	bne.n	1bf9e <spi_cmd.constprop.2+0x1e>
			bc[len-1] = (crc7(0x7f, (const uint8 *)&bc[0], len-1)) << 1;
   1bfac:	2105      	movs	r1, #5
   1bfae:	005b      	lsls	r3, r3, #1
   1bfb0:	7103      	strb	r3, [r0, #4]
		if (M2M_SUCCESS != nmi_spi_write(bc, len)) {
   1bfb2:	4b0c      	ldr	r3, [pc, #48]	; (1bfe4 <spi_cmd.constprop.2+0x64>)
   1bfb4:	b289      	uxth	r1, r1
   1bfb6:	4798      	blx	r3
   1bfb8:	2301      	movs	r3, #1
   1bfba:	2800      	cmp	r0, #0
   1bfbc:	d00a      	beq.n	1bfd4 <spi_cmd.constprop.2+0x54>
			M2M_ERR("[nmi spi]: Failed cmd write, bus error...\n");
   1bfbe:	2290      	movs	r2, #144	; 0x90
   1bfc0:	4909      	ldr	r1, [pc, #36]	; (1bfe8 <spi_cmd.constprop.2+0x68>)
   1bfc2:	0052      	lsls	r2, r2, #1
   1bfc4:	4c09      	ldr	r4, [pc, #36]	; (1bfec <spi_cmd.constprop.2+0x6c>)
   1bfc6:	480a      	ldr	r0, [pc, #40]	; (1bff0 <spi_cmd.constprop.2+0x70>)
   1bfc8:	47a0      	blx	r4
   1bfca:	480a      	ldr	r0, [pc, #40]	; (1bff4 <spi_cmd.constprop.2+0x74>)
   1bfcc:	47a0      	blx	r4
   1bfce:	480a      	ldr	r0, [pc, #40]	; (1bff8 <spi_cmd.constprop.2+0x78>)
   1bfd0:	47a0      	blx	r4
			result = N_FAIL;
   1bfd2:	2300      	movs	r3, #0
}
   1bfd4:	0018      	movs	r0, r3
   1bfd6:	b004      	add	sp, #16
   1bfd8:	bd10      	pop	{r4, pc}
   1bfda:	46c0      	nop			; (mov r8, r8)
   1bfdc:	20003d88 	.word	0x20003d88
   1bfe0:	0002a66f 	.word	0x0002a66f
   1bfe4:	0001ba7d 	.word	0x0001ba7d
   1bfe8:	0002a5ee 	.word	0x0002a5ee
   1bfec:	00019415 	.word	0x00019415
   1bff0:	00029fb9 	.word	0x00029fb9
   1bff4:	0002a9ce 	.word	0x0002a9ce
   1bff8:	0002b325 	.word	0x0002b325

0001bffc <spi_read_reg>:

	return result;
}

static sint8 spi_read_reg(uint32 addr, uint32 *u32data)
{
   1bffc:	b5f0      	push	{r4, r5, r6, r7, lr}
   1bffe:	b089      	sub	sp, #36	; 0x24
   1c000:	0005      	movs	r5, r0
   1c002:	9105      	str	r1, [sp, #20]
   1c004:	28ff      	cmp	r0, #255	; 0xff
   1c006:	d83b      	bhi.n	1c080 <spi_read_reg+0x84>
   1c008:	4b20      	ldr	r3, [pc, #128]	; (1c08c <spi_read_reg+0x90>)
   1c00a:	781b      	ldrb	r3, [r3, #0]
   1c00c:	22ff      	movs	r2, #255	; 0xff
   1c00e:	b2db      	uxtb	r3, r3
   1c010:	9303      	str	r3, [sp, #12]
   1c012:	2300      	movs	r3, #0
   1c014:	42aa      	cmp	r2, r5
   1c016:	415b      	adcs	r3, r3
   1c018:	260a      	movs	r6, #10
   1c01a:	b2db      	uxtb	r3, r3
   1c01c:	9304      	str	r3, [sp, #16]
	if (result != N_OK) {
		M2M_ERR("[nmi spi]: Failed data read...\n");
		goto _FAIL_;
	}
#else
	result = spi_cmd_complete(cmd, addr, (uint8*)&tmp[0], 4, clockless);
   1c01e:	9b04      	ldr	r3, [sp, #16]
   1c020:	aa07      	add	r2, sp, #28
   1c022:	9300      	str	r3, [sp, #0]
   1c024:	0029      	movs	r1, r5
   1c026:	2304      	movs	r3, #4
   1c028:	9803      	ldr	r0, [sp, #12]
   1c02a:	4c19      	ldr	r4, [pc, #100]	; (1c090 <spi_read_reg+0x94>)
   1c02c:	47a0      	blx	r4
   1c02e:	b243      	sxtb	r3, r0
   1c030:	9302      	str	r3, [sp, #8]
	if (result != N_OK) {
   1c032:	2b01      	cmp	r3, #1
   1c034:	d026      	beq.n	1c084 <spi_read_reg+0x88>
		M2M_ERR( "[nmi spi]: Failed cmd, read reg (%08x)...\n", addr);
   1c036:	4f17      	ldr	r7, [pc, #92]	; (1c094 <spi_read_reg+0x98>)
   1c038:	4a17      	ldr	r2, [pc, #92]	; (1c098 <spi_read_reg+0x9c>)
   1c03a:	4c18      	ldr	r4, [pc, #96]	; (1c09c <spi_read_reg+0xa0>)
   1c03c:	0039      	movs	r1, r7
   1c03e:	4818      	ldr	r0, [pc, #96]	; (1c0a0 <spi_read_reg+0xa4>)
   1c040:	47a0      	blx	r4
   1c042:	0029      	movs	r1, r5
   1c044:	4817      	ldr	r0, [pc, #92]	; (1c0a4 <spi_read_reg+0xa8>)
   1c046:	47a0      	blx	r4
   1c048:	4817      	ldr	r0, [pc, #92]	; (1c0a8 <spi_read_reg+0xac>)
   1c04a:	47a0      	blx	r4
		
_FAIL_:
	if(result != N_OK)
	{
		
		nm_bsp_sleep(1);
   1c04c:	2001      	movs	r0, #1
   1c04e:	4b17      	ldr	r3, [pc, #92]	; (1c0ac <spi_read_reg+0xb0>)
   1c050:	4798      	blx	r3
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
   1c052:	4b17      	ldr	r3, [pc, #92]	; (1c0b0 <spi_read_reg+0xb4>)
   1c054:	4798      	blx	r3
		spi_cmd_rsp(CMD_RESET);
   1c056:	4b17      	ldr	r3, [pc, #92]	; (1c0b4 <spi_read_reg+0xb8>)
   1c058:	4798      	blx	r3
		M2M_ERR("Reset and retry %d %lx\n",retry,addr);
   1c05a:	4a17      	ldr	r2, [pc, #92]	; (1c0b8 <spi_read_reg+0xbc>)
   1c05c:	0039      	movs	r1, r7
   1c05e:	4810      	ldr	r0, [pc, #64]	; (1c0a0 <spi_read_reg+0xa4>)
   1c060:	47a0      	blx	r4
   1c062:	0031      	movs	r1, r6
   1c064:	002a      	movs	r2, r5
   1c066:	4815      	ldr	r0, [pc, #84]	; (1c0bc <spi_read_reg+0xc0>)
   1c068:	47a0      	blx	r4
   1c06a:	480f      	ldr	r0, [pc, #60]	; (1c0a8 <spi_read_reg+0xac>)
   1c06c:	47a0      	blx	r4
   1c06e:	3e01      	subs	r6, #1
		nm_bsp_sleep(1);
   1c070:	2001      	movs	r0, #1
   1c072:	4b0e      	ldr	r3, [pc, #56]	; (1c0ac <spi_read_reg+0xb0>)
   1c074:	4798      	blx	r3
		retry--;
		if(retry) goto _RETRY_;
   1c076:	2e00      	cmp	r6, #0
   1c078:	d1d1      	bne.n	1c01e <spi_read_reg+0x22>
	}
		
	return result;
}
   1c07a:	9802      	ldr	r0, [sp, #8]
   1c07c:	b009      	add	sp, #36	; 0x24
   1c07e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1c080:	4b0f      	ldr	r3, [pc, #60]	; (1c0c0 <spi_read_reg+0xc4>)
   1c082:	e7c2      	b.n	1c00a <spi_read_reg+0xe>
	*u32data = tmp[0] |
   1c084:	9b05      	ldr	r3, [sp, #20]
   1c086:	9a07      	ldr	r2, [sp, #28]
   1c088:	601a      	str	r2, [r3, #0]
   1c08a:	e7f6      	b.n	1c07a <spi_read_reg+0x7e>
   1c08c:	0002a5e7 	.word	0x0002a5e7
   1c090:	0001bb4d 	.word	0x0001bb4d
   1c094:	0002a64a 	.word	0x0002a64a
   1c098:	00000423 	.word	0x00000423
   1c09c:	00019415 	.word	0x00019415
   1c0a0:	00029fb9 	.word	0x00029fb9
   1c0a4:	0002abba 	.word	0x0002abba
   1c0a8:	0002b325 	.word	0x0002b325
   1c0ac:	0001a489 	.word	0x0001a489
   1c0b0:	0001bf81 	.word	0x0001bf81
   1c0b4:	0001bab5 	.word	0x0001bab5
   1c0b8:	00000435 	.word	0x00000435
   1c0bc:	0002abe5 	.word	0x0002abe5
   1c0c0:	0002a5e8 	.word	0x0002a5e8

0001c0c4 <spi_write_reg>:
{
   1c0c4:	b5f0      	push	{r4, r5, r6, r7, lr}
   1c0c6:	b087      	sub	sp, #28
   1c0c8:	0005      	movs	r5, r0
   1c0ca:	9105      	str	r1, [sp, #20]
   1c0cc:	2830      	cmp	r0, #48	; 0x30
   1c0ce:	d83d      	bhi.n	1c14c <spi_write_reg+0x88>
   1c0d0:	4b1f      	ldr	r3, [pc, #124]	; (1c150 <spi_write_reg+0x8c>)
   1c0d2:	781b      	ldrb	r3, [r3, #0]
   1c0d4:	2230      	movs	r2, #48	; 0x30
   1c0d6:	b2db      	uxtb	r3, r3
   1c0d8:	9303      	str	r3, [sp, #12]
   1c0da:	2300      	movs	r3, #0
   1c0dc:	42aa      	cmp	r2, r5
   1c0de:	415b      	adcs	r3, r3
   1c0e0:	260a      	movs	r6, #10
   1c0e2:	b2db      	uxtb	r3, r3
   1c0e4:	9304      	str	r3, [sp, #16]
	result = spi_cmd_complete(cmd, addr, (uint8*)&u32data, 4, clockless);
   1c0e6:	9b04      	ldr	r3, [sp, #16]
   1c0e8:	aa05      	add	r2, sp, #20
   1c0ea:	9300      	str	r3, [sp, #0]
   1c0ec:	0029      	movs	r1, r5
   1c0ee:	2304      	movs	r3, #4
   1c0f0:	9803      	ldr	r0, [sp, #12]
   1c0f2:	4c18      	ldr	r4, [pc, #96]	; (1c154 <spi_write_reg+0x90>)
   1c0f4:	47a0      	blx	r4
   1c0f6:	b243      	sxtb	r3, r0
   1c0f8:	9302      	str	r3, [sp, #8]
	if (result != N_OK) {
   1c0fa:	2b01      	cmp	r3, #1
   1c0fc:	d023      	beq.n	1c146 <spi_write_reg+0x82>
		M2M_ERR( "[nmi spi]: Failed cmd, write reg (%08x)...\n", addr);
   1c0fe:	4f16      	ldr	r7, [pc, #88]	; (1c158 <spi_write_reg+0x94>)
   1c100:	4a16      	ldr	r2, [pc, #88]	; (1c15c <spi_write_reg+0x98>)
   1c102:	4c17      	ldr	r4, [pc, #92]	; (1c160 <spi_write_reg+0x9c>)
   1c104:	0039      	movs	r1, r7
   1c106:	4817      	ldr	r0, [pc, #92]	; (1c164 <spi_write_reg+0xa0>)
   1c108:	47a0      	blx	r4
   1c10a:	0029      	movs	r1, r5
   1c10c:	4816      	ldr	r0, [pc, #88]	; (1c168 <spi_write_reg+0xa4>)
   1c10e:	47a0      	blx	r4
   1c110:	4816      	ldr	r0, [pc, #88]	; (1c16c <spi_write_reg+0xa8>)
   1c112:	47a0      	blx	r4
		nm_bsp_sleep(1);
   1c114:	2001      	movs	r0, #1
   1c116:	4b16      	ldr	r3, [pc, #88]	; (1c170 <spi_write_reg+0xac>)
   1c118:	4798      	blx	r3
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
   1c11a:	4b16      	ldr	r3, [pc, #88]	; (1c174 <spi_write_reg+0xb0>)
   1c11c:	4798      	blx	r3
		spi_cmd_rsp(CMD_RESET);
   1c11e:	4b16      	ldr	r3, [pc, #88]	; (1c178 <spi_write_reg+0xb4>)
   1c120:	4798      	blx	r3
		M2M_ERR("Reset and retry %d %lx %lx\n",retry,addr,u32data);
   1c122:	22ea      	movs	r2, #234	; 0xea
   1c124:	0039      	movs	r1, r7
   1c126:	0092      	lsls	r2, r2, #2
   1c128:	480e      	ldr	r0, [pc, #56]	; (1c164 <spi_write_reg+0xa0>)
   1c12a:	47a0      	blx	r4
   1c12c:	0031      	movs	r1, r6
   1c12e:	9b05      	ldr	r3, [sp, #20]
   1c130:	002a      	movs	r2, r5
   1c132:	4812      	ldr	r0, [pc, #72]	; (1c17c <spi_write_reg+0xb8>)
   1c134:	47a0      	blx	r4
   1c136:	480d      	ldr	r0, [pc, #52]	; (1c16c <spi_write_reg+0xa8>)
   1c138:	47a0      	blx	r4
   1c13a:	3e01      	subs	r6, #1
		nm_bsp_sleep(1);
   1c13c:	2001      	movs	r0, #1
   1c13e:	4b0c      	ldr	r3, [pc, #48]	; (1c170 <spi_write_reg+0xac>)
   1c140:	4798      	blx	r3
		if(retry) goto _RETRY_;
   1c142:	2e00      	cmp	r6, #0
   1c144:	d1cf      	bne.n	1c0e6 <spi_write_reg+0x22>
}
   1c146:	9802      	ldr	r0, [sp, #8]
   1c148:	b007      	add	sp, #28
   1c14a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1c14c:	4b0c      	ldr	r3, [pc, #48]	; (1c180 <spi_write_reg+0xbc>)
   1c14e:	e7c0      	b.n	1c0d2 <spi_write_reg+0xe>
   1c150:	0002a5e9 	.word	0x0002a5e9
   1c154:	0001bb4d 	.word	0x0001bb4d
   1c158:	0002a62f 	.word	0x0002a62f
   1c15c:	0000039d 	.word	0x0000039d
   1c160:	00019415 	.word	0x00019415
   1c164:	00029fb9 	.word	0x00029fb9
   1c168:	0002abfd 	.word	0x0002abfd
   1c16c:	0002b325 	.word	0x0002b325
   1c170:	0001a489 	.word	0x0001a489
   1c174:	0001bf81 	.word	0x0001bf81
   1c178:	0001bab5 	.word	0x0001bab5
   1c17c:	0002ac29 	.word	0x0002ac29
   1c180:	0002a5ea 	.word	0x0002a5ea

0001c184 <nm_spi_reset>:
	}
	nm_spi_write_reg(SPI_BASE+0x24, val32);
}

sint8 nm_spi_reset(void)
{
   1c184:	b510      	push	{r4, lr}
	spi_cmd(CMD_RESET, 0, 0, 0, 0);
   1c186:	4b03      	ldr	r3, [pc, #12]	; (1c194 <nm_spi_reset+0x10>)
   1c188:	4798      	blx	r3
	spi_cmd_rsp(CMD_RESET);
   1c18a:	4b03      	ldr	r3, [pc, #12]	; (1c198 <nm_spi_reset+0x14>)
   1c18c:	4798      	blx	r3
	return M2M_SUCCESS;
}
   1c18e:	2000      	movs	r0, #0
   1c190:	bd10      	pop	{r4, pc}
   1c192:	46c0      	nop			; (mov r8, r8)
   1c194:	0001bf81 	.word	0x0001bf81
   1c198:	0001bab5 	.word	0x0001bab5

0001c19c <nm_spi_deinit>:
*	@date	27 Feb 2015
*	@version	1.0
*/ 
sint8 nm_spi_deinit(void)
{
	gu8Crc_off = 0;
   1c19c:	2000      	movs	r0, #0
   1c19e:	4b01      	ldr	r3, [pc, #4]	; (1c1a4 <nm_spi_deinit+0x8>)
   1c1a0:	7018      	strb	r0, [r3, #0]
	return M2M_SUCCESS;
}
   1c1a2:	4770      	bx	lr
   1c1a4:	20003d88 	.word	0x20003d88

0001c1a8 <nm_spi_read_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
uint32 nm_spi_read_reg(uint32 u32Addr)
{
   1c1a8:	b507      	push	{r0, r1, r2, lr}
	uint32 u32Val;

	spi_read_reg(u32Addr, &u32Val);
   1c1aa:	4b02      	ldr	r3, [pc, #8]	; (1c1b4 <nm_spi_read_reg+0xc>)
   1c1ac:	a901      	add	r1, sp, #4
   1c1ae:	4798      	blx	r3

	return u32Val;
}
   1c1b0:	9801      	ldr	r0, [sp, #4]
   1c1b2:	bd0e      	pop	{r1, r2, r3, pc}
   1c1b4:	0001bffd 	.word	0x0001bffd

0001c1b8 <nm_spi_read_reg_with_ret>:
*/
sint8 nm_spi_read_reg_with_ret(uint32 u32Addr, uint32* pu32RetVal)
{
	sint8 s8Ret;

	s8Ret = spi_read_reg(u32Addr,pu32RetVal);
   1c1b8:	4b04      	ldr	r3, [pc, #16]	; (1c1cc <nm_spi_read_reg_with_ret+0x14>)
{
   1c1ba:	b510      	push	{r4, lr}
	s8Ret = spi_read_reg(u32Addr,pu32RetVal);
   1c1bc:	4798      	blx	r3

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
   1c1be:	2300      	movs	r3, #0
   1c1c0:	2801      	cmp	r0, #1
   1c1c2:	d000      	beq.n	1c1c6 <nm_spi_read_reg_with_ret+0xe>
	else s8Ret = M2M_ERR_BUS_FAIL;
   1c1c4:	3b06      	subs	r3, #6

	return s8Ret;
}
   1c1c6:	0018      	movs	r0, r3
   1c1c8:	bd10      	pop	{r4, pc}
   1c1ca:	46c0      	nop			; (mov r8, r8)
   1c1cc:	0001bffd 	.word	0x0001bffd

0001c1d0 <nm_spi_write_reg>:
*/
sint8 nm_spi_write_reg(uint32 u32Addr, uint32 u32Val)
{
	sint8 s8Ret;

	s8Ret = spi_write_reg(u32Addr, u32Val);
   1c1d0:	4b04      	ldr	r3, [pc, #16]	; (1c1e4 <nm_spi_write_reg+0x14>)
{
   1c1d2:	b510      	push	{r4, lr}
	s8Ret = spi_write_reg(u32Addr, u32Val);
   1c1d4:	4798      	blx	r3

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
   1c1d6:	2300      	movs	r3, #0
   1c1d8:	2801      	cmp	r0, #1
   1c1da:	d000      	beq.n	1c1de <nm_spi_write_reg+0xe>
	else s8Ret = M2M_ERR_BUS_FAIL;
   1c1dc:	3b06      	subs	r3, #6

	return s8Ret;
}
   1c1de:	0018      	movs	r0, r3
   1c1e0:	bd10      	pop	{r4, pc}
   1c1e2:	46c0      	nop			; (mov r8, r8)
   1c1e4:	0001c0c5 	.word	0x0001c0c5

0001c1e8 <nm_spi_init>:
	uint32 reg = 0;
   1c1e8:	2300      	movs	r3, #0
{
   1c1ea:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	gu8Crc_off = 0;
   1c1ec:	4e2d      	ldr	r6, [pc, #180]	; (1c2a4 <nm_spi_init+0xbc>)
	if (!spi_read_reg(NMI_SPI_PROTOCOL_CONFIG, &reg)) {
   1c1ee:	a901      	add	r1, sp, #4
   1c1f0:	482d      	ldr	r0, [pc, #180]	; (1c2a8 <nm_spi_init+0xc0>)
   1c1f2:	4c2e      	ldr	r4, [pc, #184]	; (1c2ac <nm_spi_init+0xc4>)
	uint32 reg = 0;
   1c1f4:	9301      	str	r3, [sp, #4]
	gu8Crc_off = 0;
   1c1f6:	7033      	strb	r3, [r6, #0]
	if (!spi_read_reg(NMI_SPI_PROTOCOL_CONFIG, &reg)) {
   1c1f8:	47a0      	blx	r4
   1c1fa:	2800      	cmp	r0, #0
   1c1fc:	d11b      	bne.n	1c236 <nm_spi_init+0x4e>
		M2M_ERR("[nmi spi]: Failed internal read protocol with CRC on, retyring with CRC off...\n");
   1c1fe:	2298      	movs	r2, #152	; 0x98
		gu8Crc_off = 1;
   1c200:	2301      	movs	r3, #1
		M2M_ERR("[nmi spi]: Failed internal read protocol with CRC on, retyring with CRC off...\n");
   1c202:	4f2b      	ldr	r7, [pc, #172]	; (1c2b0 <nm_spi_init+0xc8>)
   1c204:	00d2      	lsls	r2, r2, #3
   1c206:	0039      	movs	r1, r7
   1c208:	4d2a      	ldr	r5, [pc, #168]	; (1c2b4 <nm_spi_init+0xcc>)
   1c20a:	482b      	ldr	r0, [pc, #172]	; (1c2b8 <nm_spi_init+0xd0>)
		gu8Crc_off = 1;
   1c20c:	7033      	strb	r3, [r6, #0]
		M2M_ERR("[nmi spi]: Failed internal read protocol with CRC on, retyring with CRC off...\n");
   1c20e:	47a8      	blx	r5
   1c210:	482a      	ldr	r0, [pc, #168]	; (1c2bc <nm_spi_init+0xd4>)
   1c212:	47a8      	blx	r5
   1c214:	482a      	ldr	r0, [pc, #168]	; (1c2c0 <nm_spi_init+0xd8>)
   1c216:	47a8      	blx	r5
		if (!spi_read_reg(NMI_SPI_PROTOCOL_CONFIG, &reg)){
   1c218:	a901      	add	r1, sp, #4
   1c21a:	4823      	ldr	r0, [pc, #140]	; (1c2a8 <nm_spi_init+0xc0>)
   1c21c:	47a0      	blx	r4
   1c21e:	1e04      	subs	r4, r0, #0
   1c220:	d109      	bne.n	1c236 <nm_spi_init+0x4e>
			M2M_ERR( "[nmi spi]: Failed internal read protocol...\n");
   1c222:	4825      	ldr	r0, [pc, #148]	; (1c2b8 <nm_spi_init+0xd0>)
   1c224:	4a27      	ldr	r2, [pc, #156]	; (1c2c4 <nm_spi_init+0xdc>)
   1c226:	0039      	movs	r1, r7
   1c228:	47a8      	blx	r5
   1c22a:	4827      	ldr	r0, [pc, #156]	; (1c2c8 <nm_spi_init+0xe0>)
			M2M_ERR( "[nmi spi]: Failed internal write protocol reg...\n");
   1c22c:	47a8      	blx	r5
   1c22e:	4824      	ldr	r0, [pc, #144]	; (1c2c0 <nm_spi_init+0xd8>)
   1c230:	47a8      	blx	r5
}
   1c232:	0020      	movs	r0, r4
   1c234:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	if(gu8Crc_off == 0)
   1c236:	7833      	ldrb	r3, [r6, #0]
   1c238:	2b00      	cmp	r3, #0
   1c23a:	d113      	bne.n	1c264 <nm_spi_init+0x7c>
		reg |= (0x5 << 4);
   1c23c:	2150      	movs	r1, #80	; 0x50
		reg &= ~0x70;
   1c23e:	9a01      	ldr	r2, [sp, #4]
   1c240:	337c      	adds	r3, #124	; 0x7c
   1c242:	439a      	bics	r2, r3
		reg |= (0x5 << 4);
   1c244:	4311      	orrs	r1, r2
		if (!spi_write_reg(NMI_SPI_PROTOCOL_CONFIG, reg)) {
   1c246:	4818      	ldr	r0, [pc, #96]	; (1c2a8 <nm_spi_init+0xc0>)
   1c248:	4b20      	ldr	r3, [pc, #128]	; (1c2cc <nm_spi_init+0xe4>)
		reg |= (0x5 << 4);
   1c24a:	9101      	str	r1, [sp, #4]
		if (!spi_write_reg(NMI_SPI_PROTOCOL_CONFIG, reg)) {
   1c24c:	4798      	blx	r3
   1c24e:	1e04      	subs	r4, r0, #0
   1c250:	d106      	bne.n	1c260 <nm_spi_init+0x78>
			M2M_ERR( "[nmi spi]: Failed internal write protocol reg...\n");
   1c252:	4819      	ldr	r0, [pc, #100]	; (1c2b8 <nm_spi_init+0xd0>)
   1c254:	4a1e      	ldr	r2, [pc, #120]	; (1c2d0 <nm_spi_init+0xe8>)
   1c256:	4916      	ldr	r1, [pc, #88]	; (1c2b0 <nm_spi_init+0xc8>)
   1c258:	4d16      	ldr	r5, [pc, #88]	; (1c2b4 <nm_spi_init+0xcc>)
   1c25a:	47a8      	blx	r5
   1c25c:	481d      	ldr	r0, [pc, #116]	; (1c2d4 <nm_spi_init+0xec>)
   1c25e:	e7e5      	b.n	1c22c <nm_spi_init+0x44>
		gu8Crc_off = 1;
   1c260:	2301      	movs	r3, #1
   1c262:	7033      	strb	r3, [r6, #0]
	if (!spi_read_reg(0x1000, &chipid)) {
   1c264:	2080      	movs	r0, #128	; 0x80
   1c266:	4669      	mov	r1, sp
   1c268:	0140      	lsls	r0, r0, #5
   1c26a:	4b10      	ldr	r3, [pc, #64]	; (1c2ac <nm_spi_init+0xc4>)
   1c26c:	4798      	blx	r3
   1c26e:	2800      	cmp	r0, #0
   1c270:	d10b      	bne.n	1c28a <nm_spi_init+0xa2>
		M2M_ERR("[nmi spi]: Fail cmd read chip id...\n");
   1c272:	4c10      	ldr	r4, [pc, #64]	; (1c2b4 <nm_spi_init+0xcc>)
   1c274:	4a18      	ldr	r2, [pc, #96]	; (1c2d8 <nm_spi_init+0xf0>)
   1c276:	490e      	ldr	r1, [pc, #56]	; (1c2b0 <nm_spi_init+0xc8>)
   1c278:	480f      	ldr	r0, [pc, #60]	; (1c2b8 <nm_spi_init+0xd0>)
   1c27a:	47a0      	blx	r4
   1c27c:	4817      	ldr	r0, [pc, #92]	; (1c2dc <nm_spi_init+0xf4>)
   1c27e:	47a0      	blx	r4
   1c280:	480f      	ldr	r0, [pc, #60]	; (1c2c0 <nm_spi_init+0xd8>)
   1c282:	47a0      	blx	r4
		return M2M_ERR_BUS_FAIL;
   1c284:	2406      	movs	r4, #6
   1c286:	4264      	negs	r4, r4
   1c288:	e7d3      	b.n	1c232 <nm_spi_init+0x4a>
	val32 = nm_spi_read_reg(SPI_BASE+0x24);
   1c28a:	4b15      	ldr	r3, [pc, #84]	; (1c2e0 <nm_spi_init+0xf8>)
   1c28c:	4806      	ldr	r0, [pc, #24]	; (1c2a8 <nm_spi_init+0xc0>)
   1c28e:	4798      	blx	r3
	val32 &= ~(0x7 << 4);
   1c290:	2370      	movs	r3, #112	; 0x70
	case 8192: val32 |= (5 << 4); break;
   1c292:	2150      	movs	r1, #80	; 0x50
	val32 &= ~(0x7 << 4);
   1c294:	4398      	bics	r0, r3
	case 8192: val32 |= (5 << 4); break;
   1c296:	4301      	orrs	r1, r0
	nm_spi_write_reg(SPI_BASE+0x24, val32);
   1c298:	4b12      	ldr	r3, [pc, #72]	; (1c2e4 <nm_spi_init+0xfc>)
   1c29a:	4803      	ldr	r0, [pc, #12]	; (1c2a8 <nm_spi_init+0xc0>)
   1c29c:	4798      	blx	r3
	return M2M_SUCCESS;
   1c29e:	2400      	movs	r4, #0
   1c2a0:	e7c7      	b.n	1c232 <nm_spi_init+0x4a>
   1c2a2:	46c0      	nop			; (mov r8, r8)
   1c2a4:	20003d88 	.word	0x20003d88
   1c2a8:	0000e824 	.word	0x0000e824
   1c2ac:	0001bffd 	.word	0x0001bffd
   1c2b0:	0002a663 	.word	0x0002a663
   1c2b4:	00019415 	.word	0x00019415
   1c2b8:	00029fb9 	.word	0x00029fb9
   1c2bc:	0002a76f 	.word	0x0002a76f
   1c2c0:	0002b325 	.word	0x0002b325
   1c2c4:	000004c3 	.word	0x000004c3
   1c2c8:	0002a7bf 	.word	0x0002a7bf
   1c2cc:	0001c0c5 	.word	0x0001c0c5
   1c2d0:	000004cd 	.word	0x000004cd
   1c2d4:	0002a7ec 	.word	0x0002a7ec
   1c2d8:	000004d7 	.word	0x000004d7
   1c2dc:	0002a81e 	.word	0x0002a81e
   1c2e0:	0001c1a9 	.word	0x0001c1a9
   1c2e4:	0001c1d1 	.word	0x0001c1d1

0001c2e8 <nm_spi_read_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
   1c2e8:	b5f0      	push	{r4, r5, r6, r7, lr}
   1c2ea:	0007      	movs	r7, r0
   1c2ec:	260a      	movs	r6, #10
   1c2ee:	b085      	sub	sp, #20
   1c2f0:	9103      	str	r1, [sp, #12]
   1c2f2:	9202      	str	r2, [sp, #8]
	result = spi_cmd_complete(cmd, addr, buf, size, 0);
   1c2f4:	2400      	movs	r4, #0
   1c2f6:	9b02      	ldr	r3, [sp, #8]
   1c2f8:	9400      	str	r4, [sp, #0]
   1c2fa:	9a03      	ldr	r2, [sp, #12]
   1c2fc:	0039      	movs	r1, r7
   1c2fe:	20c8      	movs	r0, #200	; 0xc8
   1c300:	4d16      	ldr	r5, [pc, #88]	; (1c35c <nm_spi_read_block+0x74>)
   1c302:	47a8      	blx	r5
	if (result != N_OK) {
   1c304:	b240      	sxtb	r0, r0
   1c306:	2801      	cmp	r0, #1
   1c308:	d026      	beq.n	1c358 <nm_spi_read_block+0x70>
		M2M_ERR("[nmi spi]: Failed cmd, read block (%08x)...\n", addr);
   1c30a:	4a15      	ldr	r2, [pc, #84]	; (1c360 <nm_spi_read_block+0x78>)
   1c30c:	4c15      	ldr	r4, [pc, #84]	; (1c364 <nm_spi_read_block+0x7c>)
   1c30e:	4916      	ldr	r1, [pc, #88]	; (1c368 <nm_spi_read_block+0x80>)
   1c310:	4816      	ldr	r0, [pc, #88]	; (1c36c <nm_spi_read_block+0x84>)
   1c312:	47a0      	blx	r4
   1c314:	0039      	movs	r1, r7
   1c316:	4816      	ldr	r0, [pc, #88]	; (1c370 <nm_spi_read_block+0x88>)
   1c318:	47a0      	blx	r4
   1c31a:	4d16      	ldr	r5, [pc, #88]	; (1c374 <nm_spi_read_block+0x8c>)
   1c31c:	0028      	movs	r0, r5
   1c31e:	47a0      	blx	r4
		nm_bsp_sleep(1);
   1c320:	2001      	movs	r0, #1
   1c322:	4b15      	ldr	r3, [pc, #84]	; (1c378 <nm_spi_read_block+0x90>)
   1c324:	4798      	blx	r3
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
   1c326:	4b15      	ldr	r3, [pc, #84]	; (1c37c <nm_spi_read_block+0x94>)
   1c328:	4798      	blx	r3
		spi_cmd_rsp(CMD_RESET);
   1c32a:	4b15      	ldr	r3, [pc, #84]	; (1c380 <nm_spi_read_block+0x98>)
   1c32c:	4798      	blx	r3
		M2M_ERR("Reset and retry %d %lx %d\n",retry,addr,size);
   1c32e:	4a15      	ldr	r2, [pc, #84]	; (1c384 <nm_spi_read_block+0x9c>)
   1c330:	490d      	ldr	r1, [pc, #52]	; (1c368 <nm_spi_read_block+0x80>)
   1c332:	480e      	ldr	r0, [pc, #56]	; (1c36c <nm_spi_read_block+0x84>)
   1c334:	47a0      	blx	r4
   1c336:	0031      	movs	r1, r6
   1c338:	9b02      	ldr	r3, [sp, #8]
   1c33a:	003a      	movs	r2, r7
   1c33c:	4812      	ldr	r0, [pc, #72]	; (1c388 <nm_spi_read_block+0xa0>)
   1c33e:	47a0      	blx	r4
   1c340:	0028      	movs	r0, r5
   1c342:	47a0      	blx	r4
   1c344:	3e01      	subs	r6, #1
		nm_bsp_sleep(1);
   1c346:	2001      	movs	r0, #1
   1c348:	4b0b      	ldr	r3, [pc, #44]	; (1c378 <nm_spi_read_block+0x90>)
   1c34a:	4798      	blx	r3
		if(retry) goto _RETRY_;
   1c34c:	2e00      	cmp	r6, #0
   1c34e:	d1d1      	bne.n	1c2f4 <nm_spi_read_block+0xc>
	sint8 s8Ret;

	s8Ret = nm_spi_read(u32Addr, puBuf, u16Sz);

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
	else s8Ret = M2M_ERR_BUS_FAIL;
   1c350:	2006      	movs	r0, #6
   1c352:	4240      	negs	r0, r0

	return s8Ret;
}
   1c354:	b005      	add	sp, #20
   1c356:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
   1c358:	0020      	movs	r0, r4
   1c35a:	e7fb      	b.n	1c354 <nm_spi_read_block+0x6c>
   1c35c:	0001bb4d 	.word	0x0001bb4d
   1c360:	00000472 	.word	0x00000472
   1c364:	00019415 	.word	0x00019415
   1c368:	0002a657 	.word	0x0002a657
   1c36c:	00029fb9 	.word	0x00029fb9
   1c370:	0002a843 	.word	0x0002a843
   1c374:	0002b325 	.word	0x0002b325
   1c378:	0001a489 	.word	0x0001a489
   1c37c:	0001bf81 	.word	0x0001bf81
   1c380:	0001bab5 	.word	0x0001bab5
   1c384:	0000047d 	.word	0x0000047d
   1c388:	0002a870 	.word	0x0002a870

0001c38c <nm_spi_write_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_write_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
   1c38c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1c38e:	270a      	movs	r7, #10
   1c390:	b08b      	sub	sp, #44	; 0x2c
   1c392:	9004      	str	r0, [sp, #16]
   1c394:	9107      	str	r1, [sp, #28]
   1c396:	9205      	str	r2, [sp, #20]
	result = spi_cmd_complete(cmd, addr, NULL, size, 0);
   1c398:	2500      	movs	r5, #0
   1c39a:	9b05      	ldr	r3, [sp, #20]
   1c39c:	9500      	str	r5, [sp, #0]
   1c39e:	002a      	movs	r2, r5
   1c3a0:	9904      	ldr	r1, [sp, #16]
   1c3a2:	20c7      	movs	r0, #199	; 0xc7
   1c3a4:	4c5c      	ldr	r4, [pc, #368]	; (1c518 <nm_spi_write_block+0x18c>)
   1c3a6:	47a0      	blx	r4
	if (result != N_OK) {
   1c3a8:	b240      	sxtb	r0, r0
   1c3aa:	2801      	cmp	r0, #1
   1c3ac:	d024      	beq.n	1c3f8 <nm_spi_write_block+0x6c>
		M2M_ERR( "[nmi spi]: Failed cmd, write block (%08x)...\n", addr);
   1c3ae:	495b      	ldr	r1, [pc, #364]	; (1c51c <nm_spi_write_block+0x190>)
   1c3b0:	485b      	ldr	r0, [pc, #364]	; (1c520 <nm_spi_write_block+0x194>)
   1c3b2:	4a5c      	ldr	r2, [pc, #368]	; (1c524 <nm_spi_write_block+0x198>)
   1c3b4:	4c5c      	ldr	r4, [pc, #368]	; (1c528 <nm_spi_write_block+0x19c>)
   1c3b6:	47a0      	blx	r4
   1c3b8:	9904      	ldr	r1, [sp, #16]
   1c3ba:	485c      	ldr	r0, [pc, #368]	; (1c52c <nm_spi_write_block+0x1a0>)
   1c3bc:	47a0      	blx	r4
		M2M_ERR("[nmi spi]: Failed block data write...\n");
   1c3be:	485c      	ldr	r0, [pc, #368]	; (1c530 <nm_spi_write_block+0x1a4>)
   1c3c0:	47a0      	blx	r4
		nm_bsp_sleep(1);
   1c3c2:	2001      	movs	r0, #1
   1c3c4:	4d5b      	ldr	r5, [pc, #364]	; (1c534 <nm_spi_write_block+0x1a8>)
   1c3c6:	47a8      	blx	r5
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
   1c3c8:	4b5b      	ldr	r3, [pc, #364]	; (1c538 <nm_spi_write_block+0x1ac>)
   1c3ca:	4798      	blx	r3
		spi_cmd_rsp(CMD_RESET);
   1c3cc:	4b5b      	ldr	r3, [pc, #364]	; (1c53c <nm_spi_write_block+0x1b0>)
   1c3ce:	4798      	blx	r3
		M2M_ERR("Reset and retry %d %lx %d\n",retry,addr,size);
   1c3d0:	4c55      	ldr	r4, [pc, #340]	; (1c528 <nm_spi_write_block+0x19c>)
   1c3d2:	4a5b      	ldr	r2, [pc, #364]	; (1c540 <nm_spi_write_block+0x1b4>)
   1c3d4:	4951      	ldr	r1, [pc, #324]	; (1c51c <nm_spi_write_block+0x190>)
   1c3d6:	4852      	ldr	r0, [pc, #328]	; (1c520 <nm_spi_write_block+0x194>)
   1c3d8:	47a0      	blx	r4
   1c3da:	0039      	movs	r1, r7
   1c3dc:	9b05      	ldr	r3, [sp, #20]
   1c3de:	9a04      	ldr	r2, [sp, #16]
   1c3e0:	4858      	ldr	r0, [pc, #352]	; (1c544 <nm_spi_write_block+0x1b8>)
   1c3e2:	47a0      	blx	r4
   1c3e4:	4852      	ldr	r0, [pc, #328]	; (1c530 <nm_spi_write_block+0x1a4>)
   1c3e6:	47a0      	blx	r4
   1c3e8:	3f01      	subs	r7, #1
		nm_bsp_sleep(1);
   1c3ea:	2001      	movs	r0, #1
   1c3ec:	47a8      	blx	r5
		if(retry) goto _RETRY_;
   1c3ee:	2f00      	cmp	r7, #0
   1c3f0:	d1d2      	bne.n	1c398 <nm_spi_write_block+0xc>
	sint8 s8Ret;

	s8Ret = nm_spi_write(u32Addr, puBuf, u16Sz);

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
	else s8Ret = M2M_ERR_BUS_FAIL;
   1c3f2:	2006      	movs	r0, #6
   1c3f4:	4240      	negs	r0, r0

	return s8Ret;
   1c3f6:	e08c      	b.n	1c512 <nm_spi_write_block+0x186>
	uint8 cmd, order, crc[2] = {0};
   1c3f8:	ab09      	add	r3, sp, #36	; 0x24
   1c3fa:	9c05      	ldr	r4, [sp, #20]
   1c3fc:	801d      	strh	r5, [r3, #0]
				order = 0x1;
   1c3fe:	9006      	str	r0, [sp, #24]
   1c400:	2380      	movs	r3, #128	; 0x80
   1c402:	1c20      	adds	r0, r4, #0
   1c404:	019b      	lsls	r3, r3, #6
   1c406:	429c      	cmp	r4, r3
   1c408:	d901      	bls.n	1c40e <nm_spi_write_block+0x82>
   1c40a:	4b4f      	ldr	r3, [pc, #316]	; (1c548 <nm_spi_write_block+0x1bc>)
   1c40c:	8818      	ldrh	r0, [r3, #0]
   1c40e:	b283      	uxth	r3, r0
   1c410:	9303      	str	r3, [sp, #12]
		if (ix == 0)  {
   1c412:	2d00      	cmp	r5, #0
   1c414:	d122      	bne.n	1c45c <nm_spi_write_block+0xd0>
			if (sz <= DATA_PKT_SZ)
   1c416:	2280      	movs	r2, #128	; 0x80
				order = 0x1;
   1c418:	9b06      	ldr	r3, [sp, #24]
			if (sz <= DATA_PKT_SZ)
   1c41a:	0192      	lsls	r2, r2, #6
   1c41c:	4294      	cmp	r4, r2
   1c41e:	d800      	bhi.n	1c422 <nm_spi_write_block+0x96>
				order = 0x3;
   1c420:	2303      	movs	r3, #3
		cmd |= order;
   1c422:	200b      	movs	r0, #11
   1c424:	aa06      	add	r2, sp, #24
   1c426:	1880      	adds	r0, r0, r2
   1c428:	2210      	movs	r2, #16
   1c42a:	4252      	negs	r2, r2
   1c42c:	4313      	orrs	r3, r2
		if (M2M_SUCCESS != nmi_spi_write(&cmd, 1)) {
   1c42e:	9906      	ldr	r1, [sp, #24]
   1c430:	4e46      	ldr	r6, [pc, #280]	; (1c54c <nm_spi_write_block+0x1c0>)
		cmd |= order;
   1c432:	7003      	strb	r3, [r0, #0]
		if (M2M_SUCCESS != nmi_spi_write(&cmd, 1)) {
   1c434:	47b0      	blx	r6
   1c436:	2800      	cmp	r0, #0
   1c438:	d017      	beq.n	1c46a <nm_spi_write_block+0xde>
			M2M_ERR("[nmi spi]: Failed data block cmd write, bus error...\n");
   1c43a:	4839      	ldr	r0, [pc, #228]	; (1c520 <nm_spi_write_block+0x194>)
   1c43c:	4a44      	ldr	r2, [pc, #272]	; (1c550 <nm_spi_write_block+0x1c4>)
   1c43e:	4945      	ldr	r1, [pc, #276]	; (1c554 <nm_spi_write_block+0x1c8>)
   1c440:	4c39      	ldr	r4, [pc, #228]	; (1c528 <nm_spi_write_block+0x19c>)
   1c442:	47a0      	blx	r4
   1c444:	4844      	ldr	r0, [pc, #272]	; (1c558 <nm_spi_write_block+0x1cc>)
				M2M_ERR("[nmi spi]: Failed data block crc write, bus error...\n");
   1c446:	47a0      	blx	r4
   1c448:	4839      	ldr	r0, [pc, #228]	; (1c530 <nm_spi_write_block+0x1a4>)
   1c44a:	47a0      	blx	r4
		M2M_ERR("[nmi spi]: Failed block data write...\n");
   1c44c:	4a43      	ldr	r2, [pc, #268]	; (1c55c <nm_spi_write_block+0x1d0>)
		M2M_ERR("[nmi spi]: Failed block data write...\n");
   1c44e:	4933      	ldr	r1, [pc, #204]	; (1c51c <nm_spi_write_block+0x190>)
   1c450:	4833      	ldr	r0, [pc, #204]	; (1c520 <nm_spi_write_block+0x194>)
   1c452:	4c35      	ldr	r4, [pc, #212]	; (1c528 <nm_spi_write_block+0x19c>)
   1c454:	47a0      	blx	r4
   1c456:	4842      	ldr	r0, [pc, #264]	; (1c560 <nm_spi_write_block+0x1d4>)
   1c458:	47a0      	blx	r4
   1c45a:	e7b0      	b.n	1c3be <nm_spi_write_block+0x32>
				order = 0x3;
   1c45c:	2280      	movs	r2, #128	; 0x80
   1c45e:	2300      	movs	r3, #0
   1c460:	0192      	lsls	r2, r2, #6
   1c462:	42a2      	cmp	r2, r4
   1c464:	415b      	adcs	r3, r3
   1c466:	3302      	adds	r3, #2
   1c468:	e7db      	b.n	1c422 <nm_spi_write_block+0x96>
		if (M2M_SUCCESS != nmi_spi_write(&b[ix], nbytes)) {
   1c46a:	9b07      	ldr	r3, [sp, #28]
   1c46c:	9903      	ldr	r1, [sp, #12]
   1c46e:	1958      	adds	r0, r3, r5
   1c470:	47b0      	blx	r6
   1c472:	2800      	cmp	r0, #0
   1c474:	d006      	beq.n	1c484 <nm_spi_write_block+0xf8>
			M2M_ERR("[nmi spi]: Failed data block write, bus error...\n");
   1c476:	482a      	ldr	r0, [pc, #168]	; (1c520 <nm_spi_write_block+0x194>)
   1c478:	4a3a      	ldr	r2, [pc, #232]	; (1c564 <nm_spi_write_block+0x1d8>)
   1c47a:	4936      	ldr	r1, [pc, #216]	; (1c554 <nm_spi_write_block+0x1c8>)
   1c47c:	4c2a      	ldr	r4, [pc, #168]	; (1c528 <nm_spi_write_block+0x19c>)
   1c47e:	47a0      	blx	r4
   1c480:	4839      	ldr	r0, [pc, #228]	; (1c568 <nm_spi_write_block+0x1dc>)
   1c482:	e7e0      	b.n	1c446 <nm_spi_write_block+0xba>
		if (!gu8Crc_off) {
   1c484:	4b39      	ldr	r3, [pc, #228]	; (1c56c <nm_spi_write_block+0x1e0>)
   1c486:	781b      	ldrb	r3, [r3, #0]
   1c488:	2b00      	cmp	r3, #0
   1c48a:	d10c      	bne.n	1c4a6 <nm_spi_write_block+0x11a>
			if (M2M_SUCCESS != nmi_spi_write(crc, 2)) {
   1c48c:	2102      	movs	r1, #2
   1c48e:	a809      	add	r0, sp, #36	; 0x24
   1c490:	47b0      	blx	r6
   1c492:	2800      	cmp	r0, #0
   1c494:	d007      	beq.n	1c4a6 <nm_spi_write_block+0x11a>
				M2M_ERR("[nmi spi]: Failed data block crc write, bus error...\n");
   1c496:	22d7      	movs	r2, #215	; 0xd7
   1c498:	4821      	ldr	r0, [pc, #132]	; (1c520 <nm_spi_write_block+0x194>)
   1c49a:	0092      	lsls	r2, r2, #2
   1c49c:	492d      	ldr	r1, [pc, #180]	; (1c554 <nm_spi_write_block+0x1c8>)
   1c49e:	4c22      	ldr	r4, [pc, #136]	; (1c528 <nm_spi_write_block+0x19c>)
   1c4a0:	47a0      	blx	r4
   1c4a2:	4833      	ldr	r0, [pc, #204]	; (1c570 <nm_spi_write_block+0x1e4>)
   1c4a4:	e7cf      	b.n	1c446 <nm_spi_write_block+0xba>
		ix += nbytes;
   1c4a6:	9b03      	ldr	r3, [sp, #12]
		sz -= nbytes;
   1c4a8:	1ae4      	subs	r4, r4, r3
		ix += nbytes;
   1c4aa:	195d      	adds	r5, r3, r5
		sz -= nbytes;
   1c4ac:	b2a4      	uxth	r4, r4
		ix += nbytes;
   1c4ae:	b22d      	sxth	r5, r5
	} while (sz);
   1c4b0:	2c00      	cmp	r4, #0
   1c4b2:	d1a5      	bne.n	1c400 <nm_spi_write_block+0x74>
    if (!gu8Crc_off)
   1c4b4:	4b2d      	ldr	r3, [pc, #180]	; (1c56c <nm_spi_write_block+0x1e0>)
	if (M2M_SUCCESS != nmi_spi_read(&rsp[0], len)) {
   1c4b6:	a809      	add	r0, sp, #36	; 0x24
    if (!gu8Crc_off)
   1c4b8:	781d      	ldrb	r5, [r3, #0]
		len = 3;
   1c4ba:	1e6b      	subs	r3, r5, #1
   1c4bc:	419d      	sbcs	r5, r3
   1c4be:	3502      	adds	r5, #2
	if (M2M_SUCCESS != nmi_spi_read(&rsp[0], len)) {
   1c4c0:	b2a9      	uxth	r1, r5
   1c4c2:	4b2c      	ldr	r3, [pc, #176]	; (1c574 <nm_spi_write_block+0x1e8>)
   1c4c4:	4798      	blx	r3
   1c4c6:	2800      	cmp	r0, #0
   1c4c8:	d00b      	beq.n	1c4e2 <nm_spi_write_block+0x156>
		M2M_ERR("[nmi spi]: Failed bus error...\n");
   1c4ca:	229a      	movs	r2, #154	; 0x9a
   1c4cc:	4814      	ldr	r0, [pc, #80]	; (1c520 <nm_spi_write_block+0x194>)
   1c4ce:	0052      	lsls	r2, r2, #1
   1c4d0:	4929      	ldr	r1, [pc, #164]	; (1c578 <nm_spi_write_block+0x1ec>)
   1c4d2:	4c15      	ldr	r4, [pc, #84]	; (1c528 <nm_spi_write_block+0x19c>)
   1c4d4:	47a0      	blx	r4
   1c4d6:	4829      	ldr	r0, [pc, #164]	; (1c57c <nm_spi_write_block+0x1f0>)
   1c4d8:	47a0      	blx	r4
		M2M_ERR("[nmi spi]: Failed data response read, %x %x %x\n",rsp[0],rsp[1],rsp[2]);
   1c4da:	4815      	ldr	r0, [pc, #84]	; (1c530 <nm_spi_write_block+0x1a4>)
   1c4dc:	47a0      	blx	r4
		M2M_ERR("[nmi spi]: Failed block data write...\n");
   1c4de:	4a28      	ldr	r2, [pc, #160]	; (1c580 <nm_spi_write_block+0x1f4>)
   1c4e0:	e7b5      	b.n	1c44e <nm_spi_write_block+0xc2>
	if((rsp[len-1] != 0)||(rsp[len-2] != 0xC3))
   1c4e2:	ab09      	add	r3, sp, #36	; 0x24
   1c4e4:	195d      	adds	r5, r3, r5
   1c4e6:	1e6b      	subs	r3, r5, #1
   1c4e8:	781b      	ldrb	r3, [r3, #0]
   1c4ea:	2b00      	cmp	r3, #0
   1c4ec:	d103      	bne.n	1c4f6 <nm_spi_write_block+0x16a>
   1c4ee:	3d02      	subs	r5, #2
   1c4f0:	782b      	ldrb	r3, [r5, #0]
   1c4f2:	2bc3      	cmp	r3, #195	; 0xc3
   1c4f4:	d00c      	beq.n	1c510 <nm_spi_write_block+0x184>
		M2M_ERR("[nmi spi]: Failed data response read, %x %x %x\n",rsp[0],rsp[1],rsp[2]);
   1c4f6:	223c      	movs	r2, #60	; 0x3c
   1c4f8:	491f      	ldr	r1, [pc, #124]	; (1c578 <nm_spi_write_block+0x1ec>)
   1c4fa:	32ff      	adds	r2, #255	; 0xff
   1c4fc:	4808      	ldr	r0, [pc, #32]	; (1c520 <nm_spi_write_block+0x194>)
   1c4fe:	4c0a      	ldr	r4, [pc, #40]	; (1c528 <nm_spi_write_block+0x19c>)
   1c500:	47a0      	blx	r4
   1c502:	a909      	add	r1, sp, #36	; 0x24
   1c504:	788b      	ldrb	r3, [r1, #2]
   1c506:	784a      	ldrb	r2, [r1, #1]
   1c508:	481e      	ldr	r0, [pc, #120]	; (1c584 <nm_spi_write_block+0x1f8>)
   1c50a:	7809      	ldrb	r1, [r1, #0]
   1c50c:	47a0      	blx	r4
   1c50e:	e7e4      	b.n	1c4da <nm_spi_write_block+0x14e>
	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
   1c510:	0020      	movs	r0, r4
}
   1c512:	b00b      	add	sp, #44	; 0x2c
   1c514:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1c516:	46c0      	nop			; (mov r8, r8)
   1c518:	0001bb4d 	.word	0x0001bb4d
   1c51c:	0002a63d 	.word	0x0002a63d
   1c520:	00029fb9 	.word	0x00029fb9
   1c524:	000003cf 	.word	0x000003cf
   1c528:	00019415 	.word	0x00019415
   1c52c:	0002a88b 	.word	0x0002a88b
   1c530:	0002b325 	.word	0x0002b325
   1c534:	0001a489 	.word	0x0001a489
   1c538:	0001bf81 	.word	0x0001bf81
   1c53c:	0001bab5 	.word	0x0001bab5
   1c540:	000003eb 	.word	0x000003eb
   1c544:	0002a870 	.word	0x0002a870
   1c548:	0002a5ec 	.word	0x0002a5ec
   1c54c:	0001ba7d 	.word	0x0001ba7d
   1c550:	00000349 	.word	0x00000349
   1c554:	0002a620 	.word	0x0002a620
   1c558:	0002a8b9 	.word	0x0002a8b9
   1c55c:	000003d9 	.word	0x000003d9
   1c560:	0002a9a7 	.word	0x0002a9a7
   1c564:	00000352 	.word	0x00000352
   1c568:	0002a8ef 	.word	0x0002a8ef
   1c56c:	20003d88 	.word	0x20003d88
   1c570:	0002a921 	.word	0x0002a921
   1c574:	0001ba99 	.word	0x0001ba99
   1c578:	0002a5f6 	.word	0x0002a5f6
   1c57c:	0002a957 	.word	0x0002a957
   1c580:	000003e1 	.word	0x000003e1
   1c584:	0002a977 	.word	0x0002a977

0001c588 <Socket_ReadSocketData>:
Date
		17 July 2012
*********************************************************************/
NMI_API void Socket_ReadSocketData(SOCKET sock, tstrSocketRecvMsg *pstrRecv,uint8 u8SocketMsg,
								  uint32 u32StartAddress,uint16 u16ReadCount)
{
   1c588:	b5f0      	push	{r4, r5, r6, r7, lr}
   1c58a:	b087      	sub	sp, #28
   1c58c:	9302      	str	r3, [sp, #8]
   1c58e:	ab0c      	add	r3, sp, #48	; 0x30
   1c590:	881c      	ldrh	r4, [r3, #0]
   1c592:	9001      	str	r0, [sp, #4]
   1c594:	000e      	movs	r6, r1
   1c596:	9204      	str	r2, [sp, #16]
	if((u16ReadCount > 0) && (gastrSockets[sock].pu8UserBuffer != NULL) && (gastrSockets[sock].u16UserBufferSize > 0) && (gastrSockets[sock].bIsUsed == 1))
   1c598:	2c00      	cmp	r4, #0
   1c59a:	d04b      	beq.n	1c634 <Socket_ReadSocketData+0xac>
   1c59c:	4a2e      	ldr	r2, [pc, #184]	; (1c658 <Socket_ReadSocketData+0xd0>)
   1c59e:	0103      	lsls	r3, r0, #4
   1c5a0:	589a      	ldr	r2, [r3, r2]
   1c5a2:	2a00      	cmp	r2, #0
   1c5a4:	d046      	beq.n	1c634 <Socket_ReadSocketData+0xac>
   1c5a6:	4a2c      	ldr	r2, [pc, #176]	; (1c658 <Socket_ReadSocketData+0xd0>)
   1c5a8:	18d3      	adds	r3, r2, r3
   1c5aa:	889a      	ldrh	r2, [r3, #4]
   1c5ac:	2a00      	cmp	r2, #0
   1c5ae:	d041      	beq.n	1c634 <Socket_ReadSocketData+0xac>
   1c5b0:	7a9b      	ldrb	r3, [r3, #10]
   1c5b2:	b2db      	uxtb	r3, r3
   1c5b4:	2b01      	cmp	r3, #1
   1c5b6:	d13d      	bne.n	1c634 <Socket_ReadSocketData+0xac>
		uint32	u32Address = u32StartAddress;
		uint16	u16Read;
		sint16	s16Diff;
		uint8	u8SetRxDone;

		pstrRecv->u16RemainingSize = u16ReadCount;
   1c5b8:	80cc      	strh	r4, [r1, #6]
		do
		{
			u8SetRxDone = 1;
   1c5ba:	9305      	str	r3, [sp, #20]
			u16Read = u16ReadCount;
			s16Diff	= u16Read - gastrSockets[sock].u16UserBufferSize;
   1c5bc:	9b01      	ldr	r3, [sp, #4]
   1c5be:	011b      	lsls	r3, r3, #4
   1c5c0:	9303      	str	r3, [sp, #12]
   1c5c2:	9a03      	ldr	r2, [sp, #12]
   1c5c4:	4b24      	ldr	r3, [pc, #144]	; (1c658 <Socket_ReadSocketData+0xd0>)
   1c5c6:	189a      	adds	r2, r3, r2
   1c5c8:	8893      	ldrh	r3, [r2, #4]
   1c5ca:	1ae3      	subs	r3, r4, r3
			if(s16Diff > 0)
   1c5cc:	b21b      	sxth	r3, r3
   1c5ce:	2b00      	cmp	r3, #0
   1c5d0:	dd32      	ble.n	1c638 <Socket_ReadSocketData+0xb0>
			{
				u8SetRxDone = 0;
   1c5d2:	2300      	movs	r3, #0
				u16Read		= gastrSockets[sock].u16UserBufferSize;
   1c5d4:	8895      	ldrh	r5, [r2, #4]
   1c5d6:	b2ad      	uxth	r5, r5
			}
			
			if(hif_receive(u32Address, gastrSockets[sock].pu8UserBuffer, u16Read, u8SetRxDone) == M2M_SUCCESS)
   1c5d8:	4a1f      	ldr	r2, [pc, #124]	; (1c658 <Socket_ReadSocketData+0xd0>)
   1c5da:	9903      	ldr	r1, [sp, #12]
   1c5dc:	9802      	ldr	r0, [sp, #8]
   1c5de:	5851      	ldr	r1, [r2, r1]
   1c5e0:	4f1e      	ldr	r7, [pc, #120]	; (1c65c <Socket_ReadSocketData+0xd4>)
   1c5e2:	002a      	movs	r2, r5
   1c5e4:	47b8      	blx	r7
   1c5e6:	2800      	cmp	r0, #0
   1c5e8:	d129      	bne.n	1c63e <Socket_ReadSocketData+0xb6>
			{
				pstrRecv->pu8Buffer			= gastrSockets[sock].pu8UserBuffer;
   1c5ea:	9a03      	ldr	r2, [sp, #12]
   1c5ec:	4b1a      	ldr	r3, [pc, #104]	; (1c658 <Socket_ReadSocketData+0xd0>)
   1c5ee:	589b      	ldr	r3, [r3, r2]
				pstrRecv->s16BufferSize		= u16Read;
   1c5f0:	80b5      	strh	r5, [r6, #4]
				pstrRecv->pu8Buffer			= gastrSockets[sock].pu8UserBuffer;
   1c5f2:	6033      	str	r3, [r6, #0]
				pstrRecv->u16RemainingSize	-= u16Read;
   1c5f4:	88f3      	ldrh	r3, [r6, #6]
   1c5f6:	1b5b      	subs	r3, r3, r5
   1c5f8:	80f3      	strh	r3, [r6, #6]

				if (gpfAppSocketCb)
   1c5fa:	4b19      	ldr	r3, [pc, #100]	; (1c660 <Socket_ReadSocketData+0xd8>)
   1c5fc:	681a      	ldr	r2, [r3, #0]
   1c5fe:	2a00      	cmp	r2, #0
   1c600:	d004      	beq.n	1c60c <Socket_ReadSocketData+0x84>
					gpfAppSocketCb(sock,u8SocketMsg, pstrRecv);
   1c602:	681b      	ldr	r3, [r3, #0]
   1c604:	0032      	movs	r2, r6
   1c606:	9904      	ldr	r1, [sp, #16]
   1c608:	9801      	ldr	r0, [sp, #4]
   1c60a:	4798      	blx	r3

				u16ReadCount -= u16Read;
				u32Address += u16Read;
   1c60c:	9b02      	ldr	r3, [sp, #8]

				if((!gastrSockets[sock].bIsUsed) && (u16ReadCount))
   1c60e:	4a12      	ldr	r2, [pc, #72]	; (1c658 <Socket_ReadSocketData+0xd0>)
				u32Address += u16Read;
   1c610:	195b      	adds	r3, r3, r5
   1c612:	9302      	str	r3, [sp, #8]
				if((!gastrSockets[sock].bIsUsed) && (u16ReadCount))
   1c614:	9b01      	ldr	r3, [sp, #4]
				u16ReadCount -= u16Read;
   1c616:	1b64      	subs	r4, r4, r5
				if((!gastrSockets[sock].bIsUsed) && (u16ReadCount))
   1c618:	011b      	lsls	r3, r3, #4
   1c61a:	18d3      	adds	r3, r2, r3
   1c61c:	7a98      	ldrb	r0, [r3, #10]
				u16ReadCount -= u16Read;
   1c61e:	b2a4      	uxth	r4, r4
				if((!gastrSockets[sock].bIsUsed) && (u16ReadCount))
   1c620:	b2c0      	uxtb	r0, r0
   1c622:	2800      	cmp	r0, #0
   1c624:	d114      	bne.n	1c650 <Socket_ReadSocketData+0xc8>
   1c626:	2c00      	cmp	r4, #0
   1c628:	d004      	beq.n	1c634 <Socket_ReadSocketData+0xac>
				{
					M2M_DBG("Application Closed Socket While Rx Is not Complete\n");
					if(hif_receive(0, NULL, 0, 1) == M2M_SUCCESS)
   1c62a:	2301      	movs	r3, #1
   1c62c:	0002      	movs	r2, r0
   1c62e:	0001      	movs	r1, r0
   1c630:	4c0a      	ldr	r4, [pc, #40]	; (1c65c <Socket_ReadSocketData+0xd4>)
   1c632:	47a0      	blx	r4
				M2M_INFO("(ERRR)Current <%d>\n", u16ReadCount);
				break;
			}
		}while(u16ReadCount != 0);
	}
}
   1c634:	b007      	add	sp, #28
   1c636:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if(s16Diff > 0)
   1c638:	0025      	movs	r5, r4
			u8SetRxDone = 1;
   1c63a:	9b05      	ldr	r3, [sp, #20]
   1c63c:	e7cc      	b.n	1c5d8 <Socket_ReadSocketData+0x50>
				M2M_INFO("(ERRR)Current <%d>\n", u16ReadCount);
   1c63e:	4d09      	ldr	r5, [pc, #36]	; (1c664 <Socket_ReadSocketData+0xdc>)
   1c640:	4809      	ldr	r0, [pc, #36]	; (1c668 <Socket_ReadSocketData+0xe0>)
   1c642:	47a8      	blx	r5
   1c644:	0021      	movs	r1, r4
   1c646:	4809      	ldr	r0, [pc, #36]	; (1c66c <Socket_ReadSocketData+0xe4>)
   1c648:	47a8      	blx	r5
   1c64a:	4809      	ldr	r0, [pc, #36]	; (1c670 <Socket_ReadSocketData+0xe8>)
   1c64c:	47a8      	blx	r5
   1c64e:	e7f1      	b.n	1c634 <Socket_ReadSocketData+0xac>
		}while(u16ReadCount != 0);
   1c650:	2c00      	cmp	r4, #0
   1c652:	d1b3      	bne.n	1c5bc <Socket_ReadSocketData+0x34>
   1c654:	e7ee      	b.n	1c634 <Socket_ReadSocketData+0xac>
   1c656:	46c0      	nop			; (mov r8, r8)
   1c658:	2000557c 	.word	0x2000557c
   1c65c:	0001ad51 	.word	0x0001ad51
   1c660:	2000562c 	.word	0x2000562c
   1c664:	00019415 	.word	0x00019415
   1c668:	0002a2b4 	.word	0x0002a2b4
   1c66c:	0002ac45 	.word	0x0002ac45
   1c670:	0002b325 	.word	0x0002b325

0001c674 <m2m_ip_cb>:

Date
		17 July 2012
*********************************************************************/
static void m2m_ip_cb(uint8 u8OpCode, uint16 u16BufferSize,uint32 u32Address)
{	
   1c674:	b5f0      	push	{r4, r5, r6, r7, lr}
   1c676:	b09d      	sub	sp, #116	; 0x74
   1c678:	9102      	str	r1, [sp, #8]
   1c67a:	0014      	movs	r4, r2
	if((u8OpCode == SOCKET_CMD_BIND) || (u8OpCode == SOCKET_CMD_SSL_BIND))
   1c67c:	2841      	cmp	r0, #65	; 0x41
   1c67e:	d001      	beq.n	1c684 <m2m_ip_cb+0x10>
   1c680:	2854      	cmp	r0, #84	; 0x54
   1c682:	d116      	bne.n	1c6b2 <m2m_ip_cb+0x3e>
	{
		tstrBindReply		strBindReply;
		tstrSocketBindMsg	strBind;

		if(hif_receive(u32Address, (uint8*)&strBindReply, sizeof(tstrBindReply), 0) == M2M_SUCCESS)
   1c684:	ad0b      	add	r5, sp, #44	; 0x2c
   1c686:	0020      	movs	r0, r4
   1c688:	2300      	movs	r3, #0
   1c68a:	2204      	movs	r2, #4
   1c68c:	0029      	movs	r1, r5
   1c68e:	4c9a      	ldr	r4, [pc, #616]	; (1c8f8 <m2m_ip_cb+0x284>)
   1c690:	47a0      	blx	r4
   1c692:	2800      	cmp	r0, #0
   1c694:	d10b      	bne.n	1c6ae <m2m_ip_cb+0x3a>
		{
			strBind.status = strBindReply.s8Status;
   1c696:	786b      	ldrb	r3, [r5, #1]
   1c698:	aa07      	add	r2, sp, #28
   1c69a:	7013      	strb	r3, [r2, #0]
			if(gpfAppSocketCb)
   1c69c:	4b97      	ldr	r3, [pc, #604]	; (1c8fc <m2m_ip_cb+0x288>)
   1c69e:	6819      	ldr	r1, [r3, #0]
   1c6a0:	2900      	cmp	r1, #0
   1c6a2:	d004      	beq.n	1c6ae <m2m_ip_cb+0x3a>
				gpfAppSocketCb(strBindReply.sock,SOCKET_MSG_BIND,&strBind);
   1c6a4:	2000      	movs	r0, #0
   1c6a6:	2101      	movs	r1, #1
   1c6a8:	681b      	ldr	r3, [r3, #0]
   1c6aa:	5628      	ldrsb	r0, [r5, r0]
		tstrSocketListenMsg		strListen;
		if(hif_receive(u32Address, (uint8*)&strListenReply, sizeof(tstrListenReply), 0) == M2M_SUCCESS)
		{
			strListen.status = strListenReply.s8Status;
			if(gpfAppSocketCb)
				gpfAppSocketCb(strListenReply.sock,SOCKET_MSG_LISTEN, &strListen);
   1c6ac:	4798      	blx	r3
			{
				gfpPingCb(strPingReply.u32IPAddr, strPingReply.u32RTT, strPingReply.u8ErrorCode);
			}
		}
	}
}
   1c6ae:	b01d      	add	sp, #116	; 0x74
   1c6b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	else if(u8OpCode == SOCKET_CMD_LISTEN)
   1c6b2:	2842      	cmp	r0, #66	; 0x42
   1c6b4:	d114      	bne.n	1c6e0 <m2m_ip_cb+0x6c>
		if(hif_receive(u32Address, (uint8*)&strListenReply, sizeof(tstrListenReply), 0) == M2M_SUCCESS)
   1c6b6:	ad0b      	add	r5, sp, #44	; 0x2c
   1c6b8:	0020      	movs	r0, r4
   1c6ba:	2300      	movs	r3, #0
   1c6bc:	2204      	movs	r2, #4
   1c6be:	0029      	movs	r1, r5
   1c6c0:	4c8d      	ldr	r4, [pc, #564]	; (1c8f8 <m2m_ip_cb+0x284>)
   1c6c2:	47a0      	blx	r4
   1c6c4:	2800      	cmp	r0, #0
   1c6c6:	d1f2      	bne.n	1c6ae <m2m_ip_cb+0x3a>
			strListen.status = strListenReply.s8Status;
   1c6c8:	786b      	ldrb	r3, [r5, #1]
   1c6ca:	aa07      	add	r2, sp, #28
   1c6cc:	7013      	strb	r3, [r2, #0]
			if(gpfAppSocketCb)
   1c6ce:	4b8b      	ldr	r3, [pc, #556]	; (1c8fc <m2m_ip_cb+0x288>)
   1c6d0:	6819      	ldr	r1, [r3, #0]
   1c6d2:	2900      	cmp	r1, #0
   1c6d4:	d0eb      	beq.n	1c6ae <m2m_ip_cb+0x3a>
				gpfAppSocketCb(strListenReply.sock,SOCKET_MSG_LISTEN, &strListen);
   1c6d6:	2000      	movs	r0, #0
   1c6d8:	681b      	ldr	r3, [r3, #0]
   1c6da:	5628      	ldrsb	r0, [r5, r0]
   1c6dc:	2102      	movs	r1, #2
   1c6de:	e7e5      	b.n	1c6ac <m2m_ip_cb+0x38>
	else if(u8OpCode == SOCKET_CMD_ACCEPT)
   1c6e0:	2843      	cmp	r0, #67	; 0x43
   1c6e2:	d13d      	bne.n	1c760 <m2m_ip_cb+0xec>
		if(hif_receive(u32Address, (uint8*)&strAcceptReply, sizeof(tstrAcceptReply), 0) == M2M_SUCCESS)
   1c6e4:	ad07      	add	r5, sp, #28
   1c6e6:	0020      	movs	r0, r4
   1c6e8:	2300      	movs	r3, #0
   1c6ea:	220c      	movs	r2, #12
   1c6ec:	0029      	movs	r1, r5
   1c6ee:	4c82      	ldr	r4, [pc, #520]	; (1c8f8 <m2m_ip_cb+0x284>)
   1c6f0:	47a0      	blx	r4
   1c6f2:	2800      	cmp	r0, #0
   1c6f4:	d1db      	bne.n	1c6ae <m2m_ip_cb+0x3a>
			if(strAcceptReply.sConnectedSock >= 0)
   1c6f6:	2009      	movs	r0, #9
   1c6f8:	5628      	ldrsb	r0, [r5, r0]
   1c6fa:	2800      	cmp	r0, #0
   1c6fc:	db1f      	blt.n	1c73e <m2m_ip_cb+0xca>
				gastrSockets[strAcceptReply.sConnectedSock].u8SSLFlags 		= gastrSockets[strAcceptReply.sListenSock].u8SSLFlags;
   1c6fe:	2308      	movs	r3, #8
   1c700:	56eb      	ldrsb	r3, [r5, r3]
   1c702:	4a7f      	ldr	r2, [pc, #508]	; (1c900 <m2m_ip_cb+0x28c>)
   1c704:	011b      	lsls	r3, r3, #4
   1c706:	18d3      	adds	r3, r2, r3
   1c708:	7adb      	ldrb	r3, [r3, #11]
   1c70a:	0104      	lsls	r4, r0, #4
   1c70c:	1911      	adds	r1, r2, r4
   1c70e:	b2db      	uxtb	r3, r3
   1c710:	72cb      	strb	r3, [r1, #11]
				gastrSockets[strAcceptReply.sConnectedSock].bIsUsed 		= 1;
   1c712:	2301      	movs	r3, #1
   1c714:	728b      	strb	r3, [r1, #10]
				gastrSockets[strAcceptReply.sConnectedSock].u16DataOffset 	= strAcceptReply.u16AppDataOffset - M2M_HIF_HDR_OFFSET;
   1c716:	896b      	ldrh	r3, [r5, #10]
   1c718:	3b08      	subs	r3, #8
   1c71a:	b29b      	uxth	r3, r3
   1c71c:	810b      	strh	r3, [r1, #8]
				++gu16SessionID;
   1c71e:	4b79      	ldr	r3, [pc, #484]	; (1c904 <m2m_ip_cb+0x290>)
   1c720:	8819      	ldrh	r1, [r3, #0]
   1c722:	3101      	adds	r1, #1
   1c724:	b289      	uxth	r1, r1
   1c726:	8019      	strh	r1, [r3, #0]
				if(gu16SessionID == 0)
   1c728:	8819      	ldrh	r1, [r3, #0]
   1c72a:	2900      	cmp	r1, #0
   1c72c:	d103      	bne.n	1c736 <m2m_ip_cb+0xc2>
					++gu16SessionID;
   1c72e:	8819      	ldrh	r1, [r3, #0]
   1c730:	3101      	adds	r1, #1
   1c732:	b289      	uxth	r1, r1
   1c734:	8019      	strh	r1, [r3, #0]
				gastrSockets[strAcceptReply.sConnectedSock].u16SessionID = gu16SessionID;
   1c736:	881b      	ldrh	r3, [r3, #0]
   1c738:	1912      	adds	r2, r2, r4
   1c73a:	b29b      	uxth	r3, r3
   1c73c:	80d3      	strh	r3, [r2, #6]
			strAccept.strAddr.sin_family		= AF_INET;
   1c73e:	2302      	movs	r3, #2
			strAccept.sock = strAcceptReply.sConnectedSock;
   1c740:	aa0b      	add	r2, sp, #44	; 0x2c
   1c742:	7010      	strb	r0, [r2, #0]
			strAccept.strAddr.sin_family		= AF_INET;
   1c744:	8093      	strh	r3, [r2, #4]
			strAccept.strAddr.sin_port = strAcceptReply.strAddr.u16Port;
   1c746:	886b      	ldrh	r3, [r5, #2]
   1c748:	80d3      	strh	r3, [r2, #6]
			strAccept.strAddr.sin_addr.s_addr = strAcceptReply.strAddr.u32IPAddr;
   1c74a:	686b      	ldr	r3, [r5, #4]
   1c74c:	6093      	str	r3, [r2, #8]
			if(gpfAppSocketCb)
   1c74e:	4b6b      	ldr	r3, [pc, #428]	; (1c8fc <m2m_ip_cb+0x288>)
   1c750:	6819      	ldr	r1, [r3, #0]
   1c752:	2900      	cmp	r1, #0
   1c754:	d0ab      	beq.n	1c6ae <m2m_ip_cb+0x3a>
				gpfAppSocketCb(strAcceptReply.sListenSock, SOCKET_MSG_ACCEPT, &strAccept);
   1c756:	2008      	movs	r0, #8
   1c758:	681b      	ldr	r3, [r3, #0]
   1c75a:	5628      	ldrsb	r0, [r5, r0]
   1c75c:	2104      	movs	r1, #4
   1c75e:	e7a5      	b.n	1c6ac <m2m_ip_cb+0x38>
	else if((u8OpCode == SOCKET_CMD_CONNECT) || (u8OpCode == SOCKET_CMD_SSL_CONNECT))
   1c760:	2844      	cmp	r0, #68	; 0x44
   1c762:	d001      	beq.n	1c768 <m2m_ip_cb+0xf4>
   1c764:	284b      	cmp	r0, #75	; 0x4b
   1c766:	d121      	bne.n	1c7ac <m2m_ip_cb+0x138>
		if(hif_receive(u32Address, (uint8*)&strConnectReply, sizeof(tstrConnectReply), 0) == M2M_SUCCESS)
   1c768:	ad0b      	add	r5, sp, #44	; 0x2c
   1c76a:	0020      	movs	r0, r4
   1c76c:	2300      	movs	r3, #0
   1c76e:	2204      	movs	r2, #4
   1c770:	0029      	movs	r1, r5
   1c772:	4c61      	ldr	r4, [pc, #388]	; (1c8f8 <m2m_ip_cb+0x284>)
   1c774:	47a0      	blx	r4
   1c776:	2800      	cmp	r0, #0
   1c778:	d000      	beq.n	1c77c <m2m_ip_cb+0x108>
   1c77a:	e798      	b.n	1c6ae <m2m_ip_cb+0x3a>
			strConnMsg.sock		= strConnectReply.sock;
   1c77c:	2000      	movs	r0, #0
			strConnMsg.s8Error	= strConnectReply.s8Error;
   1c77e:	2301      	movs	r3, #1
			strConnMsg.sock		= strConnectReply.sock;
   1c780:	5628      	ldrsb	r0, [r5, r0]
   1c782:	aa07      	add	r2, sp, #28
   1c784:	7010      	strb	r0, [r2, #0]
			strConnMsg.s8Error	= strConnectReply.s8Error;
   1c786:	56eb      	ldrsb	r3, [r5, r3]
   1c788:	7053      	strb	r3, [r2, #1]
			if(strConnectReply.s8Error == SOCK_ERR_NO_ERROR)
   1c78a:	2b00      	cmp	r3, #0
   1c78c:	d106      	bne.n	1c79c <m2m_ip_cb+0x128>
				gastrSockets[strConnectReply.sock].u16DataOffset = strConnectReply.u16AppDataOffset - M2M_HIF_HDR_OFFSET;
   1c78e:	886b      	ldrh	r3, [r5, #2]
   1c790:	495b      	ldr	r1, [pc, #364]	; (1c900 <m2m_ip_cb+0x28c>)
   1c792:	3b08      	subs	r3, #8
   1c794:	0104      	lsls	r4, r0, #4
   1c796:	b29b      	uxth	r3, r3
   1c798:	1909      	adds	r1, r1, r4
   1c79a:	810b      	strh	r3, [r1, #8]
			if(gpfAppSocketCb)
   1c79c:	4b57      	ldr	r3, [pc, #348]	; (1c8fc <m2m_ip_cb+0x288>)
   1c79e:	6819      	ldr	r1, [r3, #0]
   1c7a0:	2900      	cmp	r1, #0
   1c7a2:	d100      	bne.n	1c7a6 <m2m_ip_cb+0x132>
   1c7a4:	e783      	b.n	1c6ae <m2m_ip_cb+0x3a>
				gpfAppSocketCb(strConnectReply.sock,SOCKET_MSG_CONNECT, &strConnMsg);
   1c7a6:	681b      	ldr	r3, [r3, #0]
   1c7a8:	2105      	movs	r1, #5
   1c7aa:	e77f      	b.n	1c6ac <m2m_ip_cb+0x38>
	else if(u8OpCode == SOCKET_CMD_DNS_RESOLVE)
   1c7ac:	284a      	cmp	r0, #74	; 0x4a
   1c7ae:	d112      	bne.n	1c7d6 <m2m_ip_cb+0x162>
		if(hif_receive(u32Address, (uint8*)&strDnsReply, sizeof(tstrDnsReply), 0) == M2M_SUCCESS)
   1c7b0:	0020      	movs	r0, r4
   1c7b2:	2300      	movs	r3, #0
   1c7b4:	2244      	movs	r2, #68	; 0x44
   1c7b6:	a90b      	add	r1, sp, #44	; 0x2c
   1c7b8:	4c4f      	ldr	r4, [pc, #316]	; (1c8f8 <m2m_ip_cb+0x284>)
   1c7ba:	47a0      	blx	r4
   1c7bc:	2800      	cmp	r0, #0
   1c7be:	d000      	beq.n	1c7c2 <m2m_ip_cb+0x14e>
   1c7c0:	e775      	b.n	1c6ae <m2m_ip_cb+0x3a>
			if(gpfAppResolveCb)
   1c7c2:	4b51      	ldr	r3, [pc, #324]	; (1c908 <m2m_ip_cb+0x294>)
   1c7c4:	681a      	ldr	r2, [r3, #0]
   1c7c6:	2a00      	cmp	r2, #0
   1c7c8:	d100      	bne.n	1c7cc <m2m_ip_cb+0x158>
   1c7ca:	e770      	b.n	1c6ae <m2m_ip_cb+0x3a>
				gpfAppResolveCb((uint8*)strDnsReply.acHostName, strDnsReply.u32HostIP);
   1c7cc:	681b      	ldr	r3, [r3, #0]
   1c7ce:	991b      	ldr	r1, [sp, #108]	; 0x6c
   1c7d0:	a80b      	add	r0, sp, #44	; 0x2c
   1c7d2:	4798      	blx	r3
   1c7d4:	e76b      	b.n	1c6ae <m2m_ip_cb+0x3a>
	else if((u8OpCode == SOCKET_CMD_RECV) || (u8OpCode == SOCKET_CMD_RECVFROM) || (u8OpCode == SOCKET_CMD_SSL_RECV))
   1c7d6:	2846      	cmp	r0, #70	; 0x46
   1c7d8:	d003      	beq.n	1c7e2 <m2m_ip_cb+0x16e>
   1c7da:	2848      	cmp	r0, #72	; 0x48
   1c7dc:	d031      	beq.n	1c842 <m2m_ip_cb+0x1ce>
   1c7de:	284d      	cmp	r0, #77	; 0x4d
   1c7e0:	d148      	bne.n	1c874 <m2m_ip_cb+0x200>
		uint8				u8CallbackMsgID = SOCKET_MSG_RECV;
   1c7e2:	2606      	movs	r6, #6
		if(hif_receive(u32Address, (uint8*)&strRecvReply, u16ReadSize, 0) == M2M_SUCCESS)
   1c7e4:	ad07      	add	r5, sp, #28
   1c7e6:	2300      	movs	r3, #0
   1c7e8:	2210      	movs	r2, #16
   1c7ea:	0029      	movs	r1, r5
   1c7ec:	0020      	movs	r0, r4
   1c7ee:	4f42      	ldr	r7, [pc, #264]	; (1c8f8 <m2m_ip_cb+0x284>)
   1c7f0:	47b8      	blx	r7
   1c7f2:	2800      	cmp	r0, #0
   1c7f4:	d000      	beq.n	1c7f8 <m2m_ip_cb+0x184>
   1c7f6:	e75a      	b.n	1c6ae <m2m_ip_cb+0x3a>
			sock			= strRecvReply.sock;
   1c7f8:	270c      	movs	r7, #12
			u16SessionID = strRecvReply.u16SessionID;
   1c7fa:	89eb      	ldrh	r3, [r5, #14]
			sock			= strRecvReply.sock;
   1c7fc:	57ef      	ldrsb	r7, [r5, r7]
			gastrSockets[sock].bIsRecvPending = 0;
   1c7fe:	4a40      	ldr	r2, [pc, #256]	; (1c900 <m2m_ip_cb+0x28c>)
			u16SessionID = strRecvReply.u16SessionID;
   1c800:	9304      	str	r3, [sp, #16]
			gastrSockets[sock].bIsRecvPending = 0;
   1c802:	013b      	lsls	r3, r7, #4
   1c804:	18d3      	adds	r3, r2, r3
   1c806:	9303      	str	r3, [sp, #12]
   1c808:	7318      	strb	r0, [r3, #12]
			u16DataOffset	= NM_BSP_B_L_16(strRecvReply.u16DataOffset);
   1c80a:	8969      	ldrh	r1, [r5, #10]
			s16RecvStatus	= NM_BSP_B_L_16(strRecvReply.s16RecvStatus);
   1c80c:	2308      	movs	r3, #8
   1c80e:	5eea      	ldrsh	r2, [r5, r3]
			u16DataOffset	= NM_BSP_B_L_16(strRecvReply.u16DataOffset);
   1c810:	9105      	str	r1, [sp, #20]
			strRecvMsg.strRemoteAddr.sin_port 			= strRecvReply.strRemoteAddr.u16Port;
   1c812:	886b      	ldrh	r3, [r5, #2]
   1c814:	a90b      	add	r1, sp, #44	; 0x2c
   1c816:	814b      	strh	r3, [r1, #10]
			strRecvMsg.strRemoteAddr.sin_addr.s_addr 	= strRecvReply.strRemoteAddr.u32IPAddr;
   1c818:	686b      	ldr	r3, [r5, #4]
			if(u16SessionID == gastrSockets[sock].u16SessionID)
   1c81a:	9d04      	ldr	r5, [sp, #16]
			strRecvMsg.strRemoteAddr.sin_addr.s_addr 	= strRecvReply.strRemoteAddr.u32IPAddr;
   1c81c:	60cb      	str	r3, [r1, #12]
			if(u16SessionID == gastrSockets[sock].u16SessionID)
   1c81e:	9b03      	ldr	r3, [sp, #12]
   1c820:	88db      	ldrh	r3, [r3, #6]
   1c822:	429d      	cmp	r5, r3
   1c824:	d11c      	bne.n	1c860 <m2m_ip_cb+0x1ec>
				if((s16RecvStatus > 0) && (s16RecvStatus < u16BufferSize))
   1c826:	2a00      	cmp	r2, #0
   1c828:	dd0d      	ble.n	1c846 <m2m_ip_cb+0x1d2>
   1c82a:	9b02      	ldr	r3, [sp, #8]
   1c82c:	429a      	cmp	r2, r3
   1c82e:	da0a      	bge.n	1c846 <m2m_ip_cb+0x1d2>
					u32Address += u16DataOffset;
   1c830:	9b05      	ldr	r3, [sp, #20]
					Socket_ReadSocketData(sock, &strRecvMsg, u8CallbackMsgID, u32Address, u16ReadSize);
   1c832:	b292      	uxth	r2, r2
					u32Address += u16DataOffset;
   1c834:	191b      	adds	r3, r3, r4
					Socket_ReadSocketData(sock, &strRecvMsg, u8CallbackMsgID, u32Address, u16ReadSize);
   1c836:	9200      	str	r2, [sp, #0]
   1c838:	0038      	movs	r0, r7
   1c83a:	0032      	movs	r2, r6
   1c83c:	4c33      	ldr	r4, [pc, #204]	; (1c90c <m2m_ip_cb+0x298>)
   1c83e:	47a0      	blx	r4
   1c840:	e735      	b.n	1c6ae <m2m_ip_cb+0x3a>
			u8CallbackMsgID = SOCKET_MSG_RECVFROM;
   1c842:	2609      	movs	r6, #9
   1c844:	e7ce      	b.n	1c7e4 <m2m_ip_cb+0x170>
					strRecvMsg.pu8Buffer		= NULL;
   1c846:	2300      	movs	r3, #0
   1c848:	930b      	str	r3, [sp, #44]	; 0x2c
					if(gpfAppSocketCb)
   1c84a:	4b2c      	ldr	r3, [pc, #176]	; (1c8fc <m2m_ip_cb+0x288>)
					strRecvMsg.s16BufferSize	= s16RecvStatus;
   1c84c:	808a      	strh	r2, [r1, #4]
					if(gpfAppSocketCb)
   1c84e:	681a      	ldr	r2, [r3, #0]
   1c850:	2a00      	cmp	r2, #0
   1c852:	d100      	bne.n	1c856 <m2m_ip_cb+0x1e2>
   1c854:	e72b      	b.n	1c6ae <m2m_ip_cb+0x3a>
						gpfAppSocketCb(sock,u8CallbackMsgID, &strRecvMsg);
   1c856:	000a      	movs	r2, r1
   1c858:	681b      	ldr	r3, [r3, #0]
   1c85a:	0031      	movs	r1, r6
   1c85c:	0038      	movs	r0, r7
   1c85e:	e725      	b.n	1c6ac <m2m_ip_cb+0x38>
				if(u16ReadSize < u16BufferSize)
   1c860:	9b02      	ldr	r3, [sp, #8]
   1c862:	2b10      	cmp	r3, #16
   1c864:	d800      	bhi.n	1c868 <m2m_ip_cb+0x1f4>
   1c866:	e722      	b.n	1c6ae <m2m_ip_cb+0x3a>
					if(hif_receive(0, NULL, 0, 1) == M2M_SUCCESS)
   1c868:	2301      	movs	r3, #1
   1c86a:	0002      	movs	r2, r0
   1c86c:	0001      	movs	r1, r0
   1c86e:	4c22      	ldr	r4, [pc, #136]	; (1c8f8 <m2m_ip_cb+0x284>)
   1c870:	47a0      	blx	r4
   1c872:	e71c      	b.n	1c6ae <m2m_ip_cb+0x3a>
	else if((u8OpCode == SOCKET_CMD_SEND) || (u8OpCode == SOCKET_CMD_SENDTO) || (u8OpCode == SOCKET_CMD_SSL_SEND))
   1c874:	2845      	cmp	r0, #69	; 0x45
   1c876:	d003      	beq.n	1c880 <m2m_ip_cb+0x20c>
   1c878:	2847      	cmp	r0, #71	; 0x47
   1c87a:	d021      	beq.n	1c8c0 <m2m_ip_cb+0x24c>
   1c87c:	284c      	cmp	r0, #76	; 0x4c
   1c87e:	d121      	bne.n	1c8c4 <m2m_ip_cb+0x250>
		uint8			u8CallbackMsgID = SOCKET_MSG_SEND;
   1c880:	2607      	movs	r6, #7
		if(hif_receive(u32Address, (uint8*)&strReply, sizeof(tstrSendReply), 0) == M2M_SUCCESS)
   1c882:	ad0b      	add	r5, sp, #44	; 0x2c
   1c884:	0020      	movs	r0, r4
   1c886:	2300      	movs	r3, #0
   1c888:	2208      	movs	r2, #8
   1c88a:	0029      	movs	r1, r5
   1c88c:	4c1a      	ldr	r4, [pc, #104]	; (1c8f8 <m2m_ip_cb+0x284>)
   1c88e:	47a0      	blx	r4
   1c890:	2800      	cmp	r0, #0
   1c892:	d000      	beq.n	1c896 <m2m_ip_cb+0x222>
   1c894:	e70b      	b.n	1c6ae <m2m_ip_cb+0x3a>
			sock = strReply.sock;
   1c896:	2000      	movs	r0, #0
			s16Rcvd = NM_BSP_B_L_16(strReply.s16SentBytes);
   1c898:	886b      	ldrh	r3, [r5, #2]
			sock = strReply.sock;
   1c89a:	5628      	ldrsb	r0, [r5, r0]
			s16Rcvd = NM_BSP_B_L_16(strReply.s16SentBytes);
   1c89c:	aa07      	add	r2, sp, #28
			u16SessionID = strReply.u16SessionID;
   1c89e:	88a9      	ldrh	r1, [r5, #4]
			s16Rcvd = NM_BSP_B_L_16(strReply.s16SentBytes);
   1c8a0:	8013      	strh	r3, [r2, #0]
			if(u16SessionID == gastrSockets[sock].u16SessionID)
   1c8a2:	4b17      	ldr	r3, [pc, #92]	; (1c900 <m2m_ip_cb+0x28c>)
   1c8a4:	0104      	lsls	r4, r0, #4
   1c8a6:	191b      	adds	r3, r3, r4
   1c8a8:	88db      	ldrh	r3, [r3, #6]
   1c8aa:	4299      	cmp	r1, r3
   1c8ac:	d000      	beq.n	1c8b0 <m2m_ip_cb+0x23c>
   1c8ae:	e6fe      	b.n	1c6ae <m2m_ip_cb+0x3a>
				if(gpfAppSocketCb)
   1c8b0:	4b12      	ldr	r3, [pc, #72]	; (1c8fc <m2m_ip_cb+0x288>)
   1c8b2:	6819      	ldr	r1, [r3, #0]
   1c8b4:	2900      	cmp	r1, #0
   1c8b6:	d100      	bne.n	1c8ba <m2m_ip_cb+0x246>
   1c8b8:	e6f9      	b.n	1c6ae <m2m_ip_cb+0x3a>
					gpfAppSocketCb(sock,u8CallbackMsgID, &s16Rcvd);
   1c8ba:	681b      	ldr	r3, [r3, #0]
   1c8bc:	0031      	movs	r1, r6
   1c8be:	e6f5      	b.n	1c6ac <m2m_ip_cb+0x38>
			u8CallbackMsgID = SOCKET_MSG_SENDTO;
   1c8c0:	2608      	movs	r6, #8
   1c8c2:	e7de      	b.n	1c882 <m2m_ip_cb+0x20e>
	else if(u8OpCode == SOCKET_CMD_PING)
   1c8c4:	2852      	cmp	r0, #82	; 0x52
   1c8c6:	d000      	beq.n	1c8ca <m2m_ip_cb+0x256>
   1c8c8:	e6f1      	b.n	1c6ae <m2m_ip_cb+0x3a>
		if(hif_receive(u32Address, (uint8*)&strPingReply, sizeof(tstrPingReply), 1) == M2M_SUCCESS)
   1c8ca:	ad0b      	add	r5, sp, #44	; 0x2c
   1c8cc:	0020      	movs	r0, r4
   1c8ce:	2301      	movs	r3, #1
   1c8d0:	2214      	movs	r2, #20
   1c8d2:	0029      	movs	r1, r5
   1c8d4:	4c08      	ldr	r4, [pc, #32]	; (1c8f8 <m2m_ip_cb+0x284>)
   1c8d6:	47a0      	blx	r4
   1c8d8:	2800      	cmp	r0, #0
   1c8da:	d000      	beq.n	1c8de <m2m_ip_cb+0x26a>
   1c8dc:	e6e7      	b.n	1c6ae <m2m_ip_cb+0x3a>
			gfpPingCb = (void (*)(uint32 , uint32 , uint8))strPingReply.u32CmdPrivate;
   1c8de:	4b0c      	ldr	r3, [pc, #48]	; (1c910 <m2m_ip_cb+0x29c>)
   1c8e0:	686a      	ldr	r2, [r5, #4]
   1c8e2:	601a      	str	r2, [r3, #0]
			if(gfpPingCb != NULL)
   1c8e4:	681a      	ldr	r2, [r3, #0]
   1c8e6:	2a00      	cmp	r2, #0
   1c8e8:	d100      	bne.n	1c8ec <m2m_ip_cb+0x278>
   1c8ea:	e6e0      	b.n	1c6ae <m2m_ip_cb+0x3a>
				gfpPingCb(strPingReply.u32IPAddr, strPingReply.u32RTT, strPingReply.u8ErrorCode);
   1c8ec:	681b      	ldr	r3, [r3, #0]
   1c8ee:	7c2a      	ldrb	r2, [r5, #16]
   1c8f0:	68a9      	ldr	r1, [r5, #8]
   1c8f2:	6828      	ldr	r0, [r5, #0]
   1c8f4:	4798      	blx	r3
}
   1c8f6:	e6da      	b.n	1c6ae <m2m_ip_cb+0x3a>
   1c8f8:	0001ad51 	.word	0x0001ad51
   1c8fc:	2000562c 	.word	0x2000562c
   1c900:	2000557c 	.word	0x2000557c
   1c904:	20003d8a 	.word	0x20003d8a
   1c908:	20005634 	.word	0x20005634
   1c90c:	0001c589 	.word	0x0001c589
   1c910:	20005630 	.word	0x20005630

0001c914 <socketInit>:

Date
		4 June 2012
*********************************************************************/
void socketInit(void)
{
   1c914:	b570      	push	{r4, r5, r6, lr}
	if(gbSocketInit == 0)
   1c916:	4d09      	ldr	r5, [pc, #36]	; (1c93c <socketInit+0x28>)
   1c918:	782c      	ldrb	r4, [r5, #0]
   1c91a:	b2e4      	uxtb	r4, r4
   1c91c:	2c00      	cmp	r4, #0
   1c91e:	d10c      	bne.n	1c93a <socketInit+0x26>
	{
		m2m_memset((uint8*)gastrSockets, 0, MAX_SOCKET * sizeof(tstrSocket));
   1c920:	22b0      	movs	r2, #176	; 0xb0
   1c922:	0021      	movs	r1, r4
   1c924:	4806      	ldr	r0, [pc, #24]	; (1c940 <socketInit+0x2c>)
   1c926:	4b07      	ldr	r3, [pc, #28]	; (1c944 <socketInit+0x30>)
   1c928:	4798      	blx	r3
		hif_register_cb(M2M_REQ_GROUP_IP,m2m_ip_cb);
   1c92a:	4b07      	ldr	r3, [pc, #28]	; (1c948 <socketInit+0x34>)
   1c92c:	4907      	ldr	r1, [pc, #28]	; (1c94c <socketInit+0x38>)
   1c92e:	2002      	movs	r0, #2
   1c930:	4798      	blx	r3
		gbSocketInit	= 1;
   1c932:	2301      	movs	r3, #1
   1c934:	702b      	strb	r3, [r5, #0]
		gu16SessionID	= 0;
   1c936:	4b06      	ldr	r3, [pc, #24]	; (1c950 <socketInit+0x3c>)
   1c938:	801c      	strh	r4, [r3, #0]
	}
}
   1c93a:	bd70      	pop	{r4, r5, r6, pc}
   1c93c:	20003d89 	.word	0x20003d89
   1c940:	2000557c 	.word	0x2000557c
   1c944:	0001a797 	.word	0x0001a797
   1c948:	0001ae11 	.word	0x0001ae11
   1c94c:	0001c675 	.word	0x0001c675
   1c950:	20003d8a 	.word	0x20003d8a

0001c954 <socketDeinit>:

Date
		27 Feb 2015
*********************************************************************/
void socketDeinit(void)
{	
   1c954:	b510      	push	{r4, lr}
	m2m_memset((uint8*)gastrSockets, 0, MAX_SOCKET * sizeof(tstrSocket));
   1c956:	22b0      	movs	r2, #176	; 0xb0
   1c958:	2100      	movs	r1, #0
   1c95a:	4807      	ldr	r0, [pc, #28]	; (1c978 <socketDeinit+0x24>)
   1c95c:	4b07      	ldr	r3, [pc, #28]	; (1c97c <socketDeinit+0x28>)
   1c95e:	4798      	blx	r3
	hif_register_cb(M2M_REQ_GROUP_IP, NULL);
   1c960:	4b07      	ldr	r3, [pc, #28]	; (1c980 <socketDeinit+0x2c>)
   1c962:	2100      	movs	r1, #0
   1c964:	2002      	movs	r0, #2
   1c966:	4798      	blx	r3
	gpfAppSocketCb	= NULL;
   1c968:	2300      	movs	r3, #0
   1c96a:	4a06      	ldr	r2, [pc, #24]	; (1c984 <socketDeinit+0x30>)
   1c96c:	6013      	str	r3, [r2, #0]
	gpfAppResolveCb	= NULL;
   1c96e:	4a06      	ldr	r2, [pc, #24]	; (1c988 <socketDeinit+0x34>)
   1c970:	6013      	str	r3, [r2, #0]
	gbSocketInit	= 0;
   1c972:	4a06      	ldr	r2, [pc, #24]	; (1c98c <socketDeinit+0x38>)
   1c974:	7013      	strb	r3, [r2, #0]
}
   1c976:	bd10      	pop	{r4, pc}
   1c978:	2000557c 	.word	0x2000557c
   1c97c:	0001a797 	.word	0x0001a797
   1c980:	0001ae11 	.word	0x0001ae11
   1c984:	2000562c 	.word	0x2000562c
   1c988:	20005634 	.word	0x20005634
   1c98c:	20003d89 	.word	0x20003d89

0001c990 <registerSocketCallback>:
Date
		4 June 2012
*********************************************************************/
void registerSocketCallback(tpfAppSocketCb pfAppSocketCb, tpfAppResolveCb pfAppResolveCb)
{
	gpfAppSocketCb = pfAppSocketCb;
   1c990:	4b02      	ldr	r3, [pc, #8]	; (1c99c <registerSocketCallback+0xc>)
   1c992:	6018      	str	r0, [r3, #0]
	gpfAppResolveCb = pfAppResolveCb;
   1c994:	4b02      	ldr	r3, [pc, #8]	; (1c9a0 <registerSocketCallback+0x10>)
   1c996:	6019      	str	r1, [r3, #0]
}
   1c998:	4770      	bx	lr
   1c99a:	46c0      	nop			; (mov r8, r8)
   1c99c:	2000562c 	.word	0x2000562c
   1c9a0:	20005634 	.word	0x20005634

0001c9a4 <socket>:

Date
		4 June 2012
*********************************************************************/
SOCKET socket(uint16 u16Domain, uint8 u8Type, uint8 u8Flags)
{
   1c9a4:	b5f0      	push	{r4, r5, r6, r7, lr}
   1c9a6:	b089      	sub	sp, #36	; 0x24
   1c9a8:	9205      	str	r2, [sp, #20]
	volatile tstrSocket		*pstrSock;
	static volatile uint8	u8NextTcpSock	= 0;
	static volatile uint8	u8NextUdpSock	= 0;

	/* The only supported family is the AF_INET for UDP and TCP transport layer protocols. */
	if(u16Domain == AF_INET)
   1c9aa:	2802      	cmp	r0, #2
   1c9ac:	d004      	beq.n	1c9b8 <socket+0x14>
	SOCKET					sock = -1;
   1c9ae:	2501      	movs	r5, #1
   1c9b0:	426d      	negs	r5, r5
				SOCKET_REQUEST(SOCKET_CMD_SSL_CREATE, (uint8*)&strSSLCreate, sizeof(tstrSSLSocketCreateCmd), 0, 0, 0);
			}
		}
	}
	return sock;
}
   1c9b2:	0028      	movs	r0, r5
   1c9b4:	b009      	add	sp, #36	; 0x24
   1c9b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if(u8Type == SOCK_STREAM)
   1c9b8:	2901      	cmp	r1, #1
   1c9ba:	d14b      	bne.n	1ca54 <socket+0xb0>
   1c9bc:	2607      	movs	r6, #7
				u8SockID	= u8NextTcpSock;
   1c9be:	4f32      	ldr	r7, [pc, #200]	; (1ca88 <socket+0xe4>)
   1c9c0:	783d      	ldrb	r5, [r7, #0]
				pstrSock	= &gastrSockets[u8NextTcpSock];
   1c9c2:	783c      	ldrb	r4, [r7, #0]
				u8NextTcpSock = (u8NextTcpSock + 1) % TCP_SOCK_MAX;
   1c9c4:	7838      	ldrb	r0, [r7, #0]
   1c9c6:	4b31      	ldr	r3, [pc, #196]	; (1ca8c <socket+0xe8>)
   1c9c8:	3001      	adds	r0, #1
   1c9ca:	2107      	movs	r1, #7
   1c9cc:	4798      	blx	r3
				pstrSock	= &gastrSockets[u8NextTcpSock];
   1c9ce:	b2e4      	uxtb	r4, r4
				if(!pstrSock->bIsUsed)
   1c9d0:	4b2f      	ldr	r3, [pc, #188]	; (1ca90 <socket+0xec>)
				u8NextTcpSock = (u8NextTcpSock + 1) % TCP_SOCK_MAX;
   1c9d2:	b2c9      	uxtb	r1, r1
				if(!pstrSock->bIsUsed)
   1c9d4:	0124      	lsls	r4, r4, #4
				u8NextTcpSock = (u8NextTcpSock + 1) % TCP_SOCK_MAX;
   1c9d6:	7039      	strb	r1, [r7, #0]
				if(!pstrSock->bIsUsed)
   1c9d8:	191c      	adds	r4, r3, r4
   1c9da:	7aa3      	ldrb	r3, [r4, #10]
				u8SockID	= u8NextTcpSock;
   1c9dc:	b2ed      	uxtb	r5, r5
				if(!pstrSock->bIsUsed)
   1c9de:	2b00      	cmp	r3, #0
   1c9e0:	d133      	bne.n	1ca4a <socket+0xa6>
					sock = (SOCKET)(u8SockID + TCP_SOCK_MAX);
   1c9e2:	b26d      	sxtb	r5, r5
		if(sock >= 0)
   1c9e4:	2d00      	cmp	r5, #0
   1c9e6:	dbe4      	blt.n	1c9b2 <socket+0xe>
			m2m_memset((uint8*)pstrSock, 0, sizeof(tstrSocket));
   1c9e8:	4b2a      	ldr	r3, [pc, #168]	; (1ca94 <socket+0xf0>)
   1c9ea:	2210      	movs	r2, #16
   1c9ec:	2100      	movs	r1, #0
   1c9ee:	0020      	movs	r0, r4
   1c9f0:	4798      	blx	r3
			pstrSock->bIsUsed = 1;
   1c9f2:	2301      	movs	r3, #1
			++gu16SessionID;
   1c9f4:	4e28      	ldr	r6, [pc, #160]	; (1ca98 <socket+0xf4>)
			pstrSock->bIsUsed = 1;
   1c9f6:	72a3      	strb	r3, [r4, #10]
			++gu16SessionID;
   1c9f8:	8833      	ldrh	r3, [r6, #0]
   1c9fa:	3301      	adds	r3, #1
   1c9fc:	b29b      	uxth	r3, r3
   1c9fe:	8033      	strh	r3, [r6, #0]
			if(gu16SessionID == 0)
   1ca00:	8833      	ldrh	r3, [r6, #0]
   1ca02:	2b00      	cmp	r3, #0
   1ca04:	d103      	bne.n	1ca0e <socket+0x6a>
				++gu16SessionID;
   1ca06:	8833      	ldrh	r3, [r6, #0]
   1ca08:	3301      	adds	r3, #1
   1ca0a:	b29b      	uxth	r3, r3
   1ca0c:	8033      	strh	r3, [r6, #0]
			pstrSock->u16SessionID = gu16SessionID;
   1ca0e:	8833      	ldrh	r3, [r6, #0]
            M2M_INFO("Socket %d session ID = %d\r\n",sock, gu16SessionID );
   1ca10:	4f22      	ldr	r7, [pc, #136]	; (1ca9c <socket+0xf8>)
			pstrSock->u16SessionID = gu16SessionID;
   1ca12:	b29b      	uxth	r3, r3
   1ca14:	80e3      	strh	r3, [r4, #6]
            M2M_INFO("Socket %d session ID = %d\r\n",sock, gu16SessionID );
   1ca16:	4822      	ldr	r0, [pc, #136]	; (1caa0 <socket+0xfc>)
   1ca18:	47b8      	blx	r7
   1ca1a:	8832      	ldrh	r2, [r6, #0]
   1ca1c:	0029      	movs	r1, r5
   1ca1e:	b292      	uxth	r2, r2
   1ca20:	4820      	ldr	r0, [pc, #128]	; (1caa4 <socket+0x100>)
   1ca22:	47b8      	blx	r7
   1ca24:	4820      	ldr	r0, [pc, #128]	; (1caa8 <socket+0x104>)
   1ca26:	47b8      	blx	r7
			if(u8Flags & SOCKET_FLAGS_SSL)
   1ca28:	9b05      	ldr	r3, [sp, #20]
   1ca2a:	07db      	lsls	r3, r3, #31
   1ca2c:	d5c1      	bpl.n	1c9b2 <socket+0xe>
				pstrSock->u8SSLFlags = SSL_FLAGS_ACTIVE | SSL_FLAGS_NO_TX_COPY;
   1ca2e:	2321      	movs	r3, #33	; 0x21
   1ca30:	72e3      	strb	r3, [r4, #11]
				SOCKET_REQUEST(SOCKET_CMD_SSL_CREATE, (uint8*)&strSSLCreate, sizeof(tstrSSLSocketCreateCmd), 0, 0, 0);
   1ca32:	2300      	movs	r3, #0
				strSSLCreate.sslSock = sock;
   1ca34:	aa07      	add	r2, sp, #28
   1ca36:	7015      	strb	r5, [r2, #0]
				SOCKET_REQUEST(SOCKET_CMD_SSL_CREATE, (uint8*)&strSSLCreate, sizeof(tstrSSLSocketCreateCmd), 0, 0, 0);
   1ca38:	2150      	movs	r1, #80	; 0x50
   1ca3a:	9302      	str	r3, [sp, #8]
   1ca3c:	9301      	str	r3, [sp, #4]
   1ca3e:	9300      	str	r3, [sp, #0]
   1ca40:	4c1a      	ldr	r4, [pc, #104]	; (1caac <socket+0x108>)
   1ca42:	3304      	adds	r3, #4
   1ca44:	2002      	movs	r0, #2
   1ca46:	47a0      	blx	r4
   1ca48:	e7b3      	b.n	1c9b2 <socket+0xe>
   1ca4a:	3e01      	subs	r6, #1
   1ca4c:	b2f6      	uxtb	r6, r6
			for(u8Count = 0; u8Count < TCP_SOCK_MAX; u8Count ++)
   1ca4e:	2e00      	cmp	r6, #0
   1ca50:	d1b6      	bne.n	1c9c0 <socket+0x1c>
   1ca52:	e7ac      	b.n	1c9ae <socket+0xa>
		else if(u8Type == SOCK_DGRAM)
   1ca54:	2902      	cmp	r1, #2
   1ca56:	d1aa      	bne.n	1c9ae <socket+0xa>
   1ca58:	2304      	movs	r3, #4
				u8NextUdpSock	= (u8NextUdpSock + 1) % UDP_SOCK_MAX;
   1ca5a:	2603      	movs	r6, #3
				u8SockID		= u8NextUdpSock;
   1ca5c:	4914      	ldr	r1, [pc, #80]	; (1cab0 <socket+0x10c>)
				pstrSock		= &pastrUDPSockets[u8NextUdpSock];
   1ca5e:	4815      	ldr	r0, [pc, #84]	; (1cab4 <socket+0x110>)
				u8SockID		= u8NextUdpSock;
   1ca60:	780d      	ldrb	r5, [r1, #0]
				pstrSock		= &pastrUDPSockets[u8NextUdpSock];
   1ca62:	780c      	ldrb	r4, [r1, #0]
				u8NextUdpSock	= (u8NextUdpSock + 1) % UDP_SOCK_MAX;
   1ca64:	780a      	ldrb	r2, [r1, #0]
				pstrSock		= &pastrUDPSockets[u8NextUdpSock];
   1ca66:	0124      	lsls	r4, r4, #4
				u8NextUdpSock	= (u8NextUdpSock + 1) % UDP_SOCK_MAX;
   1ca68:	3201      	adds	r2, #1
   1ca6a:	4032      	ands	r2, r6
				pstrSock		= &pastrUDPSockets[u8NextUdpSock];
   1ca6c:	1824      	adds	r4, r4, r0
				u8NextUdpSock	= (u8NextUdpSock + 1) % UDP_SOCK_MAX;
   1ca6e:	700a      	strb	r2, [r1, #0]
				if(!pstrSock->bIsUsed)
   1ca70:	7aa2      	ldrb	r2, [r4, #10]
				u8SockID		= u8NextUdpSock;
   1ca72:	b2ed      	uxtb	r5, r5
				if(!pstrSock->bIsUsed)
   1ca74:	2a00      	cmp	r2, #0
   1ca76:	d101      	bne.n	1ca7c <socket+0xd8>
					sock = (SOCKET)(u8SockID + TCP_SOCK_MAX);
   1ca78:	3507      	adds	r5, #7
   1ca7a:	e7b2      	b.n	1c9e2 <socket+0x3e>
   1ca7c:	3b01      	subs	r3, #1
   1ca7e:	b2db      	uxtb	r3, r3
			for(u8Count = 0; u8Count < UDP_SOCK_MAX; u8Count ++)
   1ca80:	2b00      	cmp	r3, #0
   1ca82:	d1ed      	bne.n	1ca60 <socket+0xbc>
   1ca84:	e793      	b.n	1c9ae <socket+0xa>
   1ca86:	46c0      	nop			; (mov r8, r8)
   1ca88:	20003d8c 	.word	0x20003d8c
   1ca8c:	00025b9d 	.word	0x00025b9d
   1ca90:	2000557c 	.word	0x2000557c
   1ca94:	0001a797 	.word	0x0001a797
   1ca98:	20003d8a 	.word	0x20003d8a
   1ca9c:	00019415 	.word	0x00019415
   1caa0:	0002a2b4 	.word	0x0002a2b4
   1caa4:	0002ac6e 	.word	0x0002ac6e
   1caa8:	0002b325 	.word	0x0002b325
   1caac:	0001a88d 	.word	0x0001a88d
   1cab0:	20003d8d 	.word	0x20003d8d
   1cab4:	200055ec 	.word	0x200055ec

0001cab8 <connect>:

Date
		5 June 2012
*********************************************************************/
sint8 connect(SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen)
{
   1cab8:	b5f0      	push	{r4, r5, r6, r7, lr}
   1caba:	0014      	movs	r4, r2
   1cabc:	b089      	sub	sp, #36	; 0x24
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
	if((sock >= 0) && (pstrAddr != NULL) && (gastrSockets[sock].bIsUsed == 1) && (u8AddrLen != 0))
   1cabe:	2800      	cmp	r0, #0
   1cac0:	db2d      	blt.n	1cb1e <connect+0x66>
   1cac2:	2900      	cmp	r1, #0
   1cac4:	d02b      	beq.n	1cb1e <connect+0x66>
   1cac6:	4b17      	ldr	r3, [pc, #92]	; (1cb24 <connect+0x6c>)
   1cac8:	0107      	lsls	r7, r0, #4
   1caca:	19da      	adds	r2, r3, r7
   1cacc:	7a93      	ldrb	r3, [r2, #10]
   1cace:	b2db      	uxtb	r3, r3
   1cad0:	2b01      	cmp	r3, #1
   1cad2:	d124      	bne.n	1cb1e <connect+0x66>
   1cad4:	2c00      	cmp	r4, #0
   1cad6:	d022      	beq.n	1cb1e <connect+0x66>
	{
		tstrConnectCmd	strConnect;
		uint8			u8Cmd = SOCKET_CMD_CONNECT;
		if((gastrSockets[sock].u8SSLFlags) & SSL_FLAGS_ACTIVE)
   1cad8:	7ad4      	ldrb	r4, [r2, #11]
		uint8			u8Cmd = SOCKET_CMD_CONNECT;
   1cada:	2644      	movs	r6, #68	; 0x44
		if((gastrSockets[sock].u8SSLFlags) & SSL_FLAGS_ACTIVE)
   1cadc:	46a4      	mov	ip, r4
   1cade:	4665      	mov	r5, ip
   1cae0:	ac05      	add	r4, sp, #20
   1cae2:	421d      	tst	r5, r3
   1cae4:	d002      	beq.n	1caec <connect+0x34>
		{
			u8Cmd = SOCKET_CMD_SSL_CONNECT;
			strConnect.u8SslFlags = gastrSockets[sock].u8SSLFlags;
   1cae6:	7ad3      	ldrb	r3, [r2, #11]
			u8Cmd = SOCKET_CMD_SSL_CONNECT;
   1cae8:	3607      	adds	r6, #7
			strConnect.u8SslFlags = gastrSockets[sock].u8SSLFlags;
   1caea:	7263      	strb	r3, [r4, #9]
		}
		strConnect.sock = sock;
   1caec:	7220      	strb	r0, [r4, #8]
		m2m_memcpy((uint8 *)&strConnect.strAddr, (uint8 *)pstrAddr, sizeof(tstrSockAddr));
   1caee:	2208      	movs	r2, #8
   1caf0:	0020      	movs	r0, r4
   1caf2:	4b0d      	ldr	r3, [pc, #52]	; (1cb28 <connect+0x70>)
   1caf4:	4798      	blx	r3

		strConnect.u16SessionID		= gastrSockets[sock].u16SessionID;
   1caf6:	4b0b      	ldr	r3, [pc, #44]	; (1cb24 <connect+0x6c>)
		s8Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strConnect,sizeof(tstrConnectCmd), NULL, 0, 0);
   1caf8:	0022      	movs	r2, r4
		strConnect.u16SessionID		= gastrSockets[sock].u16SessionID;
   1cafa:	19dd      	adds	r5, r3, r7
   1cafc:	88eb      	ldrh	r3, [r5, #6]
		s8Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strConnect,sizeof(tstrConnectCmd), NULL, 0, 0);
   1cafe:	0031      	movs	r1, r6
		strConnect.u16SessionID		= gastrSockets[sock].u16SessionID;
   1cb00:	8163      	strh	r3, [r4, #10]
		s8Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strConnect,sizeof(tstrConnectCmd), NULL, 0, 0);
   1cb02:	2300      	movs	r3, #0
   1cb04:	2002      	movs	r0, #2
   1cb06:	9302      	str	r3, [sp, #8]
   1cb08:	9301      	str	r3, [sp, #4]
   1cb0a:	9300      	str	r3, [sp, #0]
   1cb0c:	4c07      	ldr	r4, [pc, #28]	; (1cb2c <connect+0x74>)
   1cb0e:	330c      	adds	r3, #12
   1cb10:	47a0      	blx	r4
		if(s8Ret != SOCK_ERR_NO_ERROR)
   1cb12:	2800      	cmp	r0, #0
   1cb14:	d001      	beq.n	1cb1a <connect+0x62>
		{
			s8Ret = SOCK_ERR_INVALID;
   1cb16:	2009      	movs	r0, #9
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
   1cb18:	4240      	negs	r0, r0
		}
	}
	return s8Ret;
}
   1cb1a:	b009      	add	sp, #36	; 0x24
   1cb1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
   1cb1e:	2006      	movs	r0, #6
   1cb20:	e7fa      	b.n	1cb18 <connect+0x60>
   1cb22:	46c0      	nop			; (mov r8, r8)
   1cb24:	2000557c 	.word	0x2000557c
   1cb28:	0001a785 	.word	0x0001a785
   1cb2c:	0001a88d 	.word	0x0001a88d

0001cb30 <send>:

Date
		5 June 2012
*********************************************************************/
sint16 send(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flags)
{
   1cb30:	b570      	push	{r4, r5, r6, lr}
   1cb32:	b088      	sub	sp, #32
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
	
	if((sock >= 0) && (pvSendBuffer != NULL) && (u16SendLength <= SOCKET_BUFFER_MAX_LENGTH) && (gastrSockets[sock].bIsUsed == 1))
   1cb34:	2800      	cmp	r0, #0
   1cb36:	db2d      	blt.n	1cb94 <send+0x64>
   1cb38:	2900      	cmp	r1, #0
   1cb3a:	d02b      	beq.n	1cb94 <send+0x64>
   1cb3c:	23af      	movs	r3, #175	; 0xaf
   1cb3e:	00db      	lsls	r3, r3, #3
   1cb40:	429a      	cmp	r2, r3
   1cb42:	d827      	bhi.n	1cb94 <send+0x64>
   1cb44:	4c14      	ldr	r4, [pc, #80]	; (1cb98 <send+0x68>)
   1cb46:	0106      	lsls	r6, r0, #4
   1cb48:	19a3      	adds	r3, r4, r6
   1cb4a:	7a9d      	ldrb	r5, [r3, #10]
   1cb4c:	2d01      	cmp	r5, #1
   1cb4e:	d121      	bne.n	1cb94 <send+0x64>
		u8Cmd			= SOCKET_CMD_SEND;
		u16DataOffset	= TCP_TX_PACKET_OFFSET;

		strSend.sock			= sock;
		strSend.u16DataSize		= NM_BSP_B_L_16(u16SendLength);
		strSend.u16SessionID	= gastrSockets[sock].u16SessionID;
   1cb50:	88db      	ldrh	r3, [r3, #6]
		strSend.sock			= sock;
   1cb52:	ad04      	add	r5, sp, #16
		strSend.u16SessionID	= gastrSockets[sock].u16SessionID;
   1cb54:	81ab      	strh	r3, [r5, #12]
		strSend.sock			= sock;
   1cb56:	7028      	strb	r0, [r5, #0]
		strSend.u16DataSize		= NM_BSP_B_L_16(u16SendLength);
   1cb58:	806a      	strh	r2, [r5, #2]
		u16DataOffset	= TCP_TX_PACKET_OFFSET;
   1cb5a:	2350      	movs	r3, #80	; 0x50

		if(sock >= TCP_SOCK_MAX)
   1cb5c:	2806      	cmp	r0, #6
   1cb5e:	dd00      	ble.n	1cb62 <send+0x32>
		{
			u16DataOffset = UDP_TX_PACKET_OFFSET;
   1cb60:	3b0c      	subs	r3, #12
		}
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
   1cb62:	19a0      	adds	r0, r4, r6
   1cb64:	7ac6      	ldrb	r6, [r0, #11]
		u8Cmd			= SOCKET_CMD_SEND;
   1cb66:	2445      	movs	r4, #69	; 0x45
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
   1cb68:	07f6      	lsls	r6, r6, #31
   1cb6a:	d502      	bpl.n	1cb72 <send+0x42>
		{
			u8Cmd			= SOCKET_CMD_SSL_SEND;
			u16DataOffset	= gastrSockets[sock].u16DataOffset;
   1cb6c:	8903      	ldrh	r3, [r0, #8]
			u8Cmd			= SOCKET_CMD_SSL_SEND;
   1cb6e:	3407      	adds	r4, #7
			u16DataOffset	= gastrSockets[sock].u16DataOffset;
   1cb70:	b29b      	uxth	r3, r3
		}

		s16Ret =  SOCKET_REQUEST(u8Cmd|M2M_REQ_DATA_PKT, (uint8*)&strSend, sizeof(tstrSendCmd), pvSendBuffer, u16SendLength, u16DataOffset);
   1cb72:	2080      	movs	r0, #128	; 0x80
   1cb74:	4304      	orrs	r4, r0
   1cb76:	9302      	str	r3, [sp, #8]
   1cb78:	9201      	str	r2, [sp, #4]
   1cb7a:	9100      	str	r1, [sp, #0]
   1cb7c:	2310      	movs	r3, #16
   1cb7e:	0021      	movs	r1, r4
   1cb80:	002a      	movs	r2, r5
   1cb82:	387e      	subs	r0, #126	; 0x7e
   1cb84:	4c05      	ldr	r4, [pc, #20]	; (1cb9c <send+0x6c>)
   1cb86:	47a0      	blx	r4
		if(s16Ret != SOCK_ERR_NO_ERROR)
   1cb88:	2800      	cmp	r0, #0
   1cb8a:	d001      	beq.n	1cb90 <send+0x60>
		{
			s16Ret = SOCK_ERR_BUFFER_FULL;
   1cb8c:	200e      	movs	r0, #14
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
   1cb8e:	4240      	negs	r0, r0
		}
	}
	return s16Ret;
}
   1cb90:	b008      	add	sp, #32
   1cb92:	bd70      	pop	{r4, r5, r6, pc}
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
   1cb94:	2006      	movs	r0, #6
   1cb96:	e7fa      	b.n	1cb8e <send+0x5e>
   1cb98:	2000557c 	.word	0x2000557c
   1cb9c:	0001a88d 	.word	0x0001a88d

0001cba0 <recv>:

Date
		5 June 2012
*********************************************************************/
sint16 recv(SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Timeoutmsec)
{
   1cba0:	b5f0      	push	{r4, r5, r6, r7, lr}
   1cba2:	0007      	movs	r7, r0
   1cba4:	b087      	sub	sp, #28
   1cba6:	0010      	movs	r0, r2
   1cba8:	001a      	movs	r2, r3
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
	
	if((sock >= 0) && (pvRecvBuf != NULL) && (u16BufLen != 0) && (gastrSockets[sock].bIsUsed == 1))
   1cbaa:	2f00      	cmp	r7, #0
   1cbac:	db2d      	blt.n	1cc0a <recv+0x6a>
   1cbae:	2900      	cmp	r1, #0
   1cbb0:	d02b      	beq.n	1cc0a <recv+0x6a>
   1cbb2:	2800      	cmp	r0, #0
   1cbb4:	d029      	beq.n	1cc0a <recv+0x6a>
   1cbb6:	4c16      	ldr	r4, [pc, #88]	; (1cc10 <recv+0x70>)
   1cbb8:	013b      	lsls	r3, r7, #4
   1cbba:	18e6      	adds	r6, r4, r3
   1cbbc:	7ab5      	ldrb	r5, [r6, #10]
   1cbbe:	b2ed      	uxtb	r5, r5
   1cbc0:	2d01      	cmp	r5, #1
   1cbc2:	d122      	bne.n	1cc0a <recv+0x6a>
	{
		s16Ret = SOCK_ERR_NO_ERROR;
		gastrSockets[sock].pu8UserBuffer 		= (uint8*)pvRecvBuf;
   1cbc4:	5119      	str	r1, [r3, r4]
		gastrSockets[sock].u16UserBufferSize 	= u16BufLen;
   1cbc6:	80b0      	strh	r0, [r6, #4]
		s16Ret = SOCK_ERR_NO_ERROR;
   1cbc8:	2000      	movs	r0, #0

		if(!gastrSockets[sock].bIsRecvPending)
   1cbca:	7b31      	ldrb	r1, [r6, #12]
   1cbcc:	4281      	cmp	r1, r0
   1cbce:	d11a      	bne.n	1cc06 <recv+0x66>
		{
			tstrRecvCmd	strRecv;
			uint8		u8Cmd = SOCKET_CMD_RECV;

			gastrSockets[sock].bIsRecvPending = 1;
   1cbd0:	7335      	strb	r5, [r6, #12]
			if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
   1cbd2:	7af0      	ldrb	r0, [r6, #11]
			uint8		u8Cmd = SOCKET_CMD_RECV;
   1cbd4:	2146      	movs	r1, #70	; 0x46
			if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
   1cbd6:	4228      	tst	r0, r5
   1cbd8:	d000      	beq.n	1cbdc <recv+0x3c>
			{
				u8Cmd = SOCKET_CMD_SSL_RECV;
   1cbda:	3107      	adds	r1, #7
			}

			/* Check the timeout value. */
			if(u32Timeoutmsec == 0)
   1cbdc:	2a00      	cmp	r2, #0
   1cbde:	d100      	bne.n	1cbe2 <recv+0x42>
				strRecv.u32Timeoutmsec = 0xFFFFFFFF;
   1cbe0:	3a01      	subs	r2, #1
			else
				strRecv.u32Timeoutmsec = NM_BSP_B_L_32(u32Timeoutmsec);
			strRecv.sock = sock;
			strRecv.u16SessionID		= gastrSockets[sock].u16SessionID;
   1cbe2:	18e4      	adds	r4, r4, r3
   1cbe4:	88e3      	ldrh	r3, [r4, #6]
				strRecv.u32Timeoutmsec = NM_BSP_B_L_32(u32Timeoutmsec);
   1cbe6:	9204      	str	r2, [sp, #16]
			strRecv.sock = sock;
   1cbe8:	aa04      	add	r2, sp, #16
			strRecv.u16SessionID		= gastrSockets[sock].u16SessionID;
   1cbea:	80d3      	strh	r3, [r2, #6]
		
			s16Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strRecv, sizeof(tstrRecvCmd), NULL , 0, 0);
   1cbec:	2300      	movs	r3, #0
			strRecv.sock = sock;
   1cbee:	7117      	strb	r7, [r2, #4]
			s16Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strRecv, sizeof(tstrRecvCmd), NULL , 0, 0);
   1cbf0:	2002      	movs	r0, #2
   1cbf2:	9302      	str	r3, [sp, #8]
   1cbf4:	9301      	str	r3, [sp, #4]
   1cbf6:	9300      	str	r3, [sp, #0]
   1cbf8:	4c06      	ldr	r4, [pc, #24]	; (1cc14 <recv+0x74>)
   1cbfa:	3308      	adds	r3, #8
   1cbfc:	47a0      	blx	r4
			if(s16Ret != SOCK_ERR_NO_ERROR)
   1cbfe:	2800      	cmp	r0, #0
   1cc00:	d001      	beq.n	1cc06 <recv+0x66>
			{
				s16Ret = SOCK_ERR_BUFFER_FULL;
   1cc02:	200e      	movs	r0, #14
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
   1cc04:	4240      	negs	r0, r0
			}
		}
	}
	return s16Ret;
}
   1cc06:	b007      	add	sp, #28
   1cc08:	bdf0      	pop	{r4, r5, r6, r7, pc}
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
   1cc0a:	2006      	movs	r0, #6
   1cc0c:	e7fa      	b.n	1cc04 <recv+0x64>
   1cc0e:	46c0      	nop			; (mov r8, r8)
   1cc10:	2000557c 	.word	0x2000557c
   1cc14:	0001a88d 	.word	0x0001a88d

0001cc18 <close>:

Date
		4 June 2012
*********************************************************************/
sint8 close(SOCKET sock)
{
   1cc18:	b570      	push	{r4, r5, r6, lr}
   1cc1a:	0006      	movs	r6, r0
   1cc1c:	b086      	sub	sp, #24
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
    M2M_INFO("Sock to delete <%d>\n", sock);
   1cc1e:	4819      	ldr	r0, [pc, #100]	; (1cc84 <close+0x6c>)
   1cc20:	4c19      	ldr	r4, [pc, #100]	; (1cc88 <close+0x70>)
   1cc22:	47a0      	blx	r4
   1cc24:	4819      	ldr	r0, [pc, #100]	; (1cc8c <close+0x74>)
   1cc26:	0031      	movs	r1, r6
   1cc28:	47a0      	blx	r4
   1cc2a:	4819      	ldr	r0, [pc, #100]	; (1cc90 <close+0x78>)
   1cc2c:	47a0      	blx	r4
	if(sock >= 0 && (gastrSockets[sock].bIsUsed == 1))
   1cc2e:	2e00      	cmp	r6, #0
   1cc30:	db25      	blt.n	1cc7e <close+0x66>
   1cc32:	4c18      	ldr	r4, [pc, #96]	; (1cc94 <close+0x7c>)
   1cc34:	0135      	lsls	r5, r6, #4
   1cc36:	1961      	adds	r1, r4, r5
   1cc38:	7a88      	ldrb	r0, [r1, #10]
   1cc3a:	b2c0      	uxtb	r0, r0
   1cc3c:	2801      	cmp	r0, #1
   1cc3e:	d11e      	bne.n	1cc7e <close+0x66>
	{
		uint8	u8Cmd = SOCKET_CMD_CLOSE;
		tstrCloseCmd strclose;
		strclose.sock = sock; 
		strclose.u16SessionID		= gastrSockets[sock].u16SessionID;
   1cc40:	88cb      	ldrh	r3, [r1, #6]
		strclose.sock = sock; 
   1cc42:	aa05      	add	r2, sp, #20
		strclose.u16SessionID		= gastrSockets[sock].u16SessionID;
   1cc44:	8053      	strh	r3, [r2, #2]
		
		gastrSockets[sock].bIsUsed = 0;
   1cc46:	2300      	movs	r3, #0
   1cc48:	728b      	strb	r3, [r1, #10]
		gastrSockets[sock].u16SessionID =0;
   1cc4a:	80cb      	strh	r3, [r1, #6]
		strclose.sock = sock; 
   1cc4c:	7016      	strb	r6, [r2, #0]
		
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
   1cc4e:	7ace      	ldrb	r6, [r1, #11]
		uint8	u8Cmd = SOCKET_CMD_CLOSE;
   1cc50:	2149      	movs	r1, #73	; 0x49
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
   1cc52:	4206      	tst	r6, r0
   1cc54:	d000      	beq.n	1cc58 <close+0x40>
		{
			u8Cmd = SOCKET_CMD_SSL_CLOSE;
   1cc56:	3105      	adds	r1, #5
		}
		s8Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strclose, sizeof(tstrCloseCmd), NULL,0, 0);
   1cc58:	9302      	str	r3, [sp, #8]
   1cc5a:	9301      	str	r3, [sp, #4]
   1cc5c:	9300      	str	r3, [sp, #0]
   1cc5e:	4e0e      	ldr	r6, [pc, #56]	; (1cc98 <close+0x80>)
   1cc60:	2304      	movs	r3, #4
   1cc62:	2002      	movs	r0, #2
   1cc64:	47b0      	blx	r6
   1cc66:	1e06      	subs	r6, r0, #0
		if(s8Ret != SOCK_ERR_NO_ERROR)
   1cc68:	d001      	beq.n	1cc6e <close+0x56>
		{
			s8Ret = SOCK_ERR_INVALID;
   1cc6a:	2609      	movs	r6, #9
   1cc6c:	4276      	negs	r6, r6
		}
		m2m_memset((uint8*)&gastrSockets[sock], 0, sizeof(tstrSocket));
   1cc6e:	1960      	adds	r0, r4, r5
   1cc70:	2210      	movs	r2, #16
   1cc72:	2100      	movs	r1, #0
   1cc74:	4b09      	ldr	r3, [pc, #36]	; (1cc9c <close+0x84>)
   1cc76:	4798      	blx	r3
	}
	return s8Ret;
}
   1cc78:	0030      	movs	r0, r6
   1cc7a:	b006      	add	sp, #24
   1cc7c:	bd70      	pop	{r4, r5, r6, pc}
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
   1cc7e:	2606      	movs	r6, #6
   1cc80:	4276      	negs	r6, r6
   1cc82:	e7f9      	b.n	1cc78 <close+0x60>
   1cc84:	0002a2b4 	.word	0x0002a2b4
   1cc88:	00019415 	.word	0x00019415
   1cc8c:	0002ac59 	.word	0x0002ac59
   1cc90:	0002b325 	.word	0x0002b325
   1cc94:	2000557c 	.word	0x2000557c
   1cc98:	0001a88d 	.word	0x0001a88d
   1cc9c:	0001a797 	.word	0x0001a797

0001cca0 <nmi_inet_addr>:

Date
		4 June 2012
*********************************************************************/
uint32 nmi_inet_addr(char *pcIpAddr)
{
   1cca0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	uint8	tmp;
	uint32	u32IP = 0;
   1cca2:	2200      	movs	r2, #0
				au8IP[i] = tmp;
				tmp = 0;
			}
			else if(c >= '0' && c <= '9')
			{
				tmp = (tmp * 10) + (c - '0');
   1cca4:	250a      	movs	r5, #10
	tmp = 0;
   1cca6:	0013      	movs	r3, r2
	uint32	u32IP = 0;
   1cca8:	9200      	str	r2, [sp, #0]
				au8IP[i] = tmp;
   1ccaa:	ac01      	add	r4, sp, #4
   1ccac:	1d06      	adds	r6, r0, #4
			if(j > 4)
   1ccae:	42b0      	cmp	r0, r6
   1ccb0:	d01e      	beq.n	1ccf0 <nmi_inet_addr+0x50>
			c = *pcIpAddr;
   1ccb2:	7801      	ldrb	r1, [r0, #0]
			if(c == '.' || c == 0)
   1ccb4:	292e      	cmp	r1, #46	; 0x2e
   1ccb6:	d001      	beq.n	1ccbc <nmi_inet_addr+0x1c>
   1ccb8:	2900      	cmp	r1, #0
   1ccba:	d10d      	bne.n	1ccd8 <nmi_inet_addr+0x38>
				au8IP[i] = tmp;
   1ccbc:	5513      	strb	r3, [r2, r4]
				tmp = 0;
   1ccbe:	2300      	movs	r3, #0
			}
			else
			{
				return 0;
			}
			++pcIpAddr;
   1ccc0:	3001      	adds	r0, #1
		} while(c != '.' && c != 0);
   1ccc2:	292e      	cmp	r1, #46	; 0x2e
   1ccc4:	d111      	bne.n	1ccea <nmi_inet_addr+0x4a>
   1ccc6:	3201      	adds	r2, #1
	for(i = 0; i < 4; ++i)
   1ccc8:	2a04      	cmp	r2, #4
   1ccca:	d1ef      	bne.n	1ccac <nmi_inet_addr+0xc>
	}
	m2m_memcpy((uint8*)&u32IP, au8IP, 4);
   1cccc:	4668      	mov	r0, sp
   1ccce:	a901      	add	r1, sp, #4
   1ccd0:	4b08      	ldr	r3, [pc, #32]	; (1ccf4 <nmi_inet_addr+0x54>)
   1ccd2:	4798      	blx	r3
	return u32IP;
   1ccd4:	9800      	ldr	r0, [sp, #0]
}
   1ccd6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
			else if(c >= '0' && c <= '9')
   1ccd8:	000f      	movs	r7, r1
   1ccda:	3f30      	subs	r7, #48	; 0x30
   1ccdc:	2f09      	cmp	r7, #9
   1ccde:	d807      	bhi.n	1ccf0 <nmi_inet_addr+0x50>
				tmp = (tmp * 10) + (c - '0');
   1cce0:	436b      	muls	r3, r5
   1cce2:	18cb      	adds	r3, r1, r3
   1cce4:	3b30      	subs	r3, #48	; 0x30
   1cce6:	b2db      	uxtb	r3, r3
   1cce8:	e7ea      	b.n	1ccc0 <nmi_inet_addr+0x20>
		} while(c != '.' && c != 0);
   1ccea:	2900      	cmp	r1, #0
   1ccec:	d1df      	bne.n	1ccae <nmi_inet_addr+0xe>
   1ccee:	e7ea      	b.n	1ccc6 <nmi_inet_addr+0x26>
				return 0;
   1ccf0:	2000      	movs	r0, #0
   1ccf2:	e7f0      	b.n	1ccd6 <nmi_inet_addr+0x36>
   1ccf4:	0001a785 	.word	0x0001a785

0001ccf8 <gethostbyname>:

Date
		4 June 2012
*********************************************************************/
sint8 gethostbyname(uint8 * pcHostName)
{
   1ccf8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	sint8	s8Err = SOCK_ERR_INVALID_ARG;
	uint8	u8HostNameSize = (uint8)m2m_strlen(pcHostName);
   1ccfa:	4b0a      	ldr	r3, [pc, #40]	; (1cd24 <gethostbyname+0x2c>)
{
   1ccfc:	0004      	movs	r4, r0
	uint8	u8HostNameSize = (uint8)m2m_strlen(pcHostName);
   1ccfe:	4798      	blx	r3
	if(u8HostNameSize <= HOSTNAME_MAX_SIZE)
   1cd00:	b2c3      	uxtb	r3, r0
   1cd02:	2b40      	cmp	r3, #64	; 0x40
   1cd04:	d80b      	bhi.n	1cd1e <gethostbyname+0x26>
	{
		s8Err = SOCKET_REQUEST(SOCKET_CMD_DNS_RESOLVE, (uint8*)pcHostName, u8HostNameSize + 1, NULL,0, 0);
   1cd06:	2200      	movs	r2, #0
   1cd08:	3301      	adds	r3, #1
   1cd0a:	9202      	str	r2, [sp, #8]
   1cd0c:	9201      	str	r2, [sp, #4]
   1cd0e:	9200      	str	r2, [sp, #0]
   1cd10:	214a      	movs	r1, #74	; 0x4a
   1cd12:	0022      	movs	r2, r4
   1cd14:	2002      	movs	r0, #2
   1cd16:	4c04      	ldr	r4, [pc, #16]	; (1cd28 <gethostbyname+0x30>)
   1cd18:	47a0      	blx	r4
	}
	return s8Err;
}
   1cd1a:	b004      	add	sp, #16
   1cd1c:	bd10      	pop	{r4, pc}
	sint8	s8Err = SOCK_ERR_INVALID_ARG;
   1cd1e:	2006      	movs	r0, #6
   1cd20:	4240      	negs	r0, r0
   1cd22:	e7fa      	b.n	1cd1a <gethostbyname+0x22>
   1cd24:	0001a7a7 	.word	0x0001a7a7
   1cd28:	0001a88d 	.word	0x0001a88d

0001cd2c <spi_flash_enable>:
 *	@brief	Enable spi flash operations
 *	@author	M. Abdelmawla
 *	@version	1.0
 */
sint8 spi_flash_enable(uint8 enable)
{
   1cd2c:	b5f0      	push	{r4, r5, r6, r7, lr}
	sint8 s8Ret = M2M_SUCCESS;
	if(REV(nmi_get_chipid()) >= REV_3A0) {		
   1cd2e:	4b27      	ldr	r3, [pc, #156]	; (1cdcc <spi_flash_enable+0xa0>)
{
   1cd30:	b085      	sub	sp, #20
   1cd32:	0007      	movs	r7, r0
	if(REV(nmi_get_chipid()) >= REV_3A0) {		
   1cd34:	4798      	blx	r3
   1cd36:	4b26      	ldr	r3, [pc, #152]	; (1cdd0 <spi_flash_enable+0xa4>)
   1cd38:	0500      	lsls	r0, r0, #20
   1cd3a:	0d00      	lsrs	r0, r0, #20
	sint8 s8Ret = M2M_SUCCESS;
   1cd3c:	2500      	movs	r5, #0
	if(REV(nmi_get_chipid()) >= REV_3A0) {		
   1cd3e:	4298      	cmp	r0, r3
   1cd40:	d92e      	bls.n	1cda0 <spi_flash_enable+0x74>
		uint32 u32Val;
		
		/* Enable pinmux to SPI flash. */
		s8Ret = nm_read_reg_with_ret(0x1410, &u32Val);
   1cd42:	a903      	add	r1, sp, #12
   1cd44:	4823      	ldr	r0, [pc, #140]	; (1cdd4 <spi_flash_enable+0xa8>)
   1cd46:	4b24      	ldr	r3, [pc, #144]	; (1cdd8 <spi_flash_enable+0xac>)
   1cd48:	4798      	blx	r3
   1cd4a:	1e05      	subs	r5, r0, #0
		if(s8Ret != M2M_SUCCESS) {
   1cd4c:	d128      	bne.n	1cda0 <spi_flash_enable+0x74>
			goto ERR1;
		}
		/* GPIO15/16/17/18 */
		u32Val &= ~((0x7777ul) << 12);
   1cd4e:	4e23      	ldr	r6, [pc, #140]	; (1cddc <spi_flash_enable+0xb0>)
   1cd50:	9b03      	ldr	r3, [sp, #12]
		u32Val |= ((0x1111ul) << 12);
   1cd52:	4923      	ldr	r1, [pc, #140]	; (1cde0 <spi_flash_enable+0xb4>)
		u32Val &= ~((0x7777ul) << 12);
   1cd54:	4033      	ands	r3, r6
		u32Val |= ((0x1111ul) << 12);
   1cd56:	4319      	orrs	r1, r3
		nm_write_reg(0x1410, u32Val);
   1cd58:	481e      	ldr	r0, [pc, #120]	; (1cdd4 <spi_flash_enable+0xa8>)
   1cd5a:	4c22      	ldr	r4, [pc, #136]	; (1cde4 <spi_flash_enable+0xb8>)
		u32Val |= ((0x1111ul) << 12);
   1cd5c:	9103      	str	r1, [sp, #12]
		nm_write_reg(0x1410, u32Val);
   1cd5e:	47a0      	blx	r4
   1cd60:	9601      	str	r6, [sp, #4]
	nm_write_reg(SPI_FLASH_DATA_CNT, 0);
   1cd62:	0029      	movs	r1, r5
   1cd64:	4e20      	ldr	r6, [pc, #128]	; (1cde8 <spi_flash_enable+0xbc>)
   1cd66:	4821      	ldr	r0, [pc, #132]	; (1cdec <spi_flash_enable+0xc0>)
		if(enable) {
   1cd68:	2f00      	cmp	r7, #0
   1cd6a:	d01c      	beq.n	1cda6 <spi_flash_enable+0x7a>
	nm_write_reg(SPI_FLASH_DATA_CNT, 0);
   1cd6c:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_BUF1, cmd[0]);
   1cd6e:	21ab      	movs	r1, #171	; 0xab
   1cd70:	481f      	ldr	r0, [pc, #124]	; (1cdf0 <spi_flash_enable+0xc4>)
   1cd72:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_BUF_DIR, 0x1);
   1cd74:	2101      	movs	r1, #1
   1cd76:	481f      	ldr	r0, [pc, #124]	; (1cdf4 <spi_flash_enable+0xc8>)
   1cd78:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_DMA_ADDR, 0);
   1cd7a:	0029      	movs	r1, r5
   1cd7c:	481e      	ldr	r0, [pc, #120]	; (1cdf8 <spi_flash_enable+0xcc>)
   1cd7e:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_CMD_CNT,  1 | (1 << 7));
   1cd80:	2181      	movs	r1, #129	; 0x81
   1cd82:	481e      	ldr	r0, [pc, #120]	; (1cdfc <spi_flash_enable+0xd0>)
   1cd84:	47a0      	blx	r4
	while(nm_read_reg(SPI_FLASH_TR_DONE) != 1);
   1cd86:	481e      	ldr	r0, [pc, #120]	; (1ce00 <spi_flash_enable+0xd4>)
   1cd88:	47b0      	blx	r6
   1cd8a:	2801      	cmp	r0, #1
   1cd8c:	d1fb      	bne.n	1cd86 <spi_flash_enable+0x5a>
		} else {
			spi_flash_enter_low_power_mode();
		}
		/* Disable pinmux to SPI flash to minimize leakage. */
		u32Val &= ~((0x7777ul) << 12);
		u32Val |= ((0x0010ul) << 12);
   1cd8e:	2180      	movs	r1, #128	; 0x80
		u32Val &= ~((0x7777ul) << 12);
   1cd90:	9a03      	ldr	r2, [sp, #12]
   1cd92:	9b01      	ldr	r3, [sp, #4]
		u32Val |= ((0x0010ul) << 12);
   1cd94:	0249      	lsls	r1, r1, #9
		u32Val &= ~((0x7777ul) << 12);
   1cd96:	4013      	ands	r3, r2
		u32Val |= ((0x0010ul) << 12);
   1cd98:	4319      	orrs	r1, r3
		nm_write_reg(0x1410, u32Val);
   1cd9a:	480e      	ldr	r0, [pc, #56]	; (1cdd4 <spi_flash_enable+0xa8>)
		u32Val |= ((0x0010ul) << 12);
   1cd9c:	9103      	str	r1, [sp, #12]
		nm_write_reg(0x1410, u32Val);
   1cd9e:	47a0      	blx	r4
	}
ERR1:
	return s8Ret;
}
   1cda0:	0028      	movs	r0, r5
   1cda2:	b005      	add	sp, #20
   1cda4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	nm_write_reg(SPI_FLASH_DATA_CNT, 0);
   1cda6:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_BUF1, cmd[0]);
   1cda8:	21b9      	movs	r1, #185	; 0xb9
   1cdaa:	4811      	ldr	r0, [pc, #68]	; (1cdf0 <spi_flash_enable+0xc4>)
   1cdac:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_BUF_DIR, 0x1);
   1cdae:	2101      	movs	r1, #1
   1cdb0:	4810      	ldr	r0, [pc, #64]	; (1cdf4 <spi_flash_enable+0xc8>)
   1cdb2:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_DMA_ADDR, 0);
   1cdb4:	0029      	movs	r1, r5
   1cdb6:	4810      	ldr	r0, [pc, #64]	; (1cdf8 <spi_flash_enable+0xcc>)
   1cdb8:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_CMD_CNT, 1 | (1 << 7));
   1cdba:	2181      	movs	r1, #129	; 0x81
   1cdbc:	480f      	ldr	r0, [pc, #60]	; (1cdfc <spi_flash_enable+0xd0>)
   1cdbe:	47a0      	blx	r4
	while(nm_read_reg(SPI_FLASH_TR_DONE) != 1);
   1cdc0:	480f      	ldr	r0, [pc, #60]	; (1ce00 <spi_flash_enable+0xd4>)
   1cdc2:	47b0      	blx	r6
   1cdc4:	2801      	cmp	r0, #1
   1cdc6:	d1fb      	bne.n	1cdc0 <spi_flash_enable+0x94>
   1cdc8:	e7e1      	b.n	1cd8e <spi_flash_enable+0x62>
   1cdca:	46c0      	nop			; (mov r8, r8)
   1cdcc:	0001b419 	.word	0x0001b419
   1cdd0:	0000039f 	.word	0x0000039f
   1cdd4:	00001410 	.word	0x00001410
   1cdd8:	0001b7d9 	.word	0x0001b7d9
   1cddc:	f8888fff 	.word	0xf8888fff
   1cde0:	01111000 	.word	0x01111000
   1cde4:	0001b7e5 	.word	0x0001b7e5
   1cde8:	0001b7cd 	.word	0x0001b7cd
   1cdec:	00010208 	.word	0x00010208
   1cdf0:	0001020c 	.word	0x0001020c
   1cdf4:	00010214 	.word	0x00010214
   1cdf8:	0001021c 	.word	0x0001021c
   1cdfc:	00010204 	.word	0x00010204
   1ce00:	00010218 	.word	0x00010218

0001ce04 <mem_test_unit_ready>:
  return LUN_ID_0;
}


Ctrl_status mem_test_unit_ready(U8 lun)
{
   1ce04:	0003      	movs	r3, r0
   1ce06:	b510      	push	{r4, lr}

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].test_unit_ready() :
   1ce08:	2001      	movs	r0, #1
   1ce0a:	2b00      	cmp	r3, #0
   1ce0c:	d101      	bne.n	1ce12 <mem_test_unit_ready+0xe>
   1ce0e:	4b01      	ldr	r3, [pc, #4]	; (1ce14 <mem_test_unit_ready+0x10>)
   1ce10:	4798      	blx	r3
#endif

  Ctrl_access_unlock();

  return status;
}
   1ce12:	bd10      	pop	{r4, pc}
   1ce14:	00019c21 	.word	0x00019c21

0001ce18 <mem_read_capacity>:


Ctrl_status mem_read_capacity(U8 lun, U32 *u32_nb_sector)
{
   1ce18:	b510      	push	{r4, lr}

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].read_capacity(u32_nb_sector) :
   1ce1a:	2301      	movs	r3, #1
   1ce1c:	2800      	cmp	r0, #0
   1ce1e:	d103      	bne.n	1ce28 <mem_read_capacity+0x10>
   1ce20:	4b02      	ldr	r3, [pc, #8]	; (1ce2c <mem_read_capacity+0x14>)
   1ce22:	0008      	movs	r0, r1
   1ce24:	4798      	blx	r3
   1ce26:	0003      	movs	r3, r0
#endif

  Ctrl_access_unlock();

  return status;
}
   1ce28:	0018      	movs	r0, r3
   1ce2a:	bd10      	pop	{r4, pc}
   1ce2c:	00019c51 	.word	0x00019c51

0001ce30 <mem_sector_size>:

  if (!Ctrl_access_lock()) return 0;

  sector_size =
#if MAX_LUN
              (lun < MAX_LUN) ? 1 :
   1ce30:	4243      	negs	r3, r0
   1ce32:	4158      	adcs	r0, r3
#endif

  Ctrl_access_unlock();

  return sector_size;
}
   1ce34:	b2c0      	uxtb	r0, r0
   1ce36:	4770      	bx	lr

0001ce38 <mem_wr_protect>:

  return unloaded;
}

bool mem_wr_protect(U8 lun)
{
   1ce38:	0003      	movs	r3, r0
   1ce3a:	b510      	push	{r4, lr}

  if (!Ctrl_access_lock()) return true;

  wr_protect =
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
   1ce3c:	2001      	movs	r0, #1
   1ce3e:	2b00      	cmp	r3, #0
   1ce40:	d101      	bne.n	1ce46 <mem_wr_protect+0xe>
   1ce42:	4b01      	ldr	r3, [pc, #4]	; (1ce48 <mem_wr_protect+0x10>)
   1ce44:	4798      	blx	r3
#endif

  Ctrl_access_unlock();

  return wr_protect;
}
   1ce46:	bd10      	pop	{r4, pc}
   1ce48:	00019c61 	.word	0x00019c61

0001ce4c <memory_2_ram>:
 */
//! @{


Ctrl_status memory_2_ram(U8 lun, U32 addr, void *ram)
{
   1ce4c:	b510      	push	{r4, lr}
  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].mem_2_ram(addr, ram) :
   1ce4e:	2301      	movs	r3, #1
{
   1ce50:	0004      	movs	r4, r0
   1ce52:	0008      	movs	r0, r1
           (lun < MAX_LUN) ? lun_desc[lun].mem_2_ram(addr, ram) :
   1ce54:	2c00      	cmp	r4, #0
   1ce56:	d103      	bne.n	1ce60 <memory_2_ram+0x14>
   1ce58:	4b02      	ldr	r3, [pc, #8]	; (1ce64 <memory_2_ram+0x18>)
   1ce5a:	0011      	movs	r1, r2
   1ce5c:	4798      	blx	r3
   1ce5e:	0003      	movs	r3, r0
  memory_stop_read_action();

  Ctrl_access_unlock();

  return status;
}
   1ce60:	0018      	movs	r0, r3
   1ce62:	bd10      	pop	{r4, pc}
   1ce64:	00019cb1 	.word	0x00019cb1

0001ce68 <ram_2_memory>:


Ctrl_status ram_2_memory(U8 lun, U32 addr, const void *ram)
{
   1ce68:	b510      	push	{r4, lr}
  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].ram_2_mem(addr, ram) :
   1ce6a:	2301      	movs	r3, #1
{
   1ce6c:	0004      	movs	r4, r0
   1ce6e:	0008      	movs	r0, r1
           (lun < MAX_LUN) ? lun_desc[lun].ram_2_mem(addr, ram) :
   1ce70:	2c00      	cmp	r4, #0
   1ce72:	d103      	bne.n	1ce7c <ram_2_memory+0x14>
   1ce74:	4b02      	ldr	r3, [pc, #8]	; (1ce80 <ram_2_memory+0x18>)
   1ce76:	0011      	movs	r1, r2
   1ce78:	4798      	blx	r3
   1ce7a:	0003      	movs	r3, r0
  memory_stop_write_action();

  Ctrl_access_unlock();

  return status;
}
   1ce7c:	0018      	movs	r0, r3
   1ce7e:	bd10      	pop	{r4, pc}
   1ce80:	00019d05 	.word	0x00019d05

0001ce84 <cpu_irq_enter_critical>:
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
	if (cpu_irq_critical_section_counter == 0) {
   1ce84:	4b09      	ldr	r3, [pc, #36]	; (1ceac <cpu_irq_enter_critical+0x28>)
   1ce86:	6819      	ldr	r1, [r3, #0]
   1ce88:	2900      	cmp	r1, #0
   1ce8a:	d10b      	bne.n	1cea4 <cpu_irq_enter_critical+0x20>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   1ce8c:	f3ef 8010 	mrs	r0, PRIMASK
   1ce90:	4a07      	ldr	r2, [pc, #28]	; (1ceb0 <cpu_irq_enter_critical+0x2c>)
		if (cpu_irq_is_enabled()) {
   1ce92:	2800      	cmp	r0, #0
   1ce94:	d105      	bne.n	1cea2 <cpu_irq_enter_critical+0x1e>
  __ASM volatile ("cpsid i" : : : "memory");
   1ce96:	b672      	cpsid	i
   1ce98:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
   1ce9c:	4905      	ldr	r1, [pc, #20]	; (1ceb4 <cpu_irq_enter_critical+0x30>)
   1ce9e:	7008      	strb	r0, [r1, #0]
			cpu_irq_prev_interrupt_state = true;
   1cea0:	2101      	movs	r1, #1
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
   1cea2:	7011      	strb	r1, [r2, #0]
		}

	}

	cpu_irq_critical_section_counter++;
   1cea4:	681a      	ldr	r2, [r3, #0]
   1cea6:	3201      	adds	r2, #1
   1cea8:	601a      	str	r2, [r3, #0]
}
   1ceaa:	4770      	bx	lr
   1ceac:	20003d90 	.word	0x20003d90
   1ceb0:	20003d94 	.word	0x20003d94
   1ceb4:	2000020a 	.word	0x2000020a

0001ceb8 <cpu_irq_leave_critical>:
void cpu_irq_leave_critical(void)
{
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
   1ceb8:	4b08      	ldr	r3, [pc, #32]	; (1cedc <cpu_irq_leave_critical+0x24>)
   1ceba:	681a      	ldr	r2, [r3, #0]
   1cebc:	3a01      	subs	r2, #1
   1cebe:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
   1cec0:	681b      	ldr	r3, [r3, #0]
   1cec2:	2b00      	cmp	r3, #0
   1cec4:	d109      	bne.n	1ceda <cpu_irq_leave_critical+0x22>
   1cec6:	4b06      	ldr	r3, [pc, #24]	; (1cee0 <cpu_irq_leave_critical+0x28>)
   1cec8:	781b      	ldrb	r3, [r3, #0]
   1ceca:	2b00      	cmp	r3, #0
   1cecc:	d005      	beq.n	1ceda <cpu_irq_leave_critical+0x22>
		cpu_irq_enable();
   1cece:	2201      	movs	r2, #1
   1ced0:	4b04      	ldr	r3, [pc, #16]	; (1cee4 <cpu_irq_leave_critical+0x2c>)
   1ced2:	701a      	strb	r2, [r3, #0]
   1ced4:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   1ced8:	b662      	cpsie	i
	}
}
   1ceda:	4770      	bx	lr
   1cedc:	20003d90 	.word	0x20003d90
   1cee0:	20003d94 	.word	0x20003d94
   1cee4:	2000020a 	.word	0x2000020a

0001cee8 <system_board_init>:
void board_init(void);
#  pragma weak board_init=system_board_init
#endif

void system_board_init(void)
{
   1cee8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	config->input_pull = PORT_PIN_PULL_UP;
   1ceea:	2501      	movs	r5, #1
	config->powersave  = false;
   1ceec:	2700      	movs	r7, #0
	config->input_pull = PORT_PIN_PULL_UP;
   1ceee:	ac01      	add	r4, sp, #4
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);

	/* Configure LEDs as outputs, turn them off */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
	port_pin_set_config(LED_0_PIN, &pin_conf);
   1cef0:	4e08      	ldr	r6, [pc, #32]	; (1cf14 <system_board_init+0x2c>)
   1cef2:	0021      	movs	r1, r4
   1cef4:	2017      	movs	r0, #23
   1cef6:	7065      	strb	r5, [r4, #1]
	config->powersave  = false;
   1cef8:	70a7      	strb	r7, [r4, #2]
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
   1cefa:	7025      	strb	r5, [r4, #0]
	port_pin_set_config(LED_0_PIN, &pin_conf);
   1cefc:	47b0      	blx	r6
		port_base->OUTSET.reg = pin_mask;
   1cefe:	2280      	movs	r2, #128	; 0x80
   1cf00:	4b05      	ldr	r3, [pc, #20]	; (1cf18 <system_board_init+0x30>)
   1cf02:	0412      	lsls	r2, r2, #16
   1cf04:	619a      	str	r2, [r3, #24]
	port_pin_set_output_level(LED_0_PIN, LED_0_INACTIVE);
	
	/* Set buttons as inputs */
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
	pin_conf.input_pull = PORT_PIN_PULL_UP;
	port_pin_set_config(BUTTON_0_PIN, &pin_conf);
   1cf06:	0021      	movs	r1, r4
   1cf08:	2037      	movs	r0, #55	; 0x37
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
   1cf0a:	7027      	strb	r7, [r4, #0]
	pin_conf.input_pull = PORT_PIN_PULL_UP;
   1cf0c:	7065      	strb	r5, [r4, #1]
	port_pin_set_config(BUTTON_0_PIN, &pin_conf);
   1cf0e:	47b0      	blx	r6
}
   1cf10:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   1cf12:	46c0      	nop			; (mov r8, r8)
   1cf14:	0001d0dd 	.word	0x0001d0dd
   1cf18:	41004400 	.word	0x41004400

0001cf1c <extint_register_callback>:
 */
enum status_code extint_register_callback(
	const extint_callback_t callback,
	const uint8_t channel,
	const enum extint_callback_type type)
{
   1cf1c:	b510      	push	{r4, lr}
	/* Sanity check arguments */
	Assert(callback);

	if (type != EXTINT_CALLBACK_TYPE_DETECT) {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
   1cf1e:	2317      	movs	r3, #23
	if (type != EXTINT_CALLBACK_TYPE_DETECT) {
   1cf20:	2a00      	cmp	r2, #0
   1cf22:	d106      	bne.n	1cf32 <extint_register_callback+0x16>
	}

	if (_extint_dev.callbacks[channel] == NULL) {
   1cf24:	4b06      	ldr	r3, [pc, #24]	; (1cf40 <extint_register_callback+0x24>)
   1cf26:	0089      	lsls	r1, r1, #2
   1cf28:	58cc      	ldr	r4, [r1, r3]
   1cf2a:	2c00      	cmp	r4, #0
   1cf2c:	d103      	bne.n	1cf36 <extint_register_callback+0x1a>
		_extint_dev.callbacks[channel] = callback;
   1cf2e:	50c8      	str	r0, [r1, r3]
		return STATUS_OK;
   1cf30:	0023      	movs	r3, r4
	} else if (_extint_dev.callbacks[channel] == callback) {
		return STATUS_OK;
	}

	return STATUS_ERR_ALREADY_INITIALIZED;
}
   1cf32:	0018      	movs	r0, r3
   1cf34:	bd10      	pop	{r4, pc}
		return STATUS_OK;
   1cf36:	0013      	movs	r3, r2
	} else if (_extint_dev.callbacks[channel] == callback) {
   1cf38:	4284      	cmp	r4, r0
   1cf3a:	d0fa      	beq.n	1cf32 <extint_register_callback+0x16>
	return STATUS_ERR_ALREADY_INITIALIZED;
   1cf3c:	231d      	movs	r3, #29
   1cf3e:	e7f8      	b.n	1cf32 <extint_register_callback+0x16>
   1cf40:	2000563c 	.word	0x2000563c

0001cf44 <extint_chan_enable_callback>:

		eic->INTENSET.reg = (1UL << channel);
	}
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
   1cf44:	2317      	movs	r3, #23
	if (type == EXTINT_CALLBACK_TYPE_DETECT) {
   1cf46:	2900      	cmp	r1, #0
   1cf48:	d106      	bne.n	1cf58 <extint_chan_enable_callback+0x14>
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
	uint8_t eic_index = (channel / 32);

	if (eic_index < EIC_INST_NUM) {
   1cf4a:	281f      	cmp	r0, #31
   1cf4c:	d806      	bhi.n	1cf5c <extint_chan_enable_callback+0x18>
		eic->INTENSET.reg = (1UL << channel);
   1cf4e:	3b16      	subs	r3, #22
   1cf50:	4083      	lsls	r3, r0
   1cf52:	4a03      	ldr	r2, [pc, #12]	; (1cf60 <extint_chan_enable_callback+0x1c>)
   1cf54:	60d3      	str	r3, [r2, #12]
	}

	return STATUS_OK;
   1cf56:	000b      	movs	r3, r1
}
   1cf58:	0018      	movs	r0, r3
   1cf5a:	4770      	bx	lr
		eic->INTENSET.reg = (1UL << channel);
   1cf5c:	60c9      	str	r1, [r1, #12]
   1cf5e:	deff      	udf	#255	; 0xff
   1cf60:	40001800 	.word	0x40001800

0001cf64 <extint_chan_disable_callback>:

		eic->INTENCLR.reg = (1UL << channel);
	}
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
   1cf64:	2317      	movs	r3, #23
	if (type == EXTINT_CALLBACK_TYPE_DETECT) {
   1cf66:	2900      	cmp	r1, #0
   1cf68:	d106      	bne.n	1cf78 <extint_chan_disable_callback+0x14>
   1cf6a:	281f      	cmp	r0, #31
   1cf6c:	d806      	bhi.n	1cf7c <extint_chan_disable_callback+0x18>
		eic->INTENCLR.reg = (1UL << channel);
   1cf6e:	3b16      	subs	r3, #22
   1cf70:	4083      	lsls	r3, r0
   1cf72:	4a03      	ldr	r2, [pc, #12]	; (1cf80 <extint_chan_disable_callback+0x1c>)
   1cf74:	6093      	str	r3, [r2, #8]
	}

	return STATUS_OK;
   1cf76:	000b      	movs	r3, r1
}
   1cf78:	0018      	movs	r0, r3
   1cf7a:	4770      	bx	lr
		eic->INTENCLR.reg = (1UL << channel);
   1cf7c:	6089      	str	r1, [r1, #8]
   1cf7e:	deff      	udf	#255	; 0xff
   1cf80:	40001800 	.word	0x40001800

0001cf84 <EIC_Handler>:

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
   1cf84:	2300      	movs	r3, #0
{
   1cf86:	b570      	push	{r4, r5, r6, lr}
 */
static inline bool extint_chan_is_detected(
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));
   1cf88:	2501      	movs	r5, #1
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
   1cf8a:	4c0b      	ldr	r4, [pc, #44]	; (1cfb8 <EIC_Handler+0x34>)
   1cf8c:	7023      	strb	r3, [r4, #0]
   1cf8e:	7823      	ldrb	r3, [r4, #0]
   1cf90:	2b0f      	cmp	r3, #15
   1cf92:	d900      	bls.n	1cf96 <EIC_Handler+0x12>
				/* Run the registered callback */
				_extint_dev.callbacks[_current_channel]();
			}
		}
	}
}
   1cf94:	bd70      	pop	{r4, r5, r6, pc}
   1cf96:	0029      	movs	r1, r5
   1cf98:	4099      	lsls	r1, r3

	return (eic_module->INTFLAG.reg & eic_mask);
   1cf9a:	4a08      	ldr	r2, [pc, #32]	; (1cfbc <EIC_Handler+0x38>)
   1cf9c:	6910      	ldr	r0, [r2, #16]
		if (extint_chan_is_detected(_current_channel)) {
   1cf9e:	4208      	tst	r0, r1
   1cfa0:	d006      	beq.n	1cfb0 <EIC_Handler+0x2c>
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));

	eic_module->INTFLAG.reg = eic_mask;
   1cfa2:	6111      	str	r1, [r2, #16]
			if (_extint_dev.callbacks[_current_channel] != NULL) {
   1cfa4:	4a06      	ldr	r2, [pc, #24]	; (1cfc0 <EIC_Handler+0x3c>)
   1cfa6:	009b      	lsls	r3, r3, #2
   1cfa8:	589b      	ldr	r3, [r3, r2]
   1cfaa:	2b00      	cmp	r3, #0
   1cfac:	d000      	beq.n	1cfb0 <EIC_Handler+0x2c>
				_extint_dev.callbacks[_current_channel]();
   1cfae:	4798      	blx	r3
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
   1cfb0:	7823      	ldrb	r3, [r4, #0]
   1cfb2:	3301      	adds	r3, #1
   1cfb4:	7023      	strb	r3, [r4, #0]
   1cfb6:	e7ea      	b.n	1cf8e <EIC_Handler+0xa>
   1cfb8:	20005638 	.word	0x20005638
   1cfbc:	40001800 	.word	0x40001800
   1cfc0:	2000563c 	.word	0x2000563c

0001cfc4 <extint_is_syncing>:
static inline bool extint_is_syncing(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		if (eics[i]->STATUS.reg & EIC_STATUS_SYNCBUSY) {
   1cfc4:	4b01      	ldr	r3, [pc, #4]	; (1cfcc <extint_is_syncing+0x8>)
   1cfc6:	7858      	ldrb	r0, [r3, #1]
   1cfc8:	09c0      	lsrs	r0, r0, #7
			return true;
		}
	}
	return false;
}
   1cfca:	4770      	bx	lr
   1cfcc:	40001800 	.word	0x40001800

0001cfd0 <_extint_enable>:
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	/* Enable all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		eics[i]->CTRL.reg |= EIC_CTRL_ENABLE;
   1cfd0:	2302      	movs	r3, #2
{
   1cfd2:	b510      	push	{r4, lr}
		eics[i]->CTRL.reg |= EIC_CTRL_ENABLE;
   1cfd4:	4a04      	ldr	r2, [pc, #16]	; (1cfe8 <_extint_enable+0x18>)
   1cfd6:	7811      	ldrb	r1, [r2, #0]
   1cfd8:	430b      	orrs	r3, r1
   1cfda:	7013      	strb	r3, [r2, #0]
	}

	while (extint_is_syncing()) {
   1cfdc:	4b03      	ldr	r3, [pc, #12]	; (1cfec <_extint_enable+0x1c>)
   1cfde:	4798      	blx	r3
   1cfe0:	2800      	cmp	r0, #0
   1cfe2:	d1fb      	bne.n	1cfdc <_extint_enable+0xc>
		/* Wait for all hardware modules to complete synchronization */
	}
}
   1cfe4:	bd10      	pop	{r4, pc}
   1cfe6:	46c0      	nop			; (mov r8, r8)
   1cfe8:	40001800 	.word	0x40001800
   1cfec:	0001cfc5 	.word	0x0001cfc5

0001cff0 <_system_extint_init>:
			PM->APBAMASK.reg |= mask;
   1cff0:	2340      	movs	r3, #64	; 0x40
{
   1cff2:	b507      	push	{r0, r1, r2, lr}
   1cff4:	4a10      	ldr	r2, [pc, #64]	; (1d038 <_system_extint_init+0x48>)
	system_gclk_chan_set_config(EIC_GCLK_ID, &gclk_chan_conf);
   1cff6:	2005      	movs	r0, #5
   1cff8:	6991      	ldr	r1, [r2, #24]
   1cffa:	430b      	orrs	r3, r1
   1cffc:	6193      	str	r3, [r2, #24]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
   1cffe:	2300      	movs	r3, #0
   1d000:	a901      	add	r1, sp, #4
   1d002:	700b      	strb	r3, [r1, #0]
   1d004:	4b0d      	ldr	r3, [pc, #52]	; (1d03c <_system_extint_init+0x4c>)
   1d006:	4798      	blx	r3
	system_gclk_chan_enable(EIC_GCLK_ID);
   1d008:	4b0d      	ldr	r3, [pc, #52]	; (1d040 <_system_extint_init+0x50>)
   1d00a:	2005      	movs	r0, #5
   1d00c:	4798      	blx	r3
		eics[i]->CTRL.reg |= EIC_CTRL_SWRST;
   1d00e:	2301      	movs	r3, #1
   1d010:	4a0c      	ldr	r2, [pc, #48]	; (1d044 <_system_extint_init+0x54>)
   1d012:	7811      	ldrb	r1, [r2, #0]
   1d014:	430b      	orrs	r3, r1
   1d016:	7013      	strb	r3, [r2, #0]
	while (extint_is_syncing()) {
   1d018:	4b0b      	ldr	r3, [pc, #44]	; (1d048 <_system_extint_init+0x58>)
   1d01a:	4798      	blx	r3
   1d01c:	2800      	cmp	r0, #0
   1d01e:	d1fb      	bne.n	1d018 <_system_extint_init+0x28>
		_extint_dev.callbacks[j] = NULL;
   1d020:	0002      	movs	r2, r0
   1d022:	4b0a      	ldr	r3, [pc, #40]	; (1d04c <_system_extint_init+0x5c>)
   1d024:	501a      	str	r2, [r3, r0]
   1d026:	3004      	adds	r0, #4
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
   1d028:	2840      	cmp	r0, #64	; 0x40
   1d02a:	d1fb      	bne.n	1d024 <_system_extint_init+0x34>
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
   1d02c:	2210      	movs	r2, #16
   1d02e:	4b08      	ldr	r3, [pc, #32]	; (1d050 <_system_extint_init+0x60>)
   1d030:	601a      	str	r2, [r3, #0]
	_extint_enable();
   1d032:	4b08      	ldr	r3, [pc, #32]	; (1d054 <_system_extint_init+0x64>)
   1d034:	4798      	blx	r3
}
   1d036:	bd07      	pop	{r0, r1, r2, pc}
   1d038:	40000400 	.word	0x40000400
   1d03c:	0001e839 	.word	0x0001e839
   1d040:	0001e7b1 	.word	0x0001e7b1
   1d044:	40001800 	.word	0x40001800
   1d048:	0001cfc5 	.word	0x0001cfc5
   1d04c:	2000563c 	.word	0x2000563c
   1d050:	e000e100 	.word	0xe000e100
   1d054:	0001cfd1 	.word	0x0001cfd1

0001d058 <extint_chan_get_config_defaults>:
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->gpio_pin            = 0;
   1d058:	2300      	movs	r3, #0
	config->gpio_pin_mux        = 0;
	config->gpio_pin_pull       = EXTINT_PULL_UP;
   1d05a:	2201      	movs	r2, #1
	config->gpio_pin            = 0;
   1d05c:	6003      	str	r3, [r0, #0]
	config->gpio_pin_mux        = 0;
   1d05e:	6043      	str	r3, [r0, #4]
	config->wake_if_sleeping    = true;
	config->filter_input_signal = false;
   1d060:	7283      	strb	r3, [r0, #10]
	config->detection_criteria  = EXTINT_DETECT_FALLING;
   1d062:	3302      	adds	r3, #2
	config->gpio_pin_pull       = EXTINT_PULL_UP;
   1d064:	7202      	strb	r2, [r0, #8]
	config->wake_if_sleeping    = true;
   1d066:	7242      	strb	r2, [r0, #9]
	config->detection_criteria  = EXTINT_DETECT_FALLING;
   1d068:	72c3      	strb	r3, [r0, #11]
}
   1d06a:	4770      	bx	lr

0001d06c <extint_chan_set_config>:

 */
void extint_chan_set_config(
		const uint8_t channel,
		const struct extint_chan_conf *const config)
{
   1d06c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1d06e:	000c      	movs	r4, r1
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
   1d070:	2600      	movs	r6, #0
			config->detection_criteria)));

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = config->gpio_pin_mux;
   1d072:	7923      	ldrb	r3, [r4, #4]
   1d074:	a901      	add	r1, sp, #4
   1d076:	704e      	strb	r6, [r1, #1]
	config->powersave    = false;
   1d078:	70ce      	strb	r6, [r1, #3]
   1d07a:	700b      	strb	r3, [r1, #0]
	pinmux_config.direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->gpio_pin_pull;
   1d07c:	7a23      	ldrb	r3, [r4, #8]
{
   1d07e:	0005      	movs	r5, r0
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->gpio_pin_pull;
   1d080:	708b      	strb	r3, [r1, #2]
	system_pinmux_pin_set_config(config->gpio_pin, &pinmux_config);
   1d082:	7820      	ldrb	r0, [r4, #0]
   1d084:	4b13      	ldr	r3, [pc, #76]	; (1d0d4 <extint_chan_set_config+0x68>)
   1d086:	4798      	blx	r3
		return NULL;
   1d088:	0033      	movs	r3, r6
	if (eic_index < EIC_INST_NUM) {
   1d08a:	2d1f      	cmp	r5, #31
   1d08c:	d800      	bhi.n	1d090 <extint_chan_set_config+0x24>
		return eics[eic_index];
   1d08e:	4b12      	ldr	r3, [pc, #72]	; (1d0d8 <extint_chan_set_config+0x6c>)

	/* Get a pointer to the module hardware instance */
	Eic *const EIC_module = _extint_get_eic_from_channel(channel);

	uint32_t config_pos = (4 * (channel % 8));
   1d090:	2107      	movs	r1, #7

	/* Determine the channel's new edge detection configuration */
	new_config = (config->detection_criteria << EIC_CONFIG_SENSE0_Pos);

	/* Enable the hardware signal filter if requested in the config */
	if (config->filter_input_signal) {
   1d092:	7aa2      	ldrb	r2, [r4, #10]
	uint32_t config_pos = (4 * (channel % 8));
   1d094:	4029      	ands	r1, r5
   1d096:	0089      	lsls	r1, r1, #2
	new_config = (config->detection_criteria << EIC_CONFIG_SENSE0_Pos);
   1d098:	7ae6      	ldrb	r6, [r4, #11]
	if (config->filter_input_signal) {
   1d09a:	2a00      	cmp	r2, #0
   1d09c:	d001      	beq.n	1d0a2 <extint_chan_set_config+0x36>
   1d09e:	2208      	movs	r2, #8
   1d0a0:	4316      	orrs	r6, r2
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
		= (EIC_module->CONFIG[channel / 8].reg &
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
   1d0a2:	270f      	movs	r7, #15
			(new_config << config_pos);
   1d0a4:	408e      	lsls	r6, r1
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
   1d0a6:	408f      	lsls	r7, r1
			(new_config << config_pos);
   1d0a8:	0031      	movs	r1, r6
   1d0aa:	08ea      	lsrs	r2, r5, #3
   1d0ac:	0092      	lsls	r2, r2, #2
   1d0ae:	189a      	adds	r2, r3, r2
		= (EIC_module->CONFIG[channel / 8].reg &
   1d0b0:	6990      	ldr	r0, [r2, #24]
   1d0b2:	43b8      	bics	r0, r7
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
   1d0b4:	4301      	orrs	r1, r0
		= (EIC_module->CONFIG[channel / 8].reg &
   1d0b6:	6191      	str	r1, [r2, #24]

	/* Set the channel's new wake up mode setting */
	if (config->wake_if_sleeping) {
   1d0b8:	7a61      	ldrb	r1, [r4, #9]
   1d0ba:	2201      	movs	r2, #1
   1d0bc:	2900      	cmp	r1, #0
   1d0be:	d004      	beq.n	1d0ca <extint_chan_set_config+0x5e>
		EIC_module->WAKEUP.reg |=  (1UL << channel);
   1d0c0:	40aa      	lsls	r2, r5
   1d0c2:	6959      	ldr	r1, [r3, #20]
   1d0c4:	430a      	orrs	r2, r1
   1d0c6:	615a      	str	r2, [r3, #20]
	} else {
		EIC_module->WAKEUP.reg &= ~(1UL << channel);
	}
}
   1d0c8:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
		EIC_module->WAKEUP.reg &= ~(1UL << channel);
   1d0ca:	40aa      	lsls	r2, r5
   1d0cc:	6959      	ldr	r1, [r3, #20]
   1d0ce:	4391      	bics	r1, r2
   1d0d0:	6159      	str	r1, [r3, #20]
}
   1d0d2:	e7f9      	b.n	1d0c8 <extint_chan_set_config+0x5c>
   1d0d4:	0001e93d 	.word	0x0001e93d
   1d0d8:	40001800 	.word	0x40001800

0001d0dc <port_pin_set_config>:
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
   1d0dc:	b507      	push	{r0, r1, r2, lr}
	config->mux_position = SYSTEM_PINMUX_GPIO;
   1d0de:	2280      	movs	r2, #128	; 0x80
   1d0e0:	ab01      	add	r3, sp, #4
   1d0e2:	701a      	strb	r2, [r3, #0]

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
   1d0e4:	780a      	ldrb	r2, [r1, #0]
   1d0e6:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
   1d0e8:	784a      	ldrb	r2, [r1, #1]
   1d0ea:	709a      	strb	r2, [r3, #2]
	pinmux_config.powersave    = config->powersave;
   1d0ec:	788a      	ldrb	r2, [r1, #2]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
   1d0ee:	0019      	movs	r1, r3
	pinmux_config.powersave    = config->powersave;
   1d0f0:	70da      	strb	r2, [r3, #3]
	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
   1d0f2:	4b01      	ldr	r3, [pc, #4]	; (1d0f8 <port_pin_set_config+0x1c>)
   1d0f4:	4798      	blx	r3
}
   1d0f6:	bd07      	pop	{r0, r1, r2, pc}
   1d0f8:	0001e93d 	.word	0x0001e93d

0001d0fc <rtc_calendar_is_syncing>:
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
   1d0fc:	6803      	ldr	r3, [r0, #0]

        if (rtc_module->MODE2.STATUS.reg & RTC_STATUS_SYNCBUSY) {
   1d0fe:	7a98      	ldrb	r0, [r3, #10]
   1d100:	09c0      	lsrs	r0, r0, #7
                return true;
        }

        return false;
}
   1d102:	4770      	bx	lr

0001d104 <rtc_calendar_enable>:
   1d104:	2208      	movs	r2, #8
 * module configuration parameters cannot be altered while the module is enabled.
 *
 * \param[in,out] module  Pointer to the software instance struct
 */
void rtc_calendar_enable(struct rtc_module *const module)
{
   1d106:	b570      	push	{r4, r5, r6, lr}
   1d108:	0005      	movs	r5, r0
   1d10a:	4b06      	ldr	r3, [pc, #24]	; (1d124 <rtc_calendar_enable+0x20>)
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
   1d10c:	6804      	ldr	r4, [r0, #0]
   1d10e:	601a      	str	r2, [r3, #0]

#if RTC_CALENDAR_ASYNC == true
	system_interrupt_enable(SYSTEM_INTERRUPT_MODULE_RTC);
#endif

	while (rtc_calendar_is_syncing(module)) {
   1d110:	0028      	movs	r0, r5
   1d112:	4b05      	ldr	r3, [pc, #20]	; (1d128 <rtc_calendar_enable+0x24>)
   1d114:	4798      	blx	r3
   1d116:	2800      	cmp	r0, #0
   1d118:	d1fa      	bne.n	1d110 <rtc_calendar_enable+0xc>
		/* Wait for synchronization */
	}

	/* Enable RTC module. */
	rtc_module->MODE2.CTRL.reg |= RTC_MODE2_CTRL_ENABLE;
   1d11a:	2302      	movs	r3, #2
   1d11c:	8822      	ldrh	r2, [r4, #0]
   1d11e:	4313      	orrs	r3, r2
   1d120:	8023      	strh	r3, [r4, #0]
}
   1d122:	bd70      	pop	{r4, r5, r6, pc}
   1d124:	e000e100 	.word	0xe000e100
   1d128:	0001d0fd 	.word	0x0001d0fd

0001d12c <rtc_calendar_disable>:
	NVIC->ICER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
   1d12c:	2208      	movs	r2, #8
 * Disables the RTC module.
 *
 * \param[in,out] module  Pointer to the software instance struct
 */
void rtc_calendar_disable(struct rtc_module *const module)
{
   1d12e:	b570      	push	{r4, r5, r6, lr}
   1d130:	0005      	movs	r5, r0
   1d132:	4b08      	ldr	r3, [pc, #32]	; (1d154 <rtc_calendar_disable+0x28>)
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
   1d134:	6804      	ldr	r4, [r0, #0]
   1d136:	67da      	str	r2, [r3, #124]	; 0x7c

#if RTC_CALENDAR_ASYNC == true
	system_interrupt_disable(SYSTEM_INTERRUPT_MODULE_RTC);
#endif

	while (rtc_calendar_is_syncing(module)) {
   1d138:	0028      	movs	r0, r5
   1d13a:	4b07      	ldr	r3, [pc, #28]	; (1d158 <rtc_calendar_disable+0x2c>)
   1d13c:	4798      	blx	r3
   1d13e:	2800      	cmp	r0, #0
   1d140:	d1fa      	bne.n	1d138 <rtc_calendar_disable+0xc>
		/* Wait for synchronization */
	}

	/* Disbale interrupt */
	rtc_module->MODE2.INTENCLR.reg = RTC_MODE2_INTENCLR_MASK;
   1d142:	23c1      	movs	r3, #193	; 0xc1
	/* Clear interrupt flag */
	rtc_module->MODE2.INTFLAG.reg = RTC_MODE2_INTFLAG_MASK;

	/* Disable RTC module. */
	rtc_module->MODE2.CTRL.reg &= ~RTC_MODE2_CTRL_ENABLE;
   1d144:	2202      	movs	r2, #2
	rtc_module->MODE2.INTENCLR.reg = RTC_MODE2_INTENCLR_MASK;
   1d146:	71a3      	strb	r3, [r4, #6]
	rtc_module->MODE2.INTFLAG.reg = RTC_MODE2_INTFLAG_MASK;
   1d148:	7223      	strb	r3, [r4, #8]
	rtc_module->MODE2.CTRL.reg &= ~RTC_MODE2_CTRL_ENABLE;
   1d14a:	8823      	ldrh	r3, [r4, #0]
   1d14c:	4393      	bics	r3, r2
   1d14e:	8023      	strh	r3, [r4, #0]
}
   1d150:	bd70      	pop	{r4, r5, r6, pc}
   1d152:	46c0      	nop			; (mov r8, r8)
   1d154:	e000e104 	.word	0xe000e104
   1d158:	0001d0fd 	.word	0x0001d0fd

0001d15c <rtc_calendar_reset>:
 * Resets the RTC module to hardware defaults.
 *
 * \param[in,out] module  Pointer to the software instance struct
 */
void rtc_calendar_reset(struct rtc_module *const module)
{
   1d15c:	b570      	push	{r4, r5, r6, lr}
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;

	/* Disable module before reset. */
	rtc_calendar_disable(module);
   1d15e:	4b08      	ldr	r3, [pc, #32]	; (1d180 <rtc_calendar_reset+0x24>)
{
   1d160:	0004      	movs	r4, r0
	Rtc *const rtc_module = module->hw;
   1d162:	6805      	ldr	r5, [r0, #0]
	rtc_calendar_disable(module);
   1d164:	4798      	blx	r3

#if RTC_CALENDAR_ASYNC == true
	module->registered_callback = 0;
   1d166:	2300      	movs	r3, #0
   1d168:	8223      	strh	r3, [r4, #16]
	module->enabled_callback    = 0;
   1d16a:	8263      	strh	r3, [r4, #18]
#endif

	while (rtc_calendar_is_syncing(module)) {
   1d16c:	0020      	movs	r0, r4
   1d16e:	4b05      	ldr	r3, [pc, #20]	; (1d184 <rtc_calendar_reset+0x28>)
   1d170:	4798      	blx	r3
   1d172:	2800      	cmp	r0, #0
   1d174:	d1fa      	bne.n	1d16c <rtc_calendar_reset+0x10>
		/* Wait for synchronization */
	}

	/* Initiate software reset. */
	rtc_module->MODE2.CTRL.reg |= RTC_MODE2_CTRL_SWRST;
   1d176:	2301      	movs	r3, #1
   1d178:	882a      	ldrh	r2, [r5, #0]
   1d17a:	4313      	orrs	r3, r2
   1d17c:	802b      	strh	r3, [r5, #0]
}
   1d17e:	bd70      	pop	{r4, r5, r6, pc}
   1d180:	0001d12d 	.word	0x0001d12d
   1d184:	0001d0fd 	.word	0x0001d0fd

0001d188 <rtc_calendar_time_to_register_value>:
 * \return 32-bit value.
 */
uint32_t rtc_calendar_time_to_register_value(
		struct rtc_module *const module,
		const struct rtc_calendar_time *const time)
{
   1d188:	b510      	push	{r4, lr}
	/* Initialize return value. */
	uint32_t register_value;

	/* Set year value into register_value minus initial year. */
	register_value = (time->year - module->year_init_value) <<
   1d18a:	88cb      	ldrh	r3, [r1, #6]
   1d18c:	88c2      	ldrh	r2, [r0, #6]

	/* Set month value into register_value. */
	register_value |= (time->month << RTC_MODE2_CLOCK_MONTH_Pos);

	/* Set day value into register_value. */
	register_value |= (time->day << RTC_MODE2_CLOCK_DAY_Pos);
   1d18e:	790c      	ldrb	r4, [r1, #4]
	register_value = (time->year - module->year_init_value) <<
   1d190:	1a9a      	subs	r2, r3, r2
	register_value |= (time->month << RTC_MODE2_CLOCK_MONTH_Pos);
   1d192:	794b      	ldrb	r3, [r1, #5]
	register_value |= (time->day << RTC_MODE2_CLOCK_DAY_Pos);
   1d194:	0464      	lsls	r4, r4, #17
	register_value |= (time->month << RTC_MODE2_CLOCK_MONTH_Pos);
   1d196:	059b      	lsls	r3, r3, #22

	/* Set 24 hour value into register_value. */
	register_value |= (time->hour << RTC_MODE2_CLOCK_HOUR_Pos);
   1d198:	4323      	orrs	r3, r4
   1d19a:	788c      	ldrb	r4, [r1, #2]
	register_value = (time->year - module->year_init_value) <<
   1d19c:	0692      	lsls	r2, r2, #26
	register_value |= (time->hour << RTC_MODE2_CLOCK_HOUR_Pos);
   1d19e:	0324      	lsls	r4, r4, #12
   1d1a0:	4323      	orrs	r3, r4
   1d1a2:	4313      	orrs	r3, r2

	/* Check if 24 h clock and set pm flag. */
	if (!(module->clock_24h) && (time->pm)) {
   1d1a4:	7902      	ldrb	r2, [r0, #4]
   1d1a6:	2a00      	cmp	r2, #0
   1d1a8:	d105      	bne.n	1d1b6 <rtc_calendar_time_to_register_value+0x2e>
   1d1aa:	78ca      	ldrb	r2, [r1, #3]
   1d1ac:	2a00      	cmp	r2, #0
   1d1ae:	d002      	beq.n	1d1b6 <rtc_calendar_time_to_register_value+0x2e>
		/* Set pm flag. */
		register_value |= RTC_MODE2_CLOCK_HOUR_PM;
   1d1b0:	2280      	movs	r2, #128	; 0x80
   1d1b2:	0252      	lsls	r2, r2, #9
   1d1b4:	4313      	orrs	r3, r2
	}

	/* Set minute value into register_value. */
	register_value |= (time->minute << RTC_MODE2_CLOCK_MINUTE_Pos);
   1d1b6:	7848      	ldrb	r0, [r1, #1]

	/* Set second value into register_value. */
	register_value |= (time->second << RTC_MODE2_CLOCK_SECOND_Pos);
   1d1b8:	780a      	ldrb	r2, [r1, #0]
	register_value |= (time->minute << RTC_MODE2_CLOCK_MINUTE_Pos);
   1d1ba:	0180      	lsls	r0, r0, #6
	register_value |= (time->second << RTC_MODE2_CLOCK_SECOND_Pos);
   1d1bc:	4310      	orrs	r0, r2
   1d1be:	4318      	orrs	r0, r3

	return register_value;
}
   1d1c0:	bd10      	pop	{r4, pc}

0001d1c2 <rtc_calendar_register_value_to_time>:
 */
void rtc_calendar_register_value_to_time(
		struct rtc_module *const module,
		const uint32_t register_value,
		struct rtc_calendar_time *const time)
{
   1d1c2:	b570      	push	{r4, r5, r6, lr}
	/* Set year plus value of initial year. */
	time->year = ((register_value & RTC_MODE2_CLOCK_YEAR_Msk) >>
			RTC_MODE2_CLOCK_YEAR_Pos) + module->year_init_value;

	/* Set month value into time struct. */
	time->month = ((register_value & RTC_MODE2_CLOCK_MONTH_Msk) >>
   1d1c4:	250f      	movs	r5, #15
			RTC_MODE2_CLOCK_MONTH_Pos);

	/* Set day value into time struct. */
	time->day = ((register_value & RTC_MODE2_CLOCK_DAY_Msk) >>
   1d1c6:	261f      	movs	r6, #31
			RTC_MODE2_CLOCK_YEAR_Pos) + module->year_init_value;
   1d1c8:	88c4      	ldrh	r4, [r0, #6]
	time->year = ((register_value & RTC_MODE2_CLOCK_YEAR_Msk) >>
   1d1ca:	0e8b      	lsrs	r3, r1, #26
			RTC_MODE2_CLOCK_YEAR_Pos) + module->year_init_value;
   1d1cc:	191b      	adds	r3, r3, r4
	time->month = ((register_value & RTC_MODE2_CLOCK_MONTH_Msk) >>
   1d1ce:	0d8c      	lsrs	r4, r1, #22
   1d1d0:	402c      	ands	r4, r5
   1d1d2:	7154      	strb	r4, [r2, #5]
	time->day = ((register_value & RTC_MODE2_CLOCK_DAY_Msk) >>
   1d1d4:	0c4c      	lsrs	r4, r1, #17
   1d1d6:	4034      	ands	r4, r6
	time->year = ((register_value & RTC_MODE2_CLOCK_YEAR_Msk) >>
   1d1d8:	80d3      	strh	r3, [r2, #6]
	time->day = ((register_value & RTC_MODE2_CLOCK_DAY_Msk) >>
   1d1da:	7114      	strb	r4, [r2, #4]
			RTC_MODE2_CLOCK_DAY_Pos);

	if (module->clock_24h) {
   1d1dc:	7900      	ldrb	r0, [r0, #4]
   1d1de:	0b0b      	lsrs	r3, r1, #12
   1d1e0:	2800      	cmp	r0, #0
   1d1e2:	d008      	beq.n	1d1f6 <rtc_calendar_register_value_to_time+0x34>
		/* Set hour in 24h mode. */
		time->hour = ((register_value & RTC_MODE2_CLOCK_HOUR_Msk) >>
   1d1e4:	4033      	ands	r3, r6
   1d1e6:	7093      	strb	r3, [r2, #2]
		/* Set pm flag */
		time->pm = ((register_value & RTC_MODE2_CLOCK_HOUR_PM) != 0);
	}

	/* Set minute value into time struct. */
	time->minute = ((register_value & RTC_MODE2_CLOCK_MINUTE_Msk) >>
   1d1e8:	203f      	movs	r0, #63	; 0x3f
   1d1ea:	098b      	lsrs	r3, r1, #6
   1d1ec:	4003      	ands	r3, r0
			RTC_MODE2_CLOCK_MINUTE_Pos);

	/* Set second value into time struct. */
	time->second = ((register_value & RTC_MODE2_CLOCK_SECOND_Msk) >>
   1d1ee:	4001      	ands	r1, r0
	time->minute = ((register_value & RTC_MODE2_CLOCK_MINUTE_Msk) >>
   1d1f0:	7053      	strb	r3, [r2, #1]
	time->second = ((register_value & RTC_MODE2_CLOCK_SECOND_Msk) >>
   1d1f2:	7011      	strb	r1, [r2, #0]
			RTC_MODE2_CLOCK_SECOND_Pos);
}
   1d1f4:	bd70      	pop	{r4, r5, r6, pc}
				(RTC_MODE2_CLOCK_HOUR_Msk & ~RTC_MODE2_CLOCK_HOUR_PM)) >>
   1d1f6:	402b      	ands	r3, r5
		time->hour = ((register_value &
   1d1f8:	7093      	strb	r3, [r2, #2]
		time->pm = ((register_value & RTC_MODE2_CLOCK_HOUR_PM) != 0);
   1d1fa:	03cb      	lsls	r3, r1, #15
   1d1fc:	0fdb      	lsrs	r3, r3, #31
   1d1fe:	70d3      	strb	r3, [r2, #3]
   1d200:	e7f2      	b.n	1d1e8 <rtc_calendar_register_value_to_time+0x26>
	...

0001d204 <rtc_calendar_get_time>:
 * \param[out] time  Pointer to value that will be filled with current time
 */
void rtc_calendar_get_time(
		struct rtc_module *const module,
		struct rtc_calendar_time *const time)
{
   1d204:	b570      	push	{r4, r5, r6, lr}

	Rtc *const rtc_module = module->hw;

	/* Change of read method based on value of continuously_update value in
	 * the configuration structure. */
	if (!(module->continuously_update)) {
   1d206:	7943      	ldrb	r3, [r0, #5]
{
   1d208:	0005      	movs	r5, r0
   1d20a:	000e      	movs	r6, r1
	Rtc *const rtc_module = module->hw;
   1d20c:	6804      	ldr	r4, [r0, #0]
	if (!(module->continuously_update)) {
   1d20e:	2b00      	cmp	r3, #0
   1d210:	d10c      	bne.n	1d22c <rtc_calendar_get_time+0x28>
		/* Request read on CLOCK register. */
		rtc_module->MODE2.READREQ.reg = RTC_READREQ_RREQ;
   1d212:	4b0d      	ldr	r3, [pc, #52]	; (1d248 <rtc_calendar_get_time+0x44>)
   1d214:	8063      	strh	r3, [r4, #2]

		while (rtc_calendar_is_syncing(module)) {
   1d216:	0028      	movs	r0, r5
   1d218:	4b0c      	ldr	r3, [pc, #48]	; (1d24c <rtc_calendar_get_time+0x48>)
   1d21a:	4798      	blx	r3
   1d21c:	2800      	cmp	r0, #0
   1d21e:	d1fa      	bne.n	1d216 <rtc_calendar_get_time+0x12>

	/* Read value. */
	uint32_t register_value = rtc_module->MODE2.CLOCK.reg;

	/* Convert value to time structure. */
	rtc_calendar_register_value_to_time(module, register_value, time);
   1d220:	0032      	movs	r2, r6
   1d222:	0028      	movs	r0, r5
	uint32_t register_value = rtc_module->MODE2.CLOCK.reg;
   1d224:	6921      	ldr	r1, [r4, #16]
	rtc_calendar_register_value_to_time(module, register_value, time);
   1d226:	4b0a      	ldr	r3, [pc, #40]	; (1d250 <rtc_calendar_get_time+0x4c>)
   1d228:	4798      	blx	r3
}
   1d22a:	bd70      	pop	{r4, r5, r6, pc}
	} else if (!(rtc_module->MODE2.READREQ.reg & RTC_READREQ_RCONT)){
   1d22c:	8863      	ldrh	r3, [r4, #2]
   1d22e:	045b      	lsls	r3, r3, #17
   1d230:	d4f6      	bmi.n	1d220 <rtc_calendar_get_time+0x1c>
		rtc_module->MODE2.READREQ.reg |= RTC_READREQ_RCONT | RTC_READREQ_RREQ;
   1d232:	22c0      	movs	r2, #192	; 0xc0
   1d234:	8863      	ldrh	r3, [r4, #2]
   1d236:	0212      	lsls	r2, r2, #8
   1d238:	4313      	orrs	r3, r2
   1d23a:	8063      	strh	r3, [r4, #2]
		while (rtc_calendar_is_syncing(module)) {
   1d23c:	0028      	movs	r0, r5
   1d23e:	4b03      	ldr	r3, [pc, #12]	; (1d24c <rtc_calendar_get_time+0x48>)
   1d240:	4798      	blx	r3
   1d242:	2800      	cmp	r0, #0
   1d244:	d1fa      	bne.n	1d23c <rtc_calendar_get_time+0x38>
   1d246:	e7eb      	b.n	1d220 <rtc_calendar_get_time+0x1c>
   1d248:	ffff8000 	.word	0xffff8000
   1d24c:	0001d0fd 	.word	0x0001d0fd
   1d250:	0001d1c3 	.word	0x0001d1c3

0001d254 <rtc_calendar_set_alarm>:
 */
enum status_code rtc_calendar_set_alarm(
		struct rtc_module *const module,
		const struct rtc_calendar_alarm_time *const alarm,
		const enum rtc_calendar_alarm alarm_index)
{
   1d254:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1d256:	0005      	movs	r5, r0
   1d258:	000e      	movs	r6, r1
   1d25a:	0014      	movs	r4, r2

	Rtc *const rtc_module = module->hw;

	/* Sanity check. */
	if ((uint32_t)alarm_index > RTC_NUM_OF_ALARMS) {
		return STATUS_ERR_INVALID_ARG;
   1d25c:	2017      	movs	r0, #23
	if ((uint32_t)alarm_index > RTC_NUM_OF_ALARMS) {
   1d25e:	2a01      	cmp	r2, #1
   1d260:	d810      	bhi.n	1d284 <rtc_calendar_set_alarm+0x30>
	Rtc *const rtc_module = module->hw;
   1d262:	682b      	ldr	r3, [r5, #0]
	}

	/* Get register_value from time. */
	uint32_t register_value = rtc_calendar_time_to_register_value(module, &(alarm->time));
   1d264:	0028      	movs	r0, r5
	Rtc *const rtc_module = module->hw;
   1d266:	9301      	str	r3, [sp, #4]
	uint32_t register_value = rtc_calendar_time_to_register_value(module, &(alarm->time));
   1d268:	4b07      	ldr	r3, [pc, #28]	; (1d288 <rtc_calendar_set_alarm+0x34>)
   1d26a:	4798      	blx	r3
   1d26c:	0007      	movs	r7, r0

	while (rtc_calendar_is_syncing(module)) {
   1d26e:	0028      	movs	r0, r5
   1d270:	4b06      	ldr	r3, [pc, #24]	; (1d28c <rtc_calendar_set_alarm+0x38>)
   1d272:	4798      	blx	r3
   1d274:	2800      	cmp	r0, #0
   1d276:	d1fa      	bne.n	1d26e <rtc_calendar_set_alarm+0x1a>
   1d278:	9b01      	ldr	r3, [sp, #4]
   1d27a:	00e4      	lsls	r4, r4, #3
   1d27c:	191c      	adds	r4, r3, r4
		/* Wait for synchronization */
	}

	/* Set alarm value. */
	rtc_module->MODE2.Mode2Alarm[alarm_index].ALARM.reg = register_value;
   1d27e:	61a7      	str	r7, [r4, #24]

	/* Set alarm mask */
	rtc_module->MODE2.Mode2Alarm[alarm_index].MASK.reg = alarm->mask;
   1d280:	7a33      	ldrb	r3, [r6, #8]
   1d282:	7723      	strb	r3, [r4, #28]

	return STATUS_OK;
}
   1d284:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   1d286:	46c0      	nop			; (mov r8, r8)
   1d288:	0001d189 	.word	0x0001d189
   1d28c:	0001d0fd 	.word	0x0001d0fd

0001d290 <rtc_calendar_init>:
   1d290:	2320      	movs	r3, #32
{
   1d292:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1d294:	0014      	movs	r4, r2
   1d296:	4a1c      	ldr	r2, [pc, #112]	; (1d308 <rtc_calendar_init+0x78>)
	module->hw = hw;
   1d298:	6001      	str	r1, [r0, #0]
   1d29a:	6991      	ldr	r1, [r2, #24]
{
   1d29c:	0005      	movs	r5, r0
   1d29e:	430b      	orrs	r3, r1
   1d2a0:	6193      	str	r3, [r2, #24]
	gclk_chan_conf.source_generator = GCLK_GENERATOR_2;
   1d2a2:	2302      	movs	r3, #2
   1d2a4:	a901      	add	r1, sp, #4
   1d2a6:	700b      	strb	r3, [r1, #0]
	system_gclk_chan_set_config(RTC_GCLK_ID, &gclk_chan_conf);
   1d2a8:	2004      	movs	r0, #4
   1d2aa:	4b18      	ldr	r3, [pc, #96]	; (1d30c <rtc_calendar_init+0x7c>)
   1d2ac:	4798      	blx	r3
	system_gclk_chan_enable(RTC_GCLK_ID);
   1d2ae:	2004      	movs	r0, #4
   1d2b0:	4b17      	ldr	r3, [pc, #92]	; (1d310 <rtc_calendar_init+0x80>)
   1d2b2:	4798      	blx	r3
	rtc_calendar_reset(module);
   1d2b4:	4b17      	ldr	r3, [pc, #92]	; (1d314 <rtc_calendar_init+0x84>)
   1d2b6:	0028      	movs	r0, r5
   1d2b8:	4798      	blx	r3
	module->clock_24h           = config->clock_24h;
   1d2ba:	7923      	ldrb	r3, [r4, #4]
   1d2bc:	712b      	strb	r3, [r5, #4]
	module->continuously_update = config->continuously_update;
   1d2be:	78e3      	ldrb	r3, [r4, #3]
   1d2c0:	716b      	strb	r3, [r5, #5]
	module->year_init_value     = config->year_init_value;
   1d2c2:	88e3      	ldrh	r3, [r4, #6]
   1d2c4:	80eb      	strh	r3, [r5, #6]
	_rtc_instance[0] = module;
   1d2c6:	4b14      	ldr	r3, [pc, #80]	; (1d318 <rtc_calendar_init+0x88>)
   1d2c8:	601d      	str	r5, [r3, #0]
	if (!(config->clock_24h)) {
   1d2ca:	7921      	ldrb	r1, [r4, #4]
	Rtc *const rtc_module = module->hw;
   1d2cc:	682a      	ldr	r2, [r5, #0]
	tmp_reg = RTC_MODE2_CTRL_MODE(2) | config->prescaler;
   1d2ce:	8823      	ldrh	r3, [r4, #0]
	if (!(config->clock_24h)) {
   1d2d0:	2900      	cmp	r1, #0
   1d2d2:	d016      	beq.n	1d302 <rtc_calendar_init+0x72>
	tmp_reg = RTC_MODE2_CTRL_MODE(2) | config->prescaler;
   1d2d4:	2108      	movs	r1, #8
		tmp_reg |= RTC_MODE2_CTRL_CLKREP;
   1d2d6:	430b      	orrs	r3, r1
	if (config->clear_on_match) {
   1d2d8:	78a1      	ldrb	r1, [r4, #2]
   1d2da:	2900      	cmp	r1, #0
   1d2dc:	d001      	beq.n	1d2e2 <rtc_calendar_init+0x52>
		tmp_reg |= RTC_MODE2_CTRL_MATCHCLR;
   1d2de:	2180      	movs	r1, #128	; 0x80
   1d2e0:	430b      	orrs	r3, r1
	rtc_module->MODE2.CTRL.reg = tmp_reg;
   1d2e2:	8013      	strh	r3, [r2, #0]
	if (config->continuously_update) {
   1d2e4:	78e3      	ldrb	r3, [r4, #3]
   1d2e6:	2b00      	cmp	r3, #0
   1d2e8:	d004      	beq.n	1d2f4 <rtc_calendar_init+0x64>
		rtc_module->MODE2.READREQ.reg |= RTC_READREQ_RCONT;
   1d2ea:	2380      	movs	r3, #128	; 0x80
   1d2ec:	8851      	ldrh	r1, [r2, #2]
   1d2ee:	01db      	lsls	r3, r3, #7
   1d2f0:	430b      	orrs	r3, r1
   1d2f2:	8053      	strh	r3, [r2, #2]
		rtc_calendar_set_alarm(module, &(config->alarm[i]), (enum rtc_calendar_alarm)i);
   1d2f4:	0021      	movs	r1, r4
   1d2f6:	0028      	movs	r0, r5
   1d2f8:	3108      	adds	r1, #8
   1d2fa:	2200      	movs	r2, #0
   1d2fc:	4b07      	ldr	r3, [pc, #28]	; (1d31c <rtc_calendar_init+0x8c>)
   1d2fe:	4798      	blx	r3
}
   1d300:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
		tmp_reg |= RTC_MODE2_CTRL_CLKREP;
   1d302:	2148      	movs	r1, #72	; 0x48
   1d304:	e7e7      	b.n	1d2d6 <rtc_calendar_init+0x46>
   1d306:	46c0      	nop			; (mov r8, r8)
   1d308:	40000400 	.word	0x40000400
   1d30c:	0001e839 	.word	0x0001e839
   1d310:	0001e7b1 	.word	0x0001e7b1
   1d314:	0001d15d 	.word	0x0001d15d
   1d318:	2000567c 	.word	0x2000567c
   1d31c:	0001d255 	.word	0x0001d255

0001d320 <RTC_Handler>:
/**
 * \internal ISR handler for RTC
 */
#if (RTC_INST_NUM == 1)
void RTC_Handler(void)
{
   1d320:	b570      	push	{r4, r5, r6, lr}
	struct rtc_module *module = _rtc_instance[instance_index];
   1d322:	4b0e      	ldr	r3, [pc, #56]	; (1d35c <RTC_Handler+0x3c>)
   1d324:	681b      	ldr	r3, [r3, #0]
	uint16_t callback_mask = module->enabled_callback;
   1d326:	8a59      	ldrh	r1, [r3, #18]
	Rtc *const rtc_module = module->hw;
   1d328:	681c      	ldr	r4, [r3, #0]
	callback_mask &= module->registered_callback;
   1d32a:	8a1a      	ldrh	r2, [r3, #16]
	uint16_t interrupt_status = rtc_module->MODE2.INTFLAG.reg;
   1d32c:	7a20      	ldrb	r0, [r4, #8]
	callback_mask &= module->registered_callback;
   1d32e:	400a      	ands	r2, r1
	interrupt_status &= rtc_module->MODE2.INTENSET.reg;
   1d330:	79e1      	ldrb	r1, [r4, #7]
   1d332:	4001      	ands	r1, r0
	if (interrupt_status & RTC_MODE2_INTFLAG_OVF) {
   1d334:	b248      	sxtb	r0, r1
   1d336:	2800      	cmp	r0, #0
   1d338:	da06      	bge.n	1d348 <RTC_Handler+0x28>
		if (callback_mask & (1 << RTC_CALENDAR_CALLBACK_OVERFLOW)) {
   1d33a:	0792      	lsls	r2, r2, #30
   1d33c:	d501      	bpl.n	1d342 <RTC_Handler+0x22>
			module->callbacks[RTC_CALENDAR_CALLBACK_OVERFLOW]();
   1d33e:	68db      	ldr	r3, [r3, #12]
   1d340:	4798      	blx	r3
		rtc_module->MODE2.INTFLAG.reg = RTC_MODE2_INTFLAG_OVF;
   1d342:	2380      	movs	r3, #128	; 0x80
   1d344:	7223      	strb	r3, [r4, #8]
	_rtc_interrupt_handler(0);
}
   1d346:	bd70      	pop	{r4, r5, r6, pc}
   1d348:	2501      	movs	r5, #1
	} else if (interrupt_status & RTC_MODE2_INTFLAG_ALARM(1 << 0)) {
   1d34a:	4229      	tst	r1, r5
   1d34c:	d0fb      	beq.n	1d346 <RTC_Handler+0x26>
		if (callback_mask & (1 << RTC_CALENDAR_CALLBACK_ALARM_0)) {
   1d34e:	422a      	tst	r2, r5
   1d350:	d001      	beq.n	1d356 <RTC_Handler+0x36>
			module->callbacks[RTC_CALENDAR_CALLBACK_ALARM_0]();
   1d352:	689b      	ldr	r3, [r3, #8]
   1d354:	4798      	blx	r3
		rtc_module->MODE2.INTFLAG.reg = RTC_MODE2_INTFLAG_ALARM(1 << 0);
   1d356:	7225      	strb	r5, [r4, #8]
}
   1d358:	e7f5      	b.n	1d346 <RTC_Handler+0x26>
   1d35a:	46c0      	nop			; (mov r8, r8)
   1d35c:	2000567c 	.word	0x2000567c

0001d360 <long_division>:
/**
 * \internal Calculate 64 bit division, ref can be found in
 * http://en.wikipedia.org/wiki/Division_algorithm#Long_division
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
   1d360:	b5f0      	push	{r4, r5, r6, r7, lr}
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
   1d362:	2400      	movs	r4, #0
{
   1d364:	b089      	sub	sp, #36	; 0x24
   1d366:	9200      	str	r2, [sp, #0]
   1d368:	9301      	str	r3, [sp, #4]
	for (i = 63; i >= 0; i--) {
   1d36a:	233f      	movs	r3, #63	; 0x3f
	uint64_t q = 0, r = 0, bit_shift;
   1d36c:	2600      	movs	r6, #0
   1d36e:	2700      	movs	r7, #0
   1d370:	0025      	movs	r5, r4
{
   1d372:	9006      	str	r0, [sp, #24]
   1d374:	9107      	str	r1, [sp, #28]
	for (i = 63; i >= 0; i--) {
   1d376:	9303      	str	r3, [sp, #12]
		bit_shift = (uint64_t)1 << i;
   1d378:	9a03      	ldr	r2, [sp, #12]
   1d37a:	4b13      	ldr	r3, [pc, #76]	; (1d3c8 <long_division+0x68>)
   1d37c:	2001      	movs	r0, #1
   1d37e:	2100      	movs	r1, #0
   1d380:	4798      	blx	r3

		r = r << 1;
   1d382:	19b6      	adds	r6, r6, r6
   1d384:	417f      	adcs	r7, r7

		if (n & bit_shift) {
   1d386:	9b06      	ldr	r3, [sp, #24]
   1d388:	9a07      	ldr	r2, [sp, #28]
   1d38a:	4003      	ands	r3, r0
   1d38c:	400a      	ands	r2, r1
		r = r << 1;
   1d38e:	9604      	str	r6, [sp, #16]
   1d390:	9705      	str	r7, [sp, #20]
		if (n & bit_shift) {
   1d392:	4313      	orrs	r3, r2
   1d394:	d003      	beq.n	1d39e <long_division+0x3e>
			r |= 0x01;
   1d396:	2301      	movs	r3, #1
   1d398:	4333      	orrs	r3, r6
   1d39a:	001e      	movs	r6, r3
   1d39c:	9f05      	ldr	r7, [sp, #20]
		}

		if (r >= d) {
   1d39e:	9b01      	ldr	r3, [sp, #4]
   1d3a0:	42bb      	cmp	r3, r7
   1d3a2:	d809      	bhi.n	1d3b8 <long_division+0x58>
   1d3a4:	d102      	bne.n	1d3ac <long_division+0x4c>
   1d3a6:	9b00      	ldr	r3, [sp, #0]
   1d3a8:	42b3      	cmp	r3, r6
   1d3aa:	d805      	bhi.n	1d3b8 <long_division+0x58>
			r = r - d;
   1d3ac:	9a00      	ldr	r2, [sp, #0]
   1d3ae:	9b01      	ldr	r3, [sp, #4]
   1d3b0:	1ab6      	subs	r6, r6, r2
   1d3b2:	419f      	sbcs	r7, r3
			q |= bit_shift;
   1d3b4:	4304      	orrs	r4, r0
   1d3b6:	430d      	orrs	r5, r1
	for (i = 63; i >= 0; i--) {
   1d3b8:	9b03      	ldr	r3, [sp, #12]
   1d3ba:	1e5a      	subs	r2, r3, #1
   1d3bc:	9203      	str	r2, [sp, #12]
   1d3be:	d2db      	bcs.n	1d378 <long_division+0x18>
		}
	}

	return q;
}
   1d3c0:	0020      	movs	r0, r4
   1d3c2:	0029      	movs	r1, r5
   1d3c4:	b009      	add	sp, #36	; 0x24
   1d3c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1d3c8:	00025ba9 	.word	0x00025ba9

0001d3cc <_sercom_get_sync_baud_val>:
 */
enum status_code _sercom_get_sync_baud_val(
		const uint32_t baudrate,
		const uint32_t external_clock,
		uint16_t *const baudvalue)
{
   1d3cc:	b510      	push	{r4, lr}
	uint16_t baud_calculated = 0;
	uint32_t clock_value = external_clock;


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
   1d3ce:	0849      	lsrs	r1, r1, #1
{
   1d3d0:	0004      	movs	r4, r0
   1d3d2:	2300      	movs	r3, #0
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
   1d3d4:	2040      	movs	r0, #64	; 0x40
	if (baudrate > (external_clock / 2)) {
   1d3d6:	42a1      	cmp	r1, r4
   1d3d8:	d201      	bcs.n	1d3de <_sercom_get_sync_baud_val+0x12>
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	} else {
		*baudvalue = baud_calculated;
		return STATUS_OK;
	}
}
   1d3da:	bd10      	pop	{r4, pc}
		baud_calculated++;
   1d3dc:	0003      	movs	r3, r0
   1d3de:	1c58      	adds	r0, r3, #1
		clock_value = clock_value - baudrate;
   1d3e0:	1b09      	subs	r1, r1, r4
		baud_calculated++;
   1d3e2:	b280      	uxth	r0, r0
	while (clock_value >= baudrate) {
   1d3e4:	428c      	cmp	r4, r1
   1d3e6:	d9f9      	bls.n	1d3dc <_sercom_get_sync_baud_val+0x10>
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
   1d3e8:	2040      	movs	r0, #64	; 0x40
	if (baud_calculated > 0xFF) {
   1d3ea:	2bff      	cmp	r3, #255	; 0xff
   1d3ec:	d8f5      	bhi.n	1d3da <_sercom_get_sync_baud_val+0xe>
		*baudvalue = baud_calculated;
   1d3ee:	8013      	strh	r3, [r2, #0]
		return STATUS_OK;
   1d3f0:	2000      	movs	r0, #0
   1d3f2:	e7f2      	b.n	1d3da <_sercom_get_sync_baud_val+0xe>

0001d3f4 <_sercom_get_async_baud_val>:
		const uint32_t baudrate,
		const uint32_t peripheral_clock,
		uint16_t *const baudval,
		enum sercom_asynchronous_operation_mode mode,
		enum sercom_asynchronous_sample_num sample_num)
{
   1d3f4:	b5f0      	push	{r4, r5, r6, r7, lr}
   1d3f6:	b085      	sub	sp, #20
   1d3f8:	001e      	movs	r6, r3
   1d3fa:	ab0a      	add	r3, sp, #40	; 0x28
   1d3fc:	000d      	movs	r5, r1
   1d3fe:	7819      	ldrb	r1, [r3, #0]
	uint8_t baud_fp;
	uint32_t baud_int = 0;
	uint64_t temp1;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
   1d400:	0003      	movs	r3, r0
   1d402:	434b      	muls	r3, r1
{
   1d404:	9203      	str	r2, [sp, #12]
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
   1d406:	2740      	movs	r7, #64	; 0x40
	if ((baudrate * sample_num) > peripheral_clock) {
   1d408:	42ab      	cmp	r3, r5
   1d40a:	d817      	bhi.n	1d43c <_sercom_get_async_baud_val+0x48>
	}

	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
   1d40c:	2e00      	cmp	r6, #0
   1d40e:	d118      	bne.n	1d442 <_sercom_get_async_baud_val+0x4e>
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
   1d410:	0002      	movs	r2, r0
   1d412:	0033      	movs	r3, r6
   1d414:	0008      	movs	r0, r1
   1d416:	4c1b      	ldr	r4, [pc, #108]	; (1d484 <_sercom_get_async_baud_val+0x90>)
   1d418:	0031      	movs	r1, r6
   1d41a:	47a0      	blx	r4
		ratio = long_division(temp1, peripheral_clock);
   1d41c:	002a      	movs	r2, r5
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
   1d41e:	0001      	movs	r1, r0
		ratio = long_division(temp1, peripheral_clock);
   1d420:	0033      	movs	r3, r6
   1d422:	4c19      	ldr	r4, [pc, #100]	; (1d488 <_sercom_get_async_baud_val+0x94>)
   1d424:	0030      	movs	r0, r6
   1d426:	47a0      	blx	r4
		scale = ((uint64_t)1 << SHIFT) - ratio;
   1d428:	2200      	movs	r2, #0
   1d42a:	2301      	movs	r3, #1
   1d42c:	1a12      	subs	r2, r2, r0
   1d42e:	418b      	sbcs	r3, r1
		baud_calculated = (65536 * scale) >> SHIFT;
   1d430:	0c14      	lsrs	r4, r2, #16
   1d432:	0418      	lsls	r0, r3, #16
   1d434:	4304      	orrs	r4, r0
		baud_fp = temp1 - 8 * baud_int;
		baud_calculated = baud_int | (baud_fp << 13);
	}

	*baudval = baud_calculated;
	return STATUS_OK;
   1d436:	2700      	movs	r7, #0
	*baudval = baud_calculated;
   1d438:	9b03      	ldr	r3, [sp, #12]
   1d43a:	801c      	strh	r4, [r3, #0]
}
   1d43c:	0038      	movs	r0, r7
   1d43e:	b005      	add	sp, #20
   1d440:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uint64_t baud_calculated = 0;
   1d442:	2400      	movs	r4, #0
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
   1d444:	2e01      	cmp	r6, #1
   1d446:	d1f6      	bne.n	1d436 <_sercom_get_async_baud_val+0x42>
		temp1 = ((uint64_t)baudrate * sample_num);
   1d448:	000a      	movs	r2, r1
   1d44a:	0023      	movs	r3, r4
   1d44c:	0021      	movs	r1, r4
   1d44e:	4e0d      	ldr	r6, [pc, #52]	; (1d484 <_sercom_get_async_baud_val+0x90>)
   1d450:	47b0      	blx	r6
   1d452:	9000      	str	r0, [sp, #0]
   1d454:	9101      	str	r1, [sp, #4]
		baud_int = long_division( peripheral_clock, temp1);
   1d456:	000b      	movs	r3, r1
   1d458:	0002      	movs	r2, r0
   1d45a:	0021      	movs	r1, r4
   1d45c:	0028      	movs	r0, r5
   1d45e:	4c0a      	ldr	r4, [pc, #40]	; (1d488 <_sercom_get_async_baud_val+0x94>)
   1d460:	47a0      	blx	r4
		if(baud_int > BAUD_INT_MAX) {
   1d462:	2380      	movs	r3, #128	; 0x80
		baud_int = long_division( peripheral_clock, temp1);
   1d464:	0006      	movs	r6, r0
		if(baud_int > BAUD_INT_MAX) {
   1d466:	019b      	lsls	r3, r3, #6
   1d468:	4298      	cmp	r0, r3
   1d46a:	d8e7      	bhi.n	1d43c <_sercom_get_async_baud_val+0x48>
		temp1 = long_division( 8 * (uint64_t)peripheral_clock, temp1);
   1d46c:	9a00      	ldr	r2, [sp, #0]
   1d46e:	9b01      	ldr	r3, [sp, #4]
   1d470:	0f69      	lsrs	r1, r5, #29
   1d472:	00e8      	lsls	r0, r5, #3
   1d474:	47a0      	blx	r4
		baud_fp = temp1 - 8 * baud_int;
   1d476:	00f4      	lsls	r4, r6, #3
   1d478:	1b04      	subs	r4, r0, r4
		baud_calculated = baud_int | (baud_fp << 13);
   1d47a:	b2e4      	uxtb	r4, r4
   1d47c:	0364      	lsls	r4, r4, #13
   1d47e:	4334      	orrs	r4, r6
   1d480:	e7d9      	b.n	1d436 <_sercom_get_async_baud_val+0x42>
   1d482:	46c0      	nop			; (mov r8, r8)
   1d484:	00025cb1 	.word	0x00025cb1
   1d488:	0001d361 	.word	0x0001d361

0001d48c <sercom_set_gclk_generator>:
 *                                         forced.
 */
enum status_code sercom_set_gclk_generator(
		const enum gclk_generator generator_source,
		const bool force_change)
{
   1d48c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	/* Check if valid option */
	if (!_sercom_config.generator_is_set || force_change) {
   1d48e:	4c0d      	ldr	r4, [pc, #52]	; (1d4c4 <sercom_set_gclk_generator+0x38>)
{
   1d490:	0005      	movs	r5, r0
	if (!_sercom_config.generator_is_set || force_change) {
   1d492:	7823      	ldrb	r3, [r4, #0]
   1d494:	2b00      	cmp	r3, #0
   1d496:	d001      	beq.n	1d49c <sercom_set_gclk_generator+0x10>
   1d498:	2900      	cmp	r1, #0
   1d49a:	d00c      	beq.n	1d4b6 <sercom_set_gclk_generator+0x2a>
		/* Create and fill a GCLK configuration structure for the new config */
		struct system_gclk_chan_config gclk_chan_conf;
		system_gclk_chan_get_config_defaults(&gclk_chan_conf);
		gclk_chan_conf.source_generator = generator_source;
   1d49c:	a901      	add	r1, sp, #4
		system_gclk_chan_set_config(SERCOM_GCLK_ID, &gclk_chan_conf);
   1d49e:	2013      	movs	r0, #19
   1d4a0:	4b09      	ldr	r3, [pc, #36]	; (1d4c8 <sercom_set_gclk_generator+0x3c>)
		gclk_chan_conf.source_generator = generator_source;
   1d4a2:	700d      	strb	r5, [r1, #0]
		system_gclk_chan_set_config(SERCOM_GCLK_ID, &gclk_chan_conf);
   1d4a4:	4798      	blx	r3
		system_gclk_chan_enable(SERCOM_GCLK_ID);
   1d4a6:	2013      	movs	r0, #19
   1d4a8:	4b08      	ldr	r3, [pc, #32]	; (1d4cc <sercom_set_gclk_generator+0x40>)
   1d4aa:	4798      	blx	r3

		/* Save config */
		_sercom_config.generator_source = generator_source;
		_sercom_config.generator_is_set = true;
   1d4ac:	2301      	movs	r3, #1

		return STATUS_OK;
   1d4ae:	2000      	movs	r0, #0
		_sercom_config.generator_source = generator_source;
   1d4b0:	7065      	strb	r5, [r4, #1]
		_sercom_config.generator_is_set = true;
   1d4b2:	7023      	strb	r3, [r4, #0]
		return STATUS_OK;
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
}
   1d4b4:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
	} else if (generator_source == _sercom_config.generator_source) {
   1d4b6:	7863      	ldrb	r3, [r4, #1]
		return STATUS_OK;
   1d4b8:	0008      	movs	r0, r1
	} else if (generator_source == _sercom_config.generator_source) {
   1d4ba:	42ab      	cmp	r3, r5
   1d4bc:	d0fa      	beq.n	1d4b4 <sercom_set_gclk_generator+0x28>
	return STATUS_ERR_ALREADY_INITIALIZED;
   1d4be:	201d      	movs	r0, #29
   1d4c0:	e7f8      	b.n	1d4b4 <sercom_set_gclk_generator+0x28>
   1d4c2:	46c0      	nop			; (mov r8, r8)
   1d4c4:	20003d95 	.word	0x20003d95
   1d4c8:	0001e839 	.word	0x0001e839
   1d4cc:	0001e7b1 	.word	0x0001e7b1

0001d4d0 <_sercom_get_default_pad>:
 */
uint32_t _sercom_get_default_pad(
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
   1d4d0:	4a39      	ldr	r2, [pc, #228]	; (1d5b8 <_sercom_get_default_pad+0xe8>)
{
   1d4d2:	0003      	movs	r3, r0
   1d4d4:	b500      	push	{lr}
   1d4d6:	0008      	movs	r0, r1
	switch ((uintptr_t)sercom_module) {
   1d4d8:	4293      	cmp	r3, r2
   1d4da:	d033      	beq.n	1d544 <_sercom_get_default_pad+0x74>
   1d4dc:	d807      	bhi.n	1d4ee <_sercom_get_default_pad+0x1e>
   1d4de:	4a37      	ldr	r2, [pc, #220]	; (1d5bc <_sercom_get_default_pad+0xec>)
   1d4e0:	4293      	cmp	r3, r2
   1d4e2:	d014      	beq.n	1d50e <_sercom_get_default_pad+0x3e>
   1d4e4:	4a36      	ldr	r2, [pc, #216]	; (1d5c0 <_sercom_get_default_pad+0xf0>)
   1d4e6:	4293      	cmp	r3, r2
   1d4e8:	d01f      	beq.n	1d52a <_sercom_get_default_pad+0x5a>
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
	}

	Assert(false);
	return 0;
   1d4ea:	2300      	movs	r3, #0
   1d4ec:	e017      	b.n	1d51e <_sercom_get_default_pad+0x4e>
	switch ((uintptr_t)sercom_module) {
   1d4ee:	4a35      	ldr	r2, [pc, #212]	; (1d5c4 <_sercom_get_default_pad+0xf4>)
   1d4f0:	4293      	cmp	r3, r2
   1d4f2:	d03a      	beq.n	1d56a <_sercom_get_default_pad+0x9a>
   1d4f4:	4a34      	ldr	r2, [pc, #208]	; (1d5c8 <_sercom_get_default_pad+0xf8>)
   1d4f6:	4293      	cmp	r3, r2
   1d4f8:	d044      	beq.n	1d584 <_sercom_get_default_pad+0xb4>
   1d4fa:	4a34      	ldr	r2, [pc, #208]	; (1d5cc <_sercom_get_default_pad+0xfc>)
   1d4fc:	4293      	cmp	r3, r2
   1d4fe:	d1f4      	bne.n	1d4ea <_sercom_get_default_pad+0x1a>
	return 0;
   1d500:	2300      	movs	r3, #0
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
   1d502:	2903      	cmp	r1, #3
   1d504:	d80b      	bhi.n	1d51e <_sercom_get_default_pad+0x4e>
   1d506:	f008 f9cf 	bl	258a8 <__gnu_thumb1_case_uqi>
   1d50a:	2a50      	.short	0x2a50
   1d50c:	2e2c      	.short	0x2e2c
	return 0;
   1d50e:	2300      	movs	r3, #0
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
   1d510:	2903      	cmp	r1, #3
   1d512:	d804      	bhi.n	1d51e <_sercom_get_default_pad+0x4e>
   1d514:	f008 f9c8 	bl	258a8 <__gnu_thumb1_case_uqi>
   1d518:	07050243 	.word	0x07050243
   1d51c:	4b2c      	ldr	r3, [pc, #176]	; (1d5d0 <_sercom_get_default_pad+0x100>)
}
   1d51e:	0018      	movs	r0, r3
   1d520:	bd00      	pop	{pc}
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
   1d522:	4b2c      	ldr	r3, [pc, #176]	; (1d5d4 <_sercom_get_default_pad+0x104>)
   1d524:	e7fb      	b.n	1d51e <_sercom_get_default_pad+0x4e>
   1d526:	4b2c      	ldr	r3, [pc, #176]	; (1d5d8 <_sercom_get_default_pad+0x108>)
   1d528:	e7f9      	b.n	1d51e <_sercom_get_default_pad+0x4e>
	return 0;
   1d52a:	2300      	movs	r3, #0
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
   1d52c:	2903      	cmp	r1, #3
   1d52e:	d8f6      	bhi.n	1d51e <_sercom_get_default_pad+0x4e>
   1d530:	f008 f9ba 	bl	258a8 <__gnu_thumb1_case_uqi>
   1d534:	06040237 	.word	0x06040237
   1d538:	4b28      	ldr	r3, [pc, #160]	; (1d5dc <_sercom_get_default_pad+0x10c>)
   1d53a:	e7f0      	b.n	1d51e <_sercom_get_default_pad+0x4e>
   1d53c:	4b28      	ldr	r3, [pc, #160]	; (1d5e0 <_sercom_get_default_pad+0x110>)
   1d53e:	e7ee      	b.n	1d51e <_sercom_get_default_pad+0x4e>
   1d540:	4b28      	ldr	r3, [pc, #160]	; (1d5e4 <_sercom_get_default_pad+0x114>)
   1d542:	e7ec      	b.n	1d51e <_sercom_get_default_pad+0x4e>
	return 0;
   1d544:	2300      	movs	r3, #0
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
   1d546:	2903      	cmp	r1, #3
   1d548:	d8e9      	bhi.n	1d51e <_sercom_get_default_pad+0x4e>
   1d54a:	f008 f9ad 	bl	258a8 <__gnu_thumb1_case_uqi>
   1d54e:	022c      	.short	0x022c
   1d550:	0604      	.short	0x0604
   1d552:	4b25      	ldr	r3, [pc, #148]	; (1d5e8 <_sercom_get_default_pad+0x118>)
   1d554:	e7e3      	b.n	1d51e <_sercom_get_default_pad+0x4e>
   1d556:	4b25      	ldr	r3, [pc, #148]	; (1d5ec <_sercom_get_default_pad+0x11c>)
   1d558:	e7e1      	b.n	1d51e <_sercom_get_default_pad+0x4e>
   1d55a:	4b25      	ldr	r3, [pc, #148]	; (1d5f0 <_sercom_get_default_pad+0x120>)
   1d55c:	e7df      	b.n	1d51e <_sercom_get_default_pad+0x4e>
   1d55e:	4b25      	ldr	r3, [pc, #148]	; (1d5f4 <_sercom_get_default_pad+0x124>)
   1d560:	e7dd      	b.n	1d51e <_sercom_get_default_pad+0x4e>
   1d562:	4b25      	ldr	r3, [pc, #148]	; (1d5f8 <_sercom_get_default_pad+0x128>)
   1d564:	e7db      	b.n	1d51e <_sercom_get_default_pad+0x4e>
   1d566:	4b25      	ldr	r3, [pc, #148]	; (1d5fc <_sercom_get_default_pad+0x12c>)
   1d568:	e7d9      	b.n	1d51e <_sercom_get_default_pad+0x4e>
	return 0;
   1d56a:	2300      	movs	r3, #0
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
   1d56c:	2903      	cmp	r1, #3
   1d56e:	d8d6      	bhi.n	1d51e <_sercom_get_default_pad+0x4e>
   1d570:	f008 f99a 	bl	258a8 <__gnu_thumb1_case_uqi>
   1d574:	0604021d 	.word	0x0604021d
   1d578:	4b21      	ldr	r3, [pc, #132]	; (1d600 <_sercom_get_default_pad+0x130>)
   1d57a:	e7d0      	b.n	1d51e <_sercom_get_default_pad+0x4e>
   1d57c:	4b21      	ldr	r3, [pc, #132]	; (1d604 <_sercom_get_default_pad+0x134>)
   1d57e:	e7ce      	b.n	1d51e <_sercom_get_default_pad+0x4e>
   1d580:	4b21      	ldr	r3, [pc, #132]	; (1d608 <_sercom_get_default_pad+0x138>)
   1d582:	e7cc      	b.n	1d51e <_sercom_get_default_pad+0x4e>
	return 0;
   1d584:	2300      	movs	r3, #0
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
   1d586:	2903      	cmp	r1, #3
   1d588:	d8c9      	bhi.n	1d51e <_sercom_get_default_pad+0x4e>
   1d58a:	f008 f98d 	bl	258a8 <__gnu_thumb1_case_uqi>
   1d58e:	0212      	.short	0x0212
   1d590:	0604      	.short	0x0604
   1d592:	4b1e      	ldr	r3, [pc, #120]	; (1d60c <_sercom_get_default_pad+0x13c>)
   1d594:	e7c3      	b.n	1d51e <_sercom_get_default_pad+0x4e>
   1d596:	4b1e      	ldr	r3, [pc, #120]	; (1d610 <_sercom_get_default_pad+0x140>)
   1d598:	e7c1      	b.n	1d51e <_sercom_get_default_pad+0x4e>
   1d59a:	4b1e      	ldr	r3, [pc, #120]	; (1d614 <_sercom_get_default_pad+0x144>)
   1d59c:	e7bf      	b.n	1d51e <_sercom_get_default_pad+0x4e>
   1d59e:	4b1e      	ldr	r3, [pc, #120]	; (1d618 <_sercom_get_default_pad+0x148>)
   1d5a0:	e7bd      	b.n	1d51e <_sercom_get_default_pad+0x4e>
   1d5a2:	2303      	movs	r3, #3
   1d5a4:	e7bb      	b.n	1d51e <_sercom_get_default_pad+0x4e>
   1d5a6:	4b1d      	ldr	r3, [pc, #116]	; (1d61c <_sercom_get_default_pad+0x14c>)
   1d5a8:	e7b9      	b.n	1d51e <_sercom_get_default_pad+0x4e>
   1d5aa:	4b1d      	ldr	r3, [pc, #116]	; (1d620 <_sercom_get_default_pad+0x150>)
   1d5ac:	e7b7      	b.n	1d51e <_sercom_get_default_pad+0x4e>
   1d5ae:	4b1d      	ldr	r3, [pc, #116]	; (1d624 <_sercom_get_default_pad+0x154>)
   1d5b0:	e7b5      	b.n	1d51e <_sercom_get_default_pad+0x4e>
   1d5b2:	4b1d      	ldr	r3, [pc, #116]	; (1d628 <_sercom_get_default_pad+0x158>)
   1d5b4:	e7b3      	b.n	1d51e <_sercom_get_default_pad+0x4e>
   1d5b6:	46c0      	nop			; (mov r8, r8)
   1d5b8:	42001000 	.word	0x42001000
   1d5bc:	42000800 	.word	0x42000800
   1d5c0:	42000c00 	.word	0x42000c00
   1d5c4:	42001800 	.word	0x42001800
   1d5c8:	42001c00 	.word	0x42001c00
   1d5cc:	42001400 	.word	0x42001400
   1d5d0:	00050003 	.word	0x00050003
   1d5d4:	00060003 	.word	0x00060003
   1d5d8:	00070003 	.word	0x00070003
   1d5dc:	00010003 	.word	0x00010003
   1d5e0:	001e0003 	.word	0x001e0003
   1d5e4:	001f0003 	.word	0x001f0003
   1d5e8:	00090003 	.word	0x00090003
   1d5ec:	000a0003 	.word	0x000a0003
   1d5f0:	000b0003 	.word	0x000b0003
   1d5f4:	00110003 	.word	0x00110003
   1d5f8:	00120003 	.word	0x00120003
   1d5fc:	00130003 	.word	0x00130003
   1d600:	000d0003 	.word	0x000d0003
   1d604:	000e0003 	.word	0x000e0003
   1d608:	000f0003 	.word	0x000f0003
   1d60c:	00170003 	.word	0x00170003
   1d610:	00180003 	.word	0x00180003
   1d614:	00190003 	.word	0x00190003
   1d618:	00040003 	.word	0x00040003
   1d61c:	00080003 	.word	0x00080003
   1d620:	00100003 	.word	0x00100003
   1d624:	000c0003 	.word	0x000c0003
   1d628:	00160003 	.word	0x00160003

0001d62c <_sercom_get_sercom_inst_index>:
 *
 * \return Index of given instance.
 */
uint8_t _sercom_get_sercom_inst_index(
		Sercom *const sercom_instance)
{
   1d62c:	b570      	push	{r4, r5, r6, lr}
   1d62e:	b086      	sub	sp, #24
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;
   1d630:	4669      	mov	r1, sp
   1d632:	4b09      	ldr	r3, [pc, #36]	; (1d658 <_sercom_get_sercom_inst_index+0x2c>)
   1d634:	466a      	mov	r2, sp
   1d636:	cb70      	ldmia	r3!, {r4, r5, r6}
   1d638:	c170      	stmia	r1!, {r4, r5, r6}
   1d63a:	cb70      	ldmia	r3!, {r4, r5, r6}
   1d63c:	c170      	stmia	r1!, {r4, r5, r6}

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
   1d63e:	2300      	movs	r3, #0
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
   1d640:	0099      	lsls	r1, r3, #2
   1d642:	5851      	ldr	r1, [r2, r1]
   1d644:	4281      	cmp	r1, r0
   1d646:	d102      	bne.n	1d64e <_sercom_get_sercom_inst_index+0x22>
			return i;
   1d648:	b2d8      	uxtb	r0, r3
	}

	/* Invalid data given */
	Assert(false);
	return 0;
}
   1d64a:	b006      	add	sp, #24
   1d64c:	bd70      	pop	{r4, r5, r6, pc}
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
   1d64e:	3301      	adds	r3, #1
   1d650:	2b06      	cmp	r3, #6
   1d652:	d1f5      	bne.n	1d640 <_sercom_get_sercom_inst_index+0x14>
	return 0;
   1d654:	2000      	movs	r0, #0
   1d656:	e7f8      	b.n	1d64a <_sercom_get_sercom_inst_index+0x1e>
   1d658:	0002ac8c 	.word	0x0002ac8c

0001d65c <_sercom_default_handler>:
 */
static void _sercom_default_handler(
		const uint8_t instance)
{
	Assert(false);
}
   1d65c:	4770      	bx	lr
	...

0001d660 <_sercom_set_handler>:
 * \param[in]  interrupt_handler  Pointer to instance callback handler.
 */
void _sercom_set_handler(
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
   1d660:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
   1d662:	4c09      	ldr	r4, [pc, #36]	; (1d688 <_sercom_set_handler+0x28>)
   1d664:	4a09      	ldr	r2, [pc, #36]	; (1d68c <_sercom_set_handler+0x2c>)
   1d666:	7823      	ldrb	r3, [r4, #0]
   1d668:	2b00      	cmp	r3, #0
   1d66a:	d109      	bne.n	1d680 <_sercom_set_handler+0x20>
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
			_sercom_instances[i] = NULL;
   1d66c:	001e      	movs	r6, r3
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
   1d66e:	4f08      	ldr	r7, [pc, #32]	; (1d690 <_sercom_set_handler+0x30>)
			_sercom_instances[i] = NULL;
   1d670:	4d08      	ldr	r5, [pc, #32]	; (1d694 <_sercom_set_handler+0x34>)
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
   1d672:	50d7      	str	r7, [r2, r3]
			_sercom_instances[i] = NULL;
   1d674:	50ee      	str	r6, [r5, r3]
   1d676:	3304      	adds	r3, #4
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
   1d678:	2b18      	cmp	r3, #24
   1d67a:	d1fa      	bne.n	1d672 <_sercom_set_handler+0x12>
		}

		_handler_table_initialized = true;
   1d67c:	3b17      	subs	r3, #23
   1d67e:	7023      	strb	r3, [r4, #0]
	}

	/* Save interrupt handler */
	_sercom_interrupt_handlers[instance] = interrupt_handler;
   1d680:	0080      	lsls	r0, r0, #2
   1d682:	5011      	str	r1, [r2, r0]
}
   1d684:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1d686:	46c0      	nop			; (mov r8, r8)
   1d688:	20003d97 	.word	0x20003d97
   1d68c:	20003d98 	.word	0x20003d98
   1d690:	0001d65d 	.word	0x0001d65d
   1d694:	20005680 	.word	0x20005680

0001d698 <_sercom_get_interrupt_vector>:
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM6
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM7
 */
enum system_interrupt_vector _sercom_get_interrupt_vector(
		Sercom *const sercom_instance)
{
   1d698:	b507      	push	{r0, r1, r2, lr}
	const uint8_t sercom_int_vectors[SERCOM_INST_NUM] =
   1d69a:	2309      	movs	r3, #9
   1d69c:	466a      	mov	r2, sp
   1d69e:	7013      	strb	r3, [r2, #0]
   1d6a0:	3301      	adds	r3, #1
   1d6a2:	7053      	strb	r3, [r2, #1]
   1d6a4:	3301      	adds	r3, #1
   1d6a6:	7093      	strb	r3, [r2, #2]
   1d6a8:	3301      	adds	r3, #1
   1d6aa:	70d3      	strb	r3, [r2, #3]
   1d6ac:	3301      	adds	r3, #1
   1d6ae:	7113      	strb	r3, [r2, #4]
   1d6b0:	3301      	adds	r3, #1
   1d6b2:	7153      	strb	r3, [r2, #5]
		{
			MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_VECT_NUM, ~)
		};

	/* Retrieve the index of the SERCOM being requested */
	uint8_t instance_index = _sercom_get_sercom_inst_index(sercom_instance);
   1d6b4:	4b02      	ldr	r3, [pc, #8]	; (1d6c0 <_sercom_get_interrupt_vector+0x28>)
   1d6b6:	4798      	blx	r3

	/* Get the vector number from the lookup table for the requested SERCOM */
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
   1d6b8:	466b      	mov	r3, sp
   1d6ba:	5618      	ldrsb	r0, [r3, r0]
}
   1d6bc:	bd0e      	pop	{r1, r2, r3, pc}
   1d6be:	46c0      	nop			; (mov r8, r8)
   1d6c0:	0001d62d 	.word	0x0001d62d

0001d6c4 <SERCOM0_Handler>:

/** Auto-generate a set of interrupt handlers for each SERCOM in the device */
MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_HANDLER, ~)
   1d6c4:	b510      	push	{r4, lr}
   1d6c6:	4b02      	ldr	r3, [pc, #8]	; (1d6d0 <SERCOM0_Handler+0xc>)
   1d6c8:	2000      	movs	r0, #0
   1d6ca:	681b      	ldr	r3, [r3, #0]
   1d6cc:	4798      	blx	r3
   1d6ce:	bd10      	pop	{r4, pc}
   1d6d0:	20003d98 	.word	0x20003d98

0001d6d4 <SERCOM1_Handler>:
   1d6d4:	b510      	push	{r4, lr}
   1d6d6:	4b02      	ldr	r3, [pc, #8]	; (1d6e0 <SERCOM1_Handler+0xc>)
   1d6d8:	2001      	movs	r0, #1
   1d6da:	685b      	ldr	r3, [r3, #4]
   1d6dc:	4798      	blx	r3
   1d6de:	bd10      	pop	{r4, pc}
   1d6e0:	20003d98 	.word	0x20003d98

0001d6e4 <SERCOM2_Handler>:
   1d6e4:	b510      	push	{r4, lr}
   1d6e6:	4b02      	ldr	r3, [pc, #8]	; (1d6f0 <SERCOM2_Handler+0xc>)
   1d6e8:	2002      	movs	r0, #2
   1d6ea:	689b      	ldr	r3, [r3, #8]
   1d6ec:	4798      	blx	r3
   1d6ee:	bd10      	pop	{r4, pc}
   1d6f0:	20003d98 	.word	0x20003d98

0001d6f4 <SERCOM3_Handler>:
   1d6f4:	b510      	push	{r4, lr}
   1d6f6:	4b02      	ldr	r3, [pc, #8]	; (1d700 <SERCOM3_Handler+0xc>)
   1d6f8:	2003      	movs	r0, #3
   1d6fa:	68db      	ldr	r3, [r3, #12]
   1d6fc:	4798      	blx	r3
   1d6fe:	bd10      	pop	{r4, pc}
   1d700:	20003d98 	.word	0x20003d98

0001d704 <SERCOM4_Handler>:
   1d704:	b510      	push	{r4, lr}
   1d706:	4b02      	ldr	r3, [pc, #8]	; (1d710 <SERCOM4_Handler+0xc>)
   1d708:	2004      	movs	r0, #4
   1d70a:	691b      	ldr	r3, [r3, #16]
   1d70c:	4798      	blx	r3
   1d70e:	bd10      	pop	{r4, pc}
   1d710:	20003d98 	.word	0x20003d98

0001d714 <SERCOM5_Handler>:
   1d714:	b510      	push	{r4, lr}
   1d716:	4b02      	ldr	r3, [pc, #8]	; (1d720 <SERCOM5_Handler+0xc>)
   1d718:	2005      	movs	r0, #5
   1d71a:	695b      	ldr	r3, [r3, #20]
   1d71c:	4798      	blx	r3
   1d71e:	bd10      	pop	{r4, pc}
   1d720:	20003d98 	.word	0x20003d98

0001d724 <port_pin_set_output_level>:
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
   1d724:	2200      	movs	r2, #0
{
   1d726:	b510      	push	{r4, lr}
	uint8_t group_index = (gpio_pin / 32);
   1d728:	0943      	lsrs	r3, r0, #5
	if (port_index < PORT_INST_NUM) {
   1d72a:	09c4      	lsrs	r4, r0, #7
   1d72c:	4294      	cmp	r4, r2
   1d72e:	d102      	bne.n	1d736 <port_pin_set_output_level+0x12>
		return &(ports[port_index]->Group[group_index]);
   1d730:	01da      	lsls	r2, r3, #7
   1d732:	4b06      	ldr	r3, [pc, #24]	; (1d74c <port_pin_set_output_level+0x28>)
   1d734:	18d2      	adds	r2, r2, r3
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
   1d736:	231f      	movs	r3, #31
   1d738:	4018      	ands	r0, r3
   1d73a:	3b1e      	subs	r3, #30
   1d73c:	4083      	lsls	r3, r0
	if (level) {
   1d73e:	2900      	cmp	r1, #0
   1d740:	d001      	beq.n	1d746 <port_pin_set_output_level+0x22>
		port_base->OUTSET.reg = pin_mask;
   1d742:	6193      	str	r3, [r2, #24]
	}
}
   1d744:	bd10      	pop	{r4, pc}
		port_base->OUTCLR.reg = pin_mask;
   1d746:	6153      	str	r3, [r2, #20]
}
   1d748:	e7fc      	b.n	1d744 <port_pin_set_output_level+0x20>
   1d74a:	46c0      	nop			; (mov r8, r8)
   1d74c:	41004400 	.word	0x41004400

0001d750 <spi_disable>:
{
   1d750:	b570      	push	{r4, r5, r6, lr}
	SercomSpi *const spi_module = &(module->hw->SPI);
   1d752:	6804      	ldr	r4, [r0, #0]
{
   1d754:	0005      	movs	r5, r0
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
   1d756:	4b0a      	ldr	r3, [pc, #40]	; (1d780 <spi_disable+0x30>)
   1d758:	0020      	movs	r0, r4
   1d75a:	4798      	blx	r3
   1d75c:	231f      	movs	r3, #31
   1d75e:	4018      	ands	r0, r3
   1d760:	3b1e      	subs	r3, #30
   1d762:	4083      	lsls	r3, r0
   1d764:	4a07      	ldr	r2, [pc, #28]	; (1d784 <spi_disable+0x34>)
   1d766:	67d3      	str	r3, [r2, #124]	; 0x7c
	SercomSpi *const spi_module = &(module->hw->SPI);
   1d768:	682a      	ldr	r2, [r5, #0]
	return (spi_module->SYNCBUSY.reg);
   1d76a:	69d3      	ldr	r3, [r2, #28]
	while (spi_is_syncing(module)) {
   1d76c:	2b00      	cmp	r3, #0
   1d76e:	d1fc      	bne.n	1d76a <spi_disable+0x1a>
	spi_module->CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
   1d770:	2202      	movs	r2, #2
	spi_module->INTENCLR.reg = SERCOM_SPI_INTENCLR_MASK;
   1d772:	338f      	adds	r3, #143	; 0x8f
   1d774:	7523      	strb	r3, [r4, #20]
	spi_module->INTFLAG.reg = SERCOM_SPI_INTFLAG_MASK;
   1d776:	7623      	strb	r3, [r4, #24]
	spi_module->CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
   1d778:	6823      	ldr	r3, [r4, #0]
   1d77a:	4393      	bics	r3, r2
   1d77c:	6023      	str	r3, [r4, #0]
}
   1d77e:	bd70      	pop	{r4, r5, r6, pc}
   1d780:	0001d699 	.word	0x0001d699
   1d784:	e000e104 	.word	0xe000e104

0001d788 <spi_write>:
	SercomSpi *const spi_module = &(module->hw->SPI);
   1d788:	6803      	ldr	r3, [r0, #0]
		return STATUS_BUSY;
   1d78a:	2005      	movs	r0, #5
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
   1d78c:	7e1a      	ldrb	r2, [r3, #24]
	if (!spi_is_ready_to_write(module)) {
   1d78e:	07d2      	lsls	r2, r2, #31
   1d790:	d503      	bpl.n	1d79a <spi_write+0x12>
	return STATUS_OK;
   1d792:	2000      	movs	r0, #0
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
   1d794:	05c9      	lsls	r1, r1, #23
   1d796:	0dc9      	lsrs	r1, r1, #23
   1d798:	6299      	str	r1, [r3, #40]	; 0x28
}
   1d79a:	4770      	bx	lr

0001d79c <spi_read>:
{
   1d79c:	b530      	push	{r4, r5, lr}
	if (!spi_is_ready_to_read(module)) {
   1d79e:	2404      	movs	r4, #4
	SercomSpi *const spi_module = &(module->hw->SPI);
   1d7a0:	6803      	ldr	r3, [r0, #0]
		return STATUS_ERR_IO;
   1d7a2:	2210      	movs	r2, #16
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
   1d7a4:	7e1d      	ldrb	r5, [r3, #24]
	if (!spi_is_ready_to_read(module)) {
   1d7a6:	4225      	tst	r5, r4
   1d7a8:	d00c      	beq.n	1d7c4 <spi_read+0x28>
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
   1d7aa:	8b5d      	ldrh	r5, [r3, #26]
	enum status_code retval = STATUS_OK;
   1d7ac:	2200      	movs	r2, #0
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
   1d7ae:	4225      	tst	r5, r4
   1d7b0:	d001      	beq.n	1d7b6 <spi_read+0x1a>
		spi_module->STATUS.reg = SERCOM_SPI_STATUS_BUFOVF;
   1d7b2:	835c      	strh	r4, [r3, #26]
		retval = STATUS_ERR_OVERFLOW;
   1d7b4:	321e      	adds	r2, #30
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
   1d7b6:	7980      	ldrb	r0, [r0, #6]
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
   1d7b8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
   1d7ba:	2801      	cmp	r0, #1
   1d7bc:	d104      	bne.n	1d7c8 <spi_read+0x2c>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
   1d7be:	05db      	lsls	r3, r3, #23
   1d7c0:	0ddb      	lsrs	r3, r3, #23
		*rx_data = (uint8_t)spi_module->DATA.reg;
   1d7c2:	800b      	strh	r3, [r1, #0]
	}

	return retval;
}
   1d7c4:	0010      	movs	r0, r2
   1d7c6:	bd30      	pop	{r4, r5, pc}
		*rx_data = (uint8_t)spi_module->DATA.reg;
   1d7c8:	b2db      	uxtb	r3, r3
   1d7ca:	e7fa      	b.n	1d7c2 <spi_read+0x26>

0001d7cc <spi_set_baudrate>:
 * \retval STATUS_OK               If the configuration was written
 */
enum status_code spi_set_baudrate(
		struct spi_module *const module,
		uint32_t baudrate)
{
   1d7cc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	Assert(module);
	Assert(baudrate);
	Assert(module->hw);

	/* Value to write to BAUD register */
	uint16_t baud = 0;
   1d7ce:	466b      	mov	r3, sp
   1d7d0:	1d9d      	adds	r5, r3, #6
   1d7d2:	2300      	movs	r3, #0
{
   1d7d4:	0004      	movs	r4, r0
	uint16_t baud = 0;
   1d7d6:	802b      	strh	r3, [r5, #0]

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Disable the module */
	spi_disable(module);
   1d7d8:	4b19      	ldr	r3, [pc, #100]	; (1d840 <spi_set_baudrate+0x74>)
	SercomSpi *const spi_module = &(module->hw->SPI);
   1d7da:	6806      	ldr	r6, [r0, #0]
{
   1d7dc:	000f      	movs	r7, r1
	spi_disable(module);
   1d7de:	4798      	blx	r3
	SercomSpi *const spi_module = &(module->hw->SPI);
   1d7e0:	6820      	ldr	r0, [r4, #0]
	return (spi_module->SYNCBUSY.reg);
   1d7e2:	69c3      	ldr	r3, [r0, #28]

	while (spi_is_syncing(module)) {
   1d7e4:	2b00      	cmp	r3, #0
   1d7e6:	d1fc      	bne.n	1d7e2 <spi_set_baudrate+0x16>
		/* Wait until the synchronization is complete */
	}

	/* Find frequency of the internal SERCOMi_GCLK_ID_CORE */
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
   1d7e8:	4b16      	ldr	r3, [pc, #88]	; (1d844 <spi_set_baudrate+0x78>)
   1d7ea:	4798      	blx	r3
	uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
   1d7ec:	3014      	adds	r0, #20
	uint32_t internal_clock = system_gclk_chan_get_hz(gclk_index);
   1d7ee:	4b16      	ldr	r3, [pc, #88]	; (1d848 <spi_set_baudrate+0x7c>)
   1d7f0:	b2c0      	uxtb	r0, r0
   1d7f2:	4798      	blx	r3

	/* Get baud value, based on baudrate and the internal clock frequency */
	enum status_code error_code = _sercom_get_sync_baud_val(
   1d7f4:	002a      	movs	r2, r5
	uint32_t internal_clock = system_gclk_chan_get_hz(gclk_index);
   1d7f6:	0001      	movs	r1, r0
	enum status_code error_code = _sercom_get_sync_baud_val(
   1d7f8:	4b14      	ldr	r3, [pc, #80]	; (1d84c <spi_set_baudrate+0x80>)
   1d7fa:	0038      	movs	r0, r7
   1d7fc:	4798      	blx	r3
   1d7fe:	1e07      	subs	r7, r0, #0
			baudrate, internal_clock, &baud);

	if (error_code != STATUS_OK) {
   1d800:	d11c      	bne.n	1d83c <spi_set_baudrate+0x70>
		/* Baud rate calculation error, return status code */
		return STATUS_ERR_INVALID_ARG;
	}

	spi_module->BAUD.reg = (uint8_t)baud;
   1d802:	782b      	ldrb	r3, [r5, #0]
   1d804:	7333      	strb	r3, [r6, #12]
	SercomSpi *const spi_module = &(module->hw->SPI);
   1d806:	6825      	ldr	r5, [r4, #0]
	return (spi_module->SYNCBUSY.reg);
   1d808:	69eb      	ldr	r3, [r5, #28]

	while (spi_is_syncing(module)) {
   1d80a:	2b00      	cmp	r3, #0
   1d80c:	d1fc      	bne.n	1d808 <spi_set_baudrate+0x3c>
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
   1d80e:	4b10      	ldr	r3, [pc, #64]	; (1d850 <spi_set_baudrate+0x84>)
   1d810:	0028      	movs	r0, r5
   1d812:	4798      	blx	r3
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
   1d814:	231f      	movs	r3, #31
   1d816:	4018      	ands	r0, r3
   1d818:	3b1e      	subs	r3, #30
   1d81a:	4083      	lsls	r3, r0
   1d81c:	4a0d      	ldr	r2, [pc, #52]	; (1d854 <spi_set_baudrate+0x88>)
   1d81e:	6013      	str	r3, [r2, #0]
	SercomSpi *const spi_module = &(module->hw->SPI);
   1d820:	6822      	ldr	r2, [r4, #0]
	return (spi_module->SYNCBUSY.reg);
   1d822:	69d3      	ldr	r3, [r2, #28]
	while (spi_is_syncing(module)) {
   1d824:	2b00      	cmp	r3, #0
   1d826:	d1fc      	bne.n	1d822 <spi_set_baudrate+0x56>
	spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
   1d828:	682a      	ldr	r2, [r5, #0]
   1d82a:	3302      	adds	r3, #2
   1d82c:	4313      	orrs	r3, r2
   1d82e:	602b      	str	r3, [r5, #0]
	SercomSpi *const spi_module = &(module->hw->SPI);
   1d830:	6822      	ldr	r2, [r4, #0]
	return (spi_module->SYNCBUSY.reg);
   1d832:	69d3      	ldr	r3, [r2, #28]
	}

	/* Enable the module */
	spi_enable(module);

	while (spi_is_syncing(module)) {
   1d834:	2b00      	cmp	r3, #0
   1d836:	d1fc      	bne.n	1d832 <spi_set_baudrate+0x66>
		/* Wait until the synchronization is complete */
	}

	return STATUS_OK;
}
   1d838:	0038      	movs	r0, r7
   1d83a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		return STATUS_ERR_INVALID_ARG;
   1d83c:	2717      	movs	r7, #23
   1d83e:	e7fb      	b.n	1d838 <spi_set_baudrate+0x6c>
   1d840:	0001d751 	.word	0x0001d751
   1d844:	0001d62d 	.word	0x0001d62d
   1d848:	0001e855 	.word	0x0001e855
   1d84c:	0001d3cd 	.word	0x0001d3cd
   1d850:	0001d699 	.word	0x0001d699
   1d854:	e000e100 	.word	0xe000e100

0001d858 <spi_init>:
 */
enum status_code spi_init(
		struct spi_module *const module,
		Sercom *const hw,
		const struct spi_config *const config)
{
   1d858:	b5f0      	push	{r4, r5, r6, r7, lr}
   1d85a:	0005      	movs	r5, r0
	Assert(module);
	Assert(hw);
	Assert(config);

	/* Initialize device instance */
	module->hw = hw;
   1d85c:	6029      	str	r1, [r5, #0]
{
   1d85e:	0014      	movs	r4, r2

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if module is enabled. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_ENABLE) {
   1d860:	680a      	ldr	r2, [r1, #0]
{
   1d862:	b089      	sub	sp, #36	; 0x24
   1d864:	000f      	movs	r7, r1
#  if SPI_CALLBACK_MODE == false
		/* Check if config is valid */
		return _spi_check_config(module, config);
#  else
		return STATUS_ERR_DENIED;
   1d866:	231c      	movs	r3, #28
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_ENABLE) {
   1d868:	0792      	lsls	r2, r2, #30
   1d86a:	d500      	bpl.n	1d86e <spi_init+0x16>
   1d86c:	e0ba      	b.n	1d9e4 <spi_init+0x18c>
#  endif
	}

	/* Check if reset is in progress. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
   1d86e:	2601      	movs	r6, #1
   1d870:	680b      	ldr	r3, [r1, #0]
   1d872:	4033      	ands	r3, r6
   1d874:	9301      	str	r3, [sp, #4]
   1d876:	9a01      	ldr	r2, [sp, #4]
		return STATUS_BUSY;
   1d878:	2305      	movs	r3, #5
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
   1d87a:	2a00      	cmp	r2, #0
   1d87c:	d000      	beq.n	1d880 <spi_init+0x28>
   1d87e:	e0b1      	b.n	1d9e4 <spi_init+0x18c>
	}

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
   1d880:	0008      	movs	r0, r1
   1d882:	4b5a      	ldr	r3, [pc, #360]	; (1d9ec <spi_init+0x194>)
   1d884:	4798      	blx	r3
	}
#elif (SAMC20) || (SAML22)
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
   1d886:	1c81      	adds	r1, r0, #2
#  endif
	} else {
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
	}
#else
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
   1d888:	408e      	lsls	r6, r1
			PM->APBCMASK.reg |= mask;
   1d88a:	4b59      	ldr	r3, [pc, #356]	; (1d9f0 <spi_init+0x198>)
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
   1d88c:	3014      	adds	r0, #20
   1d88e:	6a1a      	ldr	r2, [r3, #32]
   1d890:	4316      	orrs	r6, r2
   1d892:	621e      	str	r6, [r3, #32]
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
   1d894:	1d63      	adds	r3, r4, #5
   1d896:	7fdb      	ldrb	r3, [r3, #31]
   1d898:	aa02      	add	r2, sp, #8
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
   1d89a:	b2c6      	uxtb	r6, r0
	gclk_chan_conf.source_generator = config->generator_source;
   1d89c:	7013      	strb	r3, [r2, #0]
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
   1d89e:	0011      	movs	r1, r2
   1d8a0:	0030      	movs	r0, r6
   1d8a2:	4b54      	ldr	r3, [pc, #336]	; (1d9f4 <spi_init+0x19c>)
   1d8a4:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
   1d8a6:	0030      	movs	r0, r6
   1d8a8:	4b53      	ldr	r3, [pc, #332]	; (1d9f8 <spi_init+0x1a0>)
   1d8aa:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
   1d8ac:	1d63      	adds	r3, r4, #5
   1d8ae:	7fd8      	ldrb	r0, [r3, #31]
   1d8b0:	9901      	ldr	r1, [sp, #4]
   1d8b2:	4b52      	ldr	r3, [pc, #328]	; (1d9fc <spi_init+0x1a4>)
   1d8b4:	4798      	blx	r3

#  if CONF_SPI_MASTER_ENABLE == true
	if (config->mode == SPI_MODE_MASTER) {
   1d8b6:	7823      	ldrb	r3, [r4, #0]
   1d8b8:	2b01      	cmp	r3, #1
   1d8ba:	d103      	bne.n	1d8c4 <spi_init+0x6c>
		/* Set the SERCOM in SPI master mode */
		spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_MODE(0x3);
   1d8bc:	683a      	ldr	r2, [r7, #0]
   1d8be:	330b      	adds	r3, #11
   1d8c0:	4313      	orrs	r3, r2
   1d8c2:	603b      	str	r3, [r7, #0]
   1d8c4:	002b      	movs	r3, r5
   1d8c6:	002a      	movs	r2, r5
	uint8_t i;
	uint8_t instance_index;

	/* Initialize parameters */
	for (i = 0; i < SPI_CALLBACK_N; i++) {
		module->callback[i]        = NULL;
   1d8c8:	2600      	movs	r6, #0
   1d8ca:	330c      	adds	r3, #12
   1d8cc:	3228      	adds	r2, #40	; 0x28
   1d8ce:	c340      	stmia	r3!, {r6}
	for (i = 0; i < SPI_CALLBACK_N; i++) {
   1d8d0:	4293      	cmp	r3, r2
   1d8d2:	d1fc      	bne.n	1d8ce <spi_init+0x76>
	}
	module->tx_buffer_ptr              = NULL;
	module->rx_buffer_ptr              = NULL;
	module->remaining_tx_buffer_length = 0x0000;
	module->remaining_rx_buffer_length = 0x0000;
	module->registered_callback        = 0x00;
   1d8d4:	002b      	movs	r3, r5
   1d8d6:	3336      	adds	r3, #54	; 0x36
	module->remaining_tx_buffer_length = 0x0000;
   1d8d8:	86ae      	strh	r6, [r5, #52]	; 0x34
	module->tx_buffer_ptr              = NULL;
   1d8da:	62ee      	str	r6, [r5, #44]	; 0x2c
	module->remaining_rx_buffer_length = 0x0000;
   1d8dc:	862e      	strh	r6, [r5, #48]	; 0x30
	module->rx_buffer_ptr              = NULL;
   1d8de:	62ae      	str	r6, [r5, #40]	; 0x28
	module->registered_callback        = 0x00;
   1d8e0:	701e      	strb	r6, [r3, #0]
	module->enabled_callback           = 0x00;
   1d8e2:	705e      	strb	r6, [r3, #1]
	module->status                     = STATUS_OK;
   1d8e4:	709e      	strb	r6, [r3, #2]
	module->dir                        = SPI_DIRECTION_IDLE;
   1d8e6:	2303      	movs	r3, #3
	module->locked                     = false;
	/*
	 * Set interrupt handler and register SPI software module struct in
	 * look-up table
	 */
	instance_index = _sercom_get_sercom_inst_index(module->hw);
   1d8e8:	6828      	ldr	r0, [r5, #0]
	module->dir                        = SPI_DIRECTION_IDLE;
   1d8ea:	726b      	strb	r3, [r5, #9]
	instance_index = _sercom_get_sercom_inst_index(module->hw);
   1d8ec:	4b3f      	ldr	r3, [pc, #252]	; (1d9ec <spi_init+0x194>)
	module->locked                     = false;
   1d8ee:	712e      	strb	r6, [r5, #4]
	instance_index = _sercom_get_sercom_inst_index(module->hw);
   1d8f0:	4798      	blx	r3
   1d8f2:	0007      	movs	r7, r0
	_sercom_set_handler(instance_index, _spi_interrupt_handler);
   1d8f4:	4b42      	ldr	r3, [pc, #264]	; (1da00 <spi_init+0x1a8>)
   1d8f6:	4943      	ldr	r1, [pc, #268]	; (1da04 <spi_init+0x1ac>)
   1d8f8:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
   1d8fa:	4b43      	ldr	r3, [pc, #268]	; (1da08 <spi_init+0x1b0>)
   1d8fc:	00bf      	lsls	r7, r7, #2
   1d8fe:	50fd      	str	r5, [r7, r3]
	config->mux_position = SYSTEM_PINMUX_GPIO;
   1d900:	2380      	movs	r3, #128	; 0x80
   1d902:	aa02      	add	r2, sp, #8
   1d904:	7113      	strb	r3, [r2, #4]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
   1d906:	2301      	movs	r3, #1
   1d908:	7193      	strb	r3, [r2, #6]
	if(config->mode == SPI_MODE_SLAVE) {
   1d90a:	7823      	ldrb	r3, [r4, #0]
	SercomSpi *const spi_module = &(module->hw->SPI);
   1d90c:	682f      	ldr	r7, [r5, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
   1d90e:	7156      	strb	r6, [r2, #5]
	config->powersave    = false;
   1d910:	71d6      	strb	r6, [r2, #7]
	if(config->mode == SPI_MODE_SLAVE) {
   1d912:	2b00      	cmp	r3, #0
   1d914:	d100      	bne.n	1d918 <spi_init+0xc0>
		pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
   1d916:	7196      	strb	r6, [r2, #6]
	uint32_t pad_pinmuxes[] = {
   1d918:	2600      	movs	r6, #0
   1d91a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1d91c:	9304      	str	r3, [sp, #16]
   1d91e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   1d920:	9305      	str	r3, [sp, #20]
   1d922:	6b23      	ldr	r3, [r4, #48]	; 0x30
   1d924:	9306      	str	r3, [sp, #24]
   1d926:	6b63      	ldr	r3, [r4, #52]	; 0x34
   1d928:	9307      	str	r3, [sp, #28]
		uint32_t current_pinmux = pad_pinmuxes[pad];
   1d92a:	00b3      	lsls	r3, r6, #2
   1d92c:	aa04      	add	r2, sp, #16
   1d92e:	5898      	ldr	r0, [r3, r2]
   1d930:	b2f1      	uxtb	r1, r6
		if (current_pinmux == PINMUX_DEFAULT) {
   1d932:	2800      	cmp	r0, #0
   1d934:	d102      	bne.n	1d93c <spi_init+0xe4>
			current_pinmux = _sercom_get_default_pad(hw, pad);
   1d936:	0038      	movs	r0, r7
   1d938:	4b34      	ldr	r3, [pc, #208]	; (1da0c <spi_init+0x1b4>)
   1d93a:	4798      	blx	r3
		if (current_pinmux != PINMUX_UNUSED) {
   1d93c:	1c43      	adds	r3, r0, #1
   1d93e:	d006      	beq.n	1d94e <spi_init+0xf6>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
   1d940:	ab02      	add	r3, sp, #8
   1d942:	7118      	strb	r0, [r3, #4]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
   1d944:	0c00      	lsrs	r0, r0, #16
   1d946:	b2c0      	uxtb	r0, r0
   1d948:	a903      	add	r1, sp, #12
   1d94a:	4b31      	ldr	r3, [pc, #196]	; (1da10 <spi_init+0x1b8>)
   1d94c:	4798      	blx	r3
   1d94e:	3601      	adds	r6, #1
	for (uint8_t pad = 0; pad < 4; pad++) {
   1d950:	2e04      	cmp	r6, #4
   1d952:	d1ea      	bne.n	1d92a <spi_init+0xd2>
	module->mode             = config->mode;
   1d954:	7823      	ldrb	r3, [r4, #0]
   1d956:	716b      	strb	r3, [r5, #5]
	module->character_size   = config->character_size;
   1d958:	7c23      	ldrb	r3, [r4, #16]
   1d95a:	71ab      	strb	r3, [r5, #6]
	module->receiver_enabled = config->receiver_enable;
   1d95c:	7ca3      	ldrb	r3, [r4, #18]
   1d95e:	71eb      	strb	r3, [r5, #7]
	module->master_slave_select_enable = config->master_slave_select_enable;
   1d960:	7d23      	ldrb	r3, [r4, #20]
   1d962:	722b      	strb	r3, [r5, #8]
	uint16_t baud = 0;
   1d964:	ab02      	add	r3, sp, #8
   1d966:	1c9e      	adds	r6, r3, #2
   1d968:	2300      	movs	r3, #0
   1d96a:	8033      	strh	r3, [r6, #0]
	if (config->mode == SPI_MODE_MASTER) {
   1d96c:	7823      	ldrb	r3, [r4, #0]
   1d96e:	2b01      	cmp	r3, #1
   1d970:	d110      	bne.n	1d994 <spi_init+0x13c>
		uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
   1d972:	4b1e      	ldr	r3, [pc, #120]	; (1d9ec <spi_init+0x194>)
   1d974:	6828      	ldr	r0, [r5, #0]
   1d976:	4798      	blx	r3
		uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
   1d978:	3014      	adds	r0, #20
		uint32_t internal_clock = system_gclk_chan_get_hz(gclk_index);
   1d97a:	4b26      	ldr	r3, [pc, #152]	; (1da14 <spi_init+0x1bc>)
   1d97c:	b2c0      	uxtb	r0, r0
   1d97e:	4798      	blx	r3
		enum status_code error_code = _sercom_get_sync_baud_val(
   1d980:	4b25      	ldr	r3, [pc, #148]	; (1da18 <spi_init+0x1c0>)
		uint32_t internal_clock = system_gclk_chan_get_hz(gclk_index);
   1d982:	0001      	movs	r1, r0
		enum status_code error_code = _sercom_get_sync_baud_val(
   1d984:	0032      	movs	r2, r6
   1d986:	69a0      	ldr	r0, [r4, #24]
   1d988:	4798      	blx	r3
			return STATUS_ERR_INVALID_ARG;
   1d98a:	2317      	movs	r3, #23
		if (error_code != STATUS_OK) {
   1d98c:	2800      	cmp	r0, #0
   1d98e:	d129      	bne.n	1d9e4 <spi_init+0x18c>
		spi_module->BAUD.reg = (uint8_t)baud;
   1d990:	7833      	ldrb	r3, [r6, #0]
   1d992:	733b      	strb	r3, [r7, #12]
	ctrla |= config->transfer_mode;
   1d994:	68a3      	ldr	r3, [r4, #8]
   1d996:	6862      	ldr	r2, [r4, #4]
	if (config->run_in_standby || system_is_debugger_present()) {
   1d998:	7c61      	ldrb	r1, [r4, #17]
	ctrla |= config->transfer_mode;
   1d99a:	431a      	orrs	r2, r3
	ctrla |= config->mux_setting;
   1d99c:	68e3      	ldr	r3, [r4, #12]
   1d99e:	431a      	orrs	r2, r3
	ctrlb |= config->character_size;
   1d9a0:	7c23      	ldrb	r3, [r4, #16]
	if (config->run_in_standby || system_is_debugger_present()) {
   1d9a2:	2900      	cmp	r1, #0
   1d9a4:	d103      	bne.n	1d9ae <spi_init+0x156>
   1d9a6:	491d      	ldr	r1, [pc, #116]	; (1da1c <spi_init+0x1c4>)
   1d9a8:	7889      	ldrb	r1, [r1, #2]
   1d9aa:	0789      	lsls	r1, r1, #30
   1d9ac:	d501      	bpl.n	1d9b2 <spi_init+0x15a>
		ctrla |= SERCOM_SPI_CTRLA_RUNSTDBY;
   1d9ae:	2180      	movs	r1, #128	; 0x80
   1d9b0:	430a      	orrs	r2, r1
	if (config->receiver_enable) {
   1d9b2:	7ca1      	ldrb	r1, [r4, #18]
   1d9b4:	2900      	cmp	r1, #0
   1d9b6:	d002      	beq.n	1d9be <spi_init+0x166>
		ctrlb |= SERCOM_SPI_CTRLB_RXEN;
   1d9b8:	2180      	movs	r1, #128	; 0x80
   1d9ba:	0289      	lsls	r1, r1, #10
   1d9bc:	430b      	orrs	r3, r1
	if (config->select_slave_low_detect_enable) {
   1d9be:	7ce1      	ldrb	r1, [r4, #19]
   1d9c0:	2900      	cmp	r1, #0
   1d9c2:	d002      	beq.n	1d9ca <spi_init+0x172>
		ctrlb |= SERCOM_SPI_CTRLB_SSDE;
   1d9c4:	2180      	movs	r1, #128	; 0x80
   1d9c6:	0089      	lsls	r1, r1, #2
   1d9c8:	430b      	orrs	r3, r1
	if (config->master_slave_select_enable) {
   1d9ca:	7d21      	ldrb	r1, [r4, #20]
   1d9cc:	2900      	cmp	r1, #0
   1d9ce:	d002      	beq.n	1d9d6 <spi_init+0x17e>
		ctrlb |= SERCOM_SPI_CTRLB_MSSEN;
   1d9d0:	2180      	movs	r1, #128	; 0x80
   1d9d2:	0189      	lsls	r1, r1, #6
   1d9d4:	430b      	orrs	r3, r1
	spi_module->CTRLA.reg |= ctrla;
   1d9d6:	6839      	ldr	r1, [r7, #0]
   1d9d8:	430a      	orrs	r2, r1
   1d9da:	603a      	str	r2, [r7, #0]
	spi_module->CTRLB.reg |= ctrlb;
   1d9dc:	687a      	ldr	r2, [r7, #4]
   1d9de:	4313      	orrs	r3, r2
   1d9e0:	607b      	str	r3, [r7, #4]
	return STATUS_OK;
   1d9e2:	2300      	movs	r3, #0
#endif

	/* Write configuration to module and return status code */
	return _spi_set_config(module, config);
}
   1d9e4:	0018      	movs	r0, r3
   1d9e6:	b009      	add	sp, #36	; 0x24
   1d9e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1d9ea:	46c0      	nop			; (mov r8, r8)
   1d9ec:	0001d62d 	.word	0x0001d62d
   1d9f0:	40000400 	.word	0x40000400
   1d9f4:	0001e839 	.word	0x0001e839
   1d9f8:	0001e7b1 	.word	0x0001e7b1
   1d9fc:	0001d48d 	.word	0x0001d48d
   1da00:	0001d661 	.word	0x0001d661
   1da04:	0001dbb9 	.word	0x0001dbb9
   1da08:	20005680 	.word	0x20005680
   1da0c:	0001d4d1 	.word	0x0001d4d1
   1da10:	0001e93d 	.word	0x0001e93d
   1da14:	0001e855 	.word	0x0001e855
   1da18:	0001d3cd 	.word	0x0001d3cd
   1da1c:	41002000 	.word	0x41002000

0001da20 <spi_read_buffer_wait>:
enum status_code spi_read_buffer_wait(
		struct spi_module *const module,
		uint8_t *rx_data,
		uint16_t length,
		uint16_t dummy)
{
   1da20:	b5f0      	push	{r4, r5, r6, r7, lr}
   1da22:	b085      	sub	sp, #20
   1da24:	9301      	str	r3, [sp, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

#  if SPI_CALLBACK_MODE == true
	if (module->status == STATUS_BUSY) {
   1da26:	0003      	movs	r3, r0
{
   1da28:	0004      	movs	r4, r0
		/* Check if the SPI module is busy with a job */
		return STATUS_BUSY;
   1da2a:	2005      	movs	r0, #5
{
   1da2c:	9100      	str	r1, [sp, #0]
	if (module->status == STATUS_BUSY) {
   1da2e:	3338      	adds	r3, #56	; 0x38
   1da30:	781b      	ldrb	r3, [r3, #0]
{
   1da32:	0016      	movs	r6, r2
	if (module->status == STATUS_BUSY) {
   1da34:	4283      	cmp	r3, r0
   1da36:	d033      	beq.n	1daa0 <spi_read_buffer_wait+0x80>
	}
#  endif

	/* Sanity check arguments */
	if (length == 0) {
		return STATUS_ERR_INVALID_ARG;
   1da38:	3012      	adds	r0, #18
	if (length == 0) {
   1da3a:	2a00      	cmp	r2, #0
   1da3c:	d030      	beq.n	1daa0 <spi_read_buffer_wait+0x80>
	}

	if (!(module->receiver_enabled)) {
   1da3e:	79e3      	ldrb	r3, [r4, #7]
		return STATUS_ERR_DENIED;
   1da40:	3005      	adds	r0, #5
	if (!(module->receiver_enabled)) {
   1da42:	2b00      	cmp	r3, #0
   1da44:	d02c      	beq.n	1daa0 <spi_read_buffer_wait+0x80>
   1da46:	2500      	movs	r5, #0
#  endif
	uint16_t rx_pos = 0;

	while (length--) {
#  if CONF_SPI_MASTER_ENABLE == true
		if (module->mode == SPI_MODE_MASTER) {
   1da48:	7963      	ldrb	r3, [r4, #5]
   1da4a:	2b01      	cmp	r3, #1
   1da4c:	d108      	bne.n	1da60 <spi_read_buffer_wait+0x40>
	SercomSpi *const spi_module = &(module->hw->SPI);
   1da4e:	6822      	ldr	r2, [r4, #0]
			/* Wait until the module is ready to write a character */
			while (!spi_is_ready_to_write(module)) {
   1da50:	2101      	movs	r1, #1
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
   1da52:	7e13      	ldrb	r3, [r2, #24]
   1da54:	420b      	tst	r3, r1
   1da56:	d0fb      	beq.n	1da50 <spi_read_buffer_wait+0x30>
			}

			/* Send dummy SPI character to read in master mode */
			spi_write(module, dummy);
   1da58:	9901      	ldr	r1, [sp, #4]
   1da5a:	0020      	movs	r0, r4
   1da5c:	4b12      	ldr	r3, [pc, #72]	; (1daa8 <spi_read_buffer_wait+0x88>)
   1da5e:	4798      	blx	r3
	SercomSpi *const spi_module = &(module->hw->SPI);
   1da60:	6822      	ldr	r2, [r4, #0]
			}
		}
#  endif

		/* Wait until the module is ready to read a character */
		while (!spi_is_ready_to_read(module)) {
   1da62:	2104      	movs	r1, #4
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
   1da64:	7e13      	ldrb	r3, [r2, #24]
   1da66:	420b      	tst	r3, r1
   1da68:	d0fb      	beq.n	1da62 <spi_read_buffer_wait+0x42>
		}

		uint16_t received_data = 0;
   1da6a:	ab02      	add	r3, sp, #8
   1da6c:	1d9f      	adds	r7, r3, #6
   1da6e:	2300      	movs	r3, #0
		enum status_code retval = spi_read(module, &received_data);
   1da70:	0039      	movs	r1, r7
		uint16_t received_data = 0;
   1da72:	803b      	strh	r3, [r7, #0]
		enum status_code retval = spi_read(module, &received_data);
   1da74:	0020      	movs	r0, r4
   1da76:	4b0d      	ldr	r3, [pc, #52]	; (1daac <spi_read_buffer_wait+0x8c>)
   1da78:	4798      	blx	r3

		if (retval != STATUS_OK) {
   1da7a:	2800      	cmp	r0, #0
   1da7c:	d110      	bne.n	1daa0 <spi_read_buffer_wait+0x80>
			/* Overflow, abort */
			return retval;
		}

		/* Read value will be at least 8-bits long */
		rx_data[rx_pos++] = received_data;
   1da7e:	9900      	ldr	r1, [sp, #0]
   1da80:	883a      	ldrh	r2, [r7, #0]
   1da82:	1c6b      	adds	r3, r5, #1
   1da84:	554a      	strb	r2, [r1, r5]

		/* If 9-bit data, write next received byte to the buffer */
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
   1da86:	79a1      	ldrb	r1, [r4, #6]
		rx_data[rx_pos++] = received_data;
   1da88:	b29b      	uxth	r3, r3
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
   1da8a:	2901      	cmp	r1, #1
   1da8c:	d10a      	bne.n	1daa4 <spi_read_buffer_wait+0x84>
			rx_data[rx_pos++] = (received_data >> 8);
   1da8e:	9900      	ldr	r1, [sp, #0]
   1da90:	3502      	adds	r5, #2
   1da92:	0a12      	lsrs	r2, r2, #8
   1da94:	b2ad      	uxth	r5, r5
   1da96:	54ca      	strb	r2, [r1, r3]
   1da98:	3e01      	subs	r6, #1
   1da9a:	b2b6      	uxth	r6, r6
	while (length--) {
   1da9c:	2e00      	cmp	r6, #0
   1da9e:	d1d3      	bne.n	1da48 <spi_read_buffer_wait+0x28>
		}
	}

	return STATUS_OK;
}
   1daa0:	b005      	add	sp, #20
   1daa2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		rx_data[rx_pos++] = received_data;
   1daa4:	001d      	movs	r5, r3
   1daa6:	e7f7      	b.n	1da98 <spi_read_buffer_wait+0x78>
   1daa8:	0001d789 	.word	0x0001d789
   1daac:	0001d79d 	.word	0x0001d79d

0001dab0 <spi_select_slave>:
 */
enum status_code spi_select_slave(
		struct spi_module *const module,
		struct spi_slave_inst *const slave,
		const bool select)
{
   1dab0:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1dab2:	000e      	movs	r6, r1
	Assert(module);
	Assert(module->hw);
	Assert(slave);

	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
   1dab4:	7941      	ldrb	r1, [r0, #5]
{
   1dab6:	0005      	movs	r5, r0
   1dab8:	0014      	movs	r4, r2
		return STATUS_ERR_UNSUPPORTED_DEV;
   1daba:	2015      	movs	r0, #21
	if (module->mode != SPI_MODE_MASTER) {
   1dabc:	2901      	cmp	r1, #1
   1dabe:	d103      	bne.n	1dac8 <spi_select_slave+0x18>
	}
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if(!(module->master_slave_select_enable))
   1dac0:	7a2a      	ldrb	r2, [r5, #8]
   1dac2:	2a00      	cmp	r2, #0
   1dac4:	d001      	beq.n	1daca <spi_select_slave+0x1a>
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
   1dac6:	2000      	movs	r0, #0
}
   1dac8:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
   1daca:	7830      	ldrb	r0, [r6, #0]
   1dacc:	4b14      	ldr	r3, [pc, #80]	; (1db20 <spi_select_slave+0x70>)
		if (select) {
   1dace:	2c00      	cmp	r4, #0
   1dad0:	d022      	beq.n	1db18 <spi_select_slave+0x68>
			if (slave->address_enabled) {
   1dad2:	7874      	ldrb	r4, [r6, #1]
   1dad4:	2c00      	cmp	r4, #0
   1dad6:	d01c      	beq.n	1db12 <spi_select_slave+0x62>
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
   1dad8:	682c      	ldr	r4, [r5, #0]
   1dada:	7e24      	ldrb	r4, [r4, #24]
				if (!spi_is_ready_to_write(module)) {
   1dadc:	420c      	tst	r4, r1
   1dade:	d102      	bne.n	1dae6 <spi_select_slave+0x36>
					port_pin_set_output_level(slave->ss_pin, true);
   1dae0:	4798      	blx	r3
					return STATUS_BUSY;
   1dae2:	2005      	movs	r0, #5
   1dae4:	e7f0      	b.n	1dac8 <spi_select_slave+0x18>
				port_pin_set_output_level(slave->ss_pin, false);
   1dae6:	0011      	movs	r1, r2
   1dae8:	4798      	blx	r3
				spi_write(module, slave->address);
   1daea:	4b0e      	ldr	r3, [pc, #56]	; (1db24 <spi_select_slave+0x74>)
   1daec:	78b1      	ldrb	r1, [r6, #2]
   1daee:	0028      	movs	r0, r5
   1daf0:	4798      	blx	r3
				if (!(module->receiver_enabled)) {
   1daf2:	79eb      	ldrb	r3, [r5, #7]
   1daf4:	2b00      	cmp	r3, #0
   1daf6:	d1e6      	bne.n	1dac6 <spi_select_slave+0x16>
	SercomSpi *const spi_module = &(module->hw->SPI);
   1daf8:	6829      	ldr	r1, [r5, #0]
					while (!spi_is_ready_to_read(module)) {
   1dafa:	3304      	adds	r3, #4
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
   1dafc:	7e0a      	ldrb	r2, [r1, #24]
   1dafe:	421a      	tst	r2, r3
   1db00:	d0fc      	beq.n	1dafc <spi_select_slave+0x4c>
					uint16_t flush = 0;
   1db02:	466b      	mov	r3, sp
   1db04:	2400      	movs	r4, #0
   1db06:	1d99      	adds	r1, r3, #6
					spi_read(module, &flush);
   1db08:	0028      	movs	r0, r5
   1db0a:	4b07      	ldr	r3, [pc, #28]	; (1db28 <spi_select_slave+0x78>)
					uint16_t flush = 0;
   1db0c:	800c      	strh	r4, [r1, #0]
					spi_read(module, &flush);
   1db0e:	4798      	blx	r3
   1db10:	e7d9      	b.n	1dac6 <spi_select_slave+0x16>
				port_pin_set_output_level(slave->ss_pin, false);
   1db12:	0021      	movs	r1, r4
   1db14:	4798      	blx	r3
   1db16:	e7d6      	b.n	1dac6 <spi_select_slave+0x16>
			port_pin_set_output_level(slave->ss_pin, true);
   1db18:	4798      	blx	r3
	return STATUS_OK;
   1db1a:	0020      	movs	r0, r4
   1db1c:	e7d4      	b.n	1dac8 <spi_select_slave+0x18>
   1db1e:	46c0      	nop			; (mov r8, r8)
   1db20:	0001d725 	.word	0x0001d725
   1db24:	0001d789 	.word	0x0001d789
   1db28:	0001d79d 	.word	0x0001d79d

0001db2c <spi_write_buffer_wait>:
{
	/* Sanity check arguments */
	Assert(module);

#  if SPI_CALLBACK_MODE == true
	if (module->status == STATUS_BUSY) {
   1db2c:	0003      	movs	r3, r0
{
   1db2e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1db30:	0004      	movs	r4, r0
		/* Check if the SPI module is busy with a job */
		return STATUS_BUSY;
   1db32:	2005      	movs	r0, #5
	if (module->status == STATUS_BUSY) {
   1db34:	3338      	adds	r3, #56	; 0x38
   1db36:	781b      	ldrb	r3, [r3, #0]
{
   1db38:	000f      	movs	r7, r1
   1db3a:	0015      	movs	r5, r2
	if (module->status == STATUS_BUSY) {
   1db3c:	4283      	cmp	r3, r0
   1db3e:	d003      	beq.n	1db48 <spi_write_buffer_wait+0x1c>
	}
#  endif

	if (length == 0) {
		return STATUS_ERR_INVALID_ARG;
   1db40:	3012      	adds	r0, #18
   1db42:	2600      	movs	r6, #0
	if (length == 0) {
   1db44:	2a00      	cmp	r2, #0
   1db46:	d120      	bne.n	1db8a <spi_write_buffer_wait+0x5e>
			}
		}
	}
#  endif
	return STATUS_OK;
}
   1db48:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		while (!spi_is_ready_to_write(module)) {
   1db4a:	2101      	movs	r1, #1
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
   1db4c:	7e1a      	ldrb	r2, [r3, #24]
   1db4e:	420a      	tst	r2, r1
   1db50:	d0fb      	beq.n	1db4a <spi_write_buffer_wait+0x1e>
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
   1db52:	79a2      	ldrb	r2, [r4, #6]
		uint16_t data_to_send = tx_data[tx_pos++];
   1db54:	1873      	adds	r3, r6, r1
   1db56:	b29b      	uxth	r3, r3
   1db58:	5db9      	ldrb	r1, [r7, r6]
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
   1db5a:	2a01      	cmp	r2, #1
   1db5c:	d017      	beq.n	1db8e <spi_write_buffer_wait+0x62>
		uint16_t data_to_send = tx_data[tx_pos++];
   1db5e:	001e      	movs	r6, r3
   1db60:	b289      	uxth	r1, r1
		spi_write(module, data_to_send);
   1db62:	4b13      	ldr	r3, [pc, #76]	; (1dbb0 <spi_write_buffer_wait+0x84>)
   1db64:	0020      	movs	r0, r4
   1db66:	4798      	blx	r3
		if (module->receiver_enabled) {
   1db68:	79e3      	ldrb	r3, [r4, #7]
   1db6a:	2b00      	cmp	r3, #0
   1db6c:	d009      	beq.n	1db82 <spi_write_buffer_wait+0x56>
	SercomSpi *const spi_module = &(module->hw->SPI);
   1db6e:	6822      	ldr	r2, [r4, #0]
			while (!spi_is_ready_to_read(module)) {
   1db70:	2104      	movs	r1, #4
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
   1db72:	7e13      	ldrb	r3, [r2, #24]
   1db74:	420b      	tst	r3, r1
   1db76:	d0fb      	beq.n	1db70 <spi_write_buffer_wait+0x44>
			spi_read(module, &flush);
   1db78:	466b      	mov	r3, sp
   1db7a:	0020      	movs	r0, r4
   1db7c:	1d99      	adds	r1, r3, #6
   1db7e:	4b0d      	ldr	r3, [pc, #52]	; (1dbb4 <spi_write_buffer_wait+0x88>)
   1db80:	4798      	blx	r3
   1db82:	3d01      	subs	r5, #1
   1db84:	b2ad      	uxth	r5, r5
	while (length--) {
   1db86:	2d00      	cmp	r5, #0
   1db88:	d007      	beq.n	1db9a <spi_write_buffer_wait+0x6e>
	SercomSpi *const spi_module = &(module->hw->SPI);
   1db8a:	6823      	ldr	r3, [r4, #0]
   1db8c:	e7dd      	b.n	1db4a <spi_write_buffer_wait+0x1e>
			data_to_send |= (tx_data[tx_pos++] << 8);
   1db8e:	5cfb      	ldrb	r3, [r7, r3]
   1db90:	3602      	adds	r6, #2
   1db92:	021b      	lsls	r3, r3, #8
   1db94:	b2b6      	uxth	r6, r6
   1db96:	4319      	orrs	r1, r3
   1db98:	e7e3      	b.n	1db62 <spi_write_buffer_wait+0x36>
	if (module->mode == SPI_MODE_MASTER) {
   1db9a:	7963      	ldrb	r3, [r4, #5]
	return STATUS_OK;
   1db9c:	0028      	movs	r0, r5
	if (module->mode == SPI_MODE_MASTER) {
   1db9e:	2b01      	cmp	r3, #1
   1dba0:	d1d2      	bne.n	1db48 <spi_write_buffer_wait+0x1c>
	SercomSpi *const spi_module = &(module->hw->SPI);
   1dba2:	6821      	ldr	r1, [r4, #0]
		while (!spi_is_write_complete(module)) {
   1dba4:	3301      	adds	r3, #1
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
   1dba6:	7e0a      	ldrb	r2, [r1, #24]
   1dba8:	421a      	tst	r2, r3
   1dbaa:	d0fc      	beq.n	1dba6 <spi_write_buffer_wait+0x7a>
	return STATUS_OK;
   1dbac:	2000      	movs	r0, #0
   1dbae:	e7cb      	b.n	1db48 <spi_write_buffer_wait+0x1c>
   1dbb0:	0001d789 	.word	0x0001d789
   1dbb4:	0001d79d 	.word	0x0001d79d

0001dbb8 <_spi_interrupt_handler>:
 * \param[in]  instance  ID of the SERCOM instance calling the interrupt
 *                       handler.
 */
void _spi_interrupt_handler(
		uint8_t instance)
{
   1dbb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Get device instance from the look-up table */
	struct spi_module *module
   1dbba:	4b68      	ldr	r3, [pc, #416]	; (1dd5c <_spi_interrupt_handler+0x1a4>)
   1dbbc:	0080      	lsls	r0, r0, #2
   1dbbe:	58c4      	ldr	r4, [r0, r3]
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);

	/* Combine callback registered and enabled masks. */
	uint8_t callback_mask =
			module->enabled_callback & module->registered_callback;
   1dbc0:	0023      	movs	r3, r4
   1dbc2:	0022      	movs	r2, r4
   1dbc4:	3337      	adds	r3, #55	; 0x37
   1dbc6:	3236      	adds	r2, #54	; 0x36
	SercomSpi *const spi_hw = &(module->hw->SPI);
   1dbc8:	6825      	ldr	r5, [r4, #0]
	uint8_t callback_mask =
   1dbca:	781b      	ldrb	r3, [r3, #0]
   1dbcc:	7816      	ldrb	r6, [r2, #0]
   1dbce:	401e      	ands	r6, r3

	/* Read and mask interrupt flag register */
	uint16_t interrupt_status = spi_hw->INTFLAG.reg;
   1dbd0:	7e2b      	ldrb	r3, [r5, #24]
	interrupt_status &= spi_hw->INTENSET.reg;
   1dbd2:	7daf      	ldrb	r7, [r5, #22]
   1dbd4:	401f      	ands	r7, r3

	/* Data register empty interrupt */
	if (interrupt_status & SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY) {
   1dbd6:	07fb      	lsls	r3, r7, #31
   1dbd8:	d534      	bpl.n	1dc44 <_spi_interrupt_handler+0x8c>
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
   1dbda:	7962      	ldrb	r2, [r4, #5]
   1dbdc:	2a01      	cmp	r2, #1
   1dbde:	d131      	bne.n	1dc44 <_spi_interrupt_handler+0x8c>
			(module->dir == SPI_DIRECTION_READ)) {
   1dbe0:	7a63      	ldrb	r3, [r4, #9]
		if ((module->mode == SPI_MODE_MASTER) &&
   1dbe2:	2b00      	cmp	r3, #0
   1dbe4:	d10d      	bne.n	1dc02 <_spi_interrupt_handler+0x4a>
	spi_hw->DATA.reg = dummy_write;
   1dbe6:	4b5e      	ldr	r3, [pc, #376]	; (1dd60 <_spi_interrupt_handler+0x1a8>)
   1dbe8:	881b      	ldrh	r3, [r3, #0]
   1dbea:	62ab      	str	r3, [r5, #40]	; 0x28
	module->remaining_dummy_buffer_length--;
   1dbec:	8e63      	ldrh	r3, [r4, #50]	; 0x32
   1dbee:	3b01      	subs	r3, #1
   1dbf0:	b29b      	uxth	r3, r3
   1dbf2:	8663      	strh	r3, [r4, #50]	; 0x32
			/* Send dummy byte when reading in master mode */
			_spi_write_dummy(module);
			if (module->remaining_dummy_buffer_length == 0) {
   1dbf4:	8e63      	ldrh	r3, [r4, #50]	; 0x32
   1dbf6:	2b00      	cmp	r3, #0
   1dbf8:	d100      	bne.n	1dbfc <_spi_interrupt_handler+0x44>
				/* Disable the Data Register Empty Interrupt */
				spi_hw->INTENCLR.reg
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
   1dbfa:	752a      	strb	r2, [r5, #20]
			}
		}
#  endif

		if (0
   1dbfc:	7963      	ldrb	r3, [r4, #5]
   1dbfe:	2b01      	cmp	r3, #1
   1dc00:	d120      	bne.n	1dc44 <_spi_interrupt_handler+0x8c>
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
			(module->dir != SPI_DIRECTION_READ))
   1dc02:	7a63      	ldrb	r3, [r4, #9]
		|| ((module->mode == SPI_MODE_MASTER) &&
   1dc04:	2b00      	cmp	r3, #0
   1dc06:	d01d      	beq.n	1dc44 <_spi_interrupt_handler+0x8c>
	uint16_t data_to_send = *(module->tx_buffer_ptr);
   1dc08:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
	SercomSpi *const spi_hw = &(module->hw->SPI);
   1dc0a:	6822      	ldr	r2, [r4, #0]
	(module->tx_buffer_ptr)++;
   1dc0c:	1c48      	adds	r0, r1, #1
	uint16_t data_to_send = *(module->tx_buffer_ptr);
   1dc0e:	780b      	ldrb	r3, [r1, #0]
	(module->tx_buffer_ptr)++;
   1dc10:	62e0      	str	r0, [r4, #44]	; 0x2c
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
   1dc12:	79a0      	ldrb	r0, [r4, #6]
	uint16_t data_to_send = *(module->tx_buffer_ptr);
   1dc14:	b2db      	uxtb	r3, r3
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
   1dc16:	2801      	cmp	r0, #1
   1dc18:	d051      	beq.n	1dcbe <_spi_interrupt_handler+0x106>
	uint16_t data_to_send = *(module->tx_buffer_ptr);
   1dc1a:	b29b      	uxth	r3, r3
	spi_hw->DATA.reg = data_to_send & SERCOM_SPI_DATA_MASK;
   1dc1c:	05db      	lsls	r3, r3, #23
   1dc1e:	0ddb      	lsrs	r3, r3, #23
   1dc20:	6293      	str	r3, [r2, #40]	; 0x28
	(module->remaining_tx_buffer_length)--;
   1dc22:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
   1dc24:	3b01      	subs	r3, #1
   1dc26:	b29b      	uxth	r3, r3
   1dc28:	86a3      	strh	r3, [r4, #52]	; 0x34
			(module->dir != SPI_DIRECTION_READ))
#  endif
		) {
			/* Write next byte from buffer */
			_spi_write(module);
			if (module->remaining_tx_buffer_length == 0) {
   1dc2a:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
   1dc2c:	2b00      	cmp	r3, #0
   1dc2e:	d109      	bne.n	1dc44 <_spi_interrupt_handler+0x8c>
				/* Disable the Data Register Empty Interrupt */
				spi_hw->INTENCLR.reg
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
   1dc30:	3301      	adds	r3, #1
   1dc32:	752b      	strb	r3, [r5, #20]

				if (module->dir == SPI_DIRECTION_WRITE &&
   1dc34:	7a63      	ldrb	r3, [r4, #9]
   1dc36:	2b01      	cmp	r3, #1
   1dc38:	d104      	bne.n	1dc44 <_spi_interrupt_handler+0x8c>
   1dc3a:	79e3      	ldrb	r3, [r4, #7]
   1dc3c:	2b00      	cmp	r3, #0
   1dc3e:	d101      	bne.n	1dc44 <_spi_interrupt_handler+0x8c>
						!(module->receiver_enabled)) {
					/* Enable the Data Register transmit complete Interrupt */
					spi_hw->INTENSET.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
   1dc40:	3302      	adds	r3, #2
   1dc42:	75ab      	strb	r3, [r5, #22]
			}
		}
	}

	/* Receive complete interrupt*/
	if (interrupt_status & SPI_INTERRUPT_FLAG_RX_COMPLETE) {
   1dc44:	2104      	movs	r1, #4
   1dc46:	420f      	tst	r7, r1
   1dc48:	d015      	beq.n	1dc76 <_spi_interrupt_handler+0xbe>
		/* Check for overflow */
		if (spi_hw->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
   1dc4a:	8b6b      	ldrh	r3, [r5, #26]
   1dc4c:	420b      	tst	r3, r1
   1dc4e:	d03c      	beq.n	1dcca <_spi_interrupt_handler+0x112>
			if (module->dir != SPI_DIRECTION_WRITE) {
   1dc50:	7a63      	ldrb	r3, [r4, #9]
   1dc52:	2b01      	cmp	r3, #1
   1dc54:	d00c      	beq.n	1dc70 <_spi_interrupt_handler+0xb8>
				/* Store the error code */
				module->status = STATUS_ERR_OVERFLOW;
   1dc56:	0023      	movs	r3, r4
   1dc58:	221e      	movs	r2, #30
   1dc5a:	3338      	adds	r3, #56	; 0x38
   1dc5c:	701a      	strb	r2, [r3, #0]

				/* End transaction */
				module->dir = SPI_DIRECTION_IDLE;
   1dc5e:	2303      	movs	r3, #3
   1dc60:	7263      	strb	r3, [r4, #9]

				spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE |
   1dc62:	3302      	adds	r3, #2
   1dc64:	752b      	strb	r3, [r5, #20]
						SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
				/* Run callback if registered and enabled */
				if (callback_mask & (1 << SPI_CALLBACK_ERROR)) {
   1dc66:	0733      	lsls	r3, r6, #28
   1dc68:	d502      	bpl.n	1dc70 <_spi_interrupt_handler+0xb8>
					(module->callback[SPI_CALLBACK_ERROR])(module);
   1dc6a:	0020      	movs	r0, r4
   1dc6c:	69a3      	ldr	r3, [r4, #24]
   1dc6e:	4798      	blx	r3
				}
			}
			/* Flush */
			uint16_t flush = spi_hw->DATA.reg;
   1dc70:	6aab      	ldr	r3, [r5, #40]	; 0x28
			UNUSED(flush);
			/* Clear overflow flag */
			spi_hw->STATUS.reg = SERCOM_SPI_STATUS_BUFOVF;
   1dc72:	2304      	movs	r3, #4
   1dc74:	836b      	strh	r3, [r5, #26]
			}
		}
	}

	/* Transmit complete */
	if (interrupt_status & SPI_INTERRUPT_FLAG_TX_COMPLETE) {
   1dc76:	2102      	movs	r1, #2
   1dc78:	420f      	tst	r7, r1
   1dc7a:	d014      	beq.n	1dca6 <_spi_interrupt_handler+0xee>
			}

		}
#  endif
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
   1dc7c:	7963      	ldrb	r3, [r4, #5]
   1dc7e:	2b01      	cmp	r3, #1
   1dc80:	d111      	bne.n	1dca6 <_spi_interrupt_handler+0xee>
			(module->dir == SPI_DIRECTION_WRITE) && !(module->receiver_enabled)) {
   1dc82:	7a63      	ldrb	r3, [r4, #9]
   1dc84:	b2db      	uxtb	r3, r3
		if ((module->mode == SPI_MODE_MASTER) &&
   1dc86:	2b01      	cmp	r3, #1
   1dc88:	d10d      	bne.n	1dca6 <_spi_interrupt_handler+0xee>
			(module->dir == SPI_DIRECTION_WRITE) && !(module->receiver_enabled)) {
   1dc8a:	79e2      	ldrb	r2, [r4, #7]
   1dc8c:	2a00      	cmp	r2, #0
   1dc8e:	d10a      	bne.n	1dca6 <_spi_interrupt_handler+0xee>
		  	/* Clear interrupt flag */
		 	spi_hw->INTENCLR.reg
					= SPI_INTERRUPT_FLAG_TX_COMPLETE;
   1dc90:	7529      	strb	r1, [r5, #20]
			/* Buffer sent with receiver disabled */
			module->dir = SPI_DIRECTION_IDLE;
   1dc92:	3101      	adds	r1, #1
   1dc94:	7261      	strb	r1, [r4, #9]
			module->status = STATUS_OK;
   1dc96:	0021      	movs	r1, r4
   1dc98:	3138      	adds	r1, #56	; 0x38
   1dc9a:	700a      	strb	r2, [r1, #0]
			/* Run callback if registered and enabled */
			if (callback_mask & (1 << SPI_CALLBACK_BUFFER_TRANSMITTED)){
   1dc9c:	421e      	tst	r6, r3
   1dc9e:	d002      	beq.n	1dca6 <_spi_interrupt_handler+0xee>
				(module->callback[SPI_CALLBACK_BUFFER_TRANSMITTED])
   1dca0:	0020      	movs	r0, r4
   1dca2:	68e3      	ldr	r3, [r4, #12]
   1dca4:	4798      	blx	r3
#  endif
#  endif

#  ifdef FEATURE_SPI_ERROR_INTERRUPT
	/* When combined error happen */
	if (interrupt_status & SPI_INTERRUPT_FLAG_COMBINED_ERROR) {
   1dca6:	b27f      	sxtb	r7, r7
   1dca8:	2f00      	cmp	r7, #0
   1dcaa:	da07      	bge.n	1dcbc <_spi_interrupt_handler+0x104>
		/* Disable interrupts */
		spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_COMBINED_ERROR;
   1dcac:	2380      	movs	r3, #128	; 0x80
   1dcae:	752b      	strb	r3, [r5, #20]
		/* Clear interrupt flag */
		spi_hw->INTFLAG.reg = SPI_INTERRUPT_FLAG_COMBINED_ERROR;
   1dcb0:	762b      	strb	r3, [r5, #24]

		if (callback_mask & (1 << SPI_CALLBACK_COMBINED_ERROR)) {
   1dcb2:	0673      	lsls	r3, r6, #25
   1dcb4:	d502      	bpl.n	1dcbc <_spi_interrupt_handler+0x104>
			(module->callback[SPI_CALLBACK_COMBINED_ERROR])(module);
   1dcb6:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1dcb8:	0020      	movs	r0, r4
   1dcba:	4798      	blx	r3
		}
	}
#  endif
}
   1dcbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		data_to_send |= ((*(module->tx_buffer_ptr)) << 8);
   1dcbe:	7848      	ldrb	r0, [r1, #1]
		(module->tx_buffer_ptr)++;
   1dcc0:	3102      	adds	r1, #2
		data_to_send |= ((*(module->tx_buffer_ptr)) << 8);
   1dcc2:	0200      	lsls	r0, r0, #8
   1dcc4:	4303      	orrs	r3, r0
		(module->tx_buffer_ptr)++;
   1dcc6:	62e1      	str	r1, [r4, #44]	; 0x2c
   1dcc8:	e7a8      	b.n	1dc1c <_spi_interrupt_handler+0x64>
			if (module->dir == SPI_DIRECTION_WRITE) {
   1dcca:	7a62      	ldrb	r2, [r4, #9]
   1dccc:	6823      	ldr	r3, [r4, #0]
   1dcce:	b2d2      	uxtb	r2, r2
	flush = spi_hw->DATA.reg;
   1dcd0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
			if (module->dir == SPI_DIRECTION_WRITE) {
   1dcd2:	2a01      	cmp	r2, #1
   1dcd4:	d113      	bne.n	1dcfe <_spi_interrupt_handler+0x146>
	module->remaining_dummy_buffer_length--;
   1dcd6:	8e63      	ldrh	r3, [r4, #50]	; 0x32
   1dcd8:	3b01      	subs	r3, #1
   1dcda:	b29b      	uxth	r3, r3
   1dcdc:	8663      	strh	r3, [r4, #50]	; 0x32
				if (module->remaining_dummy_buffer_length == 0) {
   1dcde:	8e63      	ldrh	r3, [r4, #50]	; 0x32
   1dce0:	b29b      	uxth	r3, r3
   1dce2:	2b00      	cmp	r3, #0
   1dce4:	d1c7      	bne.n	1dc76 <_spi_interrupt_handler+0xbe>
					spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE;
   1dce6:	7529      	strb	r1, [r5, #20]
					module->status = STATUS_OK;
   1dce8:	0021      	movs	r1, r4
   1dcea:	3138      	adds	r1, #56	; 0x38
   1dcec:	700b      	strb	r3, [r1, #0]
					module->dir = SPI_DIRECTION_IDLE;
   1dcee:	3303      	adds	r3, #3
   1dcf0:	7263      	strb	r3, [r4, #9]
					if (callback_mask &
   1dcf2:	4216      	tst	r6, r2
   1dcf4:	d0bf      	beq.n	1dc76 <_spi_interrupt_handler+0xbe>
						(module->callback[SPI_CALLBACK_BUFFER_TRANSMITTED])(module);
   1dcf6:	0020      	movs	r0, r4
   1dcf8:	68e3      	ldr	r3, [r4, #12]
							(module->callback[SPI_CALLBACK_BUFFER_RECEIVED])(module);
   1dcfa:	4798      	blx	r3
   1dcfc:	e7bb      	b.n	1dc76 <_spi_interrupt_handler+0xbe>
	uint16_t received_data = (spi_hw->DATA.reg & SERCOM_SPI_DATA_MASK);
   1dcfe:	05db      	lsls	r3, r3, #23
	*(module->rx_buffer_ptr) = received_data;
   1dd00:	6aa1      	ldr	r1, [r4, #40]	; 0x28
	uint16_t received_data = (spi_hw->DATA.reg & SERCOM_SPI_DATA_MASK);
   1dd02:	0ddb      	lsrs	r3, r3, #23
	*(module->rx_buffer_ptr) = received_data;
   1dd04:	b2da      	uxtb	r2, r3
   1dd06:	700a      	strb	r2, [r1, #0]
	module->rx_buffer_ptr += 1;
   1dd08:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   1dd0a:	1c51      	adds	r1, r2, #1
   1dd0c:	62a1      	str	r1, [r4, #40]	; 0x28
	if(module->character_size == SPI_CHARACTER_SIZE_9BIT) {
   1dd0e:	79a1      	ldrb	r1, [r4, #6]
   1dd10:	2901      	cmp	r1, #1
   1dd12:	d104      	bne.n	1dd1e <_spi_interrupt_handler+0x166>
		*(module->rx_buffer_ptr) = (received_data >> 8);
   1dd14:	0a1b      	lsrs	r3, r3, #8
   1dd16:	7053      	strb	r3, [r2, #1]
		module->rx_buffer_ptr += 1;
   1dd18:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1dd1a:	3301      	adds	r3, #1
   1dd1c:	62a3      	str	r3, [r4, #40]	; 0x28
	module->remaining_rx_buffer_length--;
   1dd1e:	8e23      	ldrh	r3, [r4, #48]	; 0x30
   1dd20:	3b01      	subs	r3, #1
   1dd22:	b29b      	uxth	r3, r3
   1dd24:	8623      	strh	r3, [r4, #48]	; 0x30
				if (module->remaining_rx_buffer_length == 0) {
   1dd26:	8e23      	ldrh	r3, [r4, #48]	; 0x30
   1dd28:	b29b      	uxth	r3, r3
   1dd2a:	2b00      	cmp	r3, #0
   1dd2c:	d1a3      	bne.n	1dc76 <_spi_interrupt_handler+0xbe>
					module->status = STATUS_OK;
   1dd2e:	0022      	movs	r2, r4
   1dd30:	3238      	adds	r2, #56	; 0x38
   1dd32:	7013      	strb	r3, [r2, #0]
					spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE;
   1dd34:	3304      	adds	r3, #4
   1dd36:	752b      	strb	r3, [r5, #20]
					if(module->dir == SPI_DIRECTION_BOTH) {
   1dd38:	7a62      	ldrb	r2, [r4, #9]
   1dd3a:	2a02      	cmp	r2, #2
   1dd3c:	d104      	bne.n	1dd48 <_spi_interrupt_handler+0x190>
						if (callback_mask & (1 << SPI_CALLBACK_BUFFER_TRANSCEIVED)) {
   1dd3e:	421e      	tst	r6, r3
   1dd40:	d099      	beq.n	1dc76 <_spi_interrupt_handler+0xbe>
							(module->callback[SPI_CALLBACK_BUFFER_TRANSCEIVED])(module);
   1dd42:	0020      	movs	r0, r4
   1dd44:	6963      	ldr	r3, [r4, #20]
   1dd46:	e7d8      	b.n	1dcfa <_spi_interrupt_handler+0x142>
					} else if (module->dir == SPI_DIRECTION_READ) {
   1dd48:	7a63      	ldrb	r3, [r4, #9]
   1dd4a:	2b00      	cmp	r3, #0
   1dd4c:	d000      	beq.n	1dd50 <_spi_interrupt_handler+0x198>
   1dd4e:	e792      	b.n	1dc76 <_spi_interrupt_handler+0xbe>
						if (callback_mask & (1 << SPI_CALLBACK_BUFFER_RECEIVED)) {
   1dd50:	07b3      	lsls	r3, r6, #30
   1dd52:	d400      	bmi.n	1dd56 <_spi_interrupt_handler+0x19e>
   1dd54:	e78f      	b.n	1dc76 <_spi_interrupt_handler+0xbe>
							(module->callback[SPI_CALLBACK_BUFFER_RECEIVED])(module);
   1dd56:	0020      	movs	r0, r4
   1dd58:	6923      	ldr	r3, [r4, #16]
   1dd5a:	e7ce      	b.n	1dcfa <_spi_interrupt_handler+0x142>
   1dd5c:	20005680 	.word	0x20005680
   1dd60:	20005698 	.word	0x20005698

0001dd64 <_usart_wait_for_sync>:
	SercomUsart *const usart_hw = &(module->hw->USART);
   1dd64:	6802      	ldr	r2, [r0, #0]
	return (usart_hw->SYNCBUSY.reg);
   1dd66:	69d3      	ldr	r3, [r2, #28]
	while (usart_is_syncing(module)) {
   1dd68:	2b00      	cmp	r3, #0
   1dd6a:	d1fc      	bne.n	1dd66 <_usart_wait_for_sync+0x2>
}
   1dd6c:	4770      	bx	lr
	...

0001dd70 <usart_init>:
 */
enum status_code usart_init(
		struct usart_module *const module,
		Sercom *const hw,
		const struct usart_config *const config)
{
   1dd70:	b5f0      	push	{r4, r5, r6, r7, lr}
   1dd72:	0007      	movs	r7, r0
   1dd74:	b093      	sub	sp, #76	; 0x4c
	module->hw = hw;

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
   1dd76:	4ba0      	ldr	r3, [pc, #640]	; (1dff8 <usart_init+0x288>)
	module->hw = hw;
   1dd78:	6039      	str	r1, [r7, #0]
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
   1dd7a:	0008      	movs	r0, r1
{
   1dd7c:	0016      	movs	r6, r2
   1dd7e:	9104      	str	r1, [sp, #16]
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
   1dd80:	4798      	blx	r3
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
   1dd82:	2201      	movs	r2, #1
   1dd84:	9b04      	ldr	r3, [sp, #16]
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
   1dd86:	0005      	movs	r5, r0
	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
   1dd88:	681b      	ldr	r3, [r3, #0]
		/* The module is busy resetting itself */
		return STATUS_BUSY;
   1dd8a:	2005      	movs	r0, #5
	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
   1dd8c:	4213      	tst	r3, r2
   1dd8e:	d000      	beq.n	1dd92 <usart_init+0x22>
   1dd90:	e10f      	b.n	1dfb2 <usart_init+0x242>
	}

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
   1dd92:	9b04      	ldr	r3, [sp, #16]
		/* Check the module is enabled */
		return STATUS_ERR_DENIED;
   1dd94:	3017      	adds	r0, #23
	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
   1dd96:	681c      	ldr	r4, [r3, #0]
   1dd98:	2302      	movs	r3, #2
   1dd9a:	401c      	ands	r4, r3
   1dd9c:	d000      	beq.n	1dda0 <usart_init+0x30>
   1dd9e:	e108      	b.n	1dfb2 <usart_init+0x242>
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
   1dda0:	18eb      	adds	r3, r5, r3
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBD, 1 << pm_index);
	} else {
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);	
	}
#else
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
   1dda2:	381b      	subs	r0, #27
   1dda4:	4098      	lsls	r0, r3
   1dda6:	0003      	movs	r3, r0
   1dda8:	4a94      	ldr	r2, [pc, #592]	; (1dffc <usart_init+0x28c>)
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
   1ddaa:	3514      	adds	r5, #20
   1ddac:	6a11      	ldr	r1, [r2, #32]

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
   1ddae:	b2ed      	uxtb	r5, r5
   1ddb0:	430b      	orrs	r3, r1
   1ddb2:	6213      	str	r3, [r2, #32]
	gclk_chan_conf.source_generator = config->generator_source;
   1ddb4:	0033      	movs	r3, r6
   1ddb6:	332d      	adds	r3, #45	; 0x2d
   1ddb8:	9302      	str	r3, [sp, #8]
   1ddba:	781b      	ldrb	r3, [r3, #0]
   1ddbc:	a90c      	add	r1, sp, #48	; 0x30
   1ddbe:	700b      	strb	r3, [r1, #0]
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
   1ddc0:	0028      	movs	r0, r5
   1ddc2:	4b8f      	ldr	r3, [pc, #572]	; (1e000 <usart_init+0x290>)
   1ddc4:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
   1ddc6:	0028      	movs	r0, r5
   1ddc8:	4b8e      	ldr	r3, [pc, #568]	; (1e004 <usart_init+0x294>)
   1ddca:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
   1ddcc:	9b02      	ldr	r3, [sp, #8]
   1ddce:	0021      	movs	r1, r4
   1ddd0:	7818      	ldrb	r0, [r3, #0]
   1ddd2:	4b8d      	ldr	r3, [pc, #564]	; (1e008 <usart_init+0x298>)
   1ddd4:	4798      	blx	r3

	/* Set character size */
	module->character_size = config->character_size;
   1ddd6:	7af3      	ldrb	r3, [r6, #11]
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
   1ddd8:	2508      	movs	r5, #8
	module->character_size = config->character_size;
   1ddda:	717b      	strb	r3, [r7, #5]

	/* Set transmitter and receiver status */
	module->receiver_enabled = config->receiver_enable;
   1dddc:	1d73      	adds	r3, r6, #5
   1ddde:	7fdb      	ldrb	r3, [r3, #31]
   1dde0:	71bb      	strb	r3, [r7, #6]
	module->transmitter_enabled = config->transmitter_enable;
   1dde2:	1db3      	adds	r3, r6, #6
   1dde4:	7fdb      	ldrb	r3, [r3, #31]
   1dde6:	71fb      	strb	r3, [r7, #7]

#ifdef FEATURE_USART_LIN_SLAVE
	module->lin_slave_enabled = config->lin_slave_enable;
   1dde8:	7ef3      	ldrb	r3, [r6, #27]
   1ddea:	723b      	strb	r3, [r7, #8]
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	module->start_frame_detection_enabled = config->start_frame_detection_enable;
   1ddec:	7f33      	ldrb	r3, [r6, #28]
   1ddee:	727b      	strb	r3, [r7, #9]
	SercomUsart *const usart_hw = &(module->hw->USART);
   1ddf0:	683b      	ldr	r3, [r7, #0]
   1ddf2:	9303      	str	r3, [sp, #12]
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
   1ddf4:	0018      	movs	r0, r3
   1ddf6:	4b80      	ldr	r3, [pc, #512]	; (1dff8 <usart_init+0x288>)
   1ddf8:	4798      	blx	r3
	uint16_t baud  = 0;
   1ddfa:	ab0e      	add	r3, sp, #56	; 0x38
   1ddfc:	801c      	strh	r4, [r3, #0]
	switch (config->sample_rate) {
   1ddfe:	8a33      	ldrh	r3, [r6, #16]
	uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
   1de00:	3014      	adds	r0, #20
	switch (config->sample_rate) {
   1de02:	9302      	str	r3, [sp, #8]
   1de04:	2380      	movs	r3, #128	; 0x80
   1de06:	9a02      	ldr	r2, [sp, #8]
   1de08:	01db      	lsls	r3, r3, #7
   1de0a:	429a      	cmp	r2, r3
   1de0c:	d014      	beq.n	1de38 <usart_init+0xc8>
   1de0e:	d808      	bhi.n	1de22 <usart_init+0xb2>
   1de10:	2380      	movs	r3, #128	; 0x80
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
   1de12:	2510      	movs	r5, #16
	switch (config->sample_rate) {
   1de14:	019b      	lsls	r3, r3, #6
   1de16:	429a      	cmp	r2, r3
   1de18:	d100      	bne.n	1de1c <usart_init+0xac>
   1de1a:	e0cd      	b.n	1dfb8 <usart_init+0x248>
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
   1de1c:	2510      	movs	r5, #16
	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
   1de1e:	2400      	movs	r4, #0
   1de20:	e00a      	b.n	1de38 <usart_init+0xc8>
	switch (config->sample_rate) {
   1de22:	23c0      	movs	r3, #192	; 0xc0
   1de24:	9a02      	ldr	r2, [sp, #8]
   1de26:	01db      	lsls	r3, r3, #7
   1de28:	429a      	cmp	r2, r3
   1de2a:	d100      	bne.n	1de2e <usart_init+0xbe>
   1de2c:	e0c3      	b.n	1dfb6 <usart_init+0x246>
   1de2e:	2380      	movs	r3, #128	; 0x80
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
   1de30:	2503      	movs	r5, #3
	switch (config->sample_rate) {
   1de32:	021b      	lsls	r3, r3, #8
   1de34:	429a      	cmp	r2, r3
   1de36:	d1f1      	bne.n	1de1c <usart_init+0xac>
	ctrla = (uint32_t)config->data_order |
   1de38:	6833      	ldr	r3, [r6, #0]
   1de3a:	9306      	str	r3, [sp, #24]
		(uint32_t)config->mux_setting |
   1de3c:	68f3      	ldr	r3, [r6, #12]
   1de3e:	9307      	str	r3, [sp, #28]
		config->sample_adjustment |
   1de40:	6973      	ldr	r3, [r6, #20]
   1de42:	9308      	str	r3, [sp, #32]
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
   1de44:	7e33      	ldrb	r3, [r6, #24]
   1de46:	9309      	str	r3, [sp, #36]	; 0x24
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
   1de48:	1df3      	adds	r3, r6, #7
   1de4a:	7fdb      	ldrb	r3, [r3, #31]
   1de4c:	930a      	str	r3, [sp, #40]	; 0x28
	transfer_mode = (uint32_t)config->transfer_mode;
   1de4e:	6873      	ldr	r3, [r6, #4]
   1de50:	9305      	str	r3, [sp, #20]
   1de52:	0033      	movs	r3, r6
	switch (transfer_mode)
   1de54:	9a05      	ldr	r2, [sp, #20]
   1de56:	3308      	adds	r3, #8
   1de58:	2a00      	cmp	r2, #0
   1de5a:	d100      	bne.n	1de5e <usart_init+0xee>
   1de5c:	e0ae      	b.n	1dfbc <usart_init+0x24c>
   1de5e:	2280      	movs	r2, #128	; 0x80
   1de60:	9905      	ldr	r1, [sp, #20]
   1de62:	0552      	lsls	r2, r2, #21
   1de64:	4291      	cmp	r1, r2
   1de66:	d10e      	bne.n	1de86 <usart_init+0x116>
			if (!config->use_external_clock) {
   1de68:	7fdb      	ldrb	r3, [r3, #31]
   1de6a:	2b00      	cmp	r3, #0
   1de6c:	d10b      	bne.n	1de86 <usart_init+0x116>
				status_code = _sercom_get_sync_baud_val(config->baudrate,
   1de6e:	4b67      	ldr	r3, [pc, #412]	; (1e00c <usart_init+0x29c>)
   1de70:	b2c0      	uxtb	r0, r0
   1de72:	6a34      	ldr	r4, [r6, #32]
   1de74:	4798      	blx	r3
   1de76:	aa0e      	add	r2, sp, #56	; 0x38
   1de78:	0001      	movs	r1, r0
   1de7a:	4b65      	ldr	r3, [pc, #404]	; (1e010 <usart_init+0x2a0>)
   1de7c:	0020      	movs	r0, r4
   1de7e:	4798      	blx	r3
	if (status_code != STATUS_OK) {
   1de80:	2800      	cmp	r0, #0
   1de82:	d000      	beq.n	1de86 <usart_init+0x116>
   1de84:	e095      	b.n	1dfb2 <usart_init+0x242>
	if(config->encoding_format_enable) {
   1de86:	7e73      	ldrb	r3, [r6, #25]
   1de88:	2b00      	cmp	r3, #0
   1de8a:	d002      	beq.n	1de92 <usart_init+0x122>
		usart_hw->RXPL.reg = config->receive_pulse_length;
   1de8c:	7eb3      	ldrb	r3, [r6, #26]
   1de8e:	9a03      	ldr	r2, [sp, #12]
   1de90:	7393      	strb	r3, [r2, #14]
	_usart_wait_for_sync(module);
   1de92:	4b60      	ldr	r3, [pc, #384]	; (1e014 <usart_init+0x2a4>)
   1de94:	0038      	movs	r0, r7
   1de96:	4798      	blx	r3
	usart_hw->BAUD.reg = baud;
   1de98:	ab0a      	add	r3, sp, #40	; 0x28
   1de9a:	8a1b      	ldrh	r3, [r3, #16]
   1de9c:	9a03      	ldr	r2, [sp, #12]
	ctrla |= transfer_mode;
   1de9e:	9c06      	ldr	r4, [sp, #24]
	usart_hw->BAUD.reg = baud;
   1dea0:	8193      	strh	r3, [r2, #12]
	ctrla |= transfer_mode;
   1dea2:	9b07      	ldr	r3, [sp, #28]
   1dea4:	431c      	orrs	r4, r3
   1dea6:	9b08      	ldr	r3, [sp, #32]
   1dea8:	431c      	orrs	r4, r3
   1deaa:	9b05      	ldr	r3, [sp, #20]
   1deac:	431c      	orrs	r4, r3
   1deae:	9b02      	ldr	r3, [sp, #8]
   1deb0:	431c      	orrs	r4, r3
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
   1deb2:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1deb4:	021b      	lsls	r3, r3, #8
	ctrla |= transfer_mode;
   1deb6:	431c      	orrs	r4, r3
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
   1deb8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1deba:	075b      	lsls	r3, r3, #29
	ctrla |= transfer_mode;
   1debc:	431c      	orrs	r4, r3
	if (config->use_external_clock == false) {
   1debe:	0033      	movs	r3, r6
   1dec0:	3308      	adds	r3, #8
   1dec2:	7fdb      	ldrb	r3, [r3, #31]
   1dec4:	2b00      	cmp	r3, #0
   1dec6:	d101      	bne.n	1decc <usart_init+0x15c>
		ctrla |= SERCOM_USART_CTRLA_MODE(0x1);
   1dec8:	3304      	adds	r3, #4
   1deca:	431c      	orrs	r4, r3
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
   1decc:	7e75      	ldrb	r5, [r6, #25]
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
   1dece:	7f33      	ldrb	r3, [r6, #28]
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
   1ded0:	02ad      	lsls	r5, r5, #10
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
   1ded2:	025b      	lsls	r3, r3, #9
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
   1ded4:	431d      	orrs	r5, r3
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
   1ded6:	7f73      	ldrb	r3, [r6, #29]
	ctrlb |= (uint32_t)config->character_size;
   1ded8:	7af2      	ldrb	r2, [r6, #11]
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
   1deda:	021b      	lsls	r3, r3, #8
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
   1dedc:	431d      	orrs	r5, r3
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
   1dede:	1d73      	adds	r3, r6, #5
   1dee0:	7fdb      	ldrb	r3, [r3, #31]
   1dee2:	045b      	lsls	r3, r3, #17
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
   1dee4:	431d      	orrs	r5, r3
			(config->transmitter_enable << SERCOM_USART_CTRLB_TXEN_Pos);
   1dee6:	1db3      	adds	r3, r6, #6
   1dee8:	7fdb      	ldrb	r3, [r3, #31]
   1deea:	041b      	lsls	r3, r3, #16
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
   1deec:	432b      	orrs	r3, r5
	ctrlb |= (uint32_t)config->character_size;
   1deee:	7ab5      	ldrb	r5, [r6, #10]
   1def0:	4315      	orrs	r5, r2
   1def2:	431d      	orrs	r5, r3
	if (config->parity != USART_PARITY_NONE) {
   1def4:	8933      	ldrh	r3, [r6, #8]
   1def6:	2bff      	cmp	r3, #255	; 0xff
   1def8:	d100      	bne.n	1defc <usart_init+0x18c>
   1defa:	e075      	b.n	1dfe8 <usart_init+0x278>
		ctrla |= SERCOM_USART_CTRLA_FORM(1);
   1defc:	2280      	movs	r2, #128	; 0x80
   1defe:	0452      	lsls	r2, r2, #17
   1df00:	4314      	orrs	r4, r2
		ctrlb |= config->parity;
   1df02:	431d      	orrs	r5, r3
	if (config->run_in_standby || system_is_debugger_present()) {
   1df04:	0033      	movs	r3, r6
   1df06:	332c      	adds	r3, #44	; 0x2c
   1df08:	781b      	ldrb	r3, [r3, #0]
   1df0a:	2b00      	cmp	r3, #0
   1df0c:	d103      	bne.n	1df16 <usart_init+0x1a6>
   1df0e:	4b42      	ldr	r3, [pc, #264]	; (1e018 <usart_init+0x2a8>)
   1df10:	789b      	ldrb	r3, [r3, #2]
   1df12:	079b      	lsls	r3, r3, #30
   1df14:	d501      	bpl.n	1df1a <usart_init+0x1aa>
		ctrla |= SERCOM_USART_CTRLA_RUNSTDBY;
   1df16:	2380      	movs	r3, #128	; 0x80
   1df18:	431c      	orrs	r4, r3
	_usart_wait_for_sync(module);
   1df1a:	0038      	movs	r0, r7
   1df1c:	4b3d      	ldr	r3, [pc, #244]	; (1e014 <usart_init+0x2a4>)
   1df1e:	4798      	blx	r3
	usart_hw->CTRLB.reg = ctrlb;
   1df20:	9b03      	ldr	r3, [sp, #12]
	_usart_wait_for_sync(module);
   1df22:	0038      	movs	r0, r7
	usart_hw->CTRLB.reg = ctrlb;
   1df24:	605d      	str	r5, [r3, #4]
	_usart_wait_for_sync(module);
   1df26:	4b3b      	ldr	r3, [pc, #236]	; (1e014 <usart_init+0x2a4>)
   1df28:	4798      	blx	r3
	usart_hw->CTRLA.reg = ctrla;
   1df2a:	9b03      	ldr	r3, [sp, #12]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
   1df2c:	2500      	movs	r5, #0
   1df2e:	601c      	str	r4, [r3, #0]
	config->mux_position = SYSTEM_PINMUX_GPIO;
   1df30:	2380      	movs	r3, #128	; 0x80
   1df32:	ac0d      	add	r4, sp, #52	; 0x34
   1df34:	7023      	strb	r3, [r4, #0]
	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;

	uint32_t pad_pinmuxes[] = {
   1df36:	6b33      	ldr	r3, [r6, #48]	; 0x30
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
   1df38:	7065      	strb	r5, [r4, #1]
   1df3a:	930e      	str	r3, [sp, #56]	; 0x38
   1df3c:	6b73      	ldr	r3, [r6, #52]	; 0x34
	config->powersave    = false;
   1df3e:	70e5      	strb	r5, [r4, #3]
   1df40:	930f      	str	r3, [sp, #60]	; 0x3c
   1df42:	6bb3      	ldr	r3, [r6, #56]	; 0x38
	pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
   1df44:	70a5      	strb	r5, [r4, #2]
	uint32_t pad_pinmuxes[] = {
   1df46:	9310      	str	r3, [sp, #64]	; 0x40
   1df48:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
   1df4a:	9302      	str	r3, [sp, #8]
   1df4c:	9311      	str	r3, [sp, #68]	; 0x44
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];
   1df4e:	2010      	movs	r0, #16
   1df50:	aa0a      	add	r2, sp, #40	; 0x28
   1df52:	00ab      	lsls	r3, r5, #2
   1df54:	1812      	adds	r2, r2, r0
   1df56:	58d0      	ldr	r0, [r2, r3]
   1df58:	b2e9      	uxtb	r1, r5

		if (current_pinmux == PINMUX_DEFAULT) {
   1df5a:	2800      	cmp	r0, #0
   1df5c:	d102      	bne.n	1df64 <usart_init+0x1f4>
			current_pinmux = _sercom_get_default_pad(hw, pad);
   1df5e:	9804      	ldr	r0, [sp, #16]
   1df60:	4b2e      	ldr	r3, [pc, #184]	; (1e01c <usart_init+0x2ac>)
   1df62:	4798      	blx	r3
		}

		if (current_pinmux != PINMUX_UNUSED) {
   1df64:	1c43      	adds	r3, r0, #1
   1df66:	d005      	beq.n	1df74 <usart_init+0x204>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
   1df68:	7020      	strb	r0, [r4, #0]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
   1df6a:	0c00      	lsrs	r0, r0, #16
   1df6c:	b2c0      	uxtb	r0, r0
   1df6e:	0021      	movs	r1, r4
   1df70:	4b2b      	ldr	r3, [pc, #172]	; (1e020 <usart_init+0x2b0>)
   1df72:	4798      	blx	r3
   1df74:	3501      	adds	r5, #1
	for (uint8_t pad = 0; pad < 4; pad++) {
   1df76:	2d04      	cmp	r5, #4
   1df78:	d1e9      	bne.n	1df4e <usart_init+0x1de>

	module->tx_buffer_ptr              = NULL;
	module->rx_buffer_ptr              = NULL;
	module->remaining_tx_buffer_length = 0x0000;
	module->remaining_rx_buffer_length = 0x0000;
	module->callback_reg_mask          = 0x00;
   1df7a:	003b      	movs	r3, r7
		module->callback[i]            = NULL;
   1df7c:	2400      	movs	r4, #0
	module->callback_reg_mask          = 0x00;
   1df7e:	3330      	adds	r3, #48	; 0x30
	module->remaining_tx_buffer_length = 0x0000;
   1df80:	85fc      	strh	r4, [r7, #46]	; 0x2e
		module->callback[i]            = NULL;
   1df82:	60fc      	str	r4, [r7, #12]
   1df84:	613c      	str	r4, [r7, #16]
   1df86:	617c      	str	r4, [r7, #20]
   1df88:	61bc      	str	r4, [r7, #24]
   1df8a:	61fc      	str	r4, [r7, #28]
   1df8c:	623c      	str	r4, [r7, #32]
	module->tx_buffer_ptr              = NULL;
   1df8e:	62bc      	str	r4, [r7, #40]	; 0x28
	module->rx_buffer_ptr              = NULL;
   1df90:	627c      	str	r4, [r7, #36]	; 0x24
	module->remaining_rx_buffer_length = 0x0000;
   1df92:	85bc      	strh	r4, [r7, #44]	; 0x2c
	module->callback_enable_mask       = 0x00;
	module->rx_status                  = STATUS_OK;
   1df94:	709c      	strb	r4, [r3, #2]
	module->callback_reg_mask          = 0x00;
   1df96:	701c      	strb	r4, [r3, #0]
	module->callback_enable_mask       = 0x00;
   1df98:	705c      	strb	r4, [r3, #1]
	module->tx_status                  = STATUS_OK;
   1df9a:	70dc      	strb	r4, [r3, #3]

	/* Set interrupt handler and register USART software module struct in
	 * look-up table */
	uint8_t instance_index = _sercom_get_sercom_inst_index(module->hw);
   1df9c:	6838      	ldr	r0, [r7, #0]
   1df9e:	4b16      	ldr	r3, [pc, #88]	; (1dff8 <usart_init+0x288>)
   1dfa0:	4798      	blx	r3
   1dfa2:	0005      	movs	r5, r0
	_sercom_set_handler(instance_index, _usart_interrupt_handler);
   1dfa4:	4b1f      	ldr	r3, [pc, #124]	; (1e024 <usart_init+0x2b4>)
   1dfa6:	4920      	ldr	r1, [pc, #128]	; (1e028 <usart_init+0x2b8>)
   1dfa8:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
#endif

	return status_code;
   1dfaa:	0020      	movs	r0, r4
	_sercom_instances[instance_index] = module;
   1dfac:	4b1f      	ldr	r3, [pc, #124]	; (1e02c <usart_init+0x2bc>)
   1dfae:	00ad      	lsls	r5, r5, #2
   1dfb0:	50ef      	str	r7, [r5, r3]
}
   1dfb2:	b013      	add	sp, #76	; 0x4c
   1dfb4:	bdf0      	pop	{r4, r5, r6, r7, pc}
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
   1dfb6:	2508      	movs	r5, #8
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
   1dfb8:	2401      	movs	r4, #1
   1dfba:	e73d      	b.n	1de38 <usart_init+0xc8>
			if (config->use_external_clock) {
   1dfbc:	7fdb      	ldrb	r3, [r3, #31]
   1dfbe:	2b00      	cmp	r3, #0
   1dfc0:	d007      	beq.n	1dfd2 <usart_init+0x262>
				status_code =
   1dfc2:	0023      	movs	r3, r4
   1dfc4:	6ab1      	ldr	r1, [r6, #40]	; 0x28
   1dfc6:	6a30      	ldr	r0, [r6, #32]
   1dfc8:	9500      	str	r5, [sp, #0]
   1dfca:	aa0e      	add	r2, sp, #56	; 0x38
				status_code =
   1dfcc:	4c18      	ldr	r4, [pc, #96]	; (1e030 <usart_init+0x2c0>)
   1dfce:	47a0      	blx	r4
   1dfd0:	e756      	b.n	1de80 <usart_init+0x110>
						_sercom_get_async_baud_val(config->baudrate,
   1dfd2:	6a33      	ldr	r3, [r6, #32]
   1dfd4:	b2c0      	uxtb	r0, r0
   1dfd6:	930b      	str	r3, [sp, #44]	; 0x2c
   1dfd8:	4b0c      	ldr	r3, [pc, #48]	; (1e00c <usart_init+0x29c>)
   1dfda:	4798      	blx	r3
				status_code =
   1dfdc:	9500      	str	r5, [sp, #0]
						_sercom_get_async_baud_val(config->baudrate,
   1dfde:	0001      	movs	r1, r0
				status_code =
   1dfe0:	0023      	movs	r3, r4
   1dfe2:	aa0e      	add	r2, sp, #56	; 0x38
   1dfe4:	980b      	ldr	r0, [sp, #44]	; 0x2c
   1dfe6:	e7f1      	b.n	1dfcc <usart_init+0x25c>
		if(config->lin_slave_enable) {
   1dfe8:	7ef3      	ldrb	r3, [r6, #27]
   1dfea:	2b00      	cmp	r3, #0
   1dfec:	d100      	bne.n	1dff0 <usart_init+0x280>
   1dfee:	e789      	b.n	1df04 <usart_init+0x194>
			ctrla |= SERCOM_USART_CTRLA_FORM(0x4);
   1dff0:	2380      	movs	r3, #128	; 0x80
   1dff2:	04db      	lsls	r3, r3, #19
   1dff4:	431c      	orrs	r4, r3
   1dff6:	e785      	b.n	1df04 <usart_init+0x194>
   1dff8:	0001d62d 	.word	0x0001d62d
   1dffc:	40000400 	.word	0x40000400
   1e000:	0001e839 	.word	0x0001e839
   1e004:	0001e7b1 	.word	0x0001e7b1
   1e008:	0001d48d 	.word	0x0001d48d
   1e00c:	0001e855 	.word	0x0001e855
   1e010:	0001d3cd 	.word	0x0001d3cd
   1e014:	0001dd65 	.word	0x0001dd65
   1e018:	41002000 	.word	0x41002000
   1e01c:	0001d4d1 	.word	0x0001d4d1
   1e020:	0001e93d 	.word	0x0001e93d
   1e024:	0001d661 	.word	0x0001d661
   1e028:	0001e135 	.word	0x0001e135
   1e02c:	20005680 	.word	0x20005680
   1e030:	0001d3f5 	.word	0x0001d3f5

0001e034 <_usart_write_buffer>:
 */
enum status_code _usart_write_buffer(
		struct usart_module *const module,
		uint8_t *tx_data,
		uint16_t length)
{
   1e034:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1e036:	0005      	movs	r5, r0
	Assert(module);
	Assert(module->hw);
	Assert(tx_data);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
   1e038:	6803      	ldr	r3, [r0, #0]
{
   1e03a:	000e      	movs	r6, r1
	SercomUsart *const usart_hw = &(module->hw->USART);
   1e03c:	9301      	str	r3, [sp, #4]
	cpu_irq_enter_critical();
   1e03e:	4b0b      	ldr	r3, [pc, #44]	; (1e06c <_usart_write_buffer+0x38>)
{
   1e040:	0017      	movs	r7, r2
   1e042:	4798      	blx	r3

	system_interrupt_enter_critical_section();

	/* Check if the USART transmitter is busy */
	if (module->remaining_tx_buffer_length > 0) {
   1e044:	8dec      	ldrh	r4, [r5, #46]	; 0x2e
   1e046:	4b0a      	ldr	r3, [pc, #40]	; (1e070 <_usart_write_buffer+0x3c>)
   1e048:	b2a4      	uxth	r4, r4
   1e04a:	2c00      	cmp	r4, #0
   1e04c:	d002      	beq.n	1e054 <_usart_write_buffer+0x20>
	cpu_irq_leave_critical();
   1e04e:	4798      	blx	r3
		system_interrupt_leave_critical_section();
		return STATUS_BUSY;
   1e050:	2005      	movs	r0, #5

	/* Enable the Data Register Empty Interrupt */
	usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_DRE;

	return STATUS_OK;
}
   1e052:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	module->remaining_tx_buffer_length = length;
   1e054:	85ef      	strh	r7, [r5, #46]	; 0x2e
   1e056:	4798      	blx	r3
	module->tx_status                  = STATUS_BUSY;
   1e058:	2305      	movs	r3, #5
	module->tx_buffer_ptr              = tx_data;
   1e05a:	62ae      	str	r6, [r5, #40]	; 0x28
	usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_DRE;
   1e05c:	9a01      	ldr	r2, [sp, #4]
	module->tx_status                  = STATUS_BUSY;
   1e05e:	3533      	adds	r5, #51	; 0x33
   1e060:	702b      	strb	r3, [r5, #0]
	usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_DRE;
   1e062:	3b04      	subs	r3, #4
   1e064:	7593      	strb	r3, [r2, #22]
	return STATUS_OK;
   1e066:	0020      	movs	r0, r4
   1e068:	e7f3      	b.n	1e052 <_usart_write_buffer+0x1e>
   1e06a:	46c0      	nop			; (mov r8, r8)
   1e06c:	0001ce85 	.word	0x0001ce85
   1e070:	0001ceb9 	.word	0x0001ceb9

0001e074 <_usart_read_buffer>:
 */
enum status_code _usart_read_buffer(
		struct usart_module *const module,
		uint8_t *rx_data,
		uint16_t length)
{
   1e074:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1e076:	0004      	movs	r4, r0
	cpu_irq_enter_critical();
   1e078:	4b10      	ldr	r3, [pc, #64]	; (1e0bc <_usart_read_buffer+0x48>)
   1e07a:	0017      	movs	r7, r2
   1e07c:	000e      	movs	r6, r1
	Assert(module);
	Assert(module->hw);
	Assert(rx_data);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
   1e07e:	6805      	ldr	r5, [r0, #0]
   1e080:	4798      	blx	r3

	system_interrupt_enter_critical_section();

	/* Check if the USART receiver is busy */
	if (module->remaining_rx_buffer_length > 0) {
   1e082:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
   1e084:	4b0e      	ldr	r3, [pc, #56]	; (1e0c0 <_usart_read_buffer+0x4c>)
   1e086:	2a00      	cmp	r2, #0
   1e088:	d002      	beq.n	1e090 <_usart_read_buffer+0x1c>
	cpu_irq_leave_critical();
   1e08a:	4798      	blx	r3
		system_interrupt_leave_critical_section();
		return STATUS_BUSY;
   1e08c:	2005      	movs	r0, #5
		usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_RXS;
	}
#endif

	return STATUS_OK;
}
   1e08e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	module->remaining_rx_buffer_length = length;
   1e090:	85a7      	strh	r7, [r4, #44]	; 0x2c
   1e092:	4798      	blx	r3
	module->rx_status                  = STATUS_BUSY;
   1e094:	0023      	movs	r3, r4
   1e096:	2205      	movs	r2, #5
   1e098:	3332      	adds	r3, #50	; 0x32
	module->rx_buffer_ptr              = rx_data;
   1e09a:	6266      	str	r6, [r4, #36]	; 0x24
	module->rx_status                  = STATUS_BUSY;
   1e09c:	701a      	strb	r2, [r3, #0]
	usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_RXC;
   1e09e:	2304      	movs	r3, #4
   1e0a0:	75ab      	strb	r3, [r5, #22]
	if(module->lin_slave_enabled) {
   1e0a2:	7a23      	ldrb	r3, [r4, #8]
   1e0a4:	2b00      	cmp	r3, #0
   1e0a6:	d001      	beq.n	1e0ac <_usart_read_buffer+0x38>
		usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_RXBRK;
   1e0a8:	2320      	movs	r3, #32
   1e0aa:	75ab      	strb	r3, [r5, #22]
	return STATUS_OK;
   1e0ac:	2000      	movs	r0, #0
	if(module->start_frame_detection_enabled) {
   1e0ae:	7a63      	ldrb	r3, [r4, #9]
   1e0b0:	4283      	cmp	r3, r0
   1e0b2:	d0ec      	beq.n	1e08e <_usart_read_buffer+0x1a>
		usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_RXS;
   1e0b4:	2308      	movs	r3, #8
   1e0b6:	75ab      	strb	r3, [r5, #22]
   1e0b8:	e7e9      	b.n	1e08e <_usart_read_buffer+0x1a>
   1e0ba:	46c0      	nop			; (mov r8, r8)
   1e0bc:	0001ce85 	.word	0x0001ce85
   1e0c0:	0001ceb9 	.word	0x0001ceb9

0001e0c4 <usart_register_callback>:
	/* Sanity check arguments */
	Assert(module);
	Assert(callback_func);

	/* Register callback function */
	module->callback[callback_type] = callback_func;
   1e0c4:	1c93      	adds	r3, r2, #2
   1e0c6:	009b      	lsls	r3, r3, #2
   1e0c8:	18c3      	adds	r3, r0, r3
   1e0ca:	6059      	str	r1, [r3, #4]

	/* Set the bit corresponding to the callback_type */
	module->callback_reg_mask |= (1 << callback_type);
   1e0cc:	2301      	movs	r3, #1
   1e0ce:	4093      	lsls	r3, r2
   1e0d0:	001a      	movs	r2, r3
   1e0d2:	3030      	adds	r0, #48	; 0x30
   1e0d4:	7803      	ldrb	r3, [r0, #0]
   1e0d6:	4313      	orrs	r3, r2
   1e0d8:	7003      	strb	r3, [r0, #0]
}
   1e0da:	4770      	bx	lr

0001e0dc <usart_write_buffer_job>:
 */
enum status_code usart_write_buffer_job(
		struct usart_module *const module,
		uint8_t *tx_data,
		uint16_t length)
{
   1e0dc:	b510      	push	{r4, lr}
	/* Sanity check arguments */
	Assert(module);
	Assert(tx_data);

	if (length == 0) {
		return STATUS_ERR_INVALID_ARG;
   1e0de:	2317      	movs	r3, #23
	if (length == 0) {
   1e0e0:	2a00      	cmp	r2, #0
   1e0e2:	d006      	beq.n	1e0f2 <usart_write_buffer_job+0x16>
	}

	/* Check that the transmitter is enabled */
	if (!(module->transmitter_enabled)) {
   1e0e4:	79c4      	ldrb	r4, [r0, #7]
		return STATUS_ERR_DENIED;
   1e0e6:	3305      	adds	r3, #5
	if (!(module->transmitter_enabled)) {
   1e0e8:	2c00      	cmp	r4, #0
   1e0ea:	d002      	beq.n	1e0f2 <usart_write_buffer_job+0x16>
	}

	/* Issue internal asynchronous write */
	return _usart_write_buffer(module, tx_data, length);
   1e0ec:	4b02      	ldr	r3, [pc, #8]	; (1e0f8 <usart_write_buffer_job+0x1c>)
   1e0ee:	4798      	blx	r3
   1e0f0:	0003      	movs	r3, r0
}
   1e0f2:	0018      	movs	r0, r3
   1e0f4:	bd10      	pop	{r4, pc}
   1e0f6:	46c0      	nop			; (mov r8, r8)
   1e0f8:	0001e035 	.word	0x0001e035

0001e0fc <usart_read_buffer_job>:
 */
enum status_code usart_read_buffer_job(
		struct usart_module *const module,
		uint8_t *rx_data,
		uint16_t length)
{
   1e0fc:	b510      	push	{r4, lr}
	/* Sanity check arguments */
	Assert(module);
	Assert(rx_data);

	if (length == 0) {
		return STATUS_ERR_INVALID_ARG;
   1e0fe:	2317      	movs	r3, #23
	if (length == 0) {
   1e100:	2a00      	cmp	r2, #0
   1e102:	d006      	beq.n	1e112 <usart_read_buffer_job+0x16>
	}

	/* Check that the receiver is enabled */
	if (!(module->receiver_enabled)) {
   1e104:	7984      	ldrb	r4, [r0, #6]
		return STATUS_ERR_DENIED;
   1e106:	3305      	adds	r3, #5
	if (!(module->receiver_enabled)) {
   1e108:	2c00      	cmp	r4, #0
   1e10a:	d002      	beq.n	1e112 <usart_read_buffer_job+0x16>
	}

	/* Issue internal asynchronous read */
	return _usart_read_buffer(module, rx_data, length);
   1e10c:	4b02      	ldr	r3, [pc, #8]	; (1e118 <usart_read_buffer_job+0x1c>)
   1e10e:	4798      	blx	r3
   1e110:	0003      	movs	r3, r0
}
   1e112:	0018      	movs	r0, r3
   1e114:	bd10      	pop	{r4, pc}
   1e116:	46c0      	nop			; (mov r8, r8)
   1e118:	0001e075 	.word	0x0001e075

0001e11c <usart_get_job_status>:
	Assert(module);

	/* Variable for status code */
	enum status_code status_code;

	switch(transceiver_type) {
   1e11c:	2900      	cmp	r1, #0
   1e11e:	d003      	beq.n	1e128 <usart_get_job_status+0xc>
   1e120:	2901      	cmp	r1, #1
   1e122:	d005      	beq.n	1e130 <usart_get_job_status+0x14>
	case USART_TRANSCEIVER_TX:
			status_code = module->tx_status;
			break;

	default:
			status_code = STATUS_ERR_INVALID_ARG;
   1e124:	2017      	movs	r0, #23
   1e126:	e002      	b.n	1e12e <usart_get_job_status+0x12>
			status_code = module->rx_status;
   1e128:	3032      	adds	r0, #50	; 0x32
			status_code = module->tx_status;
   1e12a:	7800      	ldrb	r0, [r0, #0]
   1e12c:	b2c0      	uxtb	r0, r0
			break;
	}

	return status_code;
}
   1e12e:	4770      	bx	lr
			status_code = module->tx_status;
   1e130:	3033      	adds	r0, #51	; 0x33
   1e132:	e7fa      	b.n	1e12a <usart_get_job_status+0xe>

0001e134 <_usart_interrupt_handler>:
 * \param[in]  instance  ID of the SERCOM instance calling the interrupt
 *                       handler.
 */
void _usart_interrupt_handler(
		uint8_t instance)
{
   1e134:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint16_t callback_status;
	uint8_t error_code;


	/* Get device instance from the look-up table */
	struct usart_module *module
   1e136:	4b58      	ldr	r3, [pc, #352]	; (1e298 <_usart_interrupt_handler+0x164>)
   1e138:	0080      	lsls	r0, r0, #2
   1e13a:	58c4      	ldr	r4, [r0, r3]
		= (struct usart_module *)_sercom_instances[instance];

	/* Pointer to the hardware module instance */
	SercomUsart *const usart_hw
		= &(module->hw->USART);
   1e13c:	6825      	ldr	r5, [r4, #0]
	return (usart_hw->SYNCBUSY.reg);
   1e13e:	69eb      	ldr	r3, [r5, #28]
	while (usart_is_syncing(module)) {
   1e140:	2b00      	cmp	r3, #0
   1e142:	d1fc      	bne.n	1e13e <_usart_interrupt_handler+0xa>

	/* Wait for the synchronization to complete */
	_usart_wait_for_sync(module);

	/* Read and mask interrupt flag register */
	interrupt_status = usart_hw->INTFLAG.reg;
   1e144:	7e2b      	ldrb	r3, [r5, #24]
	interrupt_status &= usart_hw->INTENSET.reg;
   1e146:	7daf      	ldrb	r7, [r5, #22]
   1e148:	401f      	ands	r7, r3
	callback_status = module->callback_reg_mask &
   1e14a:	0023      	movs	r3, r4
   1e14c:	3330      	adds	r3, #48	; 0x30
   1e14e:	781a      	ldrb	r2, [r3, #0]
   1e150:	785e      	ldrb	r6, [r3, #1]
			module->callback_enable_mask;

	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
   1e152:	2301      	movs	r3, #1
	callback_status = module->callback_reg_mask &
   1e154:	4016      	ands	r6, r2
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
   1e156:	421f      	tst	r7, r3
   1e158:	d019      	beq.n	1e18e <_usart_interrupt_handler+0x5a>
		if (module->remaining_tx_buffer_length) {
   1e15a:	8de2      	ldrh	r2, [r4, #46]	; 0x2e
   1e15c:	2a00      	cmp	r2, #0
   1e15e:	d100      	bne.n	1e162 <_usart_interrupt_handler+0x2e>
   1e160:	e072      	b.n	1e248 <_usart_interrupt_handler+0x114>
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
   1e162:	6aa2      	ldr	r2, [r4, #40]	; 0x28
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;
   1e164:	1c51      	adds	r1, r2, #1
			uint16_t data_to_send = *(module->tx_buffer_ptr);
   1e166:	7813      	ldrb	r3, [r2, #0]
			(module->tx_buffer_ptr)++;
   1e168:	62a1      	str	r1, [r4, #40]	; 0x28

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
   1e16a:	7961      	ldrb	r1, [r4, #5]
			uint16_t data_to_send = *(module->tx_buffer_ptr);
   1e16c:	b2db      	uxtb	r3, r3
			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
   1e16e:	2901      	cmp	r1, #1
   1e170:	d064      	beq.n	1e23c <_usart_interrupt_handler+0x108>
			uint16_t data_to_send = *(module->tx_buffer_ptr);
   1e172:	b29b      	uxth	r3, r3
				data_to_send |= (*(module->tx_buffer_ptr) << 8);
				/* Increment 8-bit pointer */
				(module->tx_buffer_ptr)++;
			}
			/* Write the data to send */
			usart_hw->DATA.reg = (data_to_send & SERCOM_USART_DATA_MASK);
   1e174:	05db      	lsls	r3, r3, #23
   1e176:	0ddb      	lsrs	r3, r3, #23
   1e178:	852b      	strh	r3, [r5, #40]	; 0x28

			if (--(module->remaining_tx_buffer_length) == 0) {
   1e17a:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
   1e17c:	3b01      	subs	r3, #1
   1e17e:	b29b      	uxth	r3, r3
   1e180:	85e3      	strh	r3, [r4, #46]	; 0x2e
   1e182:	2b00      	cmp	r3, #0
   1e184:	d103      	bne.n	1e18e <_usart_interrupt_handler+0x5a>
				/* Disable the Data Register Empty Interrupt */
				usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
   1e186:	3301      	adds	r3, #1
   1e188:	752b      	strb	r3, [r5, #20]
				/* Enable Transmission Complete interrupt */
				usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_TXC;
   1e18a:	3301      	adds	r3, #1
   1e18c:	75ab      	strb	r3, [r5, #22]
		}
	}

	/* Check if the Transmission Complete interrupt has occurred and
	 * that the transmit buffer is empty */
	if (interrupt_status & SERCOM_USART_INTFLAG_TXC) {
   1e18e:	2302      	movs	r3, #2
   1e190:	421f      	tst	r7, r3
   1e192:	d009      	beq.n	1e1a8 <_usart_interrupt_handler+0x74>

		/* Disable TX Complete Interrupt, and set STATUS_OK */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_TXC;
   1e194:	752b      	strb	r3, [r5, #20]
		module->tx_status = STATUS_OK;
   1e196:	0023      	movs	r3, r4
   1e198:	2200      	movs	r2, #0
   1e19a:	3333      	adds	r3, #51	; 0x33
   1e19c:	701a      	strb	r2, [r3, #0]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BUFFER_TRANSMITTED)) {
   1e19e:	07f3      	lsls	r3, r6, #31
   1e1a0:	d502      	bpl.n	1e1a8 <_usart_interrupt_handler+0x74>
			(*(module->callback[USART_CALLBACK_BUFFER_TRANSMITTED]))(module);
   1e1a2:	0020      	movs	r0, r4
   1e1a4:	68e3      	ldr	r3, [r4, #12]
   1e1a6:	4798      	blx	r3
		}
	}

	/* Check if the Receive Complete interrupt has occurred, and that
	 * there's more data to receive */
	if (interrupt_status & SERCOM_USART_INTFLAG_RXC) {
   1e1a8:	2304      	movs	r3, #4
   1e1aa:	421f      	tst	r7, r3
   1e1ac:	d027      	beq.n	1e1fe <_usart_interrupt_handler+0xca>

		if (module->remaining_rx_buffer_length) {
   1e1ae:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
   1e1b0:	2a00      	cmp	r2, #0
   1e1b2:	d100      	bne.n	1e1b6 <_usart_interrupt_handler+0x82>
   1e1b4:	e06d      	b.n	1e292 <_usart_interrupt_handler+0x15e>
			/* Read out the status code and mask away all but the 4 LSBs*/
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
   1e1b6:	8b6b      	ldrh	r3, [r5, #26]
   1e1b8:	b2db      	uxtb	r3, r3
#if !SAMD20
			/* CTS status should not be considered as an error */
			if(error_code & SERCOM_USART_STATUS_CTS) {
   1e1ba:	071a      	lsls	r2, r3, #28
   1e1bc:	d446      	bmi.n	1e24c <_usart_interrupt_handler+0x118>
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
   1e1be:	223f      	movs	r2, #63	; 0x3f
				error_code &= ~SERCOM_USART_STATUS_CTS;
   1e1c0:	4013      	ands	r3, r2
			if(error_code & SERCOM_USART_STATUS_TXE) {
				error_code &= ~SERCOM_USART_STATUS_TXE;
			}
#endif
			/* Check if an error has occurred during the receiving */
			if (error_code) {
   1e1c2:	d045      	beq.n	1e250 <_usart_interrupt_handler+0x11c>
				/* Check which error occurred */
				if (error_code & SERCOM_USART_STATUS_FERR) {
   1e1c4:	2202      	movs	r2, #2
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_FORMAT;
   1e1c6:	211a      	movs	r1, #26
				if (error_code & SERCOM_USART_STATUS_FERR) {
   1e1c8:	4213      	tst	r3, r2
   1e1ca:	d10f      	bne.n	1e1ec <_usart_interrupt_handler+0xb8>
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_FERR;
				} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
   1e1cc:	2204      	movs	r2, #4
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_OVERFLOW;
   1e1ce:	211e      	movs	r1, #30
				} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
   1e1d0:	4213      	tst	r3, r2
   1e1d2:	d10b      	bne.n	1e1ec <_usart_interrupt_handler+0xb8>
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_BUFOVF;
				} else if (error_code & SERCOM_USART_STATUS_PERR) {
   1e1d4:	2201      	movs	r2, #1
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_DATA;
   1e1d6:	2113      	movs	r1, #19
				} else if (error_code & SERCOM_USART_STATUS_PERR) {
   1e1d8:	4213      	tst	r3, r2
   1e1da:	d107      	bne.n	1e1ec <_usart_interrupt_handler+0xb8>
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_PERR;
				}
#ifdef FEATURE_USART_LIN_SLAVE
				else if (error_code & SERCOM_USART_STATUS_ISF) {
   1e1dc:	2210      	movs	r2, #16
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_PROTOCOL;
   1e1de:	2142      	movs	r1, #66	; 0x42
				else if (error_code & SERCOM_USART_STATUS_ISF) {
   1e1e0:	4213      	tst	r3, r2
   1e1e2:	d103      	bne.n	1e1ec <_usart_interrupt_handler+0xb8>
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_ISF;
				}
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
				else if (error_code & SERCOM_USART_STATUS_COLL) {
   1e1e4:	2220      	movs	r2, #32
   1e1e6:	4213      	tst	r3, r2
   1e1e8:	d004      	beq.n	1e1f4 <_usart_interrupt_handler+0xc0>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_PACKET_COLLISION;
   1e1ea:	2141      	movs	r1, #65	; 0x41
   1e1ec:	0023      	movs	r3, r4
   1e1ee:	3332      	adds	r3, #50	; 0x32
   1e1f0:	7019      	strb	r1, [r3, #0]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_COLL;
   1e1f2:	836a      	strh	r2, [r5, #26]
				}
#endif

				/* Run callback if registered and enabled */
				if (callback_status
   1e1f4:	0773      	lsls	r3, r6, #29
   1e1f6:	d502      	bpl.n	1e1fe <_usart_interrupt_handler+0xca>
						& (1 << USART_CALLBACK_ERROR)) {
					(*(module->callback[USART_CALLBACK_ERROR]))(module);
   1e1f8:	0020      	movs	r0, r4
   1e1fa:	6963      	ldr	r3, [r4, #20]
					module->rx_status = STATUS_OK;

					/* Run callback if registered and enabled */
					if (callback_status
							& (1 << USART_CALLBACK_BUFFER_RECEIVED)) {
						(*(module->callback[USART_CALLBACK_BUFFER_RECEIVED]))(module);
   1e1fc:	4798      	blx	r3
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
		}
	}

#ifdef FEATURE_USART_HARDWARE_FLOW_CONTROL
	if (interrupt_status & SERCOM_USART_INTFLAG_CTSIC) {
   1e1fe:	2310      	movs	r3, #16
   1e200:	421f      	tst	r7, r3
   1e202:	d006      	beq.n	1e212 <_usart_interrupt_handler+0xde>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_CTSIC;
   1e204:	752b      	strb	r3, [r5, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_CTSIC;
   1e206:	762b      	strb	r3, [r5, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_CTS_INPUT_CHANGE)) {
   1e208:	421e      	tst	r6, r3
   1e20a:	d002      	beq.n	1e212 <_usart_interrupt_handler+0xde>
			(*(module->callback[USART_CALLBACK_CTS_INPUT_CHANGE]))(module);
   1e20c:	0020      	movs	r0, r4
   1e20e:	69e3      	ldr	r3, [r4, #28]
   1e210:	4798      	blx	r3
		}
	}
#endif

#ifdef FEATURE_USART_LIN_SLAVE
	if (interrupt_status & SERCOM_USART_INTFLAG_RXBRK) {
   1e212:	2320      	movs	r3, #32
   1e214:	421f      	tst	r7, r3
   1e216:	d006      	beq.n	1e226 <_usart_interrupt_handler+0xf2>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXBRK;
   1e218:	752b      	strb	r3, [r5, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXBRK;
   1e21a:	762b      	strb	r3, [r5, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BREAK_RECEIVED)) {
   1e21c:	0733      	lsls	r3, r6, #28
   1e21e:	d502      	bpl.n	1e226 <_usart_interrupt_handler+0xf2>
			(*(module->callback[USART_CALLBACK_BREAK_RECEIVED]))(module);
   1e220:	0020      	movs	r0, r4
   1e222:	69a3      	ldr	r3, [r4, #24]
   1e224:	4798      	blx	r3
		}
	}
#endif

#ifdef FEATURE_USART_START_FRAME_DECTION
	if (interrupt_status & SERCOM_USART_INTFLAG_RXS) {
   1e226:	2308      	movs	r3, #8
   1e228:	421f      	tst	r7, r3
   1e22a:	d006      	beq.n	1e23a <_usart_interrupt_handler+0x106>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXS;
   1e22c:	752b      	strb	r3, [r5, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXS;
   1e22e:	762b      	strb	r3, [r5, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_START_RECEIVED)) {
   1e230:	06b3      	lsls	r3, r6, #26
   1e232:	d502      	bpl.n	1e23a <_usart_interrupt_handler+0x106>
			(*(module->callback[USART_CALLBACK_START_RECEIVED]))(module);
   1e234:	6a23      	ldr	r3, [r4, #32]
   1e236:	0020      	movs	r0, r4
   1e238:	4798      	blx	r3
		}
	}
#endif
}
   1e23a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				data_to_send |= (*(module->tx_buffer_ptr) << 8);
   1e23c:	7851      	ldrb	r1, [r2, #1]
				(module->tx_buffer_ptr)++;
   1e23e:	3202      	adds	r2, #2
				data_to_send |= (*(module->tx_buffer_ptr) << 8);
   1e240:	0209      	lsls	r1, r1, #8
   1e242:	430b      	orrs	r3, r1
				(module->tx_buffer_ptr)++;
   1e244:	62a2      	str	r2, [r4, #40]	; 0x28
   1e246:	e795      	b.n	1e174 <_usart_interrupt_handler+0x40>
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
   1e248:	752b      	strb	r3, [r5, #20]
   1e24a:	e7a0      	b.n	1e18e <_usart_interrupt_handler+0x5a>
				error_code &= ~SERCOM_USART_STATUS_CTS;
   1e24c:	2237      	movs	r2, #55	; 0x37
   1e24e:	e7b7      	b.n	1e1c0 <_usart_interrupt_handler+0x8c>
				uint16_t received_data = (usart_hw->DATA.reg & SERCOM_USART_DATA_MASK);
   1e250:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
				*(module->rx_buffer_ptr) = received_data;
   1e252:	6a61      	ldr	r1, [r4, #36]	; 0x24
				uint16_t received_data = (usart_hw->DATA.reg & SERCOM_USART_DATA_MASK);
   1e254:	05db      	lsls	r3, r3, #23
   1e256:	0ddb      	lsrs	r3, r3, #23
				*(module->rx_buffer_ptr) = received_data;
   1e258:	b2da      	uxtb	r2, r3
   1e25a:	700a      	strb	r2, [r1, #0]
				module->rx_buffer_ptr += 1;
   1e25c:	6a62      	ldr	r2, [r4, #36]	; 0x24
   1e25e:	1c51      	adds	r1, r2, #1
   1e260:	6261      	str	r1, [r4, #36]	; 0x24
				if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
   1e262:	7961      	ldrb	r1, [r4, #5]
   1e264:	2901      	cmp	r1, #1
   1e266:	d104      	bne.n	1e272 <_usart_interrupt_handler+0x13e>
					*(module->rx_buffer_ptr) = (received_data >> 8);
   1e268:	0a1b      	lsrs	r3, r3, #8
   1e26a:	7053      	strb	r3, [r2, #1]
					module->rx_buffer_ptr += 1;
   1e26c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1e26e:	3301      	adds	r3, #1
   1e270:	6263      	str	r3, [r4, #36]	; 0x24
				if(--(module->remaining_rx_buffer_length) == 0) {
   1e272:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
   1e274:	3b01      	subs	r3, #1
   1e276:	b29b      	uxth	r3, r3
   1e278:	85a3      	strh	r3, [r4, #44]	; 0x2c
   1e27a:	2b00      	cmp	r3, #0
   1e27c:	d1bf      	bne.n	1e1fe <_usart_interrupt_handler+0xca>
					usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
   1e27e:	2204      	movs	r2, #4
   1e280:	752a      	strb	r2, [r5, #20]
					module->rx_status = STATUS_OK;
   1e282:	0022      	movs	r2, r4
   1e284:	3232      	adds	r2, #50	; 0x32
   1e286:	7013      	strb	r3, [r2, #0]
					if (callback_status
   1e288:	07b3      	lsls	r3, r6, #30
   1e28a:	d5b8      	bpl.n	1e1fe <_usart_interrupt_handler+0xca>
						(*(module->callback[USART_CALLBACK_BUFFER_RECEIVED]))(module);
   1e28c:	0020      	movs	r0, r4
   1e28e:	6923      	ldr	r3, [r4, #16]
   1e290:	e7b4      	b.n	1e1fc <_usart_interrupt_handler+0xc8>
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
   1e292:	752b      	strb	r3, [r5, #20]
   1e294:	e7b3      	b.n	1e1fe <_usart_interrupt_handler+0xca>
   1e296:	46c0      	nop			; (mov r8, r8)
   1e298:	20005680 	.word	0x20005680

0001e29c <_system_dfll_wait_for_sync>:
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
   1e29c:	2310      	movs	r3, #16
   1e29e:	4902      	ldr	r1, [pc, #8]	; (1e2a8 <_system_dfll_wait_for_sync+0xc>)
   1e2a0:	68ca      	ldr	r2, [r1, #12]
   1e2a2:	421a      	tst	r2, r3
   1e2a4:	d0fc      	beq.n	1e2a0 <_system_dfll_wait_for_sync+0x4>
		/* Wait for DFLL sync */
	}
}
   1e2a6:	4770      	bx	lr
   1e2a8:	40000800 	.word	0x40000800

0001e2ac <system_clock_source_get_hz>:
 *
 * \returns Frequency of the given clock source, in Hz.
 */
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
   1e2ac:	b570      	push	{r4, r5, r6, lr}
	switch (clock_source) {
   1e2ae:	2808      	cmp	r0, #8
   1e2b0:	d806      	bhi.n	1e2c0 <system_clock_source_get_hz+0x14>
   1e2b2:	f007 faf9 	bl	258a8 <__gnu_thumb1_case_uqi>
   1e2b6:	0508      	.short	0x0508
   1e2b8:	12303005 	.word	0x12303005
   1e2bc:	150b      	.short	0x150b
   1e2be:	28          	.byte	0x28
   1e2bf:	00          	.byte	0x00

		return _system_clock_inst.dpll.frequency;
#endif

	default:
		return 0;
   1e2c0:	2400      	movs	r4, #0
	}
}
   1e2c2:	0020      	movs	r0, r4
   1e2c4:	bd70      	pop	{r4, r5, r6, pc}
		return _system_clock_inst.xosc.frequency;
   1e2c6:	4b16      	ldr	r3, [pc, #88]	; (1e320 <system_clock_source_get_hz+0x74>)
   1e2c8:	691c      	ldr	r4, [r3, #16]
   1e2ca:	e7fa      	b.n	1e2c2 <system_clock_source_get_hz+0x16>
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;
   1e2cc:	4b15      	ldr	r3, [pc, #84]	; (1e324 <system_clock_source_get_hz+0x78>)
   1e2ce:	4c16      	ldr	r4, [pc, #88]	; (1e328 <system_clock_source_get_hz+0x7c>)
   1e2d0:	6a1b      	ldr	r3, [r3, #32]
   1e2d2:	059b      	lsls	r3, r3, #22
   1e2d4:	0f9b      	lsrs	r3, r3, #30
   1e2d6:	40dc      	lsrs	r4, r3
   1e2d8:	e7f3      	b.n	1e2c2 <system_clock_source_get_hz+0x16>
		return _system_clock_inst.xosc32k.frequency;
   1e2da:	4b11      	ldr	r3, [pc, #68]	; (1e320 <system_clock_source_get_hz+0x74>)
   1e2dc:	695c      	ldr	r4, [r3, #20]
   1e2de:	e7f0      	b.n	1e2c2 <system_clock_source_get_hz+0x16>
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
   1e2e0:	4d0f      	ldr	r5, [pc, #60]	; (1e320 <system_clock_source_get_hz+0x74>)
			return 0;
   1e2e2:	2400      	movs	r4, #0
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
   1e2e4:	682b      	ldr	r3, [r5, #0]
   1e2e6:	079b      	lsls	r3, r3, #30
   1e2e8:	d5eb      	bpl.n	1e2c2 <system_clock_source_get_hz+0x16>
		_system_dfll_wait_for_sync();
   1e2ea:	4b10      	ldr	r3, [pc, #64]	; (1e32c <system_clock_source_get_hz+0x80>)
   1e2ec:	4798      	blx	r3
		switch(_system_clock_inst.dfll.control &
   1e2ee:	2224      	movs	r2, #36	; 0x24
   1e2f0:	682b      	ldr	r3, [r5, #0]
   1e2f2:	4013      	ands	r3, r2
   1e2f4:	2b04      	cmp	r3, #4
   1e2f6:	d111      	bne.n	1e31c <system_clock_source_get_hz+0x70>
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
   1e2f8:	0020      	movs	r0, r4
   1e2fa:	4b0d      	ldr	r3, [pc, #52]	; (1e330 <system_clock_source_get_hz+0x84>)
   1e2fc:	4798      	blx	r3
					(_system_clock_inst.dfll.mul & 0xffff);
   1e2fe:	68ac      	ldr	r4, [r5, #8]
   1e300:	b2a4      	uxth	r4, r4
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
   1e302:	4344      	muls	r4, r0
   1e304:	e7dd      	b.n	1e2c2 <system_clock_source_get_hz+0x16>
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
   1e306:	4b0b      	ldr	r3, [pc, #44]	; (1e334 <system_clock_source_get_hz+0x88>)
			return 0;
   1e308:	2400      	movs	r4, #0
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
   1e30a:	781b      	ldrb	r3, [r3, #0]
   1e30c:	075b      	lsls	r3, r3, #29
   1e30e:	d5d8      	bpl.n	1e2c2 <system_clock_source_get_hz+0x16>
		return _system_clock_inst.dpll.frequency;
   1e310:	4b03      	ldr	r3, [pc, #12]	; (1e320 <system_clock_source_get_hz+0x74>)
   1e312:	68dc      	ldr	r4, [r3, #12]
   1e314:	e7d5      	b.n	1e2c2 <system_clock_source_get_hz+0x16>
		return 32768UL;
   1e316:	2480      	movs	r4, #128	; 0x80
   1e318:	0224      	lsls	r4, r4, #8
   1e31a:	e7d2      	b.n	1e2c2 <system_clock_source_get_hz+0x16>
			return 48000000UL;
   1e31c:	4c06      	ldr	r4, [pc, #24]	; (1e338 <system_clock_source_get_hz+0x8c>)
   1e31e:	e7d0      	b.n	1e2c2 <system_clock_source_get_hz+0x16>
   1e320:	20003db0 	.word	0x20003db0
   1e324:	40000800 	.word	0x40000800
   1e328:	007a1200 	.word	0x007a1200
   1e32c:	0001e29d 	.word	0x0001e29d
   1e330:	0001e855 	.word	0x0001e855
   1e334:	40000850 	.word	0x40000850
   1e338:	02dc6c00 	.word	0x02dc6c00

0001e33c <system_clock_source_osc8m_set_config>:
 *
 * \param[in] config  OSC8M configuration structure containing the new config
 */
void system_clock_source_osc8m_set_config(
		struct system_clock_source_osc8m_config *const config)
{
   1e33c:	b570      	push	{r4, r5, r6, lr}
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;

	/* Use temporary struct to reduce register access */
	temp.bit.PRESC    = config->prescaler;
	temp.bit.ONDEMAND = config->on_demand;
   1e33e:	7884      	ldrb	r4, [r0, #2]
	temp.bit.PRESC    = config->prescaler;
   1e340:	7802      	ldrb	r2, [r0, #0]
	temp.bit.RUNSTDBY = config->run_in_standby;

	SYSCTRL->OSC8M = temp;
   1e342:	7845      	ldrb	r5, [r0, #1]
   1e344:	2001      	movs	r0, #1
   1e346:	2640      	movs	r6, #64	; 0x40
   1e348:	4005      	ands	r5, r0
   1e34a:	4020      	ands	r0, r4
   1e34c:	2480      	movs	r4, #128	; 0x80
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;
   1e34e:	4908      	ldr	r1, [pc, #32]	; (1e370 <system_clock_source_osc8m_set_config+0x34>)
	SYSCTRL->OSC8M = temp;
   1e350:	01ad      	lsls	r5, r5, #6
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;
   1e352:	6a0b      	ldr	r3, [r1, #32]
	SYSCTRL->OSC8M = temp;
   1e354:	01c0      	lsls	r0, r0, #7
   1e356:	43b3      	bics	r3, r6
   1e358:	432b      	orrs	r3, r5
   1e35a:	43a3      	bics	r3, r4
   1e35c:	4303      	orrs	r3, r0
   1e35e:	2003      	movs	r0, #3
   1e360:	4002      	ands	r2, r0
   1e362:	4804      	ldr	r0, [pc, #16]	; (1e374 <system_clock_source_osc8m_set_config+0x38>)
   1e364:	0212      	lsls	r2, r2, #8
   1e366:	4003      	ands	r3, r0
   1e368:	4313      	orrs	r3, r2
   1e36a:	620b      	str	r3, [r1, #32]
}
   1e36c:	bd70      	pop	{r4, r5, r6, pc}
   1e36e:	46c0      	nop			; (mov r8, r8)
   1e370:	40000800 	.word	0x40000800
   1e374:	fffffcff 	.word	0xfffffcff

0001e378 <system_clock_source_dpll_set_config>:
 *
 * \param[in] config  DPLL configuration structure containing the new config
 */
void system_clock_source_dpll_set_config(
		struct system_clock_source_dpll_config *const config)
{
   1e378:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t refclk;

	refclk = config->reference_frequency;

	/* Only reference clock REF1 can be divided */
	if (config->reference_clock == SYSTEM_CLOCK_SOURCE_DPLL_REFERENCE_CLOCK_XOSC) {
   1e37a:	7d03      	ldrb	r3, [r0, #20]
{
   1e37c:	0004      	movs	r4, r0
	refclk = config->reference_frequency;
   1e37e:	68c5      	ldr	r5, [r0, #12]
   1e380:	4e22      	ldr	r6, [pc, #136]	; (1e40c <system_clock_source_dpll_set_config+0x94>)
	if (config->reference_clock == SYSTEM_CLOCK_SOURCE_DPLL_REFERENCE_CLOCK_XOSC) {
   1e382:	2b01      	cmp	r3, #1
   1e384:	d105      	bne.n	1e392 <system_clock_source_dpll_set_config+0x1a>
		refclk = refclk / (2 * (config->reference_divider + 1));
   1e386:	8a01      	ldrh	r1, [r0, #16]
   1e388:	0028      	movs	r0, r5
   1e38a:	3101      	adds	r1, #1
   1e38c:	0049      	lsls	r1, r1, #1
   1e38e:	47b0      	blx	r6
   1e390:	0005      	movs	r5, r0
	}

	/* Calculate LDRFRAC and LDR */
	tmpldr = (config->output_frequency << 4) / refclk;
   1e392:	68a3      	ldr	r3, [r4, #8]
   1e394:	0029      	movs	r1, r5
   1e396:	0118      	lsls	r0, r3, #4
   1e398:	47b0      	blx	r6
	tmpldrfrac = tmpldr & 0x0f;
   1e39a:	230f      	movs	r3, #15
   1e39c:	0002      	movs	r2, r0
	tmpldr = (tmpldr >> 4) - 1;

	SYSCTRL->DPLLCTRLA.reg =
			((uint32_t)config->on_demand << SYSCTRL_DPLLCTRLA_ONDEMAND_Pos) |
			((uint32_t)config->run_in_standby << SYSCTRL_DPLLCTRLA_RUNSTDBY_Pos);
   1e39e:	7866      	ldrb	r6, [r4, #1]
			((uint32_t)config->on_demand << SYSCTRL_DPLLCTRLA_ONDEMAND_Pos) |
   1e3a0:	7827      	ldrb	r7, [r4, #0]
			((uint32_t)config->run_in_standby << SYSCTRL_DPLLCTRLA_RUNSTDBY_Pos);
   1e3a2:	01b6      	lsls	r6, r6, #6
			((uint32_t)config->on_demand << SYSCTRL_DPLLCTRLA_ONDEMAND_Pos) |
   1e3a4:	01ff      	lsls	r7, r7, #7
   1e3a6:	4337      	orrs	r7, r6
	SYSCTRL->DPLLCTRLA.reg =
   1e3a8:	4919      	ldr	r1, [pc, #100]	; (1e410 <system_clock_source_dpll_set_config+0x98>)
			((uint32_t)config->on_demand << SYSCTRL_DPLLCTRLA_ONDEMAND_Pos) |
   1e3aa:	b2ff      	uxtb	r7, r7
	SYSCTRL->DPLLCTRLA.reg =
   1e3ac:	700f      	strb	r7, [r1, #0]
			((uint32_t)config->lock_bypass << SYSCTRL_DPLLCTRLB_LBYPASS_Pos) |
			SYSCTRL_DPLLCTRLB_LTIME(config->lock_time) |
			SYSCTRL_DPLLCTRLB_REFCLK(config->reference_clock) |
			((uint32_t)config->wake_up_fast << SYSCTRL_DPLLCTRLB_WUF_Pos) |
			((uint32_t)config->low_power_enable << SYSCTRL_DPLLCTRLB_LPEN_Pos) |
			SYSCTRL_DPLLCTRLB_FILTER(config->filter);
   1e3ae:	2103      	movs	r1, #3
	tmpldrfrac = tmpldr & 0x0f;
   1e3b0:	401a      	ands	r2, r3
	tmpldr = (tmpldr >> 4) - 1;
   1e3b2:	0903      	lsrs	r3, r0, #4
   1e3b4:	3b01      	subs	r3, #1
			SYSCTRL_DPLLRATIO_LDR(tmpldr);
   1e3b6:	051b      	lsls	r3, r3, #20
	SYSCTRL->DPLLCTRLA.reg =
   1e3b8:	4e16      	ldr	r6, [pc, #88]	; (1e414 <system_clock_source_dpll_set_config+0x9c>)
			SYSCTRL_DPLLRATIO_LDRFRAC(tmpldrfrac) |
   1e3ba:	0417      	lsls	r7, r2, #16
			SYSCTRL_DPLLRATIO_LDR(tmpldr);
   1e3bc:	0d1b      	lsrs	r3, r3, #20
			SYSCTRL_DPLLRATIO_LDRFRAC(tmpldrfrac) |
   1e3be:	433b      	orrs	r3, r7
	SYSCTRL->DPLLRATIO.reg =
   1e3c0:	64b3      	str	r3, [r6, #72]	; 0x48
			((uint32_t)config->lock_bypass << SYSCTRL_DPLLCTRLB_LBYPASS_Pos) |
   1e3c2:	78a3      	ldrb	r3, [r4, #2]
			((uint32_t)config->wake_up_fast << SYSCTRL_DPLLCTRLB_WUF_Pos) |
   1e3c4:	78e7      	ldrb	r7, [r4, #3]
			((uint32_t)config->lock_bypass << SYSCTRL_DPLLCTRLB_LBYPASS_Pos) |
   1e3c6:	031b      	lsls	r3, r3, #12
			((uint32_t)config->wake_up_fast << SYSCTRL_DPLLCTRLB_WUF_Pos) |
   1e3c8:	00ff      	lsls	r7, r7, #3
			((uint32_t)config->low_power_enable << SYSCTRL_DPLLCTRLB_LPEN_Pos) |
   1e3ca:	433b      	orrs	r3, r7
   1e3cc:	7927      	ldrb	r7, [r4, #4]
   1e3ce:	00bf      	lsls	r7, r7, #2
   1e3d0:	433b      	orrs	r3, r7
			SYSCTRL_DPLLCTRLB_FILTER(config->filter);
   1e3d2:	7ca7      	ldrb	r7, [r4, #18]
   1e3d4:	400f      	ands	r7, r1
			((uint32_t)config->low_power_enable << SYSCTRL_DPLLCTRLB_LPEN_Pos) |
   1e3d6:	433b      	orrs	r3, r7
			SYSCTRL_DPLLCTRLB_DIV(config->reference_divider) |
   1e3d8:	8a27      	ldrh	r7, [r4, #16]
   1e3da:	490f      	ldr	r1, [pc, #60]	; (1e418 <system_clock_source_dpll_set_config+0xa0>)
   1e3dc:	043f      	lsls	r7, r7, #16
   1e3de:	400f      	ands	r7, r1
			SYSCTRL_DPLLCTRLB_LTIME(config->lock_time) |
   1e3e0:	21e0      	movs	r1, #224	; 0xe0
			((uint32_t)config->low_power_enable << SYSCTRL_DPLLCTRLB_LPEN_Pos) |
   1e3e2:	433b      	orrs	r3, r7
			SYSCTRL_DPLLCTRLB_LTIME(config->lock_time) |
   1e3e4:	7ce7      	ldrb	r7, [r4, #19]
   1e3e6:	00c9      	lsls	r1, r1, #3
   1e3e8:	023f      	lsls	r7, r7, #8
   1e3ea:	400f      	ands	r7, r1
			((uint32_t)config->low_power_enable << SYSCTRL_DPLLCTRLB_LPEN_Pos) |
   1e3ec:	433b      	orrs	r3, r7
			SYSCTRL_DPLLCTRLB_REFCLK(config->reference_clock) |
   1e3ee:	2730      	movs	r7, #48	; 0x30
   1e3f0:	7d24      	ldrb	r4, [r4, #20]
   1e3f2:	0124      	lsls	r4, r4, #4
   1e3f4:	403c      	ands	r4, r7
			((uint32_t)config->low_power_enable << SYSCTRL_DPLLCTRLB_LPEN_Pos) |
   1e3f6:	4323      	orrs	r3, r4
	SYSCTRL->DPLLCTRLB.reg =
   1e3f8:	64f3      	str	r3, [r6, #76]	; 0x4c

	/*
	 * Fck = Fckrx * (LDR + 1 + LDRFRAC / 16)
	 */
	_system_clock_inst.dpll.frequency =
			(refclk * (((tmpldr + 1) << 4) + tmpldrfrac)) >> 4;
   1e3fa:	230f      	movs	r3, #15
   1e3fc:	4398      	bics	r0, r3
   1e3fe:	1880      	adds	r0, r0, r2
   1e400:	4345      	muls	r5, r0
	_system_clock_inst.dpll.frequency =
   1e402:	4b06      	ldr	r3, [pc, #24]	; (1e41c <system_clock_source_dpll_set_config+0xa4>)
			(refclk * (((tmpldr + 1) << 4) + tmpldrfrac)) >> 4;
   1e404:	092d      	lsrs	r5, r5, #4
	_system_clock_inst.dpll.frequency =
   1e406:	60dd      	str	r5, [r3, #12]
}
   1e408:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1e40a:	46c0      	nop			; (mov r8, r8)
   1e40c:	000258bd 	.word	0x000258bd
   1e410:	40000844 	.word	0x40000844
   1e414:	40000800 	.word	0x40000800
   1e418:	07ff0000 	.word	0x07ff0000
   1e41c:	20003db0 	.word	0x20003db0

0001e420 <system_clock_source_enable>:
 * \retval STATUS_ERR_INVALID_ARG  The clock source is not available on this
 *                                 device
 */
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
   1e420:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	switch (clock_source) {
   1e422:	2808      	cmp	r0, #8
   1e424:	d806      	bhi.n	1e434 <system_clock_source_enable+0x14>
   1e426:	f007 fa3f 	bl	258a8 <__gnu_thumb1_case_uqi>
   1e42a:	0514      	.short	0x0514
   1e42c:	1a0e0c05 	.word	0x1a0e0c05
   1e430:	2007      	.short	0x2007
   1e432:	34          	.byte	0x34
   1e433:	00          	.byte	0x00
		/* Always enabled */
		return STATUS_OK;

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
   1e434:	2017      	movs	r0, #23
	}

	return STATUS_OK;
}
   1e436:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
   1e438:	2302      	movs	r3, #2
   1e43a:	4a19      	ldr	r2, [pc, #100]	; (1e4a0 <system_clock_source_enable+0x80>)
   1e43c:	6a11      	ldr	r1, [r2, #32]
   1e43e:	430b      	orrs	r3, r1
   1e440:	6213      	str	r3, [r2, #32]
		return STATUS_OK;
   1e442:	2000      	movs	r0, #0
   1e444:	e7f7      	b.n	1e436 <system_clock_source_enable+0x16>
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
   1e446:	2302      	movs	r3, #2
   1e448:	4a15      	ldr	r2, [pc, #84]	; (1e4a0 <system_clock_source_enable+0x80>)
   1e44a:	6991      	ldr	r1, [r2, #24]
   1e44c:	430b      	orrs	r3, r1
   1e44e:	6193      	str	r3, [r2, #24]
   1e450:	e7f7      	b.n	1e442 <system_clock_source_enable+0x22>
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
   1e452:	2302      	movs	r3, #2
   1e454:	4a12      	ldr	r2, [pc, #72]	; (1e4a0 <system_clock_source_enable+0x80>)
   1e456:	8a11      	ldrh	r1, [r2, #16]
   1e458:	430b      	orrs	r3, r1
   1e45a:	8213      	strh	r3, [r2, #16]
   1e45c:	e7f1      	b.n	1e442 <system_clock_source_enable+0x22>
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
   1e45e:	2302      	movs	r3, #2
   1e460:	4a0f      	ldr	r2, [pc, #60]	; (1e4a0 <system_clock_source_enable+0x80>)
   1e462:	8a91      	ldrh	r1, [r2, #20]
   1e464:	430b      	orrs	r3, r1
   1e466:	8293      	strh	r3, [r2, #20]
   1e468:	e7eb      	b.n	1e442 <system_clock_source_enable+0x22>
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
   1e46a:	2202      	movs	r2, #2
	SYSCTRL->DFLLCTRL.reg = 0;
   1e46c:	2400      	movs	r4, #0
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
   1e46e:	4e0d      	ldr	r6, [pc, #52]	; (1e4a4 <system_clock_source_enable+0x84>)
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
   1e470:	4d0b      	ldr	r5, [pc, #44]	; (1e4a0 <system_clock_source_enable+0x80>)
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
   1e472:	6833      	ldr	r3, [r6, #0]
	_system_dfll_wait_for_sync();
   1e474:	4f0c      	ldr	r7, [pc, #48]	; (1e4a8 <system_clock_source_enable+0x88>)
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
   1e476:	4313      	orrs	r3, r2
   1e478:	6033      	str	r3, [r6, #0]
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
   1e47a:	84aa      	strh	r2, [r5, #36]	; 0x24
	_system_dfll_wait_for_sync();
   1e47c:	47b8      	blx	r7
	SYSCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
   1e47e:	68b3      	ldr	r3, [r6, #8]
   1e480:	62eb      	str	r3, [r5, #44]	; 0x2c
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;
   1e482:	6873      	ldr	r3, [r6, #4]
   1e484:	62ab      	str	r3, [r5, #40]	; 0x28
	SYSCTRL->DFLLCTRL.reg = 0;
   1e486:	84ac      	strh	r4, [r5, #36]	; 0x24
	_system_dfll_wait_for_sync();
   1e488:	47b8      	blx	r7
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
   1e48a:	6833      	ldr	r3, [r6, #0]
   1e48c:	b29b      	uxth	r3, r3
   1e48e:	84ab      	strh	r3, [r5, #36]	; 0x24
   1e490:	e7d7      	b.n	1e442 <system_clock_source_enable+0x22>
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
   1e492:	2302      	movs	r3, #2
   1e494:	4a05      	ldr	r2, [pc, #20]	; (1e4ac <system_clock_source_enable+0x8c>)
   1e496:	7811      	ldrb	r1, [r2, #0]
   1e498:	430b      	orrs	r3, r1
   1e49a:	7013      	strb	r3, [r2, #0]
   1e49c:	e7d1      	b.n	1e442 <system_clock_source_enable+0x22>
   1e49e:	46c0      	nop			; (mov r8, r8)
   1e4a0:	40000800 	.word	0x40000800
   1e4a4:	20003db0 	.word	0x20003db0
   1e4a8:	0001e29d 	.word	0x0001e29d
   1e4ac:	40000844 	.word	0x40000844

0001e4b0 <system_clock_init>:
 */
void system_clock_init(void)
{
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
   1e4b0:	22c2      	movs	r2, #194	; 0xc2
   1e4b2:	4b4a      	ldr	r3, [pc, #296]	; (1e5dc <system_clock_init+0x12c>)
   1e4b4:	00d2      	lsls	r2, r2, #3
{
   1e4b6:	b5f0      	push	{r4, r5, r6, r7, lr}
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
   1e4b8:	609a      	str	r2, [r3, #8]
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
   1e4ba:	221e      	movs	r2, #30
   1e4bc:	4948      	ldr	r1, [pc, #288]	; (1e5e0 <system_clock_init+0x130>)
	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
   1e4be:	2500      	movs	r5, #0
   1e4c0:	684b      	ldr	r3, [r1, #4]
{
   1e4c2:	b08d      	sub	sp, #52	; 0x34
   1e4c4:	4393      	bics	r3, r2
   1e4c6:	001a      	movs	r2, r3
   1e4c8:	2306      	movs	r3, #6
   1e4ca:	4313      	orrs	r3, r2
   1e4cc:	604b      	str	r3, [r1, #4]
	gclk_conf.source_generator = GCLK_GENERATOR_3;
   1e4ce:	2303      	movs	r3, #3
   1e4d0:	ac06      	add	r4, sp, #24
   1e4d2:	7023      	strb	r3, [r4, #0]
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
   1e4d4:	b2e8      	uxtb	r0, r5
   1e4d6:	0021      	movs	r1, r4
   1e4d8:	4b42      	ldr	r3, [pc, #264]	; (1e5e4 <system_clock_init+0x134>)
	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
   1e4da:	3501      	adds	r5, #1
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
   1e4dc:	4798      	blx	r3
	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
   1e4de:	2d25      	cmp	r5, #37	; 0x25
   1e4e0:	d1f8      	bne.n	1e4d4 <system_clock_init+0x24>
	config->run_in_standby  = false;
   1e4e2:	2500      	movs	r5, #0
	config->on_demand       = true;
   1e4e4:	2601      	movs	r6, #1
	config->run_in_standby  = false;
   1e4e6:	a802      	add	r0, sp, #8

	osc8m_conf.prescaler       = CONF_CLOCK_OSC8M_PRESCALER;
	osc8m_conf.on_demand       = CONF_CLOCK_OSC8M_ON_DEMAND;
	osc8m_conf.run_in_standby  = CONF_CLOCK_OSC8M_RUN_IN_STANDBY;

	system_clock_source_osc8m_set_config(&osc8m_conf);
   1e4e8:	4b3f      	ldr	r3, [pc, #252]	; (1e5e8 <system_clock_init+0x138>)
   1e4ea:	7045      	strb	r5, [r0, #1]
	config->on_demand       = true;
   1e4ec:	7086      	strb	r6, [r0, #2]
	osc8m_conf.prescaler       = CONF_CLOCK_OSC8M_PRESCALER;
   1e4ee:	7005      	strb	r5, [r0, #0]
	system_clock_source_osc8m_set_config(&osc8m_conf);
   1e4f0:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC8M);
   1e4f2:	4b3e      	ldr	r3, [pc, #248]	; (1e5ec <system_clock_init+0x13c>)
   1e4f4:	2006      	movs	r0, #6
   1e4f6:	4798      	blx	r3


	/* GCLK */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	system_gclk_init();
   1e4f8:	4b3d      	ldr	r3, [pc, #244]	; (1e5f0 <system_clock_init+0x140>)
   1e4fa:	4798      	blx	r3
	config->source_clock       = GCLK_SOURCE_OSC8M;
   1e4fc:	2306      	movs	r3, #6
   1e4fe:	7023      	strb	r3, [r4, #0]

	/* Configure all GCLK generators except for the main generator, which
	 * is configured later after all other clock systems are set up */
	MREPEAT(GCLK_GEN_NUM, _CONF_CLOCK_GCLK_CONFIG_NONMAIN, ~);
   1e500:	2308      	movs	r3, #8
   1e502:	0021      	movs	r1, r4
   1e504:	6063      	str	r3, [r4, #4]
   1e506:	0030      	movs	r0, r6
   1e508:	4b3a      	ldr	r3, [pc, #232]	; (1e5f4 <system_clock_init+0x144>)
	config->high_when_disabled = false;
   1e50a:	7065      	strb	r5, [r4, #1]
	config->run_in_standby     = false;
   1e50c:	7225      	strb	r5, [r4, #8]
	config->output_enable      = false;
   1e50e:	7265      	strb	r5, [r4, #9]
   1e510:	4798      	blx	r3
   1e512:	4f39      	ldr	r7, [pc, #228]	; (1e5f8 <system_clock_init+0x148>)
   1e514:	0030      	movs	r0, r6
   1e516:	47b8      	blx	r7
   1e518:	2303      	movs	r3, #3
   1e51a:	0021      	movs	r1, r4
   1e51c:	7023      	strb	r3, [r4, #0]
   1e51e:	2002      	movs	r0, #2
   1e520:	4b34      	ldr	r3, [pc, #208]	; (1e5f4 <system_clock_init+0x144>)
	config->division_factor    = 1;
   1e522:	6066      	str	r6, [r4, #4]
	config->high_when_disabled = false;
   1e524:	7065      	strb	r5, [r4, #1]
	config->output_enable      = false;
   1e526:	7265      	strb	r5, [r4, #9]
   1e528:	7226      	strb	r6, [r4, #8]
   1e52a:	4798      	blx	r3
   1e52c:	2002      	movs	r0, #2
   1e52e:	47b8      	blx	r7
   1e530:	2303      	movs	r3, #3
   1e532:	7023      	strb	r3, [r4, #0]
   1e534:	2320      	movs	r3, #32
   1e536:	0021      	movs	r1, r4
   1e538:	6063      	str	r3, [r4, #4]
   1e53a:	2004      	movs	r0, #4
   1e53c:	4b2d      	ldr	r3, [pc, #180]	; (1e5f4 <system_clock_init+0x144>)
	config->high_when_disabled = false;
   1e53e:	7065      	strb	r5, [r4, #1]
	config->run_in_standby     = false;
   1e540:	7225      	strb	r5, [r4, #8]
	config->output_enable      = false;
   1e542:	7265      	strb	r5, [r4, #9]
   1e544:	4798      	blx	r3
   1e546:	2004      	movs	r0, #4
   1e548:	47b8      	blx	r7
	config->source_clock       = GCLK_SOURCE_OSC8M;
   1e54a:	2306      	movs	r3, #6
   1e54c:	0021      	movs	r1, r4
   1e54e:	7023      	strb	r3, [r4, #0]
   1e550:	2005      	movs	r0, #5
   1e552:	4b28      	ldr	r3, [pc, #160]	; (1e5f4 <system_clock_init+0x144>)
	config->division_factor    = 1;
   1e554:	6066      	str	r6, [r4, #4]
	config->high_when_disabled = false;
   1e556:	7065      	strb	r5, [r4, #1]
	config->run_in_standby     = false;
   1e558:	7225      	strb	r5, [r4, #8]
	config->output_enable      = false;
   1e55a:	7265      	strb	r5, [r4, #9]
   1e55c:	4798      	blx	r3
   1e55e:	2005      	movs	r0, #5
   1e560:	47b8      	blx	r7
		system_gclk_chan_set_config(SYSCTRL_GCLK_ID_FDPLL32K, &dpll_gclk_chan_conf);
		system_gclk_chan_enable(SYSCTRL_GCLK_ID_FDPLL32K);
	}

	if (CONF_CLOCK_DPLL_REFERENCE_CLOCK == SYSTEM_CLOCK_SOURCE_DPLL_REFERENCE_CLOCK_GCLK) {
		dpll_gclk_chan_conf.source_generator = CONF_CLOCK_DPLL_REFERENCE_GCLK_GENERATOR;
   1e562:	a901      	add	r1, sp, #4
		system_gclk_chan_set_config(SYSCTRL_GCLK_ID_FDPLL, &dpll_gclk_chan_conf);
   1e564:	0030      	movs	r0, r6
   1e566:	4b1f      	ldr	r3, [pc, #124]	; (1e5e4 <system_clock_init+0x134>)
		dpll_gclk_chan_conf.source_generator = CONF_CLOCK_DPLL_REFERENCE_GCLK_GENERATOR;
   1e568:	700e      	strb	r6, [r1, #0]
		system_gclk_chan_set_config(SYSCTRL_GCLK_ID_FDPLL, &dpll_gclk_chan_conf);
   1e56a:	4798      	blx	r3
		system_gclk_chan_enable(SYSCTRL_GCLK_ID_FDPLL);
   1e56c:	0030      	movs	r0, r6
   1e56e:	4b23      	ldr	r3, [pc, #140]	; (1e5fc <system_clock_init+0x14c>)
   1e570:	4798      	blx	r3
	config->output_frequency    = 48000000;
   1e572:	4b23      	ldr	r3, [pc, #140]	; (1e600 <system_clock_init+0x150>)
	dpll_config.reference_clock     = CONF_CLOCK_DPLL_REFERENCE_CLOCK;
	dpll_config.reference_frequency = CONF_CLOCK_DPLL_REFERENCE_FREQUENCY;
	dpll_config.reference_divider   = CONF_CLOCK_DPLL_REFERENCE_DIVIDER;
	dpll_config.output_frequency    = CONF_CLOCK_DPLL_OUTPUT_FREQUENCY;

	system_clock_source_dpll_set_config(&dpll_config);
   1e574:	0020      	movs	r0, r4
   1e576:	60a3      	str	r3, [r4, #8]
	dpll_config.reference_clock     = CONF_CLOCK_DPLL_REFERENCE_CLOCK;
   1e578:	2302      	movs	r3, #2
   1e57a:	7523      	strb	r3, [r4, #20]
	dpll_config.reference_frequency = CONF_CLOCK_DPLL_REFERENCE_FREQUENCY;
   1e57c:	4b21      	ldr	r3, [pc, #132]	; (1e604 <system_clock_init+0x154>)
	config->run_in_standby      = false;
   1e57e:	7065      	strb	r5, [r4, #1]
   1e580:	60e3      	str	r3, [r4, #12]
	system_clock_source_dpll_set_config(&dpll_config);
   1e582:	4b21      	ldr	r3, [pc, #132]	; (1e608 <system_clock_init+0x158>)
	config->lock_bypass         = false;
   1e584:	70a5      	strb	r5, [r4, #2]
	config->wake_up_fast        = false;
   1e586:	70e5      	strb	r5, [r4, #3]
	config->low_power_enable    = false;
   1e588:	7125      	strb	r5, [r4, #4]
	config->reference_divider   = 1;
   1e58a:	8226      	strh	r6, [r4, #16]
	config->lock_time           = SYSTEM_CLOCK_SOURCE_DPLL_LOCK_TIME_DEFAULT;
   1e58c:	74e5      	strb	r5, [r4, #19]
	config->filter              = SYSTEM_CLOCK_SOURCE_DPLL_FILTER_DEFAULT;
   1e58e:	74a5      	strb	r5, [r4, #18]
	dpll_config.on_demand        = false;
   1e590:	7025      	strb	r5, [r4, #0]
	system_clock_source_dpll_set_config(&dpll_config);
   1e592:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DPLL);
   1e594:	4b15      	ldr	r3, [pc, #84]	; (1e5ec <system_clock_init+0x13c>)
   1e596:	2008      	movs	r0, #8
   1e598:	4798      	blx	r3
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_DPLL));
   1e59a:	2303      	movs	r3, #3
		return ((SYSCTRL->DPLLSTATUS.reg &
   1e59c:	491b      	ldr	r1, [pc, #108]	; (1e60c <system_clock_init+0x15c>)
   1e59e:	780a      	ldrb	r2, [r1, #0]
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_DPLL));
   1e5a0:	401a      	ands	r2, r3
   1e5a2:	2a03      	cmp	r2, #3
   1e5a4:	d1fb      	bne.n	1e59e <system_clock_init+0xee>
	if (CONF_CLOCK_DPLL_ON_DEMAND) {
		SYSCTRL->DPLLCTRLA.bit.ONDEMAND = 1;
   1e5a6:	2380      	movs	r3, #128	; 0x80
	PM->CPUSEL.reg = (uint32_t)divider;
   1e5a8:	2400      	movs	r4, #0
   1e5aa:	4a19      	ldr	r2, [pc, #100]	; (1e610 <system_clock_init+0x160>)
   1e5ac:	425b      	negs	r3, r3
   1e5ae:	7811      	ldrb	r1, [r2, #0]
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBC, CONF_CLOCK_APBC_DIVIDER);

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
   1e5b0:	0020      	movs	r0, r4
		SYSCTRL->DPLLCTRLA.bit.ONDEMAND = 1;
   1e5b2:	430b      	orrs	r3, r1
   1e5b4:	7013      	strb	r3, [r2, #0]
   1e5b6:	4b17      	ldr	r3, [pc, #92]	; (1e614 <system_clock_init+0x164>)
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
   1e5b8:	2208      	movs	r2, #8
   1e5ba:	721c      	strb	r4, [r3, #8]
			PM->APBASEL.reg = (uint32_t)divider;
   1e5bc:	725c      	strb	r4, [r3, #9]
			PM->APBBSEL.reg = (uint32_t)divider;
   1e5be:	729c      	strb	r4, [r3, #10]
			PM->APBCSEL.reg = (uint32_t)divider;
   1e5c0:	72dc      	strb	r4, [r3, #11]
	config->division_factor    = 1;
   1e5c2:	2301      	movs	r3, #1
   1e5c4:	a903      	add	r1, sp, #12
   1e5c6:	604b      	str	r3, [r1, #4]
   1e5c8:	724b      	strb	r3, [r1, #9]
   1e5ca:	4b0a      	ldr	r3, [pc, #40]	; (1e5f4 <system_clock_init+0x144>)
	config->high_when_disabled = false;
   1e5cc:	704c      	strb	r4, [r1, #1]
	config->run_in_standby     = false;
   1e5ce:	720c      	strb	r4, [r1, #8]
   1e5d0:	700a      	strb	r2, [r1, #0]
   1e5d2:	4798      	blx	r3
   1e5d4:	0020      	movs	r0, r4
   1e5d6:	47b8      	blx	r7
#endif
}
   1e5d8:	b00d      	add	sp, #52	; 0x34
   1e5da:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1e5dc:	40000800 	.word	0x40000800
   1e5e0:	41004000 	.word	0x41004000
   1e5e4:	0001e839 	.word	0x0001e839
   1e5e8:	0001e33d 	.word	0x0001e33d
   1e5ec:	0001e421 	.word	0x0001e421
   1e5f0:	0001e625 	.word	0x0001e625
   1e5f4:	0001e645 	.word	0x0001e645
   1e5f8:	0001e6e9 	.word	0x0001e6e9
   1e5fc:	0001e7b1 	.word	0x0001e7b1
   1e600:	02dc6c00 	.word	0x02dc6c00
   1e604:	000f4240 	.word	0x000f4240
   1e608:	0001e379 	.word	0x0001e379
   1e60c:	40000850 	.word	0x40000850
   1e610:	40000844 	.word	0x40000844
   1e614:	40000400 	.word	0x40000400

0001e618 <system_gclk_is_syncing>:
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
   1e618:	4b01      	ldr	r3, [pc, #4]	; (1e620 <system_gclk_is_syncing+0x8>)
   1e61a:	7858      	ldrb	r0, [r3, #1]
   1e61c:	09c0      	lsrs	r0, r0, #7
		return true;
	}

	return false;
}
   1e61e:	4770      	bx	lr
   1e620:	40000c00 	.word	0x40000c00

0001e624 <system_gclk_init>:
			PM->APBAMASK.reg |= mask;
   1e624:	2308      	movs	r3, #8
   1e626:	4a05      	ldr	r2, [pc, #20]	; (1e63c <system_gclk_init+0x18>)
   1e628:	6991      	ldr	r1, [r2, #24]
   1e62a:	430b      	orrs	r3, r1
   1e62c:	6193      	str	r3, [r2, #24]
{
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_GCLK);

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
   1e62e:	2301      	movs	r3, #1
   1e630:	4a03      	ldr	r2, [pc, #12]	; (1e640 <system_gclk_init+0x1c>)
   1e632:	7013      	strb	r3, [r2, #0]
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {
   1e634:	7811      	ldrb	r1, [r2, #0]
   1e636:	4219      	tst	r1, r3
   1e638:	d1fc      	bne.n	1e634 <system_gclk_init+0x10>
		/* Wait for reset to complete */
	}
}
   1e63a:	4770      	bx	lr
   1e63c:	40000400 	.word	0x40000400
   1e640:	40000c00 	.word	0x40000c00

0001e644 <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
   1e644:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
	uint32_t new_gendiv_config  = (generator << GCLK_GENDIV_ID_Pos);

	/* Select the requested source clock for the generator */
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
   1e646:	780c      	ldrb	r4, [r1, #0]

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
   1e648:	784b      	ldrb	r3, [r1, #1]
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
   1e64a:	0224      	lsls	r4, r4, #8
{
   1e64c:	0006      	movs	r6, r0
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
   1e64e:	0005      	movs	r5, r0
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
   1e650:	4304      	orrs	r4, r0
	if (config->high_when_disabled) {
   1e652:	2b00      	cmp	r3, #0
   1e654:	d002      	beq.n	1e65c <system_gclk_gen_set_config+0x18>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
   1e656:	2380      	movs	r3, #128	; 0x80
   1e658:	02db      	lsls	r3, r3, #11
   1e65a:	431c      	orrs	r4, r3
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
   1e65c:	7a4b      	ldrb	r3, [r1, #9]
   1e65e:	2b00      	cmp	r3, #0
   1e660:	d002      	beq.n	1e668 <system_gclk_gen_set_config+0x24>
		new_genctrl_config |= GCLK_GENCTRL_OE;
   1e662:	2380      	movs	r3, #128	; 0x80
   1e664:	031b      	lsls	r3, r3, #12
   1e666:	431c      	orrs	r4, r3
	}

	/* Set division factor */
	if (config->division_factor > 1) {
   1e668:	684b      	ldr	r3, [r1, #4]
   1e66a:	2b01      	cmp	r3, #1
   1e66c:	d912      	bls.n	1e694 <system_gclk_gen_set_config+0x50>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
   1e66e:	1e5d      	subs	r5, r3, #1
   1e670:	401d      	ands	r5, r3
   1e672:	2202      	movs	r2, #2
   1e674:	2d00      	cmp	r5, #0
   1e676:	d006      	beq.n	1e686 <system_gclk_gen_set_config+0x42>
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;
   1e678:	021d      	lsls	r5, r3, #8

			/* Enable non-binary division with increased duty cycle accuracy */
			new_genctrl_config |= GCLK_GENCTRL_IDC;
   1e67a:	2380      	movs	r3, #128	; 0x80
			new_gendiv_config  |=
   1e67c:	4335      	orrs	r5, r6
			new_genctrl_config |= GCLK_GENCTRL_IDC;
   1e67e:	029b      	lsls	r3, r3, #10
   1e680:	e007      	b.n	1e692 <system_gclk_gen_set_config+0x4e>
				div2_count++;
   1e682:	3501      	adds	r5, #1
						mask <<= 1) {
   1e684:	0052      	lsls	r2, r2, #1
			for (mask = (1UL << 1); mask < config->division_factor;
   1e686:	429a      	cmp	r2, r3
   1e688:	d3fb      	bcc.n	1e682 <system_gclk_gen_set_config+0x3e>
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
   1e68a:	2380      	movs	r3, #128	; 0x80
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
   1e68c:	022d      	lsls	r5, r5, #8
   1e68e:	4335      	orrs	r5, r6
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
   1e690:	035b      	lsls	r3, r3, #13
			new_genctrl_config |= GCLK_GENCTRL_IDC;
   1e692:	431c      	orrs	r4, r3
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
   1e694:	7a0b      	ldrb	r3, [r1, #8]
   1e696:	2b00      	cmp	r3, #0
   1e698:	d002      	beq.n	1e6a0 <system_gclk_gen_set_config+0x5c>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
   1e69a:	2380      	movs	r3, #128	; 0x80
   1e69c:	039b      	lsls	r3, r3, #14
   1e69e:	431c      	orrs	r4, r3
	}

	while (system_gclk_is_syncing()) {
   1e6a0:	4f0c      	ldr	r7, [pc, #48]	; (1e6d4 <system_gclk_gen_set_config+0x90>)
   1e6a2:	47b8      	blx	r7
   1e6a4:	2800      	cmp	r0, #0
   1e6a6:	d1fb      	bne.n	1e6a0 <system_gclk_gen_set_config+0x5c>
	cpu_irq_enter_critical();
   1e6a8:	4b0b      	ldr	r3, [pc, #44]	; (1e6d8 <system_gclk_gen_set_config+0x94>)
   1e6aa:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
   1e6ac:	4b0b      	ldr	r3, [pc, #44]	; (1e6dc <system_gclk_gen_set_config+0x98>)
   1e6ae:	701e      	strb	r6, [r3, #0]

	/* Write the new generator configuration */
	while (system_gclk_is_syncing()) {
   1e6b0:	47b8      	blx	r7
   1e6b2:	2800      	cmp	r0, #0
   1e6b4:	d1fc      	bne.n	1e6b0 <system_gclk_gen_set_config+0x6c>
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;
   1e6b6:	4b0a      	ldr	r3, [pc, #40]	; (1e6e0 <system_gclk_gen_set_config+0x9c>)
   1e6b8:	609d      	str	r5, [r3, #8]
   1e6ba:	001d      	movs	r5, r3

	while (system_gclk_is_syncing()) {
   1e6bc:	47b8      	blx	r7
   1e6be:	2800      	cmp	r0, #0
   1e6c0:	d1fc      	bne.n	1e6bc <system_gclk_gen_set_config+0x78>
		/* Wait for synchronization */
	};
	GCLK->GENCTRL.reg = new_genctrl_config | (GCLK->GENCTRL.reg & GCLK_GENCTRL_GENEN);
   1e6c2:	2280      	movs	r2, #128	; 0x80
   1e6c4:	686b      	ldr	r3, [r5, #4]
   1e6c6:	0252      	lsls	r2, r2, #9
   1e6c8:	4013      	ands	r3, r2
   1e6ca:	431c      	orrs	r4, r3
   1e6cc:	606c      	str	r4, [r5, #4]
	cpu_irq_leave_critical();
   1e6ce:	4b05      	ldr	r3, [pc, #20]	; (1e6e4 <system_gclk_gen_set_config+0xa0>)
   1e6d0:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
   1e6d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1e6d4:	0001e619 	.word	0x0001e619
   1e6d8:	0001ce85 	.word	0x0001ce85
   1e6dc:	40000c08 	.word	0x40000c08
   1e6e0:	40000c00 	.word	0x40000c00
   1e6e4:	0001ceb9 	.word	0x0001ceb9

0001e6e8 <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
   1e6e8:	b570      	push	{r4, r5, r6, lr}
   1e6ea:	0005      	movs	r5, r0
	while (system_gclk_is_syncing()) {
   1e6ec:	4c09      	ldr	r4, [pc, #36]	; (1e714 <system_gclk_gen_enable+0x2c>)
   1e6ee:	47a0      	blx	r4
   1e6f0:	2800      	cmp	r0, #0
   1e6f2:	d1fb      	bne.n	1e6ec <system_gclk_gen_enable+0x4>
	cpu_irq_enter_critical();
   1e6f4:	4b08      	ldr	r3, [pc, #32]	; (1e718 <system_gclk_gen_enable+0x30>)
   1e6f6:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
   1e6f8:	4b08      	ldr	r3, [pc, #32]	; (1e71c <system_gclk_gen_enable+0x34>)
   1e6fa:	701d      	strb	r5, [r3, #0]
	while (system_gclk_is_syncing()) {
   1e6fc:	47a0      	blx	r4
   1e6fe:	2800      	cmp	r0, #0
   1e700:	d1fc      	bne.n	1e6fc <system_gclk_gen_enable+0x14>
		/* Wait for synchronization */
	};

	/* Enable generator */
	GCLK->GENCTRL.reg |= GCLK_GENCTRL_GENEN;
   1e702:	2380      	movs	r3, #128	; 0x80
   1e704:	4a06      	ldr	r2, [pc, #24]	; (1e720 <system_gclk_gen_enable+0x38>)
   1e706:	025b      	lsls	r3, r3, #9
   1e708:	6851      	ldr	r1, [r2, #4]
   1e70a:	430b      	orrs	r3, r1
   1e70c:	6053      	str	r3, [r2, #4]
	cpu_irq_leave_critical();
   1e70e:	4b05      	ldr	r3, [pc, #20]	; (1e724 <system_gclk_gen_enable+0x3c>)
   1e710:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
   1e712:	bd70      	pop	{r4, r5, r6, pc}
   1e714:	0001e619 	.word	0x0001e619
   1e718:	0001ce85 	.word	0x0001ce85
   1e71c:	40000c04 	.word	0x40000c04
   1e720:	40000c00 	.word	0x40000c00
   1e724:	0001ceb9 	.word	0x0001ceb9

0001e728 <system_gclk_gen_get_hz>:
 *
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
   1e728:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1e72a:	0007      	movs	r7, r0
	while (system_gclk_is_syncing()) {
   1e72c:	4e18      	ldr	r6, [pc, #96]	; (1e790 <system_gclk_gen_get_hz+0x68>)
   1e72e:	47b0      	blx	r6
   1e730:	2800      	cmp	r0, #0
   1e732:	d1fb      	bne.n	1e72c <system_gclk_gen_get_hz+0x4>
	cpu_irq_enter_critical();
   1e734:	4b17      	ldr	r3, [pc, #92]	; (1e794 <system_gclk_gen_get_hz+0x6c>)
   1e736:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
   1e738:	4b17      	ldr	r3, [pc, #92]	; (1e798 <system_gclk_gen_get_hz+0x70>)
   1e73a:	701f      	strb	r7, [r3, #0]
   1e73c:	9301      	str	r3, [sp, #4]
	while (system_gclk_is_syncing()) {
   1e73e:	47b0      	blx	r6
   1e740:	2800      	cmp	r0, #0
   1e742:	d1fc      	bne.n	1e73e <system_gclk_gen_get_hz+0x16>
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);
   1e744:	4d15      	ldr	r5, [pc, #84]	; (1e79c <system_gclk_gen_get_hz+0x74>)
	uint32_t gen_input_hz = system_clock_source_get_hz(
   1e746:	4b16      	ldr	r3, [pc, #88]	; (1e7a0 <system_gclk_gen_get_hz+0x78>)
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);
   1e748:	6868      	ldr	r0, [r5, #4]
   1e74a:	04c0      	lsls	r0, r0, #19
   1e74c:	0ec0      	lsrs	r0, r0, #27
	uint32_t gen_input_hz = system_clock_source_get_hz(
   1e74e:	4798      	blx	r3
   1e750:	0004      	movs	r4, r0

	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
   1e752:	9b01      	ldr	r3, [sp, #4]
   1e754:	701f      	strb	r7, [r3, #0]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;
   1e756:	686b      	ldr	r3, [r5, #4]
   1e758:	02db      	lsls	r3, r3, #11
   1e75a:	0fdb      	lsrs	r3, r3, #31
   1e75c:	9301      	str	r3, [sp, #4]

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
   1e75e:	4b11      	ldr	r3, [pc, #68]	; (1e7a4 <system_gclk_gen_get_hz+0x7c>)
   1e760:	701f      	strb	r7, [r3, #0]
	while (system_gclk_is_syncing()) {
   1e762:	47b0      	blx	r6
   1e764:	2800      	cmp	r0, #0
   1e766:	d1fc      	bne.n	1e762 <system_gclk_gen_get_hz+0x3a>
		/* Wait for synchronization */
	};

	uint32_t divider = GCLK->GENDIV.bit.DIV;
   1e768:	68ad      	ldr	r5, [r5, #8]
	cpu_irq_leave_critical();
   1e76a:	4b0f      	ldr	r3, [pc, #60]	; (1e7a8 <system_gclk_gen_get_hz+0x80>)
   1e76c:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Check if the generator is using fractional or binary division */
	if (!divsel && divider > 1) {
   1e76e:	9b01      	ldr	r3, [sp, #4]
	uint32_t divider = GCLK->GENDIV.bit.DIV;
   1e770:	022d      	lsls	r5, r5, #8
   1e772:	0c2d      	lsrs	r5, r5, #16
	if (!divsel && divider > 1) {
   1e774:	2b00      	cmp	r3, #0
   1e776:	d108      	bne.n	1e78a <system_gclk_gen_get_hz+0x62>
   1e778:	2d01      	cmp	r5, #1
   1e77a:	d904      	bls.n	1e786 <system_gclk_gen_get_hz+0x5e>
		gen_input_hz /= divider;
   1e77c:	0020      	movs	r0, r4
   1e77e:	0029      	movs	r1, r5
   1e780:	4b0a      	ldr	r3, [pc, #40]	; (1e7ac <system_gclk_gen_get_hz+0x84>)
   1e782:	4798      	blx	r3
   1e784:	0004      	movs	r4, r0
	} else if (divsel) {
		gen_input_hz >>= (divider+1);
	}

	return gen_input_hz;
}
   1e786:	0020      	movs	r0, r4
   1e788:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		gen_input_hz >>= (divider+1);
   1e78a:	3501      	adds	r5, #1
   1e78c:	40ec      	lsrs	r4, r5
	return gen_input_hz;
   1e78e:	e7fa      	b.n	1e786 <system_gclk_gen_get_hz+0x5e>
   1e790:	0001e619 	.word	0x0001e619
   1e794:	0001ce85 	.word	0x0001ce85
   1e798:	40000c04 	.word	0x40000c04
   1e79c:	40000c00 	.word	0x40000c00
   1e7a0:	0001e2ad 	.word	0x0001e2ad
   1e7a4:	40000c08 	.word	0x40000c08
   1e7a8:	0001ceb9 	.word	0x0001ceb9
   1e7ac:	000258bd 	.word	0x000258bd

0001e7b0 <system_gclk_chan_enable>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_enable(
		const uint8_t channel)
{
   1e7b0:	b510      	push	{r4, lr}
   1e7b2:	0004      	movs	r4, r0
	cpu_irq_enter_critical();
   1e7b4:	4b06      	ldr	r3, [pc, #24]	; (1e7d0 <system_gclk_chan_enable+0x20>)
   1e7b6:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
   1e7b8:	4b06      	ldr	r3, [pc, #24]	; (1e7d4 <system_gclk_chan_enable+0x24>)

	/* Enable the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
   1e7ba:	4a07      	ldr	r2, [pc, #28]	; (1e7d8 <system_gclk_chan_enable+0x28>)
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
   1e7bc:	701c      	strb	r4, [r3, #0]
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
   1e7be:	2380      	movs	r3, #128	; 0x80
   1e7c0:	8851      	ldrh	r1, [r2, #2]
   1e7c2:	01db      	lsls	r3, r3, #7
   1e7c4:	430b      	orrs	r3, r1
   1e7c6:	8053      	strh	r3, [r2, #2]
	cpu_irq_leave_critical();
   1e7c8:	4b04      	ldr	r3, [pc, #16]	; (1e7dc <system_gclk_chan_enable+0x2c>)
   1e7ca:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
   1e7cc:	bd10      	pop	{r4, pc}
   1e7ce:	46c0      	nop			; (mov r8, r8)
   1e7d0:	0001ce85 	.word	0x0001ce85
   1e7d4:	40000c02 	.word	0x40000c02
   1e7d8:	40000c00 	.word	0x40000c00
   1e7dc:	0001ceb9 	.word	0x0001ceb9

0001e7e0 <system_gclk_chan_disable>:
 *
 * \param[in] channel  Generic Clock channel to disable
 */
void system_gclk_chan_disable(
		const uint8_t channel)
{
   1e7e0:	b510      	push	{r4, lr}
   1e7e2:	0004      	movs	r4, r0
	cpu_irq_enter_critical();
   1e7e4:	4b0e      	ldr	r3, [pc, #56]	; (1e820 <system_gclk_chan_disable+0x40>)
   1e7e6:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
   1e7e8:	4b0e      	ldr	r3, [pc, #56]	; (1e824 <system_gclk_chan_disable+0x44>)
	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
	GCLK->CLKCTRL.bit.GEN = 0;
   1e7ea:	4a0f      	ldr	r2, [pc, #60]	; (1e828 <system_gclk_chan_disable+0x48>)
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
   1e7ec:	701c      	strb	r4, [r3, #0]
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
   1e7ee:	4b0f      	ldr	r3, [pc, #60]	; (1e82c <system_gclk_chan_disable+0x4c>)

	/* Disable the generic clock */
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
   1e7f0:	4c0f      	ldr	r4, [pc, #60]	; (1e830 <system_gclk_chan_disable+0x50>)
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
   1e7f2:	8858      	ldrh	r0, [r3, #2]
	GCLK->CLKCTRL.bit.GEN = 0;
   1e7f4:	8859      	ldrh	r1, [r3, #2]
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
   1e7f6:	0500      	lsls	r0, r0, #20
	GCLK->CLKCTRL.bit.GEN = 0;
   1e7f8:	4011      	ands	r1, r2
   1e7fa:	8059      	strh	r1, [r3, #2]
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
   1e7fc:	8859      	ldrh	r1, [r3, #2]
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
   1e7fe:	0f00      	lsrs	r0, r0, #28
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
   1e800:	4021      	ands	r1, r4
   1e802:	8059      	strh	r1, [r3, #2]
   1e804:	0011      	movs	r1, r2
	while (GCLK->CLKCTRL.reg & GCLK_CLKCTRL_CLKEN) {
   1e806:	2280      	movs	r2, #128	; 0x80
   1e808:	01d2      	lsls	r2, r2, #7
   1e80a:	885c      	ldrh	r4, [r3, #2]
   1e80c:	4214      	tst	r4, r2
   1e80e:	d1fc      	bne.n	1e80a <system_gclk_chan_disable+0x2a>
		/* Wait for clock to become disabled */
	}

	/* Restore previous configured clock generator */
	GCLK->CLKCTRL.bit.GEN = prev_gen_id;
   1e810:	885a      	ldrh	r2, [r3, #2]
   1e812:	0200      	lsls	r0, r0, #8
   1e814:	400a      	ands	r2, r1
   1e816:	4302      	orrs	r2, r0
   1e818:	805a      	strh	r2, [r3, #2]
	cpu_irq_leave_critical();
   1e81a:	4b06      	ldr	r3, [pc, #24]	; (1e834 <system_gclk_chan_disable+0x54>)
   1e81c:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
   1e81e:	bd10      	pop	{r4, pc}
   1e820:	0001ce85 	.word	0x0001ce85
   1e824:	40000c02 	.word	0x40000c02
   1e828:	fffff0ff 	.word	0xfffff0ff
   1e82c:	40000c00 	.word	0x40000c00
   1e830:	ffffbfff 	.word	0xffffbfff
   1e834:	0001ceb9 	.word	0x0001ceb9

0001e838 <system_gclk_chan_set_config>:
{
   1e838:	b510      	push	{r4, lr}
	new_clkctrl_config |= config->source_generator << GCLK_CLKCTRL_GEN_Pos;
   1e83a:	780c      	ldrb	r4, [r1, #0]
	system_gclk_chan_disable(channel);
   1e83c:	4b03      	ldr	r3, [pc, #12]	; (1e84c <system_gclk_chan_set_config+0x14>)
	new_clkctrl_config |= config->source_generator << GCLK_CLKCTRL_GEN_Pos;
   1e83e:	0224      	lsls	r4, r4, #8
   1e840:	4304      	orrs	r4, r0
	system_gclk_chan_disable(channel);
   1e842:	4798      	blx	r3
	GCLK->CLKCTRL.reg = new_clkctrl_config;
   1e844:	4b02      	ldr	r3, [pc, #8]	; (1e850 <system_gclk_chan_set_config+0x18>)
   1e846:	b2a4      	uxth	r4, r4
   1e848:	805c      	strh	r4, [r3, #2]
}
   1e84a:	bd10      	pop	{r4, pc}
   1e84c:	0001e7e1 	.word	0x0001e7e1
   1e850:	40000c00 	.word	0x40000c00

0001e854 <system_gclk_chan_get_hz>:
 *
 * \return The frequency of the generic clock channel, in Hz.
 */
uint32_t system_gclk_chan_get_hz(
		const uint8_t channel)
{
   1e854:	b510      	push	{r4, lr}
   1e856:	0004      	movs	r4, r0
	cpu_irq_enter_critical();
   1e858:	4b06      	ldr	r3, [pc, #24]	; (1e874 <system_gclk_chan_get_hz+0x20>)
   1e85a:	4798      	blx	r3
	uint8_t gen_id;

	system_interrupt_enter_critical_section();

	/* Select the requested generic clock channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
   1e85c:	4b06      	ldr	r3, [pc, #24]	; (1e878 <system_gclk_chan_get_hz+0x24>)
   1e85e:	701c      	strb	r4, [r3, #0]
	gen_id = GCLK->CLKCTRL.bit.GEN;
   1e860:	4b06      	ldr	r3, [pc, #24]	; (1e87c <system_gclk_chan_get_hz+0x28>)
   1e862:	885c      	ldrh	r4, [r3, #2]
	cpu_irq_leave_critical();
   1e864:	4b06      	ldr	r3, [pc, #24]	; (1e880 <system_gclk_chan_get_hz+0x2c>)
   1e866:	0524      	lsls	r4, r4, #20
   1e868:	0f24      	lsrs	r4, r4, #28
   1e86a:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Return the clock speed of the associated GCLK generator */
	return system_gclk_gen_get_hz(gen_id);
   1e86c:	0020      	movs	r0, r4
   1e86e:	4b05      	ldr	r3, [pc, #20]	; (1e884 <system_gclk_chan_get_hz+0x30>)
   1e870:	4798      	blx	r3
}
   1e872:	bd10      	pop	{r4, pc}
   1e874:	0001ce85 	.word	0x0001ce85
   1e878:	40000c02 	.word	0x40000c02
   1e87c:	40000c00 	.word	0x40000c00
   1e880:	0001ceb9 	.word	0x0001ceb9
   1e884:	0001e729 	.word	0x0001e729

0001e888 <system_interrupt_clear_pending>:
enum status_code system_interrupt_clear_pending(
		const enum system_interrupt_vector vector)
{
	enum status_code status = STATUS_OK;

	if (vector >= _SYSTEM_INTERRUPT_EXTERNAL_VECTOR_START) {
   1e888:	2800      	cmp	r0, #0
   1e88a:	db08      	blt.n	1e89e <system_interrupt_clear_pending+0x16>
		NVIC->ICPR[0] = (1 << vector);
   1e88c:	2301      	movs	r3, #1
   1e88e:	22c0      	movs	r2, #192	; 0xc0
   1e890:	4083      	lsls	r3, r0
   1e892:	4907      	ldr	r1, [pc, #28]	; (1e8b0 <system_interrupt_clear_pending+0x28>)
   1e894:	0052      	lsls	r2, r2, #1
   1e896:	508b      	str	r3, [r1, r2]
	enum status_code status = STATUS_OK;
   1e898:	2300      	movs	r3, #0
		Assert(false);
		status = STATUS_ERR_INVALID_ARG;
	}

	return status;
}
   1e89a:	0018      	movs	r0, r3
   1e89c:	4770      	bx	lr
		status = STATUS_ERR_INVALID_ARG;
   1e89e:	2317      	movs	r3, #23
	} else if (vector == SYSTEM_INTERRUPT_SYSTICK) {
   1e8a0:	1c42      	adds	r2, r0, #1
   1e8a2:	d1fa      	bne.n	1e89a <system_interrupt_clear_pending+0x12>
		SCB->ICSR = SCB_ICSR_PENDSTCLR_Msk;
   1e8a4:	2280      	movs	r2, #128	; 0x80
   1e8a6:	4b03      	ldr	r3, [pc, #12]	; (1e8b4 <system_interrupt_clear_pending+0x2c>)
   1e8a8:	0492      	lsls	r2, r2, #18
   1e8aa:	605a      	str	r2, [r3, #4]
   1e8ac:	e7f4      	b.n	1e898 <system_interrupt_clear_pending+0x10>
   1e8ae:	46c0      	nop			; (mov r8, r8)
   1e8b0:	e000e100 	.word	0xe000e100
   1e8b4:	e000ed00 	.word	0xe000ed00

0001e8b8 <_system_pinmux_config>:

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
   1e8b8:	78d3      	ldrb	r3, [r2, #3]
{
   1e8ba:	b530      	push	{r4, r5, lr}
	if (!config->powersave) {
   1e8bc:	2b00      	cmp	r3, #0
   1e8be:	d135      	bne.n	1e92c <_system_pinmux_config+0x74>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
   1e8c0:	7814      	ldrb	r4, [r2, #0]
   1e8c2:	2c80      	cmp	r4, #128	; 0x80
   1e8c4:	d003      	beq.n	1e8ce <_system_pinmux_config+0x16>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
   1e8c6:	2380      	movs	r3, #128	; 0x80
   1e8c8:	0624      	lsls	r4, r4, #24
   1e8ca:	025b      	lsls	r3, r3, #9
   1e8cc:	4323      	orrs	r3, r4
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
   1e8ce:	2502      	movs	r5, #2
   1e8d0:	7854      	ldrb	r4, [r2, #1]
   1e8d2:	43ac      	bics	r4, r5
   1e8d4:	d106      	bne.n	1e8e4 <_system_pinmux_config+0x2c>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
   1e8d6:	7894      	ldrb	r4, [r2, #2]
   1e8d8:	2c00      	cmp	r4, #0
   1e8da:	d124      	bne.n	1e926 <_system_pinmux_config+0x6e>
			pin_cfg |= PORT_WRCONFIG_INEN;
   1e8dc:	2480      	movs	r4, #128	; 0x80
   1e8de:	02a4      	lsls	r4, r4, #10
				pin_cfg |= PORT_WRCONFIG_PULLEN;
   1e8e0:	4323      	orrs	r3, r4
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
   1e8e2:	6041      	str	r1, [r0, #4]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
   1e8e4:	7854      	ldrb	r4, [r2, #1]
   1e8e6:	3c01      	subs	r4, #1
   1e8e8:	2c01      	cmp	r4, #1
   1e8ea:	d801      	bhi.n	1e8f0 <_system_pinmux_config+0x38>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Cannot use a pull-up if the output driver is enabled,
			 * if requested the input buffer can only sample the current
			 * output state */
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
   1e8ec:	4c12      	ldr	r4, [pc, #72]	; (1e938 <_system_pinmux_config+0x80>)
   1e8ee:	4023      	ands	r3, r4

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
   1e8f0:	24a0      	movs	r4, #160	; 0xa0
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
   1e8f2:	b28d      	uxth	r5, r1
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
   1e8f4:	05e4      	lsls	r4, r4, #23
   1e8f6:	432c      	orrs	r4, r5
   1e8f8:	431c      	orrs	r4, r3
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
   1e8fa:	6284      	str	r4, [r0, #40]	; 0x28

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
   1e8fc:	24d0      	movs	r4, #208	; 0xd0
	uint32_t upper_pin_mask = (pin_mask >> 16);
   1e8fe:	0c0d      	lsrs	r5, r1, #16
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
   1e900:	0624      	lsls	r4, r4, #24
   1e902:	432c      	orrs	r4, r5
   1e904:	431c      	orrs	r4, r3
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
   1e906:	6284      	str	r4, [r0, #40]	; 0x28
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
   1e908:	78d4      	ldrb	r4, [r2, #3]
   1e90a:	2c00      	cmp	r4, #0
   1e90c:	d10a      	bne.n	1e924 <_system_pinmux_config+0x6c>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
   1e90e:	035b      	lsls	r3, r3, #13
   1e910:	d503      	bpl.n	1e91a <_system_pinmux_config+0x62>
			/* Set the OUT register bits to enable the pull-up if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
   1e912:	7893      	ldrb	r3, [r2, #2]
   1e914:	2b01      	cmp	r3, #1
   1e916:	d10c      	bne.n	1e932 <_system_pinmux_config+0x7a>
				port->OUTSET.reg = pin_mask;
   1e918:	6181      	str	r1, [r0, #24]
				port->OUTCLR.reg = pin_mask;
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
   1e91a:	7853      	ldrb	r3, [r2, #1]
   1e91c:	3b01      	subs	r3, #1
   1e91e:	2b01      	cmp	r3, #1
   1e920:	d800      	bhi.n	1e924 <_system_pinmux_config+0x6c>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
   1e922:	6081      	str	r1, [r0, #8]
		}
	}
}
   1e924:	bd30      	pop	{r4, r5, pc}
				pin_cfg |= PORT_WRCONFIG_PULLEN;
   1e926:	24c0      	movs	r4, #192	; 0xc0
   1e928:	02e4      	lsls	r4, r4, #11
   1e92a:	e7d9      	b.n	1e8e0 <_system_pinmux_config+0x28>
		port->DIRCLR.reg = pin_mask;
   1e92c:	6041      	str	r1, [r0, #4]
	uint32_t pin_cfg = 0;
   1e92e:	2300      	movs	r3, #0
   1e930:	e7de      	b.n	1e8f0 <_system_pinmux_config+0x38>
				port->OUTCLR.reg = pin_mask;
   1e932:	6141      	str	r1, [r0, #20]
   1e934:	e7f1      	b.n	1e91a <_system_pinmux_config+0x62>
   1e936:	46c0      	nop			; (mov r8, r8)
   1e938:	fffbffff 	.word	0xfffbffff

0001e93c <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
   1e93c:	b510      	push	{r4, lr}
   1e93e:	0003      	movs	r3, r0
   1e940:	000a      	movs	r2, r1
	uint8_t group_index = (gpio_pin / 32);
   1e942:	0944      	lsrs	r4, r0, #5
	if (port_index < PORT_INST_NUM) {
   1e944:	09c1      	lsrs	r1, r0, #7
		return NULL;
   1e946:	2000      	movs	r0, #0
	if (port_index < PORT_INST_NUM) {
   1e948:	4281      	cmp	r1, r0
   1e94a:	d102      	bne.n	1e952 <system_pinmux_pin_set_config+0x16>
		return &(ports[port_index]->Group[group_index]);
   1e94c:	4904      	ldr	r1, [pc, #16]	; (1e960 <system_pinmux_pin_set_config+0x24>)
   1e94e:	01e0      	lsls	r0, r4, #7
   1e950:	1840      	adds	r0, r0, r1
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask = (1UL << (gpio_pin % 32));
   1e952:	211f      	movs	r1, #31
   1e954:	400b      	ands	r3, r1
   1e956:	391e      	subs	r1, #30
   1e958:	4099      	lsls	r1, r3

	_system_pinmux_config(port, pin_mask, config);
   1e95a:	4b02      	ldr	r3, [pc, #8]	; (1e964 <system_pinmux_pin_set_config+0x28>)
   1e95c:	4798      	blx	r3
}
   1e95e:	bd10      	pop	{r4, pc}
   1e960:	41004400 	.word	0x41004400
   1e964:	0001e8b9 	.word	0x0001e8b9

0001e968 <_system_dummy_init>:
 */
void _system_dummy_init(void);
void _system_dummy_init(void)
{
	return;
}
   1e968:	4770      	bx	lr
	...

0001e96c <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
   1e96c:	b510      	push	{r4, lr}
	/* Configure GCLK and clock sources according to conf_clocks.h */
	system_clock_init();
   1e96e:	4b05      	ldr	r3, [pc, #20]	; (1e984 <system_init+0x18>)
   1e970:	4798      	blx	r3

	/* Initialize board hardware */
	system_board_init();
   1e972:	4b05      	ldr	r3, [pc, #20]	; (1e988 <system_init+0x1c>)
   1e974:	4798      	blx	r3

	/* Initialize EVSYS hardware */
	_system_events_init();
   1e976:	4b05      	ldr	r3, [pc, #20]	; (1e98c <system_init+0x20>)
   1e978:	4798      	blx	r3

	/* Initialize External hardware */
	_system_extint_init();
   1e97a:	4b05      	ldr	r3, [pc, #20]	; (1e990 <system_init+0x24>)
   1e97c:	4798      	blx	r3
	
	/* Initialize DIVAS hardware */
	_system_divas_init();
   1e97e:	4b05      	ldr	r3, [pc, #20]	; (1e994 <system_init+0x28>)
   1e980:	4798      	blx	r3
}
   1e982:	bd10      	pop	{r4, pc}
   1e984:	0001e4b1 	.word	0x0001e4b1
   1e988:	0001cee9 	.word	0x0001cee9
   1e98c:	00012331 	.word	0x00012331
   1e990:	0001cff1 	.word	0x0001cff1
   1e994:	0001e969 	.word	0x0001e969

0001e998 <_tcc_get_inst_index>:
uint8_t _tcc_get_inst_index(
		Tcc *const hw)
{
	/* Find index for TCC instance. */
	for (uint32_t i = 0; i < TCC_INST_NUM; i++) {
		if (hw == tcc_modules[i]) {
   1e998:	4a08      	ldr	r2, [pc, #32]	; (1e9bc <_tcc_get_inst_index+0x24>)
{
   1e99a:	0003      	movs	r3, r0
		if (hw == tcc_modules[i]) {
   1e99c:	4290      	cmp	r0, r2
   1e99e:	d009      	beq.n	1e9b4 <_tcc_get_inst_index+0x1c>
   1e9a0:	4a07      	ldr	r2, [pc, #28]	; (1e9c0 <_tcc_get_inst_index+0x28>)
   1e9a2:	4290      	cmp	r0, r2
   1e9a4:	d008      	beq.n	1e9b8 <_tcc_get_inst_index+0x20>
   1e9a6:	4a07      	ldr	r2, [pc, #28]	; (1e9c4 <_tcc_get_inst_index+0x2c>)
		}
	}

	/* Invalid data given. */
	Assert(false);
	return 0;
   1e9a8:	2000      	movs	r0, #0
		if (hw == tcc_modules[i]) {
   1e9aa:	4293      	cmp	r3, r2
   1e9ac:	d101      	bne.n	1e9b2 <_tcc_get_inst_index+0x1a>
	for (uint32_t i = 0; i < TCC_INST_NUM; i++) {
   1e9ae:	3002      	adds	r0, #2
			return i;
   1e9b0:	b2c0      	uxtb	r0, r0
}
   1e9b2:	4770      	bx	lr
	for (uint32_t i = 0; i < TCC_INST_NUM; i++) {
   1e9b4:	2000      	movs	r0, #0
   1e9b6:	e7fb      	b.n	1e9b0 <_tcc_get_inst_index+0x18>
   1e9b8:	2001      	movs	r0, #1
   1e9ba:	e7f9      	b.n	1e9b0 <_tcc_get_inst_index+0x18>
   1e9bc:	42002000 	.word	0x42002000
   1e9c0:	42002400 	.word	0x42002400
   1e9c4:	42002800 	.word	0x42002800

0001e9c8 <tcc_get_config_defaults>:
 *
 */
void tcc_get_config_defaults(
		struct tcc_config *const config,
		Tcc *const hw)
{
   1e9c8:	b510      	push	{r4, lr}
	/* TCC instance index */
	uint8_t module_index = _tcc_get_inst_index(hw);
   1e9ca:	4b3a      	ldr	r3, [pc, #232]	; (1eab4 <tcc_get_config_defaults+0xec>)
{
   1e9cc:	0004      	movs	r4, r0
	uint8_t module_index = _tcc_get_inst_index(hw);
   1e9ce:	0008      	movs	r0, r1
   1e9d0:	4798      	blx	r3

	/* Base counter defaults */
	config->counter.count                  = 0;

	config->counter.period                 = _tcc_maxs[module_index];
   1e9d2:	4a39      	ldr	r2, [pc, #228]	; (1eab8 <tcc_get_config_defaults+0xf0>)
   1e9d4:	0080      	lsls	r0, r0, #2
   1e9d6:	5882      	ldr	r2, [r0, r2]
	config->counter.count                  = 0;
   1e9d8:	2300      	movs	r3, #0
	config->counter.period                 = _tcc_maxs[module_index];
   1e9da:	6062      	str	r2, [r4, #4]
		config->wave_ext.recoverable_fault[n].source = TCC_FAULT_SOURCE_DISABLE;           \
		config->wave_ext.recoverable_fault[n].blanking = TCC_FAULT_BLANKING_DISABLE;       \
		config->wave_ext.recoverable_fault[n].halt_action = TCC_FAULT_HALT_ACTION_DISABLE; \
		config->wave_ext.recoverable_fault[n].capture_action = TCC_FAULT_CAPTURE_DISABLE;  \
		config->wave_ext.recoverable_fault[n].capture_channel = TCC_FAULT_CAPTURE_CHANNEL_0;
	MREPEAT(TCC_NUM_FAULTS, _TCC_FAULT_FUNCTION_INIT, 0)
   1e9dc:	0022      	movs	r2, r4

	/* Non-recoverable fault defaults */
#  define _TCC_NRF_FUNCTION_INIT(n, dummy) \
		config->wave_ext.non_recoverable_fault[n].filter_value = 0; \
		config->wave_ext.non_recoverable_fault[n].output = TCC_FAULT_STATE_OUTPUT_OFF;
	MREPEAT(TCC_NUM_WAVE_OUTPUTS, _TCC_NRF_FUNCTION_INIT, 0)
   1e9de:	0020      	movs	r0, r4
	MREPEAT(TCC_NUM_FAULTS, _TCC_FAULT_FUNCTION_INIT, 0)
   1e9e0:	322c      	adds	r2, #44	; 0x2c
	MREPEAT(TCC_NUM_WAVE_OUTPUTS, _TCC_NRF_FUNCTION_INIT, 0)
   1e9e2:	3048      	adds	r0, #72	; 0x48
	config->counter.count                  = 0;
   1e9e4:	6023      	str	r3, [r4, #0]
	config->counter.clock_source           = GCLK_GENERATOR_0;
   1e9e6:	72a3      	strb	r3, [r4, #10]
	config->counter.clock_prescaler        = TCC_CLOCK_PRESCALER_DIV1;
   1e9e8:	72e3      	strb	r3, [r4, #11]
	config->counter.reload_action          = TCC_RELOAD_ACTION_GCLK;
   1e9ea:	7323      	strb	r3, [r4, #12]
	config->counter.direction              = TCC_COUNT_DIRECTION_UP;
   1e9ec:	7263      	strb	r3, [r4, #9]
	config->counter.oneshot                = false;
   1e9ee:	7223      	strb	r3, [r4, #8]
	MREPEAT(TCC_NUM_CHANNELS,
   1e9f0:	61e3      	str	r3, [r4, #28]
   1e9f2:	6223      	str	r3, [r4, #32]
   1e9f4:	6263      	str	r3, [r4, #36]	; 0x24
   1e9f6:	62a3      	str	r3, [r4, #40]	; 0x28
	MREPEAT(TCC_NUM_CHANNELS,
   1e9f8:	7523      	strb	r3, [r4, #20]
   1e9fa:	7563      	strb	r3, [r4, #21]
   1e9fc:	75a3      	strb	r3, [r4, #22]
   1e9fe:	75e3      	strb	r3, [r4, #23]
	config->compare.wave_generation = TCC_WAVE_GENERATION_NORMAL_FREQ;
   1ea00:	7623      	strb	r3, [r4, #24]
	config->compare.wave_ramp       = TCC_RAMP_RAMP1;
   1ea02:	7663      	strb	r3, [r4, #25]
	MREPEAT(TCC_NUM_CHANNELS,
   1ea04:	7423      	strb	r3, [r4, #16]
   1ea06:	7463      	strb	r3, [r4, #17]
   1ea08:	74a3      	strb	r3, [r4, #18]
   1ea0a:	74e3      	strb	r3, [r4, #19]
	MREPEAT(TCC_NUM_FAULTS, _TCC_FAULT_FUNCTION_INIT, 0)
   1ea0c:	7013      	strb	r3, [r2, #0]
   1ea0e:	7053      	strb	r3, [r2, #1]
   1ea10:	7093      	strb	r3, [r2, #2]
   1ea12:	70d3      	strb	r3, [r2, #3]
   1ea14:	7113      	strb	r3, [r2, #4]
   1ea16:	7153      	strb	r3, [r2, #5]
   1ea18:	7193      	strb	r3, [r2, #6]
   1ea1a:	71d3      	strb	r3, [r2, #7]
   1ea1c:	7213      	strb	r3, [r2, #8]
   1ea1e:	7253      	strb	r3, [r2, #9]
   1ea20:	7293      	strb	r3, [r2, #10]
   1ea22:	72d3      	strb	r3, [r2, #11]
   1ea24:	320c      	adds	r2, #12
   1ea26:	7013      	strb	r3, [r2, #0]
   1ea28:	7053      	strb	r3, [r2, #1]
   1ea2a:	7093      	strb	r3, [r2, #2]
   1ea2c:	70d3      	strb	r3, [r2, #3]
   1ea2e:	7113      	strb	r3, [r2, #4]
   1ea30:	7153      	strb	r3, [r2, #5]
   1ea32:	7193      	strb	r3, [r2, #6]
   1ea34:	71d3      	strb	r3, [r2, #7]
	MREPEAT(TCC_NUM_WAVE_OUTPUTS, _TCC_NRF_FUNCTION_INIT, 0)
   1ea36:	7213      	strb	r3, [r2, #8]
   1ea38:	7253      	strb	r3, [r2, #9]
   1ea3a:	7293      	strb	r3, [r2, #10]
   1ea3c:	72d3      	strb	r3, [r2, #11]
   1ea3e:	7313      	strb	r3, [r2, #12]
   1ea40:	7353      	strb	r3, [r2, #13]
   1ea42:	7393      	strb	r3, [r2, #14]
   1ea44:	73d3      	strb	r3, [r2, #15]
   1ea46:	1d21      	adds	r1, r4, #4
   1ea48:	7003      	strb	r3, [r0, #0]
   1ea4a:	7043      	strb	r3, [r0, #1]
   1ea4c:	7083      	strb	r3, [r0, #2]
   1ea4e:	70c3      	strb	r3, [r0, #3]
   1ea50:	7103      	strb	r3, [r0, #4]
   1ea52:	7143      	strb	r3, [r0, #5]
   1ea54:	7183      	strb	r3, [r0, #6]
   1ea56:	71c3      	strb	r3, [r0, #7]
#  undef _TCC_NRF_FUNCTION_INIT

	/* Output inversion defaults */
#  define _TCC_OUT_INVERT_INIT(n, value) \
		config->wave_ext.invert[n] = value;
	MREPEAT(TCC_NUM_WAVE_OUTPUTS, _TCC_OUT_INVERT_INIT, false)
   1ea58:	7203      	strb	r3, [r0, #8]
   1ea5a:	7243      	strb	r3, [r0, #9]
   1ea5c:	7283      	strb	r3, [r0, #10]
   1ea5e:	72c3      	strb	r3, [r0, #11]
   1ea60:	7303      	strb	r3, [r0, #12]
   1ea62:	7343      	strb	r3, [r0, #13]
   1ea64:	7383      	strb	r3, [r0, #14]
   1ea66:	73c3      	strb	r3, [r0, #15]

#  define _TCC_CHANNEL_OUT_PIN_INIT(n, dummy) \
		config->pins.enable_wave_out_pin[n]                = false;\
		config->pins.wave_out_pin[TCC_WAVE_OUTPUT_##n]     = 0;    \
		config->pins.wave_out_pin_mux[TCC_WAVE_OUTPUT_##n] = 0;
	MREPEAT(TCC_NUM_WAVE_OUTPUTS, _TCC_CHANNEL_OUT_PIN_INIT, 0)
   1ea68:	3050      	adds	r0, #80	; 0x50
   1ea6a:	7003      	strb	r3, [r0, #0]
   1ea6c:	65a3      	str	r3, [r4, #88]	; 0x58
   1ea6e:	67a3      	str	r3, [r4, #120]	; 0x78
   1ea70:	7043      	strb	r3, [r0, #1]
   1ea72:	65e3      	str	r3, [r4, #92]	; 0x5c
   1ea74:	67e3      	str	r3, [r4, #124]	; 0x7c
   1ea76:	7083      	strb	r3, [r0, #2]
   1ea78:	6623      	str	r3, [r4, #96]	; 0x60
   1ea7a:	67cb      	str	r3, [r1, #124]	; 0x7c
   1ea7c:	3197      	adds	r1, #151	; 0x97
   1ea7e:	700b      	strb	r3, [r1, #0]
#  undef _TCC_CHANNEL_OUT_PIN_INIT

	config->double_buffering_enabled  = true;
   1ea80:	2101      	movs	r1, #1
	MREPEAT(TCC_NUM_WAVE_OUTPUTS, _TCC_NRF_FUNCTION_INIT, 0)
   1ea82:	3a30      	subs	r2, #48	; 0x30
	MREPEAT(TCC_NUM_WAVE_OUTPUTS, _TCC_CHANNEL_OUT_PIN_INIT, 0)
   1ea84:	6663      	str	r3, [r4, #100]	; 0x64
   1ea86:	67d3      	str	r3, [r2, #124]	; 0x7c
   1ea88:	3294      	adds	r2, #148	; 0x94
   1ea8a:	7013      	strb	r3, [r2, #0]
   1ea8c:	3a14      	subs	r2, #20
   1ea8e:	66a3      	str	r3, [r4, #104]	; 0x68
   1ea90:	6013      	str	r3, [r2, #0]
   1ea92:	7553      	strb	r3, [r2, #21]
   1ea94:	3204      	adds	r2, #4
   1ea96:	66e3      	str	r3, [r4, #108]	; 0x6c
   1ea98:	6013      	str	r3, [r2, #0]
   1ea9a:	7493      	strb	r3, [r2, #18]
   1ea9c:	3204      	adds	r2, #4
   1ea9e:	6723      	str	r3, [r4, #112]	; 0x70
   1eaa0:	6013      	str	r3, [r2, #0]
   1eaa2:	73d3      	strb	r3, [r2, #15]
   1eaa4:	6763      	str	r3, [r4, #116]	; 0x74
   1eaa6:	3204      	adds	r2, #4
	config->run_in_standby            = false;
   1eaa8:	34a1      	adds	r4, #161	; 0xa1
	MREPEAT(TCC_NUM_WAVE_OUTPUTS, _TCC_CHANNEL_OUT_PIN_INIT, 0)
   1eaaa:	6013      	str	r3, [r2, #0]
	config->double_buffering_enabled  = true;
   1eaac:	7311      	strb	r1, [r2, #12]
	config->run_in_standby            = false;
   1eaae:	7023      	strb	r3, [r4, #0]
}
   1eab0:	bd10      	pop	{r4, pc}
   1eab2:	46c0      	nop			; (mov r8, r8)
   1eab4:	0001e999 	.word	0x0001e999
   1eab8:	0002acb8 	.word	0x0002acb8

0001eabc <tcc_init>:
 */
enum status_code tcc_init(
		struct tcc_module *const module_inst,
		Tcc *const hw,
		const struct tcc_config *const config)
{
   1eabc:	b5f0      	push	{r4, r5, r6, r7, lr}
	Assert(hw);
	Assert(module_inst);
	Assert(config);

	/* TCC instance index */
	uint8_t module_index = _tcc_get_inst_index(hw);
   1eabe:	4bc0      	ldr	r3, [pc, #768]	; (1edc0 <tcc_init+0x304>)
{
   1eac0:	b08f      	sub	sp, #60	; 0x3c
   1eac2:	0006      	movs	r6, r0
	uint8_t module_index = _tcc_get_inst_index(hw);
   1eac4:	0008      	movs	r0, r1
{
   1eac6:	000d      	movs	r5, r1
   1eac8:	0014      	movs	r4, r2
	uint8_t module_index = _tcc_get_inst_index(hw);
   1eaca:	4798      	blx	r3
			PM->APBCMASK.reg |= mask;
   1eacc:	49bd      	ldr	r1, [pc, #756]	; (1edc4 <tcc_init+0x308>)

	/* Enable the user interface clock for TCC */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC,
   1eace:	0082      	lsls	r2, r0, #2
	uint8_t module_index = _tcc_get_inst_index(hw);
   1ead0:	4684      	mov	ip, r0
   1ead2:	48bd      	ldr	r0, [pc, #756]	; (1edc8 <tcc_init+0x30c>)
   1ead4:	6a0b      	ldr	r3, [r1, #32]
   1ead6:	5810      	ldr	r0, [r2, r0]
   1ead8:	4303      	orrs	r3, r0
   1eada:	620b      	str	r3, [r1, #32]
			_tcc_apbcmasks[module_index]);

	/* Check if it's enabled. */
	if (hw->CTRLA.reg & TCC_CTRLA_ENABLE) {
   1eadc:	682b      	ldr	r3, [r5, #0]
		return STATUS_ERR_DENIED;
   1eade:	201c      	movs	r0, #28
	if (hw->CTRLA.reg & TCC_CTRLA_ENABLE) {
   1eae0:	079b      	lsls	r3, r3, #30
   1eae2:	d408      	bmi.n	1eaf6 <tcc_init+0x3a>
	}
	/* Check if it's resetting */
	if (hw->CTRLA.reg & TCC_CTRLA_SWRST) {
   1eae4:	682b      	ldr	r3, [r5, #0]
   1eae6:	07db      	lsls	r3, r3, #31
   1eae8:	d405      	bmi.n	1eaf6 <tcc_init+0x3a>
	}

	enum status_code status;

	/* Check COUNT, PER, CCx */
	uint32_t count_max  = _tcc_maxs[module_index];
   1eaea:	4bb8      	ldr	r3, [pc, #736]	; (1edcc <tcc_init+0x310>)
   1eaec:	58d2      	ldr	r2, [r2, r3]

	/* Check all counter values */
	if ((config->counter.count > count_max)
   1eaee:	6823      	ldr	r3, [r4, #0]
   1eaf0:	429a      	cmp	r2, r3
   1eaf2:	d202      	bcs.n	1eafa <tcc_init+0x3e>
		|| (config->counter.period > count_max)
		) {
		return STATUS_ERR_INVALID_ARG;
   1eaf4:	2017      	movs	r0, #23
#endif
		hw->CC[i].reg = (config->compare.match[i]);
	}

	return STATUS_OK;
}
   1eaf6:	b00f      	add	sp, #60	; 0x3c
   1eaf8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		|| (config->counter.period > count_max)
   1eafa:	6863      	ldr	r3, [r4, #4]
   1eafc:	429a      	cmp	r2, r3
   1eafe:	d3f9      	bcc.n	1eaf4 <tcc_init+0x38>
   1eb00:	0023      	movs	r3, r4
   1eb02:	0021      	movs	r1, r4
   1eb04:	331c      	adds	r3, #28
   1eb06:	312c      	adds	r1, #44	; 0x2c
		if ((config->compare.match[i] > count_max)
   1eb08:	6818      	ldr	r0, [r3, #0]
   1eb0a:	4282      	cmp	r2, r0
   1eb0c:	d3f2      	bcc.n	1eaf4 <tcc_init+0x38>
   1eb0e:	3304      	adds	r3, #4
	for (i = 0; i < TCC_NUM_CHANNELS; i ++) {
   1eb10:	428b      	cmp	r3, r1
   1eb12:	d1f9      	bne.n	1eb08 <tcc_init+0x4c>
   1eb14:	2200      	movs	r2, #0
		if (i >= _tcc_ow_nums[module_index]) {
   1eb16:	49ae      	ldr	r1, [pc, #696]	; (1edd0 <tcc_init+0x314>)
		if (!config->pins.enable_wave_out_pin[i]) {
   1eb18:	0010      	movs	r0, r2
   1eb1a:	3098      	adds	r0, #152	; 0x98
   1eb1c:	5c20      	ldrb	r0, [r4, r0]
   1eb1e:	2800      	cmp	r0, #0
   1eb20:	d003      	beq.n	1eb2a <tcc_init+0x6e>
		if (i >= _tcc_ow_nums[module_index]) {
   1eb22:	4660      	mov	r0, ip
   1eb24:	5c08      	ldrb	r0, [r1, r0]
   1eb26:	4290      	cmp	r0, r2
   1eb28:	dde4      	ble.n	1eaf4 <tcc_init+0x38>
	for (i = 0; i < TCC_NUM_WAVE_OUTPUTS; i ++) {
   1eb2a:	3201      	adds	r2, #1
   1eb2c:	2a08      	cmp	r2, #8
   1eb2e:	d1f3      	bne.n	1eb18 <tcc_init+0x5c>
   1eb30:	2200      	movs	r2, #0
			ctrla |= (TCC_CTRLA_CPTEN0 << i);
   1eb32:	2080      	movs	r0, #128	; 0x80
   1eb34:	9201      	str	r2, [sp, #4]
   1eb36:	0440      	lsls	r0, r0, #17
		if (config->capture.channel_function[i] ==
   1eb38:	18a7      	adds	r7, r4, r2
   1eb3a:	7c3f      	ldrb	r7, [r7, #16]
   1eb3c:	2f01      	cmp	r7, #1
   1eb3e:	d109      	bne.n	1eb54 <tcc_init+0x98>
			if (i > _tcc_cc_nums[module_index]) {
   1eb40:	4661      	mov	r1, ip
   1eb42:	4fa4      	ldr	r7, [pc, #656]	; (1edd4 <tcc_init+0x318>)
   1eb44:	5c7f      	ldrb	r7, [r7, r1]
   1eb46:	4297      	cmp	r7, r2
   1eb48:	dbd4      	blt.n	1eaf4 <tcc_init+0x38>
			ctrla |= (TCC_CTRLA_CPTEN0 << i);
   1eb4a:	0007      	movs	r7, r0
   1eb4c:	4097      	lsls	r7, r2
   1eb4e:	9901      	ldr	r1, [sp, #4]
   1eb50:	4339      	orrs	r1, r7
   1eb52:	9101      	str	r1, [sp, #4]
	for (i = 0; i < TCC_NUM_CHANNELS; i ++) {
   1eb54:	3201      	adds	r2, #1
   1eb56:	2a04      	cmp	r2, #4
   1eb58:	d1ee      	bne.n	1eb38 <tcc_init+0x7c>
	if (config->run_in_standby) {
   1eb5a:	0022      	movs	r2, r4
   1eb5c:	32a1      	adds	r2, #161	; 0xa1
   1eb5e:	7812      	ldrb	r2, [r2, #0]
   1eb60:	2a00      	cmp	r2, #0
   1eb62:	d004      	beq.n	1eb6e <tcc_init+0xb2>
		ctrla |= TCC_CTRLA_RUNSTDBY;
   1eb64:	2280      	movs	r2, #128	; 0x80
   1eb66:	9901      	ldr	r1, [sp, #4]
   1eb68:	0112      	lsls	r2, r2, #4
   1eb6a:	4311      	orrs	r1, r2
   1eb6c:	9101      	str	r1, [sp, #4]
	if (config->counter.oneshot) {
   1eb6e:	7a22      	ldrb	r2, [r4, #8]
		ctrlb |= TCC_CTRLBSET_ONESHOT;
   1eb70:	1e51      	subs	r1, r2, #1
   1eb72:	418a      	sbcs	r2, r1
   1eb74:	0092      	lsls	r2, r2, #2
   1eb76:	9203      	str	r2, [sp, #12]
	if (config->counter.direction == TCC_COUNT_DIRECTION_DOWN) {
   1eb78:	7a62      	ldrb	r2, [r4, #9]
   1eb7a:	2a01      	cmp	r2, #1
   1eb7c:	d102      	bne.n	1eb84 <tcc_init+0xc8>
		ctrlb |= TCC_CTRLBSET_DIR;
   1eb7e:	9903      	ldr	r1, [sp, #12]
   1eb80:	4311      	orrs	r1, r2
   1eb82:	9103      	str	r1, [sp, #12]
	uint8_t cc_num = _tcc_cc_nums[module_index];
   1eb84:	4661      	mov	r1, ip
	ctrla |= config->counter.reload_action << TCC_CTRLA_PRESCSYNC_Pos;
   1eb86:	7b22      	ldrb	r2, [r4, #12]
   1eb88:	9206      	str	r2, [sp, #24]
	ctrla |= config->counter.clock_prescaler << TCC_CTRLA_PRESCALER_Pos;
   1eb8a:	7ae2      	ldrb	r2, [r4, #11]
   1eb8c:	9207      	str	r2, [sp, #28]
	uint8_t cc_num = _tcc_cc_nums[module_index];
   1eb8e:	4a91      	ldr	r2, [pc, #580]	; (1edd4 <tcc_init+0x318>)
   1eb90:	5c52      	ldrb	r2, [r2, r1]
   1eb92:	9202      	str	r2, [sp, #8]
   1eb94:	2200      	movs	r2, #0
   1eb96:	9200      	str	r2, [sp, #0]
		if (cfg->capture_channel >= cc_num) {
   1eb98:	7a5f      	ldrb	r7, [r3, #9]
   1eb9a:	9a02      	ldr	r2, [sp, #8]
   1eb9c:	42ba      	cmp	r2, r7
   1eb9e:	d9a9      	bls.n	1eaf4 <tcc_init+0x38>
		if (cfg->filter_value > 0xF) {
   1eba0:	7819      	ldrb	r1, [r3, #0]
   1eba2:	290f      	cmp	r1, #15
   1eba4:	d8a6      	bhi.n	1eaf4 <tcc_init+0x38>
		fault = TCC_FCTRLA_FILTERVAL(cfg->filter_value)
   1eba6:	20f0      	movs	r0, #240	; 0xf0
				| TCC_FCTRLA_BLANKVAL(cfg->blanking_cycles)
   1eba8:	785a      	ldrb	r2, [r3, #1]
		fault = TCC_FCTRLA_FILTERVAL(cfg->filter_value)
   1ebaa:	0500      	lsls	r0, r0, #20
   1ebac:	0609      	lsls	r1, r1, #24
   1ebae:	4001      	ands	r1, r0
				| TCC_FCTRLA_BLANKVAL(cfg->blanking_cycles)
   1ebb0:	0412      	lsls	r2, r2, #16
   1ebb2:	430a      	orrs	r2, r1
				| (cfg->restart ? TCC_FCTRLA_RESTART : 0)
   1ebb4:	7899      	ldrb	r1, [r3, #2]
				| TCC_FCTRLA_BLANKVAL(cfg->blanking_cycles)
   1ebb6:	9204      	str	r2, [sp, #16]
				| (cfg->restart ? TCC_FCTRLA_RESTART : 0)
   1ebb8:	1e48      	subs	r0, r1, #1
   1ebba:	4181      	sbcs	r1, r0
   1ebbc:	01c9      	lsls	r1, r1, #7
   1ebbe:	9105      	str	r1, [sp, #20]
				| (cfg->keep ? TCC_FCTRLA_KEEP : 0)
   1ebc0:	78d9      	ldrb	r1, [r3, #3]
				| TCC_FCTRLA_SRC(cfg->source)
   1ebc2:	2203      	movs	r2, #3
				| (cfg->keep ? TCC_FCTRLA_KEEP : 0)
   1ebc4:	1e48      	subs	r0, r1, #1
   1ebc6:	4181      	sbcs	r1, r0
				| (cfg->qualification ? TCC_FCTRLA_QUAL : 0)
   1ebc8:	7918      	ldrb	r0, [r3, #4]
				| (cfg->keep ? TCC_FCTRLA_KEEP : 0)
   1ebca:	00c9      	lsls	r1, r1, #3
   1ebcc:	9108      	str	r1, [sp, #32]
				| (cfg->qualification ? TCC_FCTRLA_QUAL : 0)
   1ebce:	1e41      	subs	r1, r0, #1
   1ebd0:	4188      	sbcs	r0, r1
   1ebd2:	0101      	lsls	r1, r0, #4
				| TCC_FCTRLA_BLANK(cfg->blanking)
   1ebd4:	2060      	movs	r0, #96	; 0x60
				| (cfg->qualification ? TCC_FCTRLA_QUAL : 0)
   1ebd6:	9109      	str	r1, [sp, #36]	; 0x24
				| TCC_FCTRLA_BLANK(cfg->blanking)
   1ebd8:	7999      	ldrb	r1, [r3, #6]
				| TCC_FCTRLA_CHSEL(cfg->capture_channel);
   1ebda:	02bf      	lsls	r7, r7, #10
				| TCC_FCTRLA_BLANK(cfg->blanking)
   1ebdc:	0149      	lsls	r1, r1, #5
   1ebde:	4001      	ands	r1, r0
				| TCC_FCTRLA_SRC(cfg->source)
   1ebe0:	7958      	ldrb	r0, [r3, #5]
   1ebe2:	4010      	ands	r0, r2
		fault = TCC_FCTRLA_FILTERVAL(cfg->filter_value)
   1ebe4:	9a04      	ldr	r2, [sp, #16]
   1ebe6:	4302      	orrs	r2, r0
   1ebe8:	430a      	orrs	r2, r1
				| TCC_FCTRLA_HALT(cfg->halt_action)
   1ebea:	21c0      	movs	r1, #192	; 0xc0
   1ebec:	79d8      	ldrb	r0, [r3, #7]
   1ebee:	0089      	lsls	r1, r1, #2
   1ebf0:	0200      	lsls	r0, r0, #8
   1ebf2:	4001      	ands	r1, r0
				| TCC_FCTRLA_CAPTURE(cfg->capture_action)
   1ebf4:	20e0      	movs	r0, #224	; 0xe0
		fault = TCC_FCTRLA_FILTERVAL(cfg->filter_value)
   1ebf6:	4311      	orrs	r1, r2
				| TCC_FCTRLA_CAPTURE(cfg->capture_action)
   1ebf8:	7a1a      	ldrb	r2, [r3, #8]
   1ebfa:	01c0      	lsls	r0, r0, #7
   1ebfc:	0312      	lsls	r2, r2, #12
   1ebfe:	4002      	ands	r2, r0
				| TCC_FCTRLA_CHSEL(cfg->capture_channel);
   1ec00:	20c0      	movs	r0, #192	; 0xc0
   1ec02:	0100      	lsls	r0, r0, #4
		fault = TCC_FCTRLA_FILTERVAL(cfg->filter_value)
   1ec04:	4311      	orrs	r1, r2
				| TCC_FCTRLA_CHSEL(cfg->capture_channel);
   1ec06:	4007      	ands	r7, r0
		fault = TCC_FCTRLA_FILTERVAL(cfg->filter_value)
   1ec08:	9a05      	ldr	r2, [sp, #20]
   1ec0a:	430f      	orrs	r7, r1
   1ec0c:	4317      	orrs	r7, r2
   1ec0e:	9a08      	ldr	r2, [sp, #32]
		value_buffer[i] = fault;
   1ec10:	9900      	ldr	r1, [sp, #0]
		fault = TCC_FCTRLA_FILTERVAL(cfg->filter_value)
   1ec12:	4317      	orrs	r7, r2
   1ec14:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1ec16:	330a      	adds	r3, #10
   1ec18:	4317      	orrs	r7, r2
		value_buffer[i] = fault;
   1ec1a:	aa0c      	add	r2, sp, #48	; 0x30
   1ec1c:	508f      	str	r7, [r1, r2]
   1ec1e:	000a      	movs	r2, r1
   1ec20:	3204      	adds	r2, #4
   1ec22:	9200      	str	r2, [sp, #0]
	for (i = 0; i < TCC_NUM_FAULTS; i ++) {
   1ec24:	2a08      	cmp	r2, #8
   1ec26:	d1b7      	bne.n	1eb98 <tcc_init+0xdc>
	uint8_t ow_num = _tcc_ow_nums[module_index];
   1ec28:	4662      	mov	r2, ip
   1ec2a:	4b69      	ldr	r3, [pc, #420]	; (1edd0 <tcc_init+0x314>)
				drvctrl |= (TCC_DRVCTRL_NRE0) << i;
   1ec2c:	2001      	movs	r0, #1
	uint8_t ow_num = _tcc_ow_nums[module_index];
   1ec2e:	5c9b      	ldrb	r3, [r3, r2]
   1ec30:	9304      	str	r3, [sp, #16]
	drvctrl = 0;
   1ec32:	2300      	movs	r3, #0
   1ec34:	9300      	str	r3, [sp, #0]
   1ec36:	18e2      	adds	r2, r4, r3
		if (config->wave_ext.invert[i]) {
   1ec38:	0017      	movs	r7, r2
   1ec3a:	3750      	adds	r7, #80	; 0x50
   1ec3c:	783f      	ldrb	r7, [r7, #0]
   1ec3e:	2f00      	cmp	r7, #0
   1ec40:	d009      	beq.n	1ec56 <tcc_init+0x19a>
			if (i >= ow_num) {
   1ec42:	9904      	ldr	r1, [sp, #16]
   1ec44:	4299      	cmp	r1, r3
   1ec46:	d800      	bhi.n	1ec4a <tcc_init+0x18e>
   1ec48:	e754      	b.n	1eaf4 <tcc_init+0x38>
			drvctrl |= (TCC_DRVCTRL_INVEN0 << i);
   1ec4a:	2780      	movs	r7, #128	; 0x80
   1ec4c:	027f      	lsls	r7, r7, #9
   1ec4e:	409f      	lsls	r7, r3
   1ec50:	9900      	ldr	r1, [sp, #0]
   1ec52:	4339      	orrs	r1, r7
   1ec54:	9100      	str	r1, [sp, #0]
		if (config->wave_ext.non_recoverable_fault[i].output !=
   1ec56:	001f      	movs	r7, r3
   1ec58:	3741      	adds	r7, #65	; 0x41
   1ec5a:	5dd2      	ldrb	r2, [r2, r7]
   1ec5c:	2a00      	cmp	r2, #0
   1ec5e:	d00c      	beq.n	1ec7a <tcc_init+0x1be>
			if (i >= ow_num) {
   1ec60:	9904      	ldr	r1, [sp, #16]
   1ec62:	4299      	cmp	r1, r3
   1ec64:	d800      	bhi.n	1ec68 <tcc_init+0x1ac>
   1ec66:	e745      	b.n	1eaf4 <tcc_init+0x38>
			if (config->wave_ext.non_recoverable_fault[i].output ==
   1ec68:	2a02      	cmp	r2, #2
   1ec6a:	d000      	beq.n	1ec6e <tcc_init+0x1b2>
   1ec6c:	e08f      	b.n	1ed8e <tcc_init+0x2d2>
				drvctrl |= (TCC_DRVCTRL_NRE0 | TCC_DRVCTRL_NRV0) << i;
   1ec6e:	2202      	movs	r2, #2
   1ec70:	32ff      	adds	r2, #255	; 0xff
				drvctrl |= (TCC_DRVCTRL_NRE0) << i;
   1ec72:	409a      	lsls	r2, r3
   1ec74:	9900      	ldr	r1, [sp, #0]
   1ec76:	4311      	orrs	r1, r2
   1ec78:	9100      	str	r1, [sp, #0]
	for (i = 0; i < TCC_NUM_WAVE_OUTPUTS; i ++) {
   1ec7a:	3301      	adds	r3, #1
   1ec7c:	2b08      	cmp	r3, #8
   1ec7e:	d1da      	bne.n	1ec36 <tcc_init+0x17a>
	wave = TCC_WAVE_RAMP(wav_cfg->wave_ramp) |
   1ec80:	2230      	movs	r2, #48	; 0x30
			TCC_WAVE_WAVEGEN(wav_cfg->wave_generation);
   1ec82:	2107      	movs	r1, #7
	wave = TCC_WAVE_RAMP(wav_cfg->wave_ramp) |
   1ec84:	7e63      	ldrb	r3, [r4, #25]
   1ec86:	011b      	lsls	r3, r3, #4
   1ec88:	4013      	ands	r3, r2
			TCC_WAVE_WAVEGEN(wav_cfg->wave_generation);
   1ec8a:	7e22      	ldrb	r2, [r4, #24]
   1ec8c:	400a      	ands	r2, r1
	wave = TCC_WAVE_RAMP(wav_cfg->wave_ramp) |
   1ec8e:	4313      	orrs	r3, r2
			wave |= (TCC_WAVE_POL0 << n);
   1ec90:	2280      	movs	r2, #128	; 0x80
	wave = TCC_WAVE_RAMP(wav_cfg->wave_ramp) |
   1ec92:	9305      	str	r3, [sp, #20]
	for (n = 0; n < TCC_NUM_CHANNELS; n++) {
   1ec94:	2300      	movs	r3, #0
			wave |= (TCC_WAVE_POL0 << n);
   1ec96:	0252      	lsls	r2, r2, #9
		if (wav_cfg->wave_polarity[n]) {
   1ec98:	18e1      	adds	r1, r4, r3
   1ec9a:	7d09      	ldrb	r1, [r1, #20]
   1ec9c:	2900      	cmp	r1, #0
   1ec9e:	d008      	beq.n	1ecb2 <tcc_init+0x1f6>
			if (n >= cc_num) {
   1eca0:	9902      	ldr	r1, [sp, #8]
   1eca2:	4299      	cmp	r1, r3
   1eca4:	dc00      	bgt.n	1eca8 <tcc_init+0x1ec>
   1eca6:	e725      	b.n	1eaf4 <tcc_init+0x38>
			wave |= (TCC_WAVE_POL0 << n);
   1eca8:	0011      	movs	r1, r2
   1ecaa:	4099      	lsls	r1, r3
   1ecac:	9805      	ldr	r0, [sp, #20]
   1ecae:	4308      	orrs	r0, r1
   1ecb0:	9005      	str	r0, [sp, #20]
	for (n = 0; n < TCC_NUM_CHANNELS; n++) {
   1ecb2:	3301      	adds	r3, #1
   1ecb4:	2b04      	cmp	r3, #4
   1ecb6:	d1ef      	bne.n	1ec98 <tcc_init+0x1dc>
   1ecb8:	0031      	movs	r1, r6
		module_inst->callback[i] = NULL;
   1ecba:	2300      	movs	r3, #0
   1ecbc:	1d32      	adds	r2, r6, #4
   1ecbe:	3134      	adds	r1, #52	; 0x34
   1ecc0:	c208      	stmia	r2!, {r3}
	for (i = 0; i < TCC_CALLBACK_N; i ++) {
   1ecc2:	4291      	cmp	r1, r2
   1ecc4:	d1fc      	bne.n	1ecc0 <tcc_init+0x204>
	module_inst->register_callback_mask = 0;
   1ecc6:	6373      	str	r3, [r6, #52]	; 0x34
	module_inst->enable_callback_mask = 0;
   1ecc8:	63b3      	str	r3, [r6, #56]	; 0x38
	_tcc_instances[module_index] = module_inst;
   1ecca:	4663      	mov	r3, ip
   1eccc:	009a      	lsls	r2, r3, #2
   1ecce:	4b42      	ldr	r3, [pc, #264]	; (1edd8 <tcc_init+0x31c>)
	system_gclk_chan_set_config(_tcc_gclk_ids[module_index], &gclk_chan_config);
   1ecd0:	a90a      	add	r1, sp, #40	; 0x28
	_tcc_instances[module_index] = module_inst;
   1ecd2:	50d6      	str	r6, [r2, r3]
	module_inst->double_buffering_enabled = config->double_buffering_enabled;
   1ecd4:	0023      	movs	r3, r4
	module_inst->hw = hw;
   1ecd6:	6035      	str	r5, [r6, #0]
	module_inst->double_buffering_enabled = config->double_buffering_enabled;
   1ecd8:	33a0      	adds	r3, #160	; 0xa0
   1ecda:	781b      	ldrb	r3, [r3, #0]
   1ecdc:	363c      	adds	r6, #60	; 0x3c
   1ecde:	7033      	strb	r3, [r6, #0]
	gclk_chan_config.source_generator = config->counter.clock_source;
   1ece0:	7aa3      	ldrb	r3, [r4, #10]
   1ece2:	aa0a      	add	r2, sp, #40	; 0x28
   1ece4:	7013      	strb	r3, [r2, #0]
	system_gclk_chan_set_config(_tcc_gclk_ids[module_index], &gclk_chan_config);
   1ece6:	4662      	mov	r2, ip
   1ece8:	4b3c      	ldr	r3, [pc, #240]	; (1eddc <tcc_init+0x320>)
   1ecea:	0027      	movs	r7, r4
   1ecec:	5c9e      	ldrb	r6, [r3, r2]
   1ecee:	4b3c      	ldr	r3, [pc, #240]	; (1ede0 <tcc_init+0x324>)
   1ecf0:	0030      	movs	r0, r6
   1ecf2:	4798      	blx	r3
	system_gclk_chan_enable(_tcc_gclk_ids[module_index]);
   1ecf4:	0030      	movs	r0, r6
   1ecf6:	0026      	movs	r6, r4
   1ecf8:	4b3a      	ldr	r3, [pc, #232]	; (1ede4 <tcc_init+0x328>)
   1ecfa:	4798      	blx	r3
   1ecfc:	9b04      	ldr	r3, [sp, #16]
   1ecfe:	3698      	adds	r6, #152	; 0x98
   1ed00:	3398      	adds	r3, #152	; 0x98
   1ed02:	18e3      	adds	r3, r4, r3
   1ed04:	3758      	adds	r7, #88	; 0x58
   1ed06:	9304      	str	r3, [sp, #16]
	for (i = 0; i <  _tcc_ow_nums[module_index]; i ++) {
   1ed08:	9b04      	ldr	r3, [sp, #16]
   1ed0a:	429e      	cmp	r6, r3
   1ed0c:	d141      	bne.n	1ed92 <tcc_init+0x2d6>
	ctrla |= config->counter.reload_action << TCC_CTRLA_PRESCSYNC_Pos;
   1ed0e:	9b06      	ldr	r3, [sp, #24]
	ctrla |= config->counter.clock_prescaler << TCC_CTRLA_PRESCALER_Pos;
   1ed10:	9a07      	ldr	r2, [sp, #28]
	ctrla |= config->counter.reload_action << TCC_CTRLA_PRESCSYNC_Pos;
   1ed12:	031b      	lsls	r3, r3, #12
	ctrla |= config->counter.clock_prescaler << TCC_CTRLA_PRESCALER_Pos;
   1ed14:	0212      	lsls	r2, r2, #8
   1ed16:	4313      	orrs	r3, r2
   1ed18:	9a01      	ldr	r2, [sp, #4]
   1ed1a:	4313      	orrs	r3, r2
	hw->CTRLA.reg = ctrla;
   1ed1c:	602b      	str	r3, [r5, #0]
	while (hw->SYNCBUSY.reg & TCC_SYNCBUSY_CTRLB) {
   1ed1e:	2304      	movs	r3, #4
   1ed20:	68aa      	ldr	r2, [r5, #8]
   1ed22:	421a      	tst	r2, r3
   1ed24:	d1fc      	bne.n	1ed20 <tcc_init+0x264>
	hw->CTRLBCLR.reg = 0xFF;
   1ed26:	23ff      	movs	r3, #255	; 0xff
   1ed28:	712b      	strb	r3, [r5, #4]
	while (hw->SYNCBUSY.reg & TCC_SYNCBUSY_CTRLB) {
   1ed2a:	3bfb      	subs	r3, #251	; 0xfb
   1ed2c:	68aa      	ldr	r2, [r5, #8]
   1ed2e:	421a      	tst	r2, r3
   1ed30:	d1fc      	bne.n	1ed2c <tcc_init+0x270>
	hw->CTRLBSET.reg = ctrlb;
   1ed32:	466b      	mov	r3, sp
   1ed34:	7b1b      	ldrb	r3, [r3, #12]
   1ed36:	716b      	strb	r3, [r5, #5]
	hw->FCTRLA.reg = faults[0];
   1ed38:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1ed3a:	60eb      	str	r3, [r5, #12]
	hw->FCTRLB.reg = faults[1];
   1ed3c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1ed3e:	612b      	str	r3, [r5, #16]
	hw->DRVCTRL.reg = drvctrl;
   1ed40:	9b00      	ldr	r3, [sp, #0]
   1ed42:	61ab      	str	r3, [r5, #24]
	while (hw->SYNCBUSY.reg & (TCC_SYNCBUSY_WAVE | TCC_SYNCBUSY_WAVEB)) {
   1ed44:	4b28      	ldr	r3, [pc, #160]	; (1ede8 <tcc_init+0x32c>)
   1ed46:	68aa      	ldr	r2, [r5, #8]
   1ed48:	421a      	tst	r2, r3
   1ed4a:	d1fc      	bne.n	1ed46 <tcc_init+0x28a>
	hw->WAVE.reg = waves[0];
   1ed4c:	9b05      	ldr	r3, [sp, #20]
   1ed4e:	63eb      	str	r3, [r5, #60]	; 0x3c
	while (hw->SYNCBUSY.reg & TCC_SYNCBUSY_COUNT) {
   1ed50:	2310      	movs	r3, #16
   1ed52:	68aa      	ldr	r2, [r5, #8]
   1ed54:	421a      	tst	r2, r3
   1ed56:	d1fc      	bne.n	1ed52 <tcc_init+0x296>
	hw->COUNT.reg = config->counter.count;
   1ed58:	6823      	ldr	r3, [r4, #0]
	while (hw->SYNCBUSY.reg & (TCC_SYNCBUSY_PER | TCC_SYNCBUSY_PERB)) {
   1ed5a:	4a24      	ldr	r2, [pc, #144]	; (1edec <tcc_init+0x330>)
	hw->COUNT.reg = config->counter.count;
   1ed5c:	636b      	str	r3, [r5, #52]	; 0x34
	while (hw->SYNCBUSY.reg & (TCC_SYNCBUSY_PER | TCC_SYNCBUSY_PERB)) {
   1ed5e:	68ab      	ldr	r3, [r5, #8]
   1ed60:	4013      	ands	r3, r2
   1ed62:	d1fc      	bne.n	1ed5e <tcc_init+0x2a2>
	hw->PER.reg = (config->counter.period);
   1ed64:	6862      	ldr	r2, [r4, #4]
			(TCC_SYNCBUSY_CC0 | TCC_SYNCBUSY_CCB0) << i)) {
   1ed66:	4922      	ldr	r1, [pc, #136]	; (1edf0 <tcc_init+0x334>)
	hw->PER.reg = (config->counter.period);
   1ed68:	642a      	str	r2, [r5, #64]	; 0x40
	for (i = 0; i <  _tcc_cc_nums[module_index]; i ++) {
   1ed6a:	9a02      	ldr	r2, [sp, #8]
   1ed6c:	4293      	cmp	r3, r2
   1ed6e:	da24      	bge.n	1edba <tcc_init+0x2fe>
			(TCC_SYNCBUSY_CC0 | TCC_SYNCBUSY_CCB0) << i)) {
   1ed70:	000a      	movs	r2, r1
   1ed72:	409a      	lsls	r2, r3
		while (hw->SYNCBUSY.reg & (
   1ed74:	68a8      	ldr	r0, [r5, #8]
   1ed76:	4202      	tst	r2, r0
   1ed78:	d1fc      	bne.n	1ed74 <tcc_init+0x2b8>
		hw->CC[i].reg = (config->compare.match[i]);
   1ed7a:	009a      	lsls	r2, r3, #2
   1ed7c:	18a2      	adds	r2, r4, r2
   1ed7e:	69d0      	ldr	r0, [r2, #28]
   1ed80:	001a      	movs	r2, r3
   1ed82:	3210      	adds	r2, #16
   1ed84:	0092      	lsls	r2, r2, #2
   1ed86:	18aa      	adds	r2, r5, r2
   1ed88:	6050      	str	r0, [r2, #4]
	for (i = 0; i <  _tcc_cc_nums[module_index]; i ++) {
   1ed8a:	3301      	adds	r3, #1
   1ed8c:	e7ed      	b.n	1ed6a <tcc_init+0x2ae>
				drvctrl |= (TCC_DRVCTRL_NRE0) << i;
   1ed8e:	0002      	movs	r2, r0
   1ed90:	e76f      	b.n	1ec72 <tcc_init+0x1b6>
		if (!config->pins.enable_wave_out_pin[i]) {
   1ed92:	7833      	ldrb	r3, [r6, #0]
   1ed94:	2b00      	cmp	r3, #0
   1ed96:	d00d      	beq.n	1edb4 <tcc_init+0x2f8>
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
   1ed98:	2301      	movs	r3, #1
   1ed9a:	a90b      	add	r1, sp, #44	; 0x2c
   1ed9c:	708b      	strb	r3, [r1, #2]
	config->powersave    = false;
   1ed9e:	2300      	movs	r3, #0
   1eda0:	70cb      	strb	r3, [r1, #3]
		pin_config.mux_position = config->pins.wave_out_pin_mux[i];
   1eda2:	3320      	adds	r3, #32
   1eda4:	18fb      	adds	r3, r7, r3
   1eda6:	781b      	ldrb	r3, [r3, #0]
		system_pinmux_pin_set_config(
   1eda8:	7838      	ldrb	r0, [r7, #0]
		pin_config.mux_position = config->pins.wave_out_pin_mux[i];
   1edaa:	700b      	strb	r3, [r1, #0]
		pin_config.direction = SYSTEM_PINMUX_PIN_DIR_OUTPUT;
   1edac:	2301      	movs	r3, #1
   1edae:	704b      	strb	r3, [r1, #1]
		system_pinmux_pin_set_config(
   1edb0:	4b10      	ldr	r3, [pc, #64]	; (1edf4 <tcc_init+0x338>)
   1edb2:	4798      	blx	r3
   1edb4:	3601      	adds	r6, #1
   1edb6:	3704      	adds	r7, #4
   1edb8:	e7a6      	b.n	1ed08 <tcc_init+0x24c>
	return STATUS_OK;
   1edba:	2000      	movs	r0, #0
   1edbc:	e69b      	b.n	1eaf6 <tcc_init+0x3a>
   1edbe:	46c0      	nop			; (mov r8, r8)
   1edc0:	0001e999 	.word	0x0001e999
   1edc4:	40000400 	.word	0x40000400
   1edc8:	0002aca4 	.word	0x0002aca4
   1edcc:	0002acb8 	.word	0x0002acb8
   1edd0:	0002acc4 	.word	0x0002acc4
   1edd4:	0002acb0 	.word	0x0002acb0
   1edd8:	2000569c 	.word	0x2000569c
   1eddc:	0002acb3 	.word	0x0002acb3
   1ede0:	0001e839 	.word	0x0001e839
   1ede4:	0001e7b1 	.word	0x0001e7b1
   1ede8:	00020040 	.word	0x00020040
   1edec:	00040080 	.word	0x00040080
   1edf0:	00080100 	.word	0x00080100
   1edf4:	0001e93d 	.word	0x0001e93d

0001edf8 <tcc_register_callback>:
	/* Sanity check arguments */
	Assert(module);
	Assert(callback_func);

	/* Register callback function */
	module->callback[callback_type] = callback_func;
   1edf8:	0092      	lsls	r2, r2, #2
   1edfa:	1883      	adds	r3, r0, r2
   1edfc:	6059      	str	r1, [r3, #4]

	/* Set the bit corresponding to the callback_type */
	module->register_callback_mask |= _tcc_intflag[callback_type];
   1edfe:	4b03      	ldr	r3, [pc, #12]	; (1ee0c <tcc_register_callback+0x14>)
   1ee00:	58d3      	ldr	r3, [r2, r3]
   1ee02:	6b42      	ldr	r2, [r0, #52]	; 0x34
   1ee04:	4313      	orrs	r3, r2
   1ee06:	6343      	str	r3, [r0, #52]	; 0x34

	return STATUS_OK;
}
   1ee08:	2000      	movs	r0, #0
   1ee0a:	4770      	bx	lr
   1ee0c:	0002acc8 	.word	0x0002acc8

0001ee10 <tcc_enable_callback>:
 * \param[in]     callback_type Callback type given by an enum
 */
void tcc_enable_callback(
		struct tcc_module *const module,
		const enum tcc_callback callback_type)
{
   1ee10:	b570      	push	{r4, r5, r6, lr}
	Assert(module);
	Assert(module->hw);

	/* Enable interrupts for this TCC module */
	system_interrupt_enable(_tcc_interrupt_get_interrupt_vector(
			_tcc_get_inst_index(module->hw)));
   1ee12:	4b0b      	ldr	r3, [pc, #44]	; (1ee40 <tcc_enable_callback+0x30>)
{
   1ee14:	0004      	movs	r4, r0
			_tcc_get_inst_index(module->hw)));
   1ee16:	6800      	ldr	r0, [r0, #0]
{
   1ee18:	000d      	movs	r5, r1
			_tcc_get_inst_index(module->hw)));
   1ee1a:	4798      	blx	r3
	return (enum system_interrupt_vector)tcc_interrupt_vectors[inst_num];
   1ee1c:	4b09      	ldr	r3, [pc, #36]	; (1ee44 <tcc_enable_callback+0x34>)

	/* Enable channel or other callbacks */
	module->enable_callback_mask |= _tcc_intflag[callback_type];
   1ee1e:	00ad      	lsls	r5, r5, #2
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
   1ee20:	5c1a      	ldrb	r2, [r3, r0]
   1ee22:	231f      	movs	r3, #31
   1ee24:	401a      	ands	r2, r3
   1ee26:	3b1e      	subs	r3, #30
   1ee28:	4093      	lsls	r3, r2
   1ee2a:	4a07      	ldr	r2, [pc, #28]	; (1ee48 <tcc_enable_callback+0x38>)
   1ee2c:	6013      	str	r3, [r2, #0]
   1ee2e:	4b07      	ldr	r3, [pc, #28]	; (1ee4c <tcc_enable_callback+0x3c>)
   1ee30:	58ea      	ldr	r2, [r5, r3]
   1ee32:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1ee34:	4313      	orrs	r3, r2
   1ee36:	63a3      	str	r3, [r4, #56]	; 0x38
	module->hw->INTENSET.reg = _tcc_intflag[callback_type];
   1ee38:	6823      	ldr	r3, [r4, #0]
   1ee3a:	629a      	str	r2, [r3, #40]	; 0x28
}
   1ee3c:	bd70      	pop	{r4, r5, r6, pc}
   1ee3e:	46c0      	nop			; (mov r8, r8)
   1ee40:	0001e999 	.word	0x0001e999
   1ee44:	0002acf8 	.word	0x0002acf8
   1ee48:	e000e100 	.word	0xe000e100
   1ee4c:	0002acc8 	.word	0x0002acc8

0001ee50 <_tcc_interrupt_handler>:
 * \param[in]  module_index  ID of the TCC instance calling the interrupt
 *                           handler
 */
void _tcc_interrupt_handler(
		uint8_t module_index)
{
   1ee50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t interrupt_and_callback_status_mask;

	struct tcc_module *module =
			(struct tcc_module *)_tcc_instances[module_index];

	interrupt_and_callback_status_mask = (module->hw->INTFLAG.reg &
   1ee52:	2500      	movs	r5, #0
	struct tcc_module *module =
   1ee54:	4b0b      	ldr	r3, [pc, #44]	; (1ee84 <_tcc_interrupt_handler+0x34>)
   1ee56:	0080      	lsls	r0, r0, #2
   1ee58:	58c4      	ldr	r4, [r0, r3]
	interrupt_and_callback_status_mask = (module->hw->INTFLAG.reg &
   1ee5a:	6823      	ldr	r3, [r4, #0]
   1ee5c:	6b62      	ldr	r2, [r4, #52]	; 0x34
   1ee5e:	6ade      	ldr	r6, [r3, #44]	; 0x2c
   1ee60:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1ee62:	4013      	ands	r3, r2
   1ee64:	401e      	ands	r6, r3
			module->register_callback_mask &
			module->enable_callback_mask);

	/* Check if callback interrupt has occured */
	for (i = 0; i < TCC_CALLBACK_N; i ++) {
		if (interrupt_and_callback_status_mask & _tcc_intflag[i]) {
   1ee66:	4b08      	ldr	r3, [pc, #32]	; (1ee88 <_tcc_interrupt_handler+0x38>)
   1ee68:	58ef      	ldr	r7, [r5, r3]
   1ee6a:	4237      	tst	r7, r6
   1ee6c:	d005      	beq.n	1ee7a <_tcc_interrupt_handler+0x2a>
			/* Invoke the registered and enabled callback function */
			(module->callback[i])(module);
   1ee6e:	1963      	adds	r3, r4, r5
   1ee70:	685b      	ldr	r3, [r3, #4]
   1ee72:	0020      	movs	r0, r4
   1ee74:	4798      	blx	r3
			/* Clear interrupt flag */
			module->hw->INTFLAG.reg = _tcc_intflag[i];
   1ee76:	6823      	ldr	r3, [r4, #0]
   1ee78:	62df      	str	r7, [r3, #44]	; 0x2c
   1ee7a:	3504      	adds	r5, #4
	for (i = 0; i < TCC_CALLBACK_N; i ++) {
   1ee7c:	2d30      	cmp	r5, #48	; 0x30
   1ee7e:	d1f2      	bne.n	1ee66 <_tcc_interrupt_handler+0x16>
		}
	}
}
   1ee80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1ee82:	46c0      	nop			; (mov r8, r8)
   1ee84:	2000569c 	.word	0x2000569c
   1ee88:	0002acc8 	.word	0x0002acc8

0001ee8c <TCC0_Handler>:
MREPEAT(TCC_INST_NUM, _TCC_INTERRUPT_HANDLER, 0)
   1ee8c:	b510      	push	{r4, lr}
   1ee8e:	2000      	movs	r0, #0
   1ee90:	4b01      	ldr	r3, [pc, #4]	; (1ee98 <TCC0_Handler+0xc>)
   1ee92:	4798      	blx	r3
   1ee94:	bd10      	pop	{r4, pc}
   1ee96:	46c0      	nop			; (mov r8, r8)
   1ee98:	0001ee51 	.word	0x0001ee51

0001ee9c <TCC1_Handler>:
   1ee9c:	b510      	push	{r4, lr}
   1ee9e:	2001      	movs	r0, #1
   1eea0:	4b01      	ldr	r3, [pc, #4]	; (1eea8 <TCC1_Handler+0xc>)
   1eea2:	4798      	blx	r3
   1eea4:	bd10      	pop	{r4, pc}
   1eea6:	46c0      	nop			; (mov r8, r8)
   1eea8:	0001ee51 	.word	0x0001ee51

0001eeac <TCC2_Handler>:
   1eeac:	b510      	push	{r4, lr}
   1eeae:	2002      	movs	r0, #2
   1eeb0:	4b01      	ldr	r3, [pc, #4]	; (1eeb8 <TCC2_Handler+0xc>)
   1eeb2:	4798      	blx	r3
   1eeb4:	bd10      	pop	{r4, pc}
   1eeb6:	46c0      	nop			; (mov r8, r8)
   1eeb8:	0001ee51 	.word	0x0001ee51

0001eebc <Dummy_Handler>:
 */
void HardFault_HandlerC(unsigned long *hardfault_args);

void Dummy_Handler(void)
{
  __asm volatile (
   1eebc:	2004      	movs	r0, #4
   1eebe:	4671      	mov	r1, lr
   1eec0:	4208      	tst	r0, r1
   1eec2:	d002      	beq.n	1eeca <_MSP>
   1eec4:	f3ef 8009 	mrs	r0, PSP
   1eec8:	e001      	b.n	1eece <_HALT>

0001eeca <_MSP>:
   1eeca:	f3ef 8008 	mrs	r0, MSP

0001eece <_HALT>:
   1eece:	6941      	ldr	r1, [r0, #20]
   1eed0:	e060      	b.n	1ef94 <HardFault_HandlerC>
   1eed2:	be00      	bkpt	0x0000
  "_HALT:              \n"
  " ldr r1,[r0,#20]  \n"
  " b HardFault_HandlerC \n"
  " bkpt #0          \n"
  );
}
   1eed4:	4770      	bx	lr
	...

0001eed8 <Reset_Handler>:
        if (pSrc != pDest) {
   1eed8:	4821      	ldr	r0, [pc, #132]	; (1ef60 <Reset_Handler+0x88>)
   1eeda:	4922      	ldr	r1, [pc, #136]	; (1ef64 <Reset_Handler+0x8c>)
{
   1eedc:	b570      	push	{r4, r5, r6, lr}
        if (pSrc != pDest) {
   1eede:	4288      	cmp	r0, r1
   1eee0:	d004      	beq.n	1eeec <Reset_Handler+0x14>
   1eee2:	2300      	movs	r3, #0
                for (; pDest < &_erelocate;) {
   1eee4:	4c20      	ldr	r4, [pc, #128]	; (1ef68 <Reset_Handler+0x90>)
   1eee6:	18ca      	adds	r2, r1, r3
   1eee8:	42a2      	cmp	r2, r4
   1eeea:	d332      	bcc.n	1ef52 <Reset_Handler+0x7a>
                *pDest++ = 0;
   1eeec:	2100      	movs	r1, #0
   1eeee:	4b1f      	ldr	r3, [pc, #124]	; (1ef6c <Reset_Handler+0x94>)
        for (pDest = &_szero; pDest < &_ezero;) {
   1eef0:	4a1f      	ldr	r2, [pc, #124]	; (1ef70 <Reset_Handler+0x98>)
   1eef2:	4293      	cmp	r3, r2
   1eef4:	d331      	bcc.n	1ef5a <Reset_Handler+0x82>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
   1eef6:	21ff      	movs	r1, #255	; 0xff
   1eef8:	4b1e      	ldr	r3, [pc, #120]	; (1ef74 <Reset_Handler+0x9c>)
   1eefa:	4a1f      	ldr	r2, [pc, #124]	; (1ef78 <Reset_Handler+0xa0>)
   1eefc:	438b      	bics	r3, r1
   1eefe:	6093      	str	r3, [r2, #8]
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
   1ef00:	2202      	movs	r2, #2
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
   1ef02:	250c      	movs	r5, #12
   1ef04:	2408      	movs	r4, #8
        DMAC->QOSCTRL.bit.DQOS = 2;
   1ef06:	2630      	movs	r6, #48	; 0x30
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
   1ef08:	4b1c      	ldr	r3, [pc, #112]	; (1ef7c <Reset_Handler+0xa4>)
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
   1ef0a:	481d      	ldr	r0, [pc, #116]	; (1ef80 <Reset_Handler+0xa8>)
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
   1ef0c:	625a      	str	r2, [r3, #36]	; 0x24
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
   1ef0e:	78c3      	ldrb	r3, [r0, #3]
   1ef10:	39fc      	subs	r1, #252	; 0xfc
   1ef12:	438b      	bics	r3, r1
   1ef14:	4313      	orrs	r3, r2
   1ef16:	70c3      	strb	r3, [r0, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
   1ef18:	78c3      	ldrb	r3, [r0, #3]
   1ef1a:	43ab      	bics	r3, r5
   1ef1c:	4323      	orrs	r3, r4
   1ef1e:	70c3      	strb	r3, [r0, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
   1ef20:	4b18      	ldr	r3, [pc, #96]	; (1ef84 <Reset_Handler+0xac>)
   1ef22:	7b98      	ldrb	r0, [r3, #14]
   1ef24:	43b0      	bics	r0, r6
   1ef26:	0006      	movs	r6, r0
   1ef28:	2020      	movs	r0, #32
   1ef2a:	4330      	orrs	r0, r6
   1ef2c:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
   1ef2e:	7b98      	ldrb	r0, [r3, #14]
   1ef30:	43a8      	bics	r0, r5
   1ef32:	4304      	orrs	r4, r0
   1ef34:	739c      	strb	r4, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
   1ef36:	7b98      	ldrb	r0, [r3, #14]
   1ef38:	4388      	bics	r0, r1
   1ef3a:	4302      	orrs	r2, r0
   1ef3c:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
   1ef3e:	2380      	movs	r3, #128	; 0x80
   1ef40:	4a11      	ldr	r2, [pc, #68]	; (1ef88 <Reset_Handler+0xb0>)
   1ef42:	6851      	ldr	r1, [r2, #4]
   1ef44:	430b      	orrs	r3, r1
   1ef46:	6053      	str	r3, [r2, #4]
        __libc_init_array();
   1ef48:	4b10      	ldr	r3, [pc, #64]	; (1ef8c <Reset_Handler+0xb4>)
   1ef4a:	4798      	blx	r3
        main();
   1ef4c:	4b10      	ldr	r3, [pc, #64]	; (1ef90 <Reset_Handler+0xb8>)
   1ef4e:	4798      	blx	r3
   1ef50:	e7fe      	b.n	1ef50 <Reset_Handler+0x78>
                        *pDest++ = *pSrc++;
   1ef52:	58c5      	ldr	r5, [r0, r3]
   1ef54:	3304      	adds	r3, #4
   1ef56:	6015      	str	r5, [r2, #0]
   1ef58:	e7c5      	b.n	1eee6 <Reset_Handler+0xe>
                *pDest++ = 0;
   1ef5a:	c302      	stmia	r3!, {r1}
   1ef5c:	e7c9      	b.n	1eef2 <Reset_Handler+0x1a>
   1ef5e:	46c0      	nop			; (mov r8, r8)
   1ef60:	0002ba88 	.word	0x0002ba88
   1ef64:	20000000 	.word	0x20000000
   1ef68:	200003dc 	.word	0x200003dc
   1ef6c:	200003e0 	.word	0x200003e0
   1ef70:	20005764 	.word	0x20005764
   1ef74:	00012000 	.word	0x00012000
   1ef78:	e000ed00 	.word	0xe000ed00
   1ef7c:	410070fc 	.word	0x410070fc
   1ef80:	41005000 	.word	0x41005000
   1ef84:	41004800 	.word	0x41004800
   1ef88:	41004000 	.word	0x41004000
   1ef8c:	00022ba1 	.word	0x00022ba1
   1ef90:	00022979 	.word	0x00022979

0001ef94 <HardFault_HandlerC>:
	volatile unsigned long _DFSR ;
	volatile unsigned long _AFSR ;
	volatile unsigned long _BFAR ;
	volatile unsigned long _MMAR ;
	
	stacked_r0  = ((unsigned long)hardfault_args[0]) ;
   1ef94:	6803      	ldr	r3, [r0, #0]
void HardFault_HandlerC(unsigned long *hardfault_args) {
   1ef96:	b08e      	sub	sp, #56	; 0x38
	stacked_r0  = ((unsigned long)hardfault_args[0]) ;
   1ef98:	9300      	str	r3, [sp, #0]
	stacked_r1  = ((unsigned long)hardfault_args[1]) ;
   1ef9a:	6843      	ldr	r3, [r0, #4]
   1ef9c:	9301      	str	r3, [sp, #4]
	stacked_r2  = ((unsigned long)hardfault_args[2]) ;
   1ef9e:	6883      	ldr	r3, [r0, #8]
   1efa0:	9302      	str	r3, [sp, #8]
	stacked_r3  = ((unsigned long)hardfault_args[3]) ;
   1efa2:	68c3      	ldr	r3, [r0, #12]
   1efa4:	9303      	str	r3, [sp, #12]
	stacked_r12 = ((unsigned long)hardfault_args[4]) ;
   1efa6:	6903      	ldr	r3, [r0, #16]
   1efa8:	9304      	str	r3, [sp, #16]
	stacked_lr  = ((unsigned long)hardfault_args[5]) ;
   1efaa:	6943      	ldr	r3, [r0, #20]
   1efac:	9305      	str	r3, [sp, #20]
	stacked_pc  = ((unsigned long)hardfault_args[6]) ;
   1efae:	6983      	ldr	r3, [r0, #24]
   1efb0:	9306      	str	r3, [sp, #24]
	stacked_psr = ((unsigned long)hardfault_args[7]) ;
   1efb2:	69c3      	ldr	r3, [r0, #28]
   1efb4:	9307      	str	r3, [sp, #28]
	
	// Configurable Fault Status Register
	// Consists of MMSR, BFSR and UFSR
	_CFSR = (*((volatile unsigned long *)(0xE000ED28))) ;
   1efb6:	4b0a      	ldr	r3, [pc, #40]	; (1efe0 <HardFault_HandlerC+0x4c>)
   1efb8:	681b      	ldr	r3, [r3, #0]
   1efba:	9308      	str	r3, [sp, #32]
	
	// Hard Fault Status Register
	_HFSR = (*((volatile unsigned long *)(0xE000ED2C))) ;
   1efbc:	4b09      	ldr	r3, [pc, #36]	; (1efe4 <HardFault_HandlerC+0x50>)
   1efbe:	681b      	ldr	r3, [r3, #0]
   1efc0:	9309      	str	r3, [sp, #36]	; 0x24
	
	// Debug Fault Status Register
	_DFSR = (*((volatile unsigned long *)(0xE000ED30))) ;
   1efc2:	4b09      	ldr	r3, [pc, #36]	; (1efe8 <HardFault_HandlerC+0x54>)
   1efc4:	681b      	ldr	r3, [r3, #0]
   1efc6:	930a      	str	r3, [sp, #40]	; 0x28
	
	// Auxiliary Fault Status Register
	_AFSR = (*((volatile unsigned long *)(0xE000ED3C))) ;
   1efc8:	4b08      	ldr	r3, [pc, #32]	; (1efec <HardFault_HandlerC+0x58>)
   1efca:	681b      	ldr	r3, [r3, #0]
   1efcc:	930b      	str	r3, [sp, #44]	; 0x2c
	
	// Read the Fault Address Registers. These may not contain valid values.
	// Check BFARVALID/MMARVALID to see if they are valid values
	// MemManage Fault Address Register
	_MMAR = (*((volatile unsigned long *)(0xE000ED34))) ;
   1efce:	4b08      	ldr	r3, [pc, #32]	; (1eff0 <HardFault_HandlerC+0x5c>)
   1efd0:	681b      	ldr	r3, [r3, #0]
   1efd2:	930d      	str	r3, [sp, #52]	; 0x34
	// Bus Fault Address Register
	_BFAR = (*((volatile unsigned long *)(0xE000ED38))) ;
   1efd4:	4b07      	ldr	r3, [pc, #28]	; (1eff4 <HardFault_HandlerC+0x60>)
   1efd6:	681b      	ldr	r3, [r3, #0]
   1efd8:	930c      	str	r3, [sp, #48]	; 0x30
	
	__asm("BKPT #0\n") ; // Break into the debugger
   1efda:	be00      	bkpt	0x0000
	#pragma GCC diagnostic pop
   1efdc:	b00e      	add	sp, #56	; 0x38
   1efde:	4770      	bx	lr
   1efe0:	e000ed28 	.word	0xe000ed28
   1efe4:	e000ed2c 	.word	0xe000ed2c
   1efe8:	e000ed30 	.word	0xe000ed30
   1efec:	e000ed3c 	.word	0xe000ed3c
   1eff0:	e000ed34 	.word	0xe000ed34
   1eff4:	e000ed38 	.word	0xe000ed38

0001eff8 <_read>:
int __attribute__((weak))
_read (int file, char * ptr, int len); // Remove GCC compiler warning

int __attribute__((weak))
_read (int file, char * ptr, int len)
{
   1eff8:	b570      	push	{r4, r5, r6, lr}
   1effa:	000e      	movs	r6, r1
   1effc:	0014      	movs	r4, r2
   1effe:	0015      	movs	r5, r2
	int nChars = 0;

	if (file != 0) {
   1f000:	2800      	cmp	r0, #0
   1f002:	d008      	beq.n	1f016 <_read+0x1e>
		return -1;
   1f004:	2001      	movs	r0, #1
   1f006:	4240      	negs	r0, r0
   1f008:	e00c      	b.n	1f024 <_read+0x2c>
	}

	for (; len > 0; --len) {
		ptr_get(stdio_base, ptr);
   1f00a:	4b07      	ldr	r3, [pc, #28]	; (1f028 <_read+0x30>)
	for (; len > 0; --len) {
   1f00c:	3d01      	subs	r5, #1
		ptr_get(stdio_base, ptr);
   1f00e:	6818      	ldr	r0, [r3, #0]
   1f010:	4b06      	ldr	r3, [pc, #24]	; (1f02c <_read+0x34>)
   1f012:	681b      	ldr	r3, [r3, #0]
   1f014:	4798      	blx	r3
   1f016:	1b61      	subs	r1, r4, r5
   1f018:	1871      	adds	r1, r6, r1
	for (; len > 0; --len) {
   1f01a:	2d00      	cmp	r5, #0
   1f01c:	dcf5      	bgt.n	1f00a <_read+0x12>
   1f01e:	43e0      	mvns	r0, r4
   1f020:	17c0      	asrs	r0, r0, #31
   1f022:	4020      	ands	r0, r4
		ptr++;
		nChars++;
	}
	return nChars;
}
   1f024:	bd70      	pop	{r4, r5, r6, pc}
   1f026:	46c0      	nop			; (mov r8, r8)
   1f028:	200056b0 	.word	0x200056b0
   1f02c:	200056a8 	.word	0x200056a8

0001f030 <_write>:
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
   1f030:	3801      	subs	r0, #1
{
   1f032:	b570      	push	{r4, r5, r6, lr}
   1f034:	000e      	movs	r6, r1
	if ((file != 1) && (file != 2) && (file!=3)) {
   1f036:	2802      	cmp	r0, #2
   1f038:	d80d      	bhi.n	1f056 <_write+0x26>
   1f03a:	000c      	movs	r4, r1
   1f03c:	188d      	adds	r5, r1, r2
   1f03e:	1ba0      	subs	r0, r4, r6
		return -1;
	}

	for (; len != 0; --len) {
   1f040:	42ac      	cmp	r4, r5
   1f042:	d00a      	beq.n	1f05a <_write+0x2a>
		if (ptr_put(stdio_base, *ptr++) < 0) {
   1f044:	4b05      	ldr	r3, [pc, #20]	; (1f05c <_write+0x2c>)
   1f046:	7821      	ldrb	r1, [r4, #0]
   1f048:	6818      	ldr	r0, [r3, #0]
   1f04a:	4b05      	ldr	r3, [pc, #20]	; (1f060 <_write+0x30>)
   1f04c:	3401      	adds	r4, #1
   1f04e:	681b      	ldr	r3, [r3, #0]
   1f050:	4798      	blx	r3
   1f052:	2800      	cmp	r0, #0
   1f054:	daf3      	bge.n	1f03e <_write+0xe>
		return -1;
   1f056:	2001      	movs	r0, #1
   1f058:	4240      	negs	r0, r0
			return -1;
		}
		++nChars;
	}
	return nChars;
}
   1f05a:	bd70      	pop	{r4, r5, r6, pc}
   1f05c:	200056b0 	.word	0x200056b0
   1f060:	200056ac 	.word	0x200056ac

0001f064 <_sbrk>:
extern caddr_t _sbrk(int incr)
{
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;

	if (heap == NULL) {
   1f064:	4b05      	ldr	r3, [pc, #20]	; (1f07c <_sbrk+0x18>)
{
   1f066:	0002      	movs	r2, r0
	if (heap == NULL) {
   1f068:	6819      	ldr	r1, [r3, #0]
   1f06a:	2900      	cmp	r1, #0
   1f06c:	d101      	bne.n	1f072 <_sbrk+0xe>
		heap = (unsigned char *)&_end;
   1f06e:	4904      	ldr	r1, [pc, #16]	; (1f080 <_sbrk+0x1c>)
   1f070:	6019      	str	r1, [r3, #0]
	}
	prev_heap = heap;
   1f072:	6818      	ldr	r0, [r3, #0]

	heap += incr;
   1f074:	1882      	adds	r2, r0, r2
   1f076:	601a      	str	r2, [r3, #0]

	return (caddr_t) prev_heap;
}
   1f078:	4770      	bx	lr
   1f07a:	46c0      	nop			; (mov r8, r8)
   1f07c:	20003dc8 	.word	0x20003dc8
   1f080:	20007768 	.word	0x20007768

0001f084 <_close>:
}

extern int _close(int file)
{
	return -1;
}
   1f084:	2001      	movs	r0, #1
   1f086:	4240      	negs	r0, r0
   1f088:	4770      	bx	lr

0001f08a <_fstat>:

extern int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
   1f08a:	2380      	movs	r3, #128	; 0x80
   1f08c:	019b      	lsls	r3, r3, #6

	return 0;
}
   1f08e:	2000      	movs	r0, #0
	st->st_mode = S_IFCHR;
   1f090:	604b      	str	r3, [r1, #4]
}
   1f092:	4770      	bx	lr

0001f094 <_isatty>:

extern int _isatty(int file)
{
	return 1;
}
   1f094:	2001      	movs	r0, #1
   1f096:	4770      	bx	lr

0001f098 <_lseek>:

extern int _lseek(int file, int ptr, int dir)
{
	return 0;
}
   1f098:	2000      	movs	r0, #0
   1f09a:	4770      	bx	lr

0001f09c <disk_initialize>:
	/* Initialize and set time structure to default */
	struct rtc_calendar_time time;
	rtc_calendar_get_time_defaults(&time);

	/* Set defaults into configuration structure */
	config->prescaler           = RTC_CALENDAR_PRESCALER_DIV_1024;
   1f09c:	23a0      	movs	r3, #160	; 0xa0
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_PROTECT).
 */
DSTATUS disk_initialize(BYTE drv)
{
   1f09e:	b530      	push	{r4, r5, lr}
   1f0a0:	b087      	sub	sp, #28
   1f0a2:	aa01      	add	r2, sp, #4
   1f0a4:	011b      	lsls	r3, r3, #4
   1f0a6:	8013      	strh	r3, [r2, #0]
	config->clear_on_match      = false;
   1f0a8:	2300      	movs	r3, #0
#ifdef FEATURE_RTC_CONTINUOUSLY_UPDATED
	config->continuously_update = false;
#endif
	config->clock_24h           = false;
	config->year_init_value     = 2000;
   1f0aa:	21fa      	movs	r1, #250	; 0xfa
	config->clear_on_match      = false;
   1f0ac:	7093      	strb	r3, [r2, #2]
	config->continuously_update = false;
   1f0ae:	70d3      	strb	r3, [r2, #3]
	config_rtc_calendar.alarm[0].time = init_time;
   1f0b0:	7253      	strb	r3, [r2, #9]
   1f0b2:	7293      	strb	r3, [r2, #10]
   1f0b4:	72d3      	strb	r3, [r2, #11]
   1f0b6:	4b15      	ldr	r3, [pc, #84]	; (1f10c <disk_initialize+0x70>)
	config->year_init_value     = 2000;
   1f0b8:	00c9      	lsls	r1, r1, #3
{
   1f0ba:	0004      	movs	r4, r0
   1f0bc:	80d1      	strh	r1, [r2, #6]
	config_rtc_calendar.alarm[0].time = init_time;
   1f0be:	2004      	movs	r0, #4
	config_rtc_calendar.clock_24h     = true;
   1f0c0:	2101      	movs	r1, #1
	config_rtc_calendar.alarm[0].time = init_time;
   1f0c2:	81d3      	strh	r3, [r2, #14]
	config_rtc_calendar.alarm[0].mask = RTC_CALENDAR_ALARM_MASK_YEAR;
   1f0c4:	2306      	movs	r3, #6
	rtc_calendar_init(&rtc_instance, RTC, &config_rtc_calendar);
   1f0c6:	4d12      	ldr	r5, [pc, #72]	; (1f110 <disk_initialize+0x74>)
	config_rtc_calendar.clock_24h     = true;
   1f0c8:	7111      	strb	r1, [r2, #4]
	config_rtc_calendar.alarm[0].time = init_time;
   1f0ca:	7210      	strb	r0, [r2, #8]
   1f0cc:	7311      	strb	r1, [r2, #12]
   1f0ce:	7351      	strb	r1, [r2, #13]
	config_rtc_calendar.alarm[0].mask = RTC_CALENDAR_ALARM_MASK_YEAR;
   1f0d0:	7413      	strb	r3, [r2, #16]
	rtc_calendar_init(&rtc_instance, RTC, &config_rtc_calendar);
   1f0d2:	0028      	movs	r0, r5
   1f0d4:	4b0f      	ldr	r3, [pc, #60]	; (1f114 <disk_initialize+0x78>)
   1f0d6:	4910      	ldr	r1, [pc, #64]	; (1f118 <disk_initialize+0x7c>)
   1f0d8:	4798      	blx	r3
	rtc_calendar_enable(&rtc_instance);
   1f0da:	0028      	movs	r0, r5
   1f0dc:	4b0f      	ldr	r3, [pc, #60]	; (1f11c <disk_initialize+0x80>)
   1f0de:	4798      	blx	r3
	/* USB disk with multiple LUNs */
	if (drv > LUN_ID_USB + Lun_usb_get_lun()) {
		return STA_NOINIT;
	}
#else
	if (drv > MAX_LUN) {
   1f0e0:	2c01      	cmp	r4, #1
   1f0e2:	d902      	bls.n	1f0ea <disk_initialize+0x4e>
		/* At least one of the LUN should be defined */
		return STA_NOINIT;
   1f0e4:	2001      	movs	r0, #1
		return STA_PROTECT;
	}

	/* The memory should already be initialized */
	return 0;
}
   1f0e6:	b007      	add	sp, #28
   1f0e8:	bd30      	pop	{r4, r5, pc}
		mem_status = mem_test_unit_ready(drv);
   1f0ea:	0020      	movs	r0, r4
   1f0ec:	4d0c      	ldr	r5, [pc, #48]	; (1f120 <disk_initialize+0x84>)
   1f0ee:	47a8      	blx	r5
		if (CTRL_BUSY != mem_status) {
   1f0f0:	2803      	cmp	r0, #3
   1f0f2:	d101      	bne.n	1f0f8 <disk_initialize+0x5c>
		mem_status = mem_test_unit_ready(drv);
   1f0f4:	0020      	movs	r0, r4
   1f0f6:	47a8      	blx	r5
	if (mem_status != CTRL_GOOD) {
   1f0f8:	2800      	cmp	r0, #0
   1f0fa:	d1f3      	bne.n	1f0e4 <disk_initialize+0x48>
	if (mem_wr_protect(drv)) {
   1f0fc:	4b09      	ldr	r3, [pc, #36]	; (1f124 <disk_initialize+0x88>)
   1f0fe:	0020      	movs	r0, r4
   1f100:	4798      	blx	r3
	return 0;
   1f102:	1e43      	subs	r3, r0, #1
   1f104:	4198      	sbcs	r0, r3
   1f106:	0080      	lsls	r0, r0, #2
   1f108:	e7ed      	b.n	1f0e6 <disk_initialize+0x4a>
   1f10a:	46c0      	nop			; (mov r8, r8)
   1f10c:	000007de 	.word	0x000007de
   1f110:	200056b4 	.word	0x200056b4
   1f114:	0001d291 	.word	0x0001d291
   1f118:	40001400 	.word	0x40001400
   1f11c:	0001d105 	.word	0x0001d105
   1f120:	0001ce05 	.word	0x0001ce05
   1f124:	0001ce39 	.word	0x0001ce39

0001f128 <disk_status>:
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_NODISK, STA_PROTECT).
 */
DSTATUS disk_status(BYTE drv)
{
	switch (mem_test_unit_ready(drv)) {
   1f128:	4b05      	ldr	r3, [pc, #20]	; (1f140 <disk_status+0x18>)
{
   1f12a:	b510      	push	{r4, lr}
	switch (mem_test_unit_ready(drv)) {
   1f12c:	4798      	blx	r3
	case CTRL_GOOD:
		return 0;
   1f12e:	1e03      	subs	r3, r0, #0
	switch (mem_test_unit_ready(drv)) {
   1f130:	d003      	beq.n	1f13a <disk_status+0x12>
	case CTRL_NO_PRESENT:
		return STA_NOINIT | STA_NODISK;
   1f132:	2303      	movs	r3, #3
	switch (mem_test_unit_ready(drv)) {
   1f134:	2802      	cmp	r0, #2
   1f136:	d000      	beq.n	1f13a <disk_status+0x12>
	default:
		return STA_NOINIT;
   1f138:	3b02      	subs	r3, #2
	}
}
   1f13a:	0018      	movs	r0, r3
   1f13c:	bd10      	pop	{r4, pc}
   1f13e:	46c0      	nop			; (mov r8, r8)
   1f140:	0001ce05 	.word	0x0001ce05

0001f144 <disk_read>:
 * \param count Number of sectors to read (1..255).
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_read(BYTE drv, BYTE *buff, DWORD sector, BYTE count)
{
   1f144:	b5f0      	push	{r4, r5, r6, r7, lr}
   1f146:	b087      	sub	sp, #28
   1f148:	9302      	str	r3, [sp, #8]
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
   1f14a:	4b17      	ldr	r3, [pc, #92]	; (1f1a8 <disk_read+0x64>)
{
   1f14c:	0007      	movs	r7, r0
   1f14e:	000c      	movs	r4, r1
   1f150:	0016      	movs	r6, r2
	uint8_t uc_sector_size = mem_sector_size(drv);
   1f152:	4798      	blx	r3
   1f154:	1e05      	subs	r5, r0, #0
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
   1f156:	d102      	bne.n	1f15e <disk_read+0x1a>
		return RES_ERROR;
   1f158:	2001      	movs	r0, #1
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
   1f15a:	b007      	add	sp, #28
   1f15c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	mem_read_capacity(drv, &ul_last_sector_num);
   1f15e:	4b13      	ldr	r3, [pc, #76]	; (1f1ac <disk_read+0x68>)
   1f160:	a905      	add	r1, sp, #20
   1f162:	0038      	movs	r0, r7
   1f164:	4798      	blx	r3
	if ((sector + count * uc_sector_size) >
   1f166:	9a02      	ldr	r2, [sp, #8]
			(ul_last_sector_num + 1) * uc_sector_size) {
   1f168:	9b05      	ldr	r3, [sp, #20]
	if ((sector + count * uc_sector_size) >
   1f16a:	436a      	muls	r2, r5
			(ul_last_sector_num + 1) * uc_sector_size) {
   1f16c:	3301      	adds	r3, #1
   1f16e:	436b      	muls	r3, r5
	if ((sector + count * uc_sector_size) >
   1f170:	1992      	adds	r2, r2, r6
		return RES_PARERR;
   1f172:	2004      	movs	r0, #4
	if ((sector + count * uc_sector_size) >
   1f174:	429a      	cmp	r2, r3
   1f176:	d8f0      	bhi.n	1f15a <disk_read+0x16>
   1f178:	026b      	lsls	r3, r5, #9
   1f17a:	9303      	str	r3, [sp, #12]
   1f17c:	2300      	movs	r3, #0
	for (i = 0; i < count; i++) {
   1f17e:	9301      	str	r3, [sp, #4]
   1f180:	9b01      	ldr	r3, [sp, #4]
   1f182:	9a02      	ldr	r2, [sp, #8]
   1f184:	4293      	cmp	r3, r2
   1f186:	d301      	bcc.n	1f18c <disk_read+0x48>
	return RES_OK;
   1f188:	2000      	movs	r0, #0
   1f18a:	e7e6      	b.n	1f15a <disk_read+0x16>
		if (memory_2_ram(drv, sector + uc_sector_size * i,
   1f18c:	0022      	movs	r2, r4
   1f18e:	0031      	movs	r1, r6
   1f190:	4b07      	ldr	r3, [pc, #28]	; (1f1b0 <disk_read+0x6c>)
   1f192:	0038      	movs	r0, r7
   1f194:	4798      	blx	r3
   1f196:	9b03      	ldr	r3, [sp, #12]
   1f198:	1976      	adds	r6, r6, r5
   1f19a:	18e4      	adds	r4, r4, r3
   1f19c:	2800      	cmp	r0, #0
   1f19e:	d1db      	bne.n	1f158 <disk_read+0x14>
	for (i = 0; i < count; i++) {
   1f1a0:	9b01      	ldr	r3, [sp, #4]
   1f1a2:	3301      	adds	r3, #1
   1f1a4:	e7eb      	b.n	1f17e <disk_read+0x3a>
   1f1a6:	46c0      	nop			; (mov r8, r8)
   1f1a8:	0001ce31 	.word	0x0001ce31
   1f1ac:	0001ce19 	.word	0x0001ce19
   1f1b0:	0001ce4d 	.word	0x0001ce4d

0001f1b4 <disk_write>:
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
#if _READONLY == 0
DRESULT disk_write(BYTE drv, BYTE const *buff, DWORD sector, BYTE count)
{
   1f1b4:	b5f0      	push	{r4, r5, r6, r7, lr}
   1f1b6:	b087      	sub	sp, #28
   1f1b8:	9302      	str	r3, [sp, #8]
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
   1f1ba:	4b17      	ldr	r3, [pc, #92]	; (1f218 <disk_write+0x64>)
{
   1f1bc:	0007      	movs	r7, r0
   1f1be:	000c      	movs	r4, r1
   1f1c0:	0016      	movs	r6, r2
	uint8_t uc_sector_size = mem_sector_size(drv);
   1f1c2:	4798      	blx	r3
   1f1c4:	1e05      	subs	r5, r0, #0
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
   1f1c6:	d102      	bne.n	1f1ce <disk_write+0x1a>
		return RES_ERROR;
   1f1c8:	2001      	movs	r0, #1
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
   1f1ca:	b007      	add	sp, #28
   1f1cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	mem_read_capacity(drv, &ul_last_sector_num);
   1f1ce:	4b13      	ldr	r3, [pc, #76]	; (1f21c <disk_write+0x68>)
   1f1d0:	a905      	add	r1, sp, #20
   1f1d2:	0038      	movs	r0, r7
   1f1d4:	4798      	blx	r3
	if ((sector + count * uc_sector_size) >
   1f1d6:	9a02      	ldr	r2, [sp, #8]
			(ul_last_sector_num + 1) * uc_sector_size) {
   1f1d8:	9b05      	ldr	r3, [sp, #20]
	if ((sector + count * uc_sector_size) >
   1f1da:	436a      	muls	r2, r5
			(ul_last_sector_num + 1) * uc_sector_size) {
   1f1dc:	3301      	adds	r3, #1
   1f1de:	436b      	muls	r3, r5
	if ((sector + count * uc_sector_size) >
   1f1e0:	1992      	adds	r2, r2, r6
		return RES_PARERR;
   1f1e2:	2004      	movs	r0, #4
	if ((sector + count * uc_sector_size) >
   1f1e4:	429a      	cmp	r2, r3
   1f1e6:	d8f0      	bhi.n	1f1ca <disk_write+0x16>
   1f1e8:	026b      	lsls	r3, r5, #9
   1f1ea:	9303      	str	r3, [sp, #12]
   1f1ec:	2300      	movs	r3, #0
	for (i = 0; i < count; i++) {
   1f1ee:	9301      	str	r3, [sp, #4]
   1f1f0:	9b01      	ldr	r3, [sp, #4]
   1f1f2:	9a02      	ldr	r2, [sp, #8]
   1f1f4:	4293      	cmp	r3, r2
   1f1f6:	d301      	bcc.n	1f1fc <disk_write+0x48>
	return RES_OK;
   1f1f8:	2000      	movs	r0, #0
   1f1fa:	e7e6      	b.n	1f1ca <disk_write+0x16>
		if (ram_2_memory(drv, sector + uc_sector_size * i,
   1f1fc:	0022      	movs	r2, r4
   1f1fe:	0031      	movs	r1, r6
   1f200:	4b07      	ldr	r3, [pc, #28]	; (1f220 <disk_write+0x6c>)
   1f202:	0038      	movs	r0, r7
   1f204:	4798      	blx	r3
   1f206:	9b03      	ldr	r3, [sp, #12]
   1f208:	1976      	adds	r6, r6, r5
   1f20a:	18e4      	adds	r4, r4, r3
   1f20c:	2800      	cmp	r0, #0
   1f20e:	d1db      	bne.n	1f1c8 <disk_write+0x14>
	for (i = 0; i < count; i++) {
   1f210:	9b01      	ldr	r3, [sp, #4]
   1f212:	3301      	adds	r3, #1
   1f214:	e7eb      	b.n	1f1ee <disk_write+0x3a>
   1f216:	46c0      	nop			; (mov r8, r8)
   1f218:	0001ce31 	.word	0x0001ce31
   1f21c:	0001ce19 	.word	0x0001ce19
   1f220:	0001ce69 	.word	0x0001ce69

0001f224 <disk_ioctl>:
 * \param buff Buffer to send/receive control data.
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_ioctl(BYTE drv, BYTE ctrl, void *buff)
{
   1f224:	b537      	push	{r0, r1, r2, r4, r5, lr}
			res = RES_NOTRDY;
		}
		break;

	default:
		res = RES_PARERR;
   1f226:	2304      	movs	r3, #4
{
   1f228:	0005      	movs	r5, r0
   1f22a:	0014      	movs	r4, r2
	switch (ctrl) {
   1f22c:	2903      	cmp	r1, #3
   1f22e:	d807      	bhi.n	1f240 <disk_ioctl+0x1c>
   1f230:	0008      	movs	r0, r1
   1f232:	f006 fb39 	bl	258a8 <__gnu_thumb1_case_uqi>
   1f236:	071d      	.short	0x071d
   1f238:	020e      	.short	0x020e
		*(DWORD *)buff = 1;
   1f23a:	2301      	movs	r3, #1
		*(DWORD *)buff = ul_last_sector_num + 1;
   1f23c:	6023      	str	r3, [r4, #0]
		res = RES_OK;
   1f23e:	2300      	movs	r3, #0
	}

	return res;
}
   1f240:	0018      	movs	r0, r3
   1f242:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
		mem_read_capacity(drv, &ul_last_sector_num);
   1f244:	4b0e      	ldr	r3, [pc, #56]	; (1f280 <disk_ioctl+0x5c>)
   1f246:	a901      	add	r1, sp, #4
   1f248:	0028      	movs	r0, r5
   1f24a:	4798      	blx	r3
		*(DWORD *)buff = ul_last_sector_num + 1;
   1f24c:	9b01      	ldr	r3, [sp, #4]
   1f24e:	3301      	adds	r3, #1
   1f250:	e7f4      	b.n	1f23c <disk_ioctl+0x18>
		uint8_t uc_sector_size = mem_sector_size(drv);
   1f252:	4b0c      	ldr	r3, [pc, #48]	; (1f284 <disk_ioctl+0x60>)
   1f254:	0028      	movs	r0, r5
   1f256:	4798      	blx	r3
		if ((uc_sector_size != SECTOR_SIZE_512) &&
   1f258:	1e43      	subs	r3, r0, #1
   1f25a:	b2db      	uxtb	r3, r3
   1f25c:	2b01      	cmp	r3, #1
   1f25e:	d904      	bls.n	1f26a <disk_ioctl+0x46>
				(uc_sector_size != SECTOR_SIZE_1024) &&
   1f260:	22fb      	movs	r2, #251	; 0xfb
   1f262:	3804      	subs	r0, #4
			return RES_ERROR;
   1f264:	2301      	movs	r3, #1
				(uc_sector_size != SECTOR_SIZE_1024) &&
   1f266:	4210      	tst	r0, r2
   1f268:	d1ea      	bne.n	1f240 <disk_ioctl+0x1c>
		*(U8 *)buff = uc_sector_size * SECTOR_SIZE_DEFAULT;
   1f26a:	2300      	movs	r3, #0
   1f26c:	7023      	strb	r3, [r4, #0]
	break;
   1f26e:	e7e7      	b.n	1f240 <disk_ioctl+0x1c>
		if (mem_test_unit_ready(drv) == CTRL_GOOD) {
   1f270:	4b05      	ldr	r3, [pc, #20]	; (1f288 <disk_ioctl+0x64>)
   1f272:	0028      	movs	r0, r5
   1f274:	4798      	blx	r3
			res = RES_OK;
   1f276:	1e03      	subs	r3, r0, #0
		if (mem_test_unit_ready(drv) == CTRL_GOOD) {
   1f278:	d0e2      	beq.n	1f240 <disk_ioctl+0x1c>
			res = RES_NOTRDY;
   1f27a:	2303      	movs	r3, #3
   1f27c:	e7e0      	b.n	1f240 <disk_ioctl+0x1c>
   1f27e:	46c0      	nop			; (mov r8, r8)
   1f280:	0001ce19 	.word	0x0001ce19
   1f284:	0001ce31 	.word	0x0001ce31
   1f288:	0001ce05 	.word	0x0001ce05

0001f28c <get_fattime>:
 * bit4:0    Second (0..29)
 *
 * \return Current time.
 */
uint32_t get_fattime(void)
{
   1f28c:	b507      	push	{r0, r1, r2, lr}
	uint32_t ul_time;
	struct rtc_calendar_time current_time;

	/* Retrieve date and time */
	rtc_calendar_get_time(&rtc_instance, &current_time);
   1f28e:	4b0e      	ldr	r3, [pc, #56]	; (1f2c8 <get_fattime+0x3c>)
   1f290:	480e      	ldr	r0, [pc, #56]	; (1f2cc <get_fattime+0x40>)
   1f292:	4669      	mov	r1, sp
   1f294:	4798      	blx	r3

	ul_time = ((current_time.year - 1980) << 25)
			| (current_time.month << 21)
   1f296:	466b      	mov	r3, sp
   1f298:	7958      	ldrb	r0, [r3, #5]
			| (current_time.day << 16)
   1f29a:	791b      	ldrb	r3, [r3, #4]
			| (current_time.month << 21)
   1f29c:	0540      	lsls	r0, r0, #21
			| (current_time.day << 16)
   1f29e:	041b      	lsls	r3, r3, #16
			| (current_time.hour << 11)
			| (current_time.minute << 5)
			| ((current_time.second >> 1) << 0);
   1f2a0:	4318      	orrs	r0, r3
			| (current_time.hour << 11)
   1f2a2:	466b      	mov	r3, sp
   1f2a4:	789b      	ldrb	r3, [r3, #2]
	ul_time = ((current_time.year - 1980) << 25)
   1f2a6:	4a0a      	ldr	r2, [pc, #40]	; (1f2d0 <get_fattime+0x44>)
			| (current_time.hour << 11)
   1f2a8:	02db      	lsls	r3, r3, #11
			| ((current_time.second >> 1) << 0);
   1f2aa:	4318      	orrs	r0, r3
			| (current_time.minute << 5)
   1f2ac:	466b      	mov	r3, sp
   1f2ae:	785b      	ldrb	r3, [r3, #1]
   1f2b0:	015b      	lsls	r3, r3, #5
			| ((current_time.second >> 1) << 0);
   1f2b2:	4318      	orrs	r0, r3
   1f2b4:	466b      	mov	r3, sp
   1f2b6:	781b      	ldrb	r3, [r3, #0]
   1f2b8:	085b      	lsrs	r3, r3, #1
   1f2ba:	4318      	orrs	r0, r3
	ul_time = ((current_time.year - 1980) << 25)
   1f2bc:	466b      	mov	r3, sp
   1f2be:	88db      	ldrh	r3, [r3, #6]
   1f2c0:	189b      	adds	r3, r3, r2
   1f2c2:	065b      	lsls	r3, r3, #25
			| ((current_time.second >> 1) << 0);
   1f2c4:	4318      	orrs	r0, r3

	return ul_time;
}
   1f2c6:	bd0e      	pop	{r1, r2, r3, pc}
   1f2c8:	0001d205 	.word	0x0001d205
   1f2cc:	200056b4 	.word	0x200056b4
   1f2d0:	fffff844 	.word	0xfffff844

0001f2d4 <mem_cpy>:
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
   1f2d4:	2300      	movs	r3, #0
void mem_cpy (void* dst, const void* src, UINT cnt) {
   1f2d6:	b510      	push	{r4, lr}
	while (cnt--)
   1f2d8:	429a      	cmp	r2, r3
   1f2da:	d100      	bne.n	1f2de <mem_cpy+0xa>
		*d++ = *s++;
}
   1f2dc:	bd10      	pop	{r4, pc}
		*d++ = *s++;
   1f2de:	5ccc      	ldrb	r4, [r1, r3]
   1f2e0:	54c4      	strb	r4, [r0, r3]
   1f2e2:	3301      	adds	r3, #1
   1f2e4:	e7f8      	b.n	1f2d8 <mem_cpy+0x4>

0001f2e6 <mem_set>:

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
   1f2e6:	1882      	adds	r2, r0, r2
	BYTE *d = (BYTE*)dst;

	while (cnt--)
   1f2e8:	4290      	cmp	r0, r2
   1f2ea:	d100      	bne.n	1f2ee <mem_set+0x8>
		*d++ = (BYTE)val;
}
   1f2ec:	4770      	bx	lr
		*d++ = (BYTE)val;
   1f2ee:	7001      	strb	r1, [r0, #0]
   1f2f0:	3001      	adds	r0, #1
   1f2f2:	e7f9      	b.n	1f2e8 <mem_set+0x2>

0001f2f4 <clust2sect>:
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
   1f2f4:	6982      	ldr	r2, [r0, #24]
	clst -= 2;
   1f2f6:	3902      	subs	r1, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
   1f2f8:	3a02      	subs	r2, #2
{
   1f2fa:	0003      	movs	r3, r0
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
   1f2fc:	2000      	movs	r0, #0
   1f2fe:	4291      	cmp	r1, r2
   1f300:	d203      	bcs.n	1f30a <clust2sect+0x16>
	return clst * fs->csize + fs->database;
   1f302:	7898      	ldrb	r0, [r3, #2]
   1f304:	4341      	muls	r1, r0
   1f306:	6a98      	ldr	r0, [r3, #40]	; 0x28
   1f308:	1808      	adds	r0, r1, r0
}
   1f30a:	4770      	bx	lr

0001f30c <sum_sfn>:
#if _USE_LFN
static
BYTE sum_sfn (
	const BYTE *dir		/* Ptr to directory entry */
)
{
   1f30c:	0001      	movs	r1, r0
	BYTE sum = 0;
   1f30e:	2300      	movs	r3, #0
   1f310:	310b      	adds	r1, #11
	UINT n = 11;

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
   1f312:	085a      	lsrs	r2, r3, #1
   1f314:	01db      	lsls	r3, r3, #7
   1f316:	4313      	orrs	r3, r2
   1f318:	7802      	ldrb	r2, [r0, #0]
   1f31a:	3001      	adds	r0, #1
   1f31c:	189b      	adds	r3, r3, r2
   1f31e:	b2db      	uxtb	r3, r3
   1f320:	4288      	cmp	r0, r1
   1f322:	d1f6      	bne.n	1f312 <sum_sfn+0x6>
	return sum;
}
   1f324:	0018      	movs	r0, r3
   1f326:	4770      	bx	lr

0001f328 <move_window>:
{
   1f328:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	wsect = fs->winsect;
   1f32a:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
{
   1f32c:	0004      	movs	r4, r0
   1f32e:	000e      	movs	r6, r1
	if (wsect != sector) {	/* Changed current window */
   1f330:	428d      	cmp	r5, r1
   1f332:	d101      	bne.n	1f338 <move_window+0x10>
	return FR_OK;
   1f334:	2000      	movs	r0, #0
}
   1f336:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		if (fs->wflag) {	/* Write back dirty window if needed */
   1f338:	7903      	ldrb	r3, [r0, #4]
   1f33a:	2b00      	cmp	r3, #0
   1f33c:	d10c      	bne.n	1f358 <move_window+0x30>
		if (sector) {
   1f33e:	2e00      	cmp	r6, #0
   1f340:	d0f8      	beq.n	1f334 <move_window+0xc>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
   1f342:	0021      	movs	r1, r4
   1f344:	7860      	ldrb	r0, [r4, #1]
   1f346:	2301      	movs	r3, #1
   1f348:	0032      	movs	r2, r6
   1f34a:	3130      	adds	r1, #48	; 0x30
   1f34c:	4d14      	ldr	r5, [pc, #80]	; (1f3a0 <move_window+0x78>)
   1f34e:	47a8      	blx	r5
   1f350:	2800      	cmp	r0, #0
   1f352:	d10c      	bne.n	1f36e <move_window+0x46>
			fs->winsect = sector;
   1f354:	62e6      	str	r6, [r4, #44]	; 0x2c
   1f356:	e7ee      	b.n	1f336 <move_window+0xe>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
   1f358:	0003      	movs	r3, r0
   1f35a:	3330      	adds	r3, #48	; 0x30
   1f35c:	9301      	str	r3, [sp, #4]
   1f35e:	7840      	ldrb	r0, [r0, #1]
   1f360:	2301      	movs	r3, #1
   1f362:	002a      	movs	r2, r5
   1f364:	9901      	ldr	r1, [sp, #4]
   1f366:	4f0f      	ldr	r7, [pc, #60]	; (1f3a4 <move_window+0x7c>)
   1f368:	47b8      	blx	r7
   1f36a:	2800      	cmp	r0, #0
   1f36c:	d001      	beq.n	1f372 <move_window+0x4a>
				return FR_DISK_ERR;
   1f36e:	2001      	movs	r0, #1
   1f370:	e7e1      	b.n	1f336 <move_window+0xe>
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
   1f372:	6a23      	ldr	r3, [r4, #32]
   1f374:	69e2      	ldr	r2, [r4, #28]
			fs->wflag = 0;
   1f376:	7120      	strb	r0, [r4, #4]
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
   1f378:	189b      	adds	r3, r3, r2
   1f37a:	429d      	cmp	r5, r3
   1f37c:	d2df      	bcs.n	1f33e <move_window+0x16>
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
   1f37e:	78e3      	ldrb	r3, [r4, #3]
   1f380:	9300      	str	r3, [sp, #0]
   1f382:	9b00      	ldr	r3, [sp, #0]
   1f384:	2b01      	cmp	r3, #1
   1f386:	d9da      	bls.n	1f33e <move_window+0x16>
					wsect += fs->fsize;
   1f388:	69e3      	ldr	r3, [r4, #28]
					disk_write(fs->drv, fs->win, wsect, 1);
   1f38a:	4f06      	ldr	r7, [pc, #24]	; (1f3a4 <move_window+0x7c>)
					wsect += fs->fsize;
   1f38c:	18ed      	adds	r5, r5, r3
					disk_write(fs->drv, fs->win, wsect, 1);
   1f38e:	7860      	ldrb	r0, [r4, #1]
   1f390:	2301      	movs	r3, #1
   1f392:	002a      	movs	r2, r5
   1f394:	9901      	ldr	r1, [sp, #4]
   1f396:	47b8      	blx	r7
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
   1f398:	9f00      	ldr	r7, [sp, #0]
   1f39a:	3f01      	subs	r7, #1
   1f39c:	b2fb      	uxtb	r3, r7
   1f39e:	e7ef      	b.n	1f380 <move_window+0x58>
   1f3a0:	0001f145 	.word	0x0001f145
   1f3a4:	0001f1b5 	.word	0x0001f1b5

0001f3a8 <sync>:
{
   1f3a8:	b570      	push	{r4, r5, r6, lr}
	res = move_window(fs, 0);
   1f3aa:	2100      	movs	r1, #0
   1f3ac:	4b2c      	ldr	r3, [pc, #176]	; (1f460 <sync+0xb8>)
{
   1f3ae:	0004      	movs	r4, r0
	res = move_window(fs, 0);
   1f3b0:	4798      	blx	r3
   1f3b2:	1e05      	subs	r5, r0, #0
	if (res == FR_OK) {
   1f3b4:	d152      	bne.n	1f45c <sync+0xb4>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
   1f3b6:	7823      	ldrb	r3, [r4, #0]
   1f3b8:	2b03      	cmp	r3, #3
   1f3ba:	d147      	bne.n	1f44c <sync+0xa4>
   1f3bc:	7963      	ldrb	r3, [r4, #5]
   1f3be:	2b00      	cmp	r3, #0
   1f3c0:	d044      	beq.n	1f44c <sync+0xa4>
			mem_set(fs->win, 0, 512);
   1f3c2:	0026      	movs	r6, r4
   1f3c4:	2280      	movs	r2, #128	; 0x80
   1f3c6:	3630      	adds	r6, #48	; 0x30
   1f3c8:	0001      	movs	r1, r0
			fs->winsect = 0;
   1f3ca:	62e0      	str	r0, [r4, #44]	; 0x2c
			mem_set(fs->win, 0, 512);
   1f3cc:	0092      	lsls	r2, r2, #2
   1f3ce:	0030      	movs	r0, r6
   1f3d0:	4b24      	ldr	r3, [pc, #144]	; (1f464 <sync+0xbc>)
   1f3d2:	4798      	blx	r3
			ST_WORD(fs->win+BS_55AA, 0xAA55);
   1f3d4:	2255      	movs	r2, #85	; 0x55
   1f3d6:	4b24      	ldr	r3, [pc, #144]	; (1f468 <sync+0xc0>)
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
   1f3d8:	2141      	movs	r1, #65	; 0x41
			ST_WORD(fs->win+BS_55AA, 0xAA55);
   1f3da:	54e2      	strb	r2, [r4, r3]
   1f3dc:	4b23      	ldr	r3, [pc, #140]	; (1f46c <sync+0xc4>)
   1f3de:	1892      	adds	r2, r2, r2
   1f3e0:	54e2      	strb	r2, [r4, r3]
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
   1f3e2:	0022      	movs	r2, r4
   1f3e4:	3bde      	subs	r3, #222	; 0xde
   1f3e6:	3bff      	subs	r3, #255	; 0xff
   1f3e8:	3231      	adds	r2, #49	; 0x31
   1f3ea:	7033      	strb	r3, [r6, #0]
   1f3ec:	7013      	strb	r3, [r2, #0]
   1f3ee:	0023      	movs	r3, r4
   1f3f0:	2261      	movs	r2, #97	; 0x61
   1f3f2:	3332      	adds	r3, #50	; 0x32
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
   1f3f4:	2085      	movs	r0, #133	; 0x85
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
   1f3f6:	701a      	strb	r2, [r3, #0]
   1f3f8:	7059      	strb	r1, [r3, #1]
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
   1f3fa:	2372      	movs	r3, #114	; 0x72
   1f3fc:	0080      	lsls	r0, r0, #2
   1f3fe:	5423      	strb	r3, [r4, r0]
   1f400:	481b      	ldr	r0, [pc, #108]	; (1f470 <sync+0xc8>)
   1f402:	5423      	strb	r3, [r4, r0]
   1f404:	4b1b      	ldr	r3, [pc, #108]	; (1f474 <sync+0xcc>)
   1f406:	54e1      	strb	r1, [r4, r3]
   1f408:	4b1b      	ldr	r3, [pc, #108]	; (1f478 <sync+0xd0>)
   1f40a:	54e2      	strb	r2, [r4, r3]
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
   1f40c:	6923      	ldr	r3, [r4, #16]
   1f40e:	32b8      	adds	r2, #184	; 0xb8
   1f410:	32ff      	adds	r2, #255	; 0xff
   1f412:	54a3      	strb	r3, [r4, r2]
   1f414:	4a19      	ldr	r2, [pc, #100]	; (1f47c <sync+0xd4>)
   1f416:	0a19      	lsrs	r1, r3, #8
   1f418:	54a1      	strb	r1, [r4, r2]
   1f41a:	4a19      	ldr	r2, [pc, #100]	; (1f480 <sync+0xd8>)
   1f41c:	0c19      	lsrs	r1, r3, #16
   1f41e:	54a1      	strb	r1, [r4, r2]
   1f420:	4a18      	ldr	r2, [pc, #96]	; (1f484 <sync+0xdc>)
   1f422:	0e1b      	lsrs	r3, r3, #24
   1f424:	54a3      	strb	r3, [r4, r2]
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
   1f426:	68e3      	ldr	r3, [r4, #12]
   1f428:	3201      	adds	r2, #1
   1f42a:	54a3      	strb	r3, [r4, r2]
   1f42c:	4a16      	ldr	r2, [pc, #88]	; (1f488 <sync+0xe0>)
   1f42e:	0a19      	lsrs	r1, r3, #8
   1f430:	54a1      	strb	r1, [r4, r2]
   1f432:	4a16      	ldr	r2, [pc, #88]	; (1f48c <sync+0xe4>)
   1f434:	0c19      	lsrs	r1, r3, #16
   1f436:	54a1      	strb	r1, [r4, r2]
   1f438:	4a15      	ldr	r2, [pc, #84]	; (1f490 <sync+0xe8>)
   1f43a:	0e1b      	lsrs	r3, r3, #24
   1f43c:	54a3      	strb	r3, [r4, r2]
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
   1f43e:	0031      	movs	r1, r6
   1f440:	7860      	ldrb	r0, [r4, #1]
   1f442:	2301      	movs	r3, #1
   1f444:	6962      	ldr	r2, [r4, #20]
   1f446:	4e13      	ldr	r6, [pc, #76]	; (1f494 <sync+0xec>)
   1f448:	47b0      	blx	r6
			fs->fsi_flag = 0;
   1f44a:	7165      	strb	r5, [r4, #5]
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
   1f44c:	2200      	movs	r2, #0
   1f44e:	4b12      	ldr	r3, [pc, #72]	; (1f498 <sync+0xf0>)
   1f450:	7860      	ldrb	r0, [r4, #1]
   1f452:	0011      	movs	r1, r2
   1f454:	4798      	blx	r3
   1f456:	1e43      	subs	r3, r0, #1
   1f458:	4198      	sbcs	r0, r3
   1f45a:	b2c0      	uxtb	r0, r0
}
   1f45c:	bd70      	pop	{r4, r5, r6, pc}
   1f45e:	46c0      	nop			; (mov r8, r8)
   1f460:	0001f329 	.word	0x0001f329
   1f464:	0001f2e7 	.word	0x0001f2e7
   1f468:	0000022e 	.word	0x0000022e
   1f46c:	0000022f 	.word	0x0000022f
   1f470:	00000215 	.word	0x00000215
   1f474:	00000216 	.word	0x00000216
   1f478:	00000217 	.word	0x00000217
   1f47c:	00000219 	.word	0x00000219
   1f480:	0000021a 	.word	0x0000021a
   1f484:	0000021b 	.word	0x0000021b
   1f488:	0000021d 	.word	0x0000021d
   1f48c:	0000021e 	.word	0x0000021e
   1f490:	0000021f 	.word	0x0000021f
   1f494:	0001f1b5 	.word	0x0001f1b5
   1f498:	0001f225 	.word	0x0001f225

0001f49c <validate>:
static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
   1f49c:	b510      	push	{r4, lr}
	if (!fs || !fs->fs_type || fs->id != id)
		return FR_INVALID_OBJECT;
   1f49e:	2309      	movs	r3, #9
	if (!fs || !fs->fs_type || fs->id != id)
   1f4a0:	2800      	cmp	r0, #0
   1f4a2:	d00c      	beq.n	1f4be <validate+0x22>
   1f4a4:	7802      	ldrb	r2, [r0, #0]
   1f4a6:	2a00      	cmp	r2, #0
   1f4a8:	d009      	beq.n	1f4be <validate+0x22>
   1f4aa:	88c2      	ldrh	r2, [r0, #6]
   1f4ac:	428a      	cmp	r2, r1
   1f4ae:	d106      	bne.n	1f4be <validate+0x22>

	ENTER_FF(fs);		/* Lock file system */

	if (disk_status(fs->drv) & STA_NOINIT)
   1f4b0:	4b04      	ldr	r3, [pc, #16]	; (1f4c4 <validate+0x28>)
   1f4b2:	7840      	ldrb	r0, [r0, #1]
   1f4b4:	4798      	blx	r3
		return FR_NOT_READY;
   1f4b6:	2303      	movs	r3, #3

	return FR_OK;
   1f4b8:	07c0      	lsls	r0, r0, #31
   1f4ba:	17c0      	asrs	r0, r0, #31
   1f4bc:	4003      	ands	r3, r0
}
   1f4be:	0018      	movs	r0, r3
   1f4c0:	bd10      	pop	{r4, pc}
   1f4c2:	46c0      	nop			; (mov r8, r8)
   1f4c4:	0001f129 	.word	0x0001f129

0001f4c8 <check_fs>:
{
   1f4c8:	000a      	movs	r2, r1
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
   1f4ca:	0001      	movs	r1, r0
{
   1f4cc:	b570      	push	{r4, r5, r6, lr}
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
   1f4ce:	2301      	movs	r3, #1
{
   1f4d0:	0004      	movs	r4, r0
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
   1f4d2:	3130      	adds	r1, #48	; 0x30
   1f4d4:	7840      	ldrb	r0, [r0, #1]
   1f4d6:	4d16      	ldr	r5, [pc, #88]	; (1f530 <check_fs+0x68>)
   1f4d8:	47a8      	blx	r5
		return 3;
   1f4da:	2303      	movs	r3, #3
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
   1f4dc:	2800      	cmp	r0, #0
   1f4de:	d124      	bne.n	1f52a <check_fs+0x62>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
   1f4e0:	4b14      	ldr	r3, [pc, #80]	; (1f534 <check_fs+0x6c>)
   1f4e2:	4a15      	ldr	r2, [pc, #84]	; (1f538 <check_fs+0x70>)
   1f4e4:	5ce3      	ldrb	r3, [r4, r3]
   1f4e6:	5ca2      	ldrb	r2, [r4, r2]
   1f4e8:	021b      	lsls	r3, r3, #8
   1f4ea:	431a      	orrs	r2, r3
   1f4ec:	4913      	ldr	r1, [pc, #76]	; (1f53c <check_fs+0x74>)
   1f4ee:	b212      	sxth	r2, r2
		return 2;
   1f4f0:	2302      	movs	r3, #2
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
   1f4f2:	428a      	cmp	r2, r1
   1f4f4:	d119      	bne.n	1f52a <check_fs+0x62>
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
   1f4f6:	0023      	movs	r3, r4
   1f4f8:	3366      	adds	r3, #102	; 0x66
   1f4fa:	885a      	ldrh	r2, [r3, #2]
   1f4fc:	8819      	ldrh	r1, [r3, #0]
   1f4fe:	0412      	lsls	r2, r2, #16
   1f500:	430a      	orrs	r2, r1
   1f502:	490f      	ldr	r1, [pc, #60]	; (1f540 <check_fs+0x78>)
   1f504:	0212      	lsls	r2, r2, #8
   1f506:	0a12      	lsrs	r2, r2, #8
		return 0;
   1f508:	0003      	movs	r3, r0
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
   1f50a:	428a      	cmp	r2, r1
   1f50c:	d00d      	beq.n	1f52a <check_fs+0x62>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
   1f50e:	0023      	movs	r3, r4
   1f510:	3484      	adds	r4, #132	; 0x84
   1f512:	3382      	adds	r3, #130	; 0x82
   1f514:	8818      	ldrh	r0, [r3, #0]
   1f516:	8823      	ldrh	r3, [r4, #0]
   1f518:	4a0a      	ldr	r2, [pc, #40]	; (1f544 <check_fs+0x7c>)
   1f51a:	041b      	lsls	r3, r3, #16
   1f51c:	4303      	orrs	r3, r0
   1f51e:	021b      	lsls	r3, r3, #8
   1f520:	0a1b      	lsrs	r3, r3, #8
   1f522:	189b      	adds	r3, r3, r2
   1f524:	1e58      	subs	r0, r3, #1
   1f526:	4183      	sbcs	r3, r0
		return 3;
   1f528:	b2db      	uxtb	r3, r3
}
   1f52a:	0018      	movs	r0, r3
   1f52c:	bd70      	pop	{r4, r5, r6, pc}
   1f52e:	46c0      	nop			; (mov r8, r8)
   1f530:	0001f145 	.word	0x0001f145
   1f534:	0000022f 	.word	0x0000022f
   1f538:	0000022e 	.word	0x0000022e
   1f53c:	ffffaa55 	.word	0xffffaa55
   1f540:	00544146 	.word	0x00544146
   1f544:	ffabbeba 	.word	0xffabbeba

0001f548 <chk_mounted>:
{
   1f548:	b5f0      	push	{r4, r5, r6, r7, lr}
	const TCHAR *p = *path;
   1f54a:	6803      	ldr	r3, [r0, #0]
{
   1f54c:	b085      	sub	sp, #20
	vol = p[0] - '0';					/* Is there a drive number? */
   1f54e:	781d      	ldrb	r5, [r3, #0]
{
   1f550:	0016      	movs	r6, r2
	vol = p[0] - '0';					/* Is there a drive number? */
   1f552:	3d30      	subs	r5, #48	; 0x30
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
   1f554:	2d09      	cmp	r5, #9
   1f556:	d81f      	bhi.n	1f598 <chk_mounted+0x50>
   1f558:	785a      	ldrb	r2, [r3, #1]
   1f55a:	2a3a      	cmp	r2, #58	; 0x3a
   1f55c:	d11c      	bne.n	1f598 <chk_mounted+0x50>
		p += 2; *path = p;				/* Return pointer to the path name */
   1f55e:	3302      	adds	r3, #2
   1f560:	6003      	str	r3, [r0, #0]
		return FR_INVALID_DRIVE;
   1f562:	230b      	movs	r3, #11
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
   1f564:	2d07      	cmp	r5, #7
   1f566:	d814      	bhi.n	1f592 <chk_mounted+0x4a>
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
   1f568:	4b88      	ldr	r3, [pc, #544]	; (1f78c <chk_mounted+0x244>)
   1f56a:	00aa      	lsls	r2, r5, #2
   1f56c:	58d4      	ldr	r4, [r2, r3]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
   1f56e:	230c      	movs	r3, #12
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
   1f570:	600c      	str	r4, [r1, #0]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
   1f572:	2c00      	cmp	r4, #0
   1f574:	d00d      	beq.n	1f592 <chk_mounted+0x4a>
	if (fs->fs_type) {					/* If the logical drive has been mounted */
   1f576:	7823      	ldrb	r3, [r4, #0]
   1f578:	2b00      	cmp	r3, #0
   1f57a:	d00f      	beq.n	1f59c <chk_mounted+0x54>
		stat = disk_status(fs->drv);
   1f57c:	4b84      	ldr	r3, [pc, #528]	; (1f790 <chk_mounted+0x248>)
   1f57e:	7860      	ldrb	r0, [r4, #1]
   1f580:	4798      	blx	r3
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
   1f582:	2301      	movs	r3, #1
   1f584:	4003      	ands	r3, r0
   1f586:	d109      	bne.n	1f59c <chk_mounted+0x54>
			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
   1f588:	2e00      	cmp	r6, #0
   1f58a:	d002      	beq.n	1f592 <chk_mounted+0x4a>
   1f58c:	0742      	lsls	r2, r0, #29
   1f58e:	d500      	bpl.n	1f592 <chk_mounted+0x4a>
				return FR_WRITE_PROTECTED;
   1f590:	230a      	movs	r3, #10
}
   1f592:	0018      	movs	r0, r3
   1f594:	b005      	add	sp, #20
   1f596:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f598:	2500      	movs	r5, #0
   1f59a:	e7e5      	b.n	1f568 <chk_mounted+0x20>
	fs->fs_type = 0;					/* Clear the file system object */
   1f59c:	2300      	movs	r3, #0
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
   1f59e:	b2e8      	uxtb	r0, r5
	fs->fs_type = 0;					/* Clear the file system object */
   1f5a0:	7023      	strb	r3, [r4, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
   1f5a2:	7060      	strb	r0, [r4, #1]
	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
   1f5a4:	4b7b      	ldr	r3, [pc, #492]	; (1f794 <chk_mounted+0x24c>)
   1f5a6:	4798      	blx	r3
		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
   1f5a8:	2303      	movs	r3, #3
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
   1f5aa:	07c2      	lsls	r2, r0, #31
   1f5ac:	d4f1      	bmi.n	1f592 <chk_mounted+0x4a>
	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
   1f5ae:	2e00      	cmp	r6, #0
   1f5b0:	d001      	beq.n	1f5b6 <chk_mounted+0x6e>
   1f5b2:	0743      	lsls	r3, r0, #29
   1f5b4:	d4ec      	bmi.n	1f590 <chk_mounted+0x48>
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
   1f5b6:	2100      	movs	r1, #0
   1f5b8:	0020      	movs	r0, r4
   1f5ba:	4d77      	ldr	r5, [pc, #476]	; (1f798 <chk_mounted+0x250>)
   1f5bc:	47a8      	blx	r5
   1f5be:	2600      	movs	r6, #0
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
   1f5c0:	2801      	cmp	r0, #1
   1f5c2:	d116      	bne.n	1f5f2 <chk_mounted+0xaa>
		if (tbl[4]) {						/* Is the partition existing? */
   1f5c4:	23f9      	movs	r3, #249	; 0xf9
   1f5c6:	005b      	lsls	r3, r3, #1
   1f5c8:	5ce3      	ldrb	r3, [r4, r3]
   1f5ca:	42b3      	cmp	r3, r6
   1f5cc:	d101      	bne.n	1f5d2 <chk_mounted+0x8a>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
   1f5ce:	230d      	movs	r3, #13
   1f5d0:	e7df      	b.n	1f592 <chk_mounted+0x4a>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
   1f5d2:	23fb      	movs	r3, #251	; 0xfb
   1f5d4:	005b      	lsls	r3, r3, #1
   1f5d6:	18e1      	adds	r1, r4, r3
   1f5d8:	5ce6      	ldrb	r6, [r4, r3]
   1f5da:	784b      	ldrb	r3, [r1, #1]
			fmt = check_fs(fs, bsect);		/* Check the partition */
   1f5dc:	0020      	movs	r0, r4
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
   1f5de:	021b      	lsls	r3, r3, #8
   1f5e0:	4333      	orrs	r3, r6
   1f5e2:	788e      	ldrb	r6, [r1, #2]
   1f5e4:	0436      	lsls	r6, r6, #16
   1f5e6:	4333      	orrs	r3, r6
   1f5e8:	78ce      	ldrb	r6, [r1, #3]
   1f5ea:	0636      	lsls	r6, r6, #24
   1f5ec:	431e      	orrs	r6, r3
			fmt = check_fs(fs, bsect);		/* Check the partition */
   1f5ee:	0031      	movs	r1, r6
   1f5f0:	47a8      	blx	r5
	if (fmt == 3) return FR_DISK_ERR;
   1f5f2:	2301      	movs	r3, #1
   1f5f4:	2803      	cmp	r0, #3
   1f5f6:	d0cc      	beq.n	1f592 <chk_mounted+0x4a>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
   1f5f8:	2800      	cmp	r0, #0
   1f5fa:	d1e8      	bne.n	1f5ce <chk_mounted+0x86>
	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
   1f5fc:	0023      	movs	r3, r4
   1f5fe:	333c      	adds	r3, #60	; 0x3c
   1f600:	781a      	ldrb	r2, [r3, #0]
   1f602:	3b01      	subs	r3, #1
   1f604:	781b      	ldrb	r3, [r3, #0]
   1f606:	0212      	lsls	r2, r2, #8
   1f608:	4313      	orrs	r3, r2
   1f60a:	2280      	movs	r2, #128	; 0x80
   1f60c:	b21b      	sxth	r3, r3
   1f60e:	0092      	lsls	r2, r2, #2
   1f610:	4293      	cmp	r3, r2
   1f612:	d1dc      	bne.n	1f5ce <chk_mounted+0x86>
	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
   1f614:	0023      	movs	r3, r4
   1f616:	3347      	adds	r3, #71	; 0x47
   1f618:	781a      	ldrb	r2, [r3, #0]
   1f61a:	3b01      	subs	r3, #1
   1f61c:	781b      	ldrb	r3, [r3, #0]
   1f61e:	0212      	lsls	r2, r2, #8
   1f620:	4313      	orrs	r3, r2
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
   1f622:	d100      	bne.n	1f626 <chk_mounted+0xde>
   1f624:	e09f      	b.n	1f766 <chk_mounted+0x21e>
   1f626:	9300      	str	r3, [sp, #0]
	fs->fsize = fasize;
   1f628:	9b00      	ldr	r3, [sp, #0]
   1f62a:	61e3      	str	r3, [r4, #28]
	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
   1f62c:	0023      	movs	r3, r4
   1f62e:	3340      	adds	r3, #64	; 0x40
   1f630:	781b      	ldrb	r3, [r3, #0]
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
   1f632:	1e5a      	subs	r2, r3, #1
	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
   1f634:	70e3      	strb	r3, [r4, #3]
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
   1f636:	2a01      	cmp	r2, #1
   1f638:	d8c9      	bhi.n	1f5ce <chk_mounted+0x86>
	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
   1f63a:	0022      	movs	r2, r4
   1f63c:	323d      	adds	r2, #61	; 0x3d
   1f63e:	7811      	ldrb	r1, [r2, #0]
   1f640:	70a1      	strb	r1, [r4, #2]
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
   1f642:	2900      	cmp	r1, #0
   1f644:	d0c3      	beq.n	1f5ce <chk_mounted+0x86>
   1f646:	1e4a      	subs	r2, r1, #1
   1f648:	4211      	tst	r1, r2
   1f64a:	d1c0      	bne.n	1f5ce <chk_mounted+0x86>
	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
   1f64c:	0022      	movs	r2, r4
   1f64e:	3242      	adds	r2, #66	; 0x42
   1f650:	7817      	ldrb	r7, [r2, #0]
   1f652:	3a01      	subs	r2, #1
   1f654:	7812      	ldrb	r2, [r2, #0]
   1f656:	023f      	lsls	r7, r7, #8
   1f658:	4317      	orrs	r7, r2
   1f65a:	8127      	strh	r7, [r4, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
   1f65c:	073a      	lsls	r2, r7, #28
   1f65e:	d1b6      	bne.n	1f5ce <chk_mounted+0x86>
	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
   1f660:	0022      	movs	r2, r4
   1f662:	3244      	adds	r2, #68	; 0x44
   1f664:	7810      	ldrb	r0, [r2, #0]
   1f666:	3a01      	subs	r2, #1
   1f668:	7812      	ldrb	r2, [r2, #0]
   1f66a:	0200      	lsls	r0, r0, #8
   1f66c:	4310      	orrs	r0, r2
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
   1f66e:	d100      	bne.n	1f672 <chk_mounted+0x12a>
   1f670:	6d20      	ldr	r0, [r4, #80]	; 0x50
	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
   1f672:	0022      	movs	r2, r4
   1f674:	0025      	movs	r5, r4
   1f676:	323f      	adds	r2, #63	; 0x3f
   1f678:	7812      	ldrb	r2, [r2, #0]
   1f67a:	353e      	adds	r5, #62	; 0x3e
   1f67c:	782d      	ldrb	r5, [r5, #0]
   1f67e:	0212      	lsls	r2, r2, #8
   1f680:	4315      	orrs	r5, r2
   1f682:	9501      	str	r5, [sp, #4]
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
   1f684:	d0a3      	beq.n	1f5ce <chk_mounted+0x86>
	fasize *= b;										/* Number of sectors for FAT area */
   1f686:	9a00      	ldr	r2, [sp, #0]
   1f688:	435a      	muls	r2, r3
   1f68a:	9203      	str	r2, [sp, #12]
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
   1f68c:	093b      	lsrs	r3, r7, #4
   1f68e:	9a03      	ldr	r2, [sp, #12]
   1f690:	195b      	adds	r3, r3, r5
   1f692:	189b      	adds	r3, r3, r2
   1f694:	9302      	str	r3, [sp, #8]
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
   1f696:	4298      	cmp	r0, r3
   1f698:	d399      	bcc.n	1f5ce <chk_mounted+0x86>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
   1f69a:	1ac0      	subs	r0, r0, r3
   1f69c:	4b3f      	ldr	r3, [pc, #252]	; (1f79c <chk_mounted+0x254>)
   1f69e:	4798      	blx	r3
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
   1f6a0:	2800      	cmp	r0, #0
   1f6a2:	d094      	beq.n	1f5ce <chk_mounted+0x86>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
   1f6a4:	4b3e      	ldr	r3, [pc, #248]	; (1f7a0 <chk_mounted+0x258>)
	fmt = FS_FAT12;
   1f6a6:	2501      	movs	r5, #1
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
   1f6a8:	4298      	cmp	r0, r3
   1f6aa:	d904      	bls.n	1f6b6 <chk_mounted+0x16e>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
   1f6ac:	4d3d      	ldr	r5, [pc, #244]	; (1f7a4 <chk_mounted+0x25c>)
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
   1f6ae:	4285      	cmp	r5, r0
   1f6b0:	41ad      	sbcs	r5, r5
   1f6b2:	426d      	negs	r5, r5
   1f6b4:	3502      	adds	r5, #2
	fs->database = bsect + sysect;						/* Data start sector */
   1f6b6:	9b02      	ldr	r3, [sp, #8]
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
   1f6b8:	3002      	adds	r0, #2
	fs->database = bsect + sysect;						/* Data start sector */
   1f6ba:	18f3      	adds	r3, r6, r3
   1f6bc:	62a3      	str	r3, [r4, #40]	; 0x28
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
   1f6be:	9b01      	ldr	r3, [sp, #4]
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
   1f6c0:	61a0      	str	r0, [r4, #24]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
   1f6c2:	18f3      	adds	r3, r6, r3
   1f6c4:	6223      	str	r3, [r4, #32]
	if (fmt == FS_FAT32) {
   1f6c6:	2d03      	cmp	r5, #3
   1f6c8:	d14f      	bne.n	1f76a <chk_mounted+0x222>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
   1f6ca:	2f00      	cmp	r7, #0
   1f6cc:	d000      	beq.n	1f6d0 <chk_mounted+0x188>
   1f6ce:	e77e      	b.n	1f5ce <chk_mounted+0x86>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
   1f6d0:	6de3      	ldr	r3, [r4, #92]	; 0x5c
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
   1f6d2:	0080      	lsls	r0, r0, #2
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
   1f6d4:	6263      	str	r3, [r4, #36]	; 0x24
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
   1f6d6:	4b34      	ldr	r3, [pc, #208]	; (1f7a8 <chk_mounted+0x260>)
   1f6d8:	18c0      	adds	r0, r0, r3
   1f6da:	9b00      	ldr	r3, [sp, #0]
   1f6dc:	0a40      	lsrs	r0, r0, #9
   1f6de:	4283      	cmp	r3, r0
   1f6e0:	d200      	bcs.n	1f6e4 <chk_mounted+0x19c>
   1f6e2:	e774      	b.n	1f5ce <chk_mounted+0x86>
	fs->free_clust = 0xFFFFFFFF;
   1f6e4:	2301      	movs	r3, #1
   1f6e6:	425b      	negs	r3, r3
   1f6e8:	6123      	str	r3, [r4, #16]
	fs->last_clust = 0;
   1f6ea:	2300      	movs	r3, #0
   1f6ec:	60e3      	str	r3, [r4, #12]
	if (fmt == FS_FAT32) {
   1f6ee:	2d03      	cmp	r5, #3
   1f6f0:	d12e      	bne.n	1f750 <chk_mounted+0x208>
	 	fs->fsi_flag = 0;
   1f6f2:	7163      	strb	r3, [r4, #5]
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
   1f6f4:	0023      	movs	r3, r4
   1f6f6:	0022      	movs	r2, r4
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
   1f6f8:	0021      	movs	r1, r4
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
   1f6fa:	3361      	adds	r3, #97	; 0x61
   1f6fc:	781b      	ldrb	r3, [r3, #0]
   1f6fe:	3260      	adds	r2, #96	; 0x60
   1f700:	7812      	ldrb	r2, [r2, #0]
   1f702:	021b      	lsls	r3, r3, #8
   1f704:	431a      	orrs	r2, r3
   1f706:	1992      	adds	r2, r2, r6
   1f708:	6162      	str	r2, [r4, #20]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
   1f70a:	7860      	ldrb	r0, [r4, #1]
   1f70c:	2301      	movs	r3, #1
   1f70e:	3130      	adds	r1, #48	; 0x30
   1f710:	4e26      	ldr	r6, [pc, #152]	; (1f7ac <chk_mounted+0x264>)
   1f712:	47b0      	blx	r6
   1f714:	2800      	cmp	r0, #0
   1f716:	d11b      	bne.n	1f750 <chk_mounted+0x208>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
   1f718:	4b25      	ldr	r3, [pc, #148]	; (1f7b0 <chk_mounted+0x268>)
   1f71a:	5ce2      	ldrb	r2, [r4, r3]
   1f71c:	4b25      	ldr	r3, [pc, #148]	; (1f7b4 <chk_mounted+0x26c>)
   1f71e:	0212      	lsls	r2, r2, #8
   1f720:	5ce3      	ldrb	r3, [r4, r3]
   1f722:	4313      	orrs	r3, r2
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
   1f724:	4a24      	ldr	r2, [pc, #144]	; (1f7b8 <chk_mounted+0x270>)
   1f726:	b21b      	sxth	r3, r3
   1f728:	4293      	cmp	r3, r2
   1f72a:	d111      	bne.n	1f750 <chk_mounted+0x208>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
   1f72c:	4b23      	ldr	r3, [pc, #140]	; (1f7bc <chk_mounted+0x274>)
   1f72e:	6b22      	ldr	r2, [r4, #48]	; 0x30
   1f730:	429a      	cmp	r2, r3
   1f732:	d10d      	bne.n	1f750 <chk_mounted+0x208>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
   1f734:	2285      	movs	r2, #133	; 0x85
   1f736:	0092      	lsls	r2, r2, #2
   1f738:	4b21      	ldr	r3, [pc, #132]	; (1f7c0 <chk_mounted+0x278>)
   1f73a:	58a2      	ldr	r2, [r4, r2]
   1f73c:	429a      	cmp	r2, r3
   1f73e:	d107      	bne.n	1f750 <chk_mounted+0x208>
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
   1f740:	2387      	movs	r3, #135	; 0x87
   1f742:	009b      	lsls	r3, r3, #2
   1f744:	58e3      	ldr	r3, [r4, r3]
   1f746:	60e3      	str	r3, [r4, #12]
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
   1f748:	2386      	movs	r3, #134	; 0x86
   1f74a:	009b      	lsls	r3, r3, #2
   1f74c:	58e3      	ldr	r3, [r4, r3]
   1f74e:	6123      	str	r3, [r4, #16]
	fs->id = ++Fsid;		/* File system mount ID */
   1f750:	4a1c      	ldr	r2, [pc, #112]	; (1f7c4 <chk_mounted+0x27c>)
	fs->fs_type = fmt;		/* FAT sub-type */
   1f752:	7025      	strb	r5, [r4, #0]
	fs->id = ++Fsid;		/* File system mount ID */
   1f754:	8813      	ldrh	r3, [r2, #0]
   1f756:	3301      	adds	r3, #1
   1f758:	b29b      	uxth	r3, r3
   1f75a:	8013      	strh	r3, [r2, #0]
   1f75c:	80e3      	strh	r3, [r4, #6]
	fs->winsect = 0;		/* Invalidate sector cache */
   1f75e:	2300      	movs	r3, #0
   1f760:	62e3      	str	r3, [r4, #44]	; 0x2c
	fs->wflag = 0;
   1f762:	7123      	strb	r3, [r4, #4]
	return FR_OK;
   1f764:	e715      	b.n	1f592 <chk_mounted+0x4a>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
   1f766:	6d63      	ldr	r3, [r4, #84]	; 0x54
   1f768:	e75d      	b.n	1f626 <chk_mounted+0xde>
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
   1f76a:	2f00      	cmp	r7, #0
   1f76c:	d100      	bne.n	1f770 <chk_mounted+0x228>
   1f76e:	e72e      	b.n	1f5ce <chk_mounted+0x86>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
   1f770:	9a03      	ldr	r2, [sp, #12]
   1f772:	18d3      	adds	r3, r2, r3
   1f774:	6263      	str	r3, [r4, #36]	; 0x24
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
   1f776:	2d02      	cmp	r5, #2
   1f778:	d101      	bne.n	1f77e <chk_mounted+0x236>
   1f77a:	0040      	lsls	r0, r0, #1
   1f77c:	e7ab      	b.n	1f6d6 <chk_mounted+0x18e>
   1f77e:	2303      	movs	r3, #3
   1f780:	2201      	movs	r2, #1
   1f782:	4343      	muls	r3, r0
   1f784:	4010      	ands	r0, r2
   1f786:	085b      	lsrs	r3, r3, #1
   1f788:	1818      	adds	r0, r3, r0
   1f78a:	e7a4      	b.n	1f6d6 <chk_mounted+0x18e>
   1f78c:	20003dcc 	.word	0x20003dcc
   1f790:	0001f129 	.word	0x0001f129
   1f794:	0001f09d 	.word	0x0001f09d
   1f798:	0001f4c9 	.word	0x0001f4c9
   1f79c:	000258bd 	.word	0x000258bd
   1f7a0:	00000ff5 	.word	0x00000ff5
   1f7a4:	0000fff5 	.word	0x0000fff5
   1f7a8:	000001ff 	.word	0x000001ff
   1f7ac:	0001f145 	.word	0x0001f145
   1f7b0:	0000022f 	.word	0x0000022f
   1f7b4:	0000022e 	.word	0x0000022e
   1f7b8:	ffffaa55 	.word	0xffffaa55
   1f7bc:	41615252 	.word	0x41615252
   1f7c0:	61417272 	.word	0x61417272
   1f7c4:	20003dec 	.word	0x20003dec

0001f7c8 <get_fat>:
{
   1f7c8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
		return 1;
   1f7ca:	2401      	movs	r4, #1
{
   1f7cc:	0006      	movs	r6, r0
   1f7ce:	000d      	movs	r5, r1
	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
   1f7d0:	42a1      	cmp	r1, r4
   1f7d2:	d92f      	bls.n	1f834 <get_fat+0x6c>
   1f7d4:	6983      	ldr	r3, [r0, #24]
   1f7d6:	4299      	cmp	r1, r3
   1f7d8:	d22c      	bcs.n	1f834 <get_fat+0x6c>
	switch (fs->fs_type) {
   1f7da:	7803      	ldrb	r3, [r0, #0]
   1f7dc:	2b02      	cmp	r3, #2
   1f7de:	d02e      	beq.n	1f83e <get_fat+0x76>
   1f7e0:	2b03      	cmp	r3, #3
   1f7e2:	d03e      	beq.n	1f862 <get_fat+0x9a>
   1f7e4:	42a3      	cmp	r3, r4
   1f7e6:	d108      	bne.n	1f7fa <get_fat+0x32>
		bc = (UINT)clst; bc += bc / 2;
   1f7e8:	084f      	lsrs	r7, r1, #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
   1f7ea:	6a03      	ldr	r3, [r0, #32]
		bc = (UINT)clst; bc += bc / 2;
   1f7ec:	187f      	adds	r7, r7, r1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
   1f7ee:	0a79      	lsrs	r1, r7, #9
   1f7f0:	18c9      	adds	r1, r1, r3
   1f7f2:	4b2a      	ldr	r3, [pc, #168]	; (1f89c <get_fat+0xd4>)
   1f7f4:	4798      	blx	r3
   1f7f6:	2800      	cmp	r0, #0
   1f7f8:	d002      	beq.n	1f800 <get_fat+0x38>
	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
   1f7fa:	2401      	movs	r4, #1
   1f7fc:	4264      	negs	r4, r4
   1f7fe:	e019      	b.n	1f834 <get_fat+0x6c>
		wc = fs->win[bc % SS(fs)]; bc++;
   1f800:	05fb      	lsls	r3, r7, #23
   1f802:	0ddb      	lsrs	r3, r3, #23
   1f804:	18f3      	adds	r3, r6, r3
   1f806:	3330      	adds	r3, #48	; 0x30
   1f808:	781b      	ldrb	r3, [r3, #0]
   1f80a:	3701      	adds	r7, #1
   1f80c:	9301      	str	r3, [sp, #4]
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
   1f80e:	6a33      	ldr	r3, [r6, #32]
   1f810:	0a79      	lsrs	r1, r7, #9
   1f812:	18c9      	adds	r1, r1, r3
   1f814:	0030      	movs	r0, r6
   1f816:	4b21      	ldr	r3, [pc, #132]	; (1f89c <get_fat+0xd4>)
   1f818:	4798      	blx	r3
   1f81a:	2800      	cmp	r0, #0
   1f81c:	d1ed      	bne.n	1f7fa <get_fat+0x32>
		wc |= fs->win[bc % SS(fs)] << 8;
   1f81e:	05ff      	lsls	r7, r7, #23
   1f820:	0dff      	lsrs	r7, r7, #23
   1f822:	19f6      	adds	r6, r6, r7
   1f824:	3630      	adds	r6, #48	; 0x30
   1f826:	7833      	ldrb	r3, [r6, #0]
   1f828:	9a01      	ldr	r2, [sp, #4]
   1f82a:	021b      	lsls	r3, r3, #8
   1f82c:	4313      	orrs	r3, r2
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
   1f82e:	4225      	tst	r5, r4
   1f830:	d002      	beq.n	1f838 <get_fat+0x70>
   1f832:	091c      	lsrs	r4, r3, #4
}
   1f834:	0020      	movs	r0, r4
   1f836:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
   1f838:	051c      	lsls	r4, r3, #20
   1f83a:	0d24      	lsrs	r4, r4, #20
   1f83c:	e7fa      	b.n	1f834 <get_fat+0x6c>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
   1f83e:	6a03      	ldr	r3, [r0, #32]
   1f840:	0a09      	lsrs	r1, r1, #8
   1f842:	18c9      	adds	r1, r1, r3
   1f844:	4b15      	ldr	r3, [pc, #84]	; (1f89c <get_fat+0xd4>)
   1f846:	4798      	blx	r3
   1f848:	2800      	cmp	r0, #0
   1f84a:	d1d6      	bne.n	1f7fa <get_fat+0x32>
		p = &fs->win[clst * 2 % SS(fs)];
   1f84c:	23ff      	movs	r3, #255	; 0xff
   1f84e:	006d      	lsls	r5, r5, #1
   1f850:	005b      	lsls	r3, r3, #1
   1f852:	401d      	ands	r5, r3
		return LD_WORD(p);
   1f854:	1976      	adds	r6, r6, r5
   1f856:	3630      	adds	r6, #48	; 0x30
   1f858:	7874      	ldrb	r4, [r6, #1]
   1f85a:	7833      	ldrb	r3, [r6, #0]
   1f85c:	0224      	lsls	r4, r4, #8
   1f85e:	431c      	orrs	r4, r3
   1f860:	e7e8      	b.n	1f834 <get_fat+0x6c>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
   1f862:	6a03      	ldr	r3, [r0, #32]
   1f864:	09c9      	lsrs	r1, r1, #7
   1f866:	18c9      	adds	r1, r1, r3
   1f868:	4b0c      	ldr	r3, [pc, #48]	; (1f89c <get_fat+0xd4>)
   1f86a:	4798      	blx	r3
   1f86c:	2800      	cmp	r0, #0
   1f86e:	d1c4      	bne.n	1f7fa <get_fat+0x32>
		p = &fs->win[clst * 4 % SS(fs)];
   1f870:	23fe      	movs	r3, #254	; 0xfe
   1f872:	00ad      	lsls	r5, r5, #2
   1f874:	005b      	lsls	r3, r3, #1
   1f876:	401d      	ands	r5, r3
   1f878:	002b      	movs	r3, r5
   1f87a:	3330      	adds	r3, #48	; 0x30
   1f87c:	18f3      	adds	r3, r6, r3
		return LD_DWORD(p) & 0x0FFFFFFF;
   1f87e:	78dc      	ldrb	r4, [r3, #3]
   1f880:	789a      	ldrb	r2, [r3, #2]
   1f882:	1976      	adds	r6, r6, r5
   1f884:	0412      	lsls	r2, r2, #16
   1f886:	0624      	lsls	r4, r4, #24
   1f888:	3630      	adds	r6, #48	; 0x30
   1f88a:	4314      	orrs	r4, r2
   1f88c:	785b      	ldrb	r3, [r3, #1]
   1f88e:	7832      	ldrb	r2, [r6, #0]
   1f890:	021b      	lsls	r3, r3, #8
   1f892:	4314      	orrs	r4, r2
   1f894:	431c      	orrs	r4, r3
   1f896:	0124      	lsls	r4, r4, #4
   1f898:	0924      	lsrs	r4, r4, #4
   1f89a:	e7cb      	b.n	1f834 <get_fat+0x6c>
   1f89c:	0001f329 	.word	0x0001f329

0001f8a0 <dir_sdi>:
{
   1f8a0:	b570      	push	{r4, r5, r6, lr}
   1f8a2:	0005      	movs	r5, r0
	dj->index = idx;
   1f8a4:	80e9      	strh	r1, [r5, #6]
{
   1f8a6:	000c      	movs	r4, r1
	clst = dj->sclust;
   1f8a8:	6881      	ldr	r1, [r0, #8]
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
   1f8aa:	2901      	cmp	r1, #1
   1f8ac:	d101      	bne.n	1f8b2 <dir_sdi+0x12>
		return FR_INT_ERR;
   1f8ae:	2002      	movs	r0, #2
}
   1f8b0:	bd70      	pop	{r4, r5, r6, pc}
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
   1f8b2:	6803      	ldr	r3, [r0, #0]
   1f8b4:	699a      	ldr	r2, [r3, #24]
   1f8b6:	4291      	cmp	r1, r2
   1f8b8:	d2f9      	bcs.n	1f8ae <dir_sdi+0xe>
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
   1f8ba:	2900      	cmp	r1, #0
   1f8bc:	d117      	bne.n	1f8ee <dir_sdi+0x4e>
   1f8be:	781a      	ldrb	r2, [r3, #0]
   1f8c0:	2a03      	cmp	r2, #3
   1f8c2:	d102      	bne.n	1f8ca <dir_sdi+0x2a>
		clst = dj->fs->dirbase;
   1f8c4:	6a59      	ldr	r1, [r3, #36]	; 0x24
	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
   1f8c6:	2900      	cmp	r1, #0
   1f8c8:	d111      	bne.n	1f8ee <dir_sdi+0x4e>
		dj->clust = clst;
   1f8ca:	2200      	movs	r2, #0
   1f8cc:	60ea      	str	r2, [r5, #12]
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
   1f8ce:	891a      	ldrh	r2, [r3, #8]
   1f8d0:	42a2      	cmp	r2, r4
   1f8d2:	d9ec      	bls.n	1f8ae <dir_sdi+0xe>
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
   1f8d4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1f8d6:	0922      	lsrs	r2, r4, #4
   1f8d8:	189b      	adds	r3, r3, r2
   1f8da:	612b      	str	r3, [r5, #16]
	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
   1f8dc:	220f      	movs	r2, #15
   1f8de:	682b      	ldr	r3, [r5, #0]
   1f8e0:	4014      	ands	r4, r2
   1f8e2:	3330      	adds	r3, #48	; 0x30
   1f8e4:	0164      	lsls	r4, r4, #5
   1f8e6:	191c      	adds	r4, r3, r4
   1f8e8:	616c      	str	r4, [r5, #20]
	return FR_OK;	/* Seek succeeded */
   1f8ea:	2000      	movs	r0, #0
   1f8ec:	e7e0      	b.n	1f8b0 <dir_sdi+0x10>
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
   1f8ee:	789e      	ldrb	r6, [r3, #2]
   1f8f0:	0136      	lsls	r6, r6, #4
		while (idx >= ic) {	/* Follow cluster chain */
   1f8f2:	42b4      	cmp	r4, r6
   1f8f4:	d207      	bcs.n	1f906 <dir_sdi+0x66>
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
   1f8f6:	4b0c      	ldr	r3, [pc, #48]	; (1f928 <dir_sdi+0x88>)
		dj->clust = clst;
   1f8f8:	60e9      	str	r1, [r5, #12]
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
   1f8fa:	6828      	ldr	r0, [r5, #0]
   1f8fc:	4798      	blx	r3
   1f8fe:	0923      	lsrs	r3, r4, #4
   1f900:	1818      	adds	r0, r3, r0
   1f902:	6128      	str	r0, [r5, #16]
   1f904:	e7ea      	b.n	1f8dc <dir_sdi+0x3c>
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
   1f906:	6828      	ldr	r0, [r5, #0]
   1f908:	4b08      	ldr	r3, [pc, #32]	; (1f92c <dir_sdi+0x8c>)
   1f90a:	4798      	blx	r3
   1f90c:	0001      	movs	r1, r0
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   1f90e:	1c43      	adds	r3, r0, #1
   1f910:	d008      	beq.n	1f924 <dir_sdi+0x84>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
   1f912:	2801      	cmp	r0, #1
   1f914:	d9cb      	bls.n	1f8ae <dir_sdi+0xe>
   1f916:	682b      	ldr	r3, [r5, #0]
   1f918:	699b      	ldr	r3, [r3, #24]
   1f91a:	4298      	cmp	r0, r3
   1f91c:	d2c7      	bcs.n	1f8ae <dir_sdi+0xe>
			idx -= ic;
   1f91e:	1ba4      	subs	r4, r4, r6
   1f920:	b2a4      	uxth	r4, r4
   1f922:	e7e6      	b.n	1f8f2 <dir_sdi+0x52>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   1f924:	2001      	movs	r0, #1
   1f926:	e7c3      	b.n	1f8b0 <dir_sdi+0x10>
   1f928:	0001f2f5 	.word	0x0001f2f5
   1f92c:	0001f7c9 	.word	0x0001f7c9

0001f930 <put_fat>:
{
   1f930:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1f932:	0005      	movs	r5, r0
   1f934:	000c      	movs	r4, r1
   1f936:	0016      	movs	r6, r2
		res = FR_INT_ERR;
   1f938:	2002      	movs	r0, #2
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   1f93a:	2901      	cmp	r1, #1
   1f93c:	d940      	bls.n	1f9c0 <put_fat+0x90>
   1f93e:	69ab      	ldr	r3, [r5, #24]
   1f940:	4299      	cmp	r1, r3
   1f942:	d23d      	bcs.n	1f9c0 <put_fat+0x90>
		switch (fs->fs_type) {
   1f944:	782f      	ldrb	r7, [r5, #0]
   1f946:	4287      	cmp	r7, r0
   1f948:	d044      	beq.n	1f9d4 <put_fat+0xa4>
   1f94a:	2f03      	cmp	r7, #3
   1f94c:	d054      	beq.n	1f9f8 <put_fat+0xc8>
   1f94e:	2f01      	cmp	r7, #1
   1f950:	d134      	bne.n	1f9bc <put_fat+0x8c>
			bc = clst; bc += bc / 2;
   1f952:	084b      	lsrs	r3, r1, #1
   1f954:	185b      	adds	r3, r3, r1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   1f956:	0a59      	lsrs	r1, r3, #9
			bc = clst; bc += bc / 2;
   1f958:	9301      	str	r3, [sp, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   1f95a:	6a2b      	ldr	r3, [r5, #32]
   1f95c:	0028      	movs	r0, r5
   1f95e:	18c9      	adds	r1, r1, r3
   1f960:	4b34      	ldr	r3, [pc, #208]	; (1fa34 <put_fat+0x104>)
   1f962:	4798      	blx	r3
			if (res != FR_OK) break;
   1f964:	2800      	cmp	r0, #0
   1f966:	d129      	bne.n	1f9bc <put_fat+0x8c>
			p = &fs->win[bc % SS(fs)];
   1f968:	9b01      	ldr	r3, [sp, #4]
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
   1f96a:	4027      	ands	r7, r4
			p = &fs->win[bc % SS(fs)];
   1f96c:	05db      	lsls	r3, r3, #23
   1f96e:	0ddb      	lsrs	r3, r3, #23
   1f970:	18eb      	adds	r3, r5, r3
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
   1f972:	b2f2      	uxtb	r2, r6
   1f974:	2f00      	cmp	r7, #0
   1f976:	d00a      	beq.n	1f98e <put_fat+0x5e>
   1f978:	001a      	movs	r2, r3
   1f97a:	210f      	movs	r1, #15
   1f97c:	20ff      	movs	r0, #255	; 0xff
   1f97e:	3230      	adds	r2, #48	; 0x30
   1f980:	7812      	ldrb	r2, [r2, #0]
   1f982:	0100      	lsls	r0, r0, #4
   1f984:	400a      	ands	r2, r1
   1f986:	0131      	lsls	r1, r6, #4
   1f988:	4001      	ands	r1, r0
   1f98a:	430a      	orrs	r2, r1
   1f98c:	b2d2      	uxtb	r2, r2
   1f98e:	3330      	adds	r3, #48	; 0x30
   1f990:	701a      	strb	r2, [r3, #0]
			fs->wflag = 1;
   1f992:	2301      	movs	r3, #1
			bc++;
   1f994:	9c01      	ldr	r4, [sp, #4]
			fs->wflag = 1;
   1f996:	712b      	strb	r3, [r5, #4]
			bc++;
   1f998:	3401      	adds	r4, #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   1f99a:	6a2b      	ldr	r3, [r5, #32]
   1f99c:	0a61      	lsrs	r1, r4, #9
   1f99e:	18c9      	adds	r1, r1, r3
   1f9a0:	0028      	movs	r0, r5
   1f9a2:	4b24      	ldr	r3, [pc, #144]	; (1fa34 <put_fat+0x104>)
   1f9a4:	4798      	blx	r3
			if (res != FR_OK) break;
   1f9a6:	2800      	cmp	r0, #0
   1f9a8:	d108      	bne.n	1f9bc <put_fat+0x8c>
			p = &fs->win[bc % SS(fs)];
   1f9aa:	05e4      	lsls	r4, r4, #23
   1f9ac:	0de4      	lsrs	r4, r4, #23
   1f9ae:	192c      	adds	r4, r5, r4
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
   1f9b0:	2f00      	cmp	r7, #0
   1f9b2:	d006      	beq.n	1f9c2 <put_fat+0x92>
   1f9b4:	0936      	lsrs	r6, r6, #4
   1f9b6:	b2f6      	uxtb	r6, r6
   1f9b8:	3430      	adds	r4, #48	; 0x30
   1f9ba:	7026      	strb	r6, [r4, #0]
		fs->wflag = 1;
   1f9bc:	2301      	movs	r3, #1
   1f9be:	712b      	strb	r3, [r5, #4]
}
   1f9c0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
   1f9c2:	0023      	movs	r3, r4
   1f9c4:	220f      	movs	r2, #15
   1f9c6:	3330      	adds	r3, #48	; 0x30
   1f9c8:	781b      	ldrb	r3, [r3, #0]
   1f9ca:	0a36      	lsrs	r6, r6, #8
   1f9cc:	4393      	bics	r3, r2
   1f9ce:	4016      	ands	r6, r2
   1f9d0:	431e      	orrs	r6, r3
   1f9d2:	e7f1      	b.n	1f9b8 <put_fat+0x88>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
   1f9d4:	6a2b      	ldr	r3, [r5, #32]
   1f9d6:	0a09      	lsrs	r1, r1, #8
   1f9d8:	18c9      	adds	r1, r1, r3
   1f9da:	0028      	movs	r0, r5
   1f9dc:	4b15      	ldr	r3, [pc, #84]	; (1fa34 <put_fat+0x104>)
   1f9de:	4798      	blx	r3
			if (res != FR_OK) break;
   1f9e0:	2800      	cmp	r0, #0
   1f9e2:	d1eb      	bne.n	1f9bc <put_fat+0x8c>
			p = &fs->win[clst * 2 % SS(fs)];
   1f9e4:	23ff      	movs	r3, #255	; 0xff
   1f9e6:	0064      	lsls	r4, r4, #1
   1f9e8:	005b      	lsls	r3, r3, #1
   1f9ea:	401c      	ands	r4, r3
			ST_WORD(p, (WORD)val);
   1f9ec:	192c      	adds	r4, r5, r4
   1f9ee:	3430      	adds	r4, #48	; 0x30
   1f9f0:	7026      	strb	r6, [r4, #0]
   1f9f2:	0a36      	lsrs	r6, r6, #8
   1f9f4:	7066      	strb	r6, [r4, #1]
   1f9f6:	e7e1      	b.n	1f9bc <put_fat+0x8c>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
   1f9f8:	6a2b      	ldr	r3, [r5, #32]
   1f9fa:	09c9      	lsrs	r1, r1, #7
   1f9fc:	18c9      	adds	r1, r1, r3
   1f9fe:	0028      	movs	r0, r5
   1fa00:	4b0c      	ldr	r3, [pc, #48]	; (1fa34 <put_fat+0x104>)
   1fa02:	4798      	blx	r3
			if (res != FR_OK) break;
   1fa04:	2800      	cmp	r0, #0
   1fa06:	d1d9      	bne.n	1f9bc <put_fat+0x8c>
			p = &fs->win[clst * 4 % SS(fs)];
   1fa08:	23fe      	movs	r3, #254	; 0xfe
   1fa0a:	00a4      	lsls	r4, r4, #2
   1fa0c:	005b      	lsls	r3, r3, #1
   1fa0e:	401c      	ands	r4, r3
   1fa10:	0023      	movs	r3, r4
   1fa12:	3330      	adds	r3, #48	; 0x30
   1fa14:	18eb      	adds	r3, r5, r3
			val |= LD_DWORD(p) & 0xF0000000;
   1fa16:	78da      	ldrb	r2, [r3, #3]
   1fa18:	192c      	adds	r4, r5, r4
   1fa1a:	0912      	lsrs	r2, r2, #4
   1fa1c:	0712      	lsls	r2, r2, #28
   1fa1e:	4316      	orrs	r6, r2
			ST_DWORD(p, val);
   1fa20:	0a32      	lsrs	r2, r6, #8
			val |= LD_DWORD(p) & 0xF0000000;
   1fa22:	3430      	adds	r4, #48	; 0x30
			ST_DWORD(p, val);
   1fa24:	7026      	strb	r6, [r4, #0]
   1fa26:	705a      	strb	r2, [r3, #1]
   1fa28:	0c32      	lsrs	r2, r6, #16
   1fa2a:	0e36      	lsrs	r6, r6, #24
   1fa2c:	709a      	strb	r2, [r3, #2]
   1fa2e:	70de      	strb	r6, [r3, #3]
   1fa30:	e7c4      	b.n	1f9bc <put_fat+0x8c>
   1fa32:	46c0      	nop			; (mov r8, r8)
   1fa34:	0001f329 	.word	0x0001f329

0001fa38 <create_chain>:
{
   1fa38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1fa3a:	0005      	movs	r5, r0
   1fa3c:	1e0f      	subs	r7, r1, #0
	if (clst == 0) {		/* Create a new chain */
   1fa3e:	d10f      	bne.n	1fa60 <create_chain+0x28>
		scl = fs->last_clust;			/* Get suggested start point */
   1fa40:	68c6      	ldr	r6, [r0, #12]
		if (!scl || scl >= fs->n_fatent) scl = 1;
   1fa42:	2e00      	cmp	r6, #0
   1fa44:	d002      	beq.n	1fa4c <create_chain+0x14>
   1fa46:	6983      	ldr	r3, [r0, #24]
   1fa48:	429e      	cmp	r6, r3
   1fa4a:	d300      	bcc.n	1fa4e <create_chain+0x16>
   1fa4c:	2601      	movs	r6, #1
   1fa4e:	0034      	movs	r4, r6
		if (ncl >= fs->n_fatent) {		/* Wrap around */
   1fa50:	69ab      	ldr	r3, [r5, #24]
		ncl++;							/* Next cluster */
   1fa52:	3401      	adds	r4, #1
		if (ncl >= fs->n_fatent) {		/* Wrap around */
   1fa54:	429c      	cmp	r4, r3
   1fa56:	d30f      	bcc.n	1fa78 <create_chain+0x40>
			if (ncl > scl) return 0;	/* No free cluster */
   1fa58:	2e01      	cmp	r6, #1
   1fa5a:	d80c      	bhi.n	1fa76 <create_chain+0x3e>
   1fa5c:	2400      	movs	r4, #0
   1fa5e:	e008      	b.n	1fa72 <create_chain+0x3a>
		cs = get_fat(fs, clst);			/* Check the cluster status */
   1fa60:	4b1b      	ldr	r3, [pc, #108]	; (1fad0 <create_chain+0x98>)
   1fa62:	4798      	blx	r3
   1fa64:	0004      	movs	r4, r0
		if (cs < 2) return 1;			/* It is an invalid cluster */
   1fa66:	2801      	cmp	r0, #1
   1fa68:	d930      	bls.n	1facc <create_chain+0x94>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
   1fa6a:	69ab      	ldr	r3, [r5, #24]
   1fa6c:	003e      	movs	r6, r7
   1fa6e:	4298      	cmp	r0, r3
   1fa70:	d2ed      	bcs.n	1fa4e <create_chain+0x16>
}
   1fa72:	0020      	movs	r0, r4
   1fa74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			ncl = 2;
   1fa76:	2402      	movs	r4, #2
		cs = get_fat(fs, ncl);			/* Get the cluster status */
   1fa78:	0021      	movs	r1, r4
   1fa7a:	0028      	movs	r0, r5
   1fa7c:	4b14      	ldr	r3, [pc, #80]	; (1fad0 <create_chain+0x98>)
   1fa7e:	4798      	blx	r3
		if (cs == 0) break;				/* Found a free cluster */
   1fa80:	2800      	cmp	r0, #0
   1fa82:	d009      	beq.n	1fa98 <create_chain+0x60>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
   1fa84:	1c43      	adds	r3, r0, #1
   1fa86:	d102      	bne.n	1fa8e <create_chain+0x56>
			ncl = 2;
   1fa88:	2401      	movs	r4, #1
   1fa8a:	4264      	negs	r4, r4
   1fa8c:	e7f1      	b.n	1fa72 <create_chain+0x3a>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
   1fa8e:	2801      	cmp	r0, #1
   1fa90:	d01c      	beq.n	1facc <create_chain+0x94>
		if (ncl == scl) return 0;		/* No free cluster */
   1fa92:	42b4      	cmp	r4, r6
   1fa94:	d1dc      	bne.n	1fa50 <create_chain+0x18>
   1fa96:	e7e1      	b.n	1fa5c <create_chain+0x24>
	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
   1fa98:	4a0e      	ldr	r2, [pc, #56]	; (1fad4 <create_chain+0x9c>)
   1fa9a:	0021      	movs	r1, r4
   1fa9c:	0028      	movs	r0, r5
   1fa9e:	4e0e      	ldr	r6, [pc, #56]	; (1fad8 <create_chain+0xa0>)
   1faa0:	47b0      	blx	r6
	if (res == FR_OK && clst != 0) {
   1faa2:	2800      	cmp	r0, #0
   1faa4:	d110      	bne.n	1fac8 <create_chain+0x90>
   1faa6:	2f00      	cmp	r7, #0
   1faa8:	d108      	bne.n	1fabc <create_chain+0x84>
		if (fs->free_clust != 0xFFFFFFFF) {
   1faaa:	692b      	ldr	r3, [r5, #16]
		fs->last_clust = ncl;			/* Update FSINFO */
   1faac:	60ec      	str	r4, [r5, #12]
		if (fs->free_clust != 0xFFFFFFFF) {
   1faae:	1c5a      	adds	r2, r3, #1
   1fab0:	d0df      	beq.n	1fa72 <create_chain+0x3a>
			fs->free_clust--;
   1fab2:	3b01      	subs	r3, #1
   1fab4:	612b      	str	r3, [r5, #16]
			fs->fsi_flag = 1;
   1fab6:	2301      	movs	r3, #1
   1fab8:	716b      	strb	r3, [r5, #5]
   1faba:	e7da      	b.n	1fa72 <create_chain+0x3a>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
   1fabc:	0022      	movs	r2, r4
   1fabe:	0039      	movs	r1, r7
   1fac0:	0028      	movs	r0, r5
   1fac2:	47b0      	blx	r6
	if (res == FR_OK) {
   1fac4:	2800      	cmp	r0, #0
   1fac6:	d0f0      	beq.n	1faaa <create_chain+0x72>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
   1fac8:	2801      	cmp	r0, #1
   1faca:	d0dd      	beq.n	1fa88 <create_chain+0x50>
   1facc:	2401      	movs	r4, #1
   1face:	e7d0      	b.n	1fa72 <create_chain+0x3a>
   1fad0:	0001f7c9 	.word	0x0001f7c9
   1fad4:	0fffffff 	.word	0x0fffffff
   1fad8:	0001f931 	.word	0x0001f931

0001fadc <dir_next>:
{
   1fadc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	i = dj->index + 1;
   1fade:	88c6      	ldrh	r6, [r0, #6]
{
   1fae0:	0004      	movs	r4, r0
	i = dj->index + 1;
   1fae2:	3601      	adds	r6, #1
   1fae4:	b2b6      	uxth	r6, r6
{
   1fae6:	000f      	movs	r7, r1
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
   1fae8:	2e00      	cmp	r6, #0
   1faea:	d101      	bne.n	1faf0 <dir_next+0x14>
		return FR_NO_FILE;
   1faec:	2004      	movs	r0, #4
}
   1faee:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
   1faf0:	6903      	ldr	r3, [r0, #16]
   1faf2:	2b00      	cmp	r3, #0
   1faf4:	d0fa      	beq.n	1faec <dir_next+0x10>
	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
   1faf6:	220f      	movs	r2, #15
   1faf8:	4032      	ands	r2, r6
   1fafa:	9200      	str	r2, [sp, #0]
   1fafc:	d108      	bne.n	1fb10 <dir_next+0x34>
		if (dj->clust == 0) {	/* Static table */
   1fafe:	68c1      	ldr	r1, [r0, #12]
		dj->sect++;					/* Next sector */
   1fb00:	3301      	adds	r3, #1
   1fb02:	6103      	str	r3, [r0, #16]
   1fb04:	6800      	ldr	r0, [r0, #0]
		if (dj->clust == 0) {	/* Static table */
   1fb06:	2900      	cmp	r1, #0
   1fb08:	d10b      	bne.n	1fb22 <dir_next+0x46>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
   1fb0a:	8903      	ldrh	r3, [r0, #8]
   1fb0c:	42b3      	cmp	r3, r6
   1fb0e:	d9ed      	bls.n	1faec <dir_next+0x10>
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
   1fb10:	6823      	ldr	r3, [r4, #0]
   1fb12:	9a00      	ldr	r2, [sp, #0]
   1fb14:	3330      	adds	r3, #48	; 0x30
   1fb16:	0152      	lsls	r2, r2, #5
   1fb18:	189b      	adds	r3, r3, r2
	dj->index = i;
   1fb1a:	80e6      	strh	r6, [r4, #6]
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
   1fb1c:	6163      	str	r3, [r4, #20]
	return FR_OK;
   1fb1e:	2000      	movs	r0, #0
   1fb20:	e7e5      	b.n	1faee <dir_next+0x12>
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
   1fb22:	7883      	ldrb	r3, [r0, #2]
   1fb24:	0932      	lsrs	r2, r6, #4
   1fb26:	3b01      	subs	r3, #1
   1fb28:	421a      	tst	r2, r3
   1fb2a:	d1f1      	bne.n	1fb10 <dir_next+0x34>
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
   1fb2c:	4b26      	ldr	r3, [pc, #152]	; (1fbc8 <dir_next+0xec>)
   1fb2e:	4798      	blx	r3
   1fb30:	0005      	movs	r5, r0
				if (clst <= 1) return FR_INT_ERR;
   1fb32:	2801      	cmp	r0, #1
   1fb34:	d801      	bhi.n	1fb3a <dir_next+0x5e>
   1fb36:	2002      	movs	r0, #2
   1fb38:	e7d9      	b.n	1faee <dir_next+0x12>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   1fb3a:	1c43      	adds	r3, r0, #1
   1fb3c:	d101      	bne.n	1fb42 <dir_next+0x66>
   1fb3e:	2001      	movs	r0, #1
   1fb40:	e7d5      	b.n	1faee <dir_next+0x12>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
   1fb42:	6820      	ldr	r0, [r4, #0]
   1fb44:	6983      	ldr	r3, [r0, #24]
   1fb46:	429d      	cmp	r5, r3
   1fb48:	d328      	bcc.n	1fb9c <dir_next+0xc0>
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
   1fb4a:	2f00      	cmp	r7, #0
   1fb4c:	d0ce      	beq.n	1faec <dir_next+0x10>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
   1fb4e:	68e1      	ldr	r1, [r4, #12]
   1fb50:	4b1e      	ldr	r3, [pc, #120]	; (1fbcc <dir_next+0xf0>)
   1fb52:	4798      	blx	r3
   1fb54:	0005      	movs	r5, r0
					if (clst == 0) return FR_DENIED;			/* No free cluster */
   1fb56:	2007      	movs	r0, #7
   1fb58:	2d00      	cmp	r5, #0
   1fb5a:	d0c8      	beq.n	1faee <dir_next+0x12>
					if (clst == 1) return FR_INT_ERR;
   1fb5c:	2d01      	cmp	r5, #1
   1fb5e:	d0ea      	beq.n	1fb36 <dir_next+0x5a>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   1fb60:	1c6b      	adds	r3, r5, #1
   1fb62:	d0ec      	beq.n	1fb3e <dir_next+0x62>
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
   1fb64:	2100      	movs	r1, #0
   1fb66:	6820      	ldr	r0, [r4, #0]
   1fb68:	4b19      	ldr	r3, [pc, #100]	; (1fbd0 <dir_next+0xf4>)
   1fb6a:	4798      	blx	r3
   1fb6c:	1e07      	subs	r7, r0, #0
   1fb6e:	d1e6      	bne.n	1fb3e <dir_next+0x62>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
   1fb70:	2280      	movs	r2, #128	; 0x80
   1fb72:	6820      	ldr	r0, [r4, #0]
   1fb74:	0092      	lsls	r2, r2, #2
   1fb76:	3030      	adds	r0, #48	; 0x30
   1fb78:	0039      	movs	r1, r7
   1fb7a:	4b16      	ldr	r3, [pc, #88]	; (1fbd4 <dir_next+0xf8>)
   1fb7c:	4798      	blx	r3
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
   1fb7e:	6823      	ldr	r3, [r4, #0]
   1fb80:	0029      	movs	r1, r5
   1fb82:	9301      	str	r3, [sp, #4]
   1fb84:	0018      	movs	r0, r3
   1fb86:	4b14      	ldr	r3, [pc, #80]	; (1fbd8 <dir_next+0xfc>)
   1fb88:	4798      	blx	r3
   1fb8a:	9b01      	ldr	r3, [sp, #4]
   1fb8c:	62d8      	str	r0, [r3, #44]	; 0x2c
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
   1fb8e:	6823      	ldr	r3, [r4, #0]
   1fb90:	789a      	ldrb	r2, [r3, #2]
   1fb92:	42ba      	cmp	r2, r7
   1fb94:	d809      	bhi.n	1fbaa <dir_next+0xce>
					dj->fs->winsect -= c;						/* Rewind window address */
   1fb96:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1fb98:	1bd7      	subs	r7, r2, r7
   1fb9a:	62df      	str	r7, [r3, #44]	; 0x2c
				dj->clust = clst;				/* Initialize data for new cluster */
   1fb9c:	60e5      	str	r5, [r4, #12]
				dj->sect = clust2sect(dj->fs, clst);
   1fb9e:	0029      	movs	r1, r5
   1fba0:	6820      	ldr	r0, [r4, #0]
   1fba2:	4b0d      	ldr	r3, [pc, #52]	; (1fbd8 <dir_next+0xfc>)
   1fba4:	4798      	blx	r3
   1fba6:	6120      	str	r0, [r4, #16]
   1fba8:	e7b2      	b.n	1fb10 <dir_next+0x34>
						dj->fs->wflag = 1;
   1fbaa:	2201      	movs	r2, #1
   1fbac:	711a      	strb	r2, [r3, #4]
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
   1fbae:	2100      	movs	r1, #0
   1fbb0:	6820      	ldr	r0, [r4, #0]
   1fbb2:	4b07      	ldr	r3, [pc, #28]	; (1fbd0 <dir_next+0xf4>)
   1fbb4:	4798      	blx	r3
   1fbb6:	2800      	cmp	r0, #0
   1fbb8:	d1c1      	bne.n	1fb3e <dir_next+0x62>
						dj->fs->winsect++;
   1fbba:	6822      	ldr	r2, [r4, #0]
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
   1fbbc:	3701      	adds	r7, #1
						dj->fs->winsect++;
   1fbbe:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
   1fbc0:	b2ff      	uxtb	r7, r7
						dj->fs->winsect++;
   1fbc2:	3301      	adds	r3, #1
   1fbc4:	62d3      	str	r3, [r2, #44]	; 0x2c
   1fbc6:	e7e2      	b.n	1fb8e <dir_next+0xb2>
   1fbc8:	0001f7c9 	.word	0x0001f7c9
   1fbcc:	0001fa39 	.word	0x0001fa39
   1fbd0:	0001f329 	.word	0x0001f329
   1fbd4:	0001f2e7 	.word	0x0001f2e7
   1fbd8:	0001f2f5 	.word	0x0001f2f5

0001fbdc <remove_chain>:
{
   1fbdc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1fbde:	0004      	movs	r4, r0
   1fbe0:	000d      	movs	r5, r1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   1fbe2:	2901      	cmp	r1, #1
   1fbe4:	d801      	bhi.n	1fbea <remove_chain+0xe>
		res = FR_INT_ERR;
   1fbe6:	2002      	movs	r0, #2
}
   1fbe8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   1fbea:	6983      	ldr	r3, [r0, #24]
				fs->fsi_flag = 1;
   1fbec:	2701      	movs	r7, #1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   1fbee:	4299      	cmp	r1, r3
   1fbf0:	d2f9      	bcs.n	1fbe6 <remove_chain+0xa>
		while (clst < fs->n_fatent) {			/* Not a last link? */
   1fbf2:	69a3      	ldr	r3, [r4, #24]
   1fbf4:	429d      	cmp	r5, r3
   1fbf6:	d205      	bcs.n	1fc04 <remove_chain+0x28>
			nxt = get_fat(fs, clst);			/* Get cluster status */
   1fbf8:	0029      	movs	r1, r5
   1fbfa:	0020      	movs	r0, r4
   1fbfc:	4b0d      	ldr	r3, [pc, #52]	; (1fc34 <remove_chain+0x58>)
   1fbfe:	4798      	blx	r3
   1fc00:	1e06      	subs	r6, r0, #0
			if (nxt == 0) break;				/* Empty cluster? */
   1fc02:	d101      	bne.n	1fc08 <remove_chain+0x2c>
		res = FR_INT_ERR;
   1fc04:	2000      	movs	r0, #0
   1fc06:	e7ef      	b.n	1fbe8 <remove_chain+0xc>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
   1fc08:	2801      	cmp	r0, #1
   1fc0a:	d0ec      	beq.n	1fbe6 <remove_chain+0xa>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
   1fc0c:	1c43      	adds	r3, r0, #1
   1fc0e:	d00e      	beq.n	1fc2e <remove_chain+0x52>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
   1fc10:	2200      	movs	r2, #0
   1fc12:	0029      	movs	r1, r5
   1fc14:	0020      	movs	r0, r4
   1fc16:	4b08      	ldr	r3, [pc, #32]	; (1fc38 <remove_chain+0x5c>)
   1fc18:	4798      	blx	r3
			if (res != FR_OK) break;
   1fc1a:	2800      	cmp	r0, #0
   1fc1c:	d1e4      	bne.n	1fbe8 <remove_chain+0xc>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
   1fc1e:	6923      	ldr	r3, [r4, #16]
   1fc20:	1c5a      	adds	r2, r3, #1
   1fc22:	d002      	beq.n	1fc2a <remove_chain+0x4e>
				fs->free_clust++;
   1fc24:	3301      	adds	r3, #1
   1fc26:	6123      	str	r3, [r4, #16]
				fs->fsi_flag = 1;
   1fc28:	7167      	strb	r7, [r4, #5]
{
   1fc2a:	0035      	movs	r5, r6
   1fc2c:	e7e1      	b.n	1fbf2 <remove_chain+0x16>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
   1fc2e:	2001      	movs	r0, #1
   1fc30:	e7da      	b.n	1fbe8 <remove_chain+0xc>
   1fc32:	46c0      	nop			; (mov r8, r8)
   1fc34:	0001f7c9 	.word	0x0001f7c9
   1fc38:	0001f931 	.word	0x0001f931

0001fc3c <dir_find.part.4>:
FRESULT dir_find (
   1fc3c:	23ff      	movs	r3, #255	; 0xff
   1fc3e:	b5f0      	push	{r4, r5, r6, r7, lr}
   1fc40:	0005      	movs	r5, r0
   1fc42:	001c      	movs	r4, r3
			ord = 0xFF;
   1fc44:	001f      	movs	r7, r3
FRESULT dir_find (
   1fc46:	b087      	sub	sp, #28
   1fc48:	9303      	str	r3, [sp, #12]
		res = move_window(dj->fs, dj->sect);
   1fc4a:	6929      	ldr	r1, [r5, #16]
   1fc4c:	6828      	ldr	r0, [r5, #0]
   1fc4e:	4b49      	ldr	r3, [pc, #292]	; (1fd74 <dir_find.part.4+0x138>)
   1fc50:	4798      	blx	r3
   1fc52:	9000      	str	r0, [sp, #0]
		if (res != FR_OK) break;
   1fc54:	2800      	cmp	r0, #0
   1fc56:	d176      	bne.n	1fd46 <dir_find.part.4+0x10a>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
   1fc58:	696e      	ldr	r6, [r5, #20]
		c = dir[DIR_Name];
   1fc5a:	7833      	ldrb	r3, [r6, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   1fc5c:	2b00      	cmp	r3, #0
   1fc5e:	d100      	bne.n	1fc62 <dir_find.part.4+0x26>
   1fc60:	e084      	b.n	1fd6c <dir_find.part.4+0x130>
		a = dir[DIR_Attr] & AM_MASK;
   1fc62:	223f      	movs	r2, #63	; 0x3f
   1fc64:	7af1      	ldrb	r1, [r6, #11]
   1fc66:	400a      	ands	r2, r1
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   1fc68:	2be5      	cmp	r3, #229	; 0xe5
   1fc6a:	d100      	bne.n	1fc6e <dir_find.part.4+0x32>
   1fc6c:	e070      	b.n	1fd50 <dir_find.part.4+0x114>
   1fc6e:	0709      	lsls	r1, r1, #28
   1fc70:	d54f      	bpl.n	1fd12 <dir_find.part.4+0xd6>
   1fc72:	2a0f      	cmp	r2, #15
   1fc74:	d000      	beq.n	1fc78 <dir_find.part.4+0x3c>
   1fc76:	e06b      	b.n	1fd50 <dir_find.part.4+0x114>
				if (dj->lfn) {
   1fc78:	69ea      	ldr	r2, [r5, #28]
   1fc7a:	9202      	str	r2, [sp, #8]
   1fc7c:	2a00      	cmp	r2, #0
   1fc7e:	d100      	bne.n	1fc82 <dir_find.part.4+0x46>
   1fc80:	e067      	b.n	1fd52 <dir_find.part.4+0x116>
					if (c & LLE) {		/* Is it start of LFN sequence? */
   1fc82:	2240      	movs	r2, #64	; 0x40
   1fc84:	4213      	tst	r3, r2
   1fc86:	d061      	beq.n	1fd4c <dir_find.part.4+0x110>
						c &= ~LLE; ord = c;	/* LFN start order */
   1fc88:	4393      	bics	r3, r2
						sum = dir[LDIR_Chksum];
   1fc8a:	7b71      	ldrb	r1, [r6, #13]
						c &= ~LLE; ord = c;	/* LFN start order */
   1fc8c:	001c      	movs	r4, r3
						dj->lfn_idx = dj->index;
   1fc8e:	88eb      	ldrh	r3, [r5, #6]
						sum = dir[LDIR_Chksum];
   1fc90:	9103      	str	r1, [sp, #12]
						dj->lfn_idx = dj->index;
   1fc92:	842b      	strh	r3, [r5, #32]
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   1fc94:	7b73      	ldrb	r3, [r6, #13]
   1fc96:	9a03      	ldr	r2, [sp, #12]
   1fc98:	4293      	cmp	r3, r2
   1fc9a:	d159      	bne.n	1fd50 <dir_find.part.4+0x114>
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
   1fc9c:	2240      	movs	r2, #64	; 0x40
   1fc9e:	7833      	ldrb	r3, [r6, #0]
   1fca0:	4393      	bics	r3, r2
   1fca2:	3b01      	subs	r3, #1
   1fca4:	3a33      	subs	r2, #51	; 0x33
   1fca6:	435a      	muls	r2, r3
   1fca8:	9200      	str	r2, [sp, #0]
	s = 0; wc = 1;
   1fcaa:	2200      	movs	r2, #0
   1fcac:	2301      	movs	r3, #1
   1fcae:	9201      	str	r2, [sp, #4]
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
   1fcb0:	4a31      	ldr	r2, [pc, #196]	; (1fd78 <dir_find.part.4+0x13c>)
   1fcb2:	9901      	ldr	r1, [sp, #4]
   1fcb4:	5c89      	ldrb	r1, [r1, r2]
   1fcb6:	1872      	adds	r2, r6, r1
   1fcb8:	7852      	ldrb	r2, [r2, #1]
   1fcba:	5c70      	ldrb	r0, [r6, r1]
   1fcbc:	0212      	lsls	r2, r2, #8
   1fcbe:	4310      	orrs	r0, r2
		if (wc) {	/* Last char has not been processed */
   1fcc0:	2b00      	cmp	r3, #0
   1fcc2:	d04f      	beq.n	1fd64 <dir_find.part.4+0x128>
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
   1fcc4:	4b2d      	ldr	r3, [pc, #180]	; (1fd7c <dir_find.part.4+0x140>)
   1fcc6:	4798      	blx	r3
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
   1fcc8:	9b00      	ldr	r3, [sp, #0]
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
   1fcca:	9005      	str	r0, [sp, #20]
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
   1fccc:	2bfe      	cmp	r3, #254	; 0xfe
   1fcce:	d83f      	bhi.n	1fd50 <dir_find.part.4+0x114>
   1fcd0:	3301      	adds	r3, #1
   1fcd2:	9304      	str	r3, [sp, #16]
   1fcd4:	9b00      	ldr	r3, [sp, #0]
   1fcd6:	9a02      	ldr	r2, [sp, #8]
   1fcd8:	005b      	lsls	r3, r3, #1
   1fcda:	5a98      	ldrh	r0, [r3, r2]
   1fcdc:	4b27      	ldr	r3, [pc, #156]	; (1fd7c <dir_find.part.4+0x140>)
   1fcde:	4798      	blx	r3
   1fce0:	9a05      	ldr	r2, [sp, #20]
   1fce2:	0003      	movs	r3, r0
   1fce4:	4282      	cmp	r2, r0
   1fce6:	d133      	bne.n	1fd50 <dir_find.part.4+0x114>
   1fce8:	9a04      	ldr	r2, [sp, #16]
   1fcea:	9200      	str	r2, [sp, #0]
	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
   1fcec:	9a01      	ldr	r2, [sp, #4]
   1fcee:	3201      	adds	r2, #1
   1fcf0:	9201      	str	r2, [sp, #4]
   1fcf2:	2a0d      	cmp	r2, #13
   1fcf4:	d1dc      	bne.n	1fcb0 <dir_find.part.4+0x74>
	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
   1fcf6:	7832      	ldrb	r2, [r6, #0]
   1fcf8:	0652      	lsls	r2, r2, #25
   1fcfa:	d507      	bpl.n	1fd0c <dir_find.part.4+0xd0>
   1fcfc:	2b00      	cmp	r3, #0
   1fcfe:	d005      	beq.n	1fd0c <dir_find.part.4+0xd0>
   1fd00:	9b00      	ldr	r3, [sp, #0]
   1fd02:	9a02      	ldr	r2, [sp, #8]
   1fd04:	005b      	lsls	r3, r3, #1
   1fd06:	5a9b      	ldrh	r3, [r3, r2]
   1fd08:	2b00      	cmp	r3, #0
   1fd0a:	d121      	bne.n	1fd50 <dir_find.part.4+0x114>
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   1fd0c:	3c01      	subs	r4, #1
   1fd0e:	b2e4      	uxtb	r4, r4
   1fd10:	e01f      	b.n	1fd52 <dir_find.part.4+0x116>
			if (a == AM_LFN) {			/* An LFN entry is found */
   1fd12:	2a0f      	cmp	r2, #15
   1fd14:	d0b0      	beq.n	1fc78 <dir_find.part.4+0x3c>
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
   1fd16:	2c00      	cmp	r4, #0
   1fd18:	d105      	bne.n	1fd26 <dir_find.part.4+0xea>
   1fd1a:	4b19      	ldr	r3, [pc, #100]	; (1fd80 <dir_find.part.4+0x144>)
   1fd1c:	0030      	movs	r0, r6
   1fd1e:	4798      	blx	r3
   1fd20:	9b03      	ldr	r3, [sp, #12]
   1fd22:	4298      	cmp	r0, r3
   1fd24:	d00f      	beq.n	1fd46 <dir_find.part.4+0x10a>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   1fd26:	2301      	movs	r3, #1
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
   1fd28:	2101      	movs	r1, #1
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   1fd2a:	425b      	negs	r3, r3
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
   1fd2c:	69aa      	ldr	r2, [r5, #24]
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   1fd2e:	842b      	strh	r3, [r5, #32]
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
   1fd30:	7ad3      	ldrb	r3, [r2, #11]
   1fd32:	400b      	ands	r3, r1
   1fd34:	d10c      	bne.n	1fd50 <dir_find.part.4+0x114>
   1fd36:	1c58      	adds	r0, r3, #1
	while (cnt-- && (r = *d++ - *s++) == 0) ;
   1fd38:	5cf1      	ldrb	r1, [r6, r3]
   1fd3a:	5cd3      	ldrb	r3, [r2, r3]
   1fd3c:	4299      	cmp	r1, r3
   1fd3e:	d107      	bne.n	1fd50 <dir_find.part.4+0x114>
   1fd40:	0003      	movs	r3, r0
   1fd42:	280b      	cmp	r0, #11
   1fd44:	d1f7      	bne.n	1fd36 <dir_find.part.4+0xfa>
}
   1fd46:	9800      	ldr	r0, [sp, #0]
   1fd48:	b007      	add	sp, #28
   1fd4a:	bdf0      	pop	{r4, r5, r6, r7, pc}
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   1fd4c:	42a3      	cmp	r3, r4
   1fd4e:	d0a1      	beq.n	1fc94 <dir_find.part.4+0x58>
   1fd50:	003c      	movs	r4, r7
		res = dir_next(dj, 0);		/* Next entry */
   1fd52:	2100      	movs	r1, #0
   1fd54:	0028      	movs	r0, r5
   1fd56:	4b0b      	ldr	r3, [pc, #44]	; (1fd84 <dir_find.part.4+0x148>)
   1fd58:	4798      	blx	r3
   1fd5a:	9000      	str	r0, [sp, #0]
	} while (res == FR_OK);
   1fd5c:	2800      	cmp	r0, #0
   1fd5e:	d100      	bne.n	1fd62 <dir_find.part.4+0x126>
   1fd60:	e773      	b.n	1fc4a <dir_find.part.4+0xe>
   1fd62:	e7f0      	b.n	1fd46 <dir_find.part.4+0x10a>
			if (uc != 0xFFFF) return 0;	/* Check filler */
   1fd64:	4a08      	ldr	r2, [pc, #32]	; (1fd88 <dir_find.part.4+0x14c>)
   1fd66:	4290      	cmp	r0, r2
   1fd68:	d0c0      	beq.n	1fcec <dir_find.part.4+0xb0>
   1fd6a:	e7f1      	b.n	1fd50 <dir_find.part.4+0x114>
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   1fd6c:	2304      	movs	r3, #4
   1fd6e:	9300      	str	r3, [sp, #0]
   1fd70:	e7e9      	b.n	1fd46 <dir_find.part.4+0x10a>
   1fd72:	46c0      	nop			; (mov r8, r8)
   1fd74:	0001f329 	.word	0x0001f329
   1fd78:	0002acfb 	.word	0x0002acfb
   1fd7c:	00020689 	.word	0x00020689
   1fd80:	0001f30d 	.word	0x0001f30d
   1fd84:	0001fadd 	.word	0x0001fadd
   1fd88:	0000ffff 	.word	0x0000ffff

0001fd8c <dir_register>:
{
   1fd8c:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
   1fd8e:	2501      	movs	r5, #1
	fn = dj->fn; lfn = dj->lfn;
   1fd90:	69c3      	ldr	r3, [r0, #28]
   1fd92:	6987      	ldr	r7, [r0, #24]
{
   1fd94:	b089      	sub	sp, #36	; 0x24
	fn = dj->fn; lfn = dj->lfn;
   1fd96:	9300      	str	r3, [sp, #0]
{
   1fd98:	0006      	movs	r6, r0
	mem_cpy(sn, fn, 12);
   1fd9a:	4b82      	ldr	r3, [pc, #520]	; (1ffa4 <dir_register+0x218>)
   1fd9c:	220c      	movs	r2, #12
   1fd9e:	0039      	movs	r1, r7
   1fda0:	a805      	add	r0, sp, #20
   1fda2:	4798      	blx	r3
	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
   1fda4:	ab02      	add	r3, sp, #8
   1fda6:	7ddb      	ldrb	r3, [r3, #23]
   1fda8:	422b      	tst	r3, r5
   1fdaa:	d063      	beq.n	1fe74 <dir_register+0xe8>
		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
   1fdac:	2300      	movs	r3, #0
   1fdae:	72fb      	strb	r3, [r7, #11]
   1fdb0:	61f3      	str	r3, [r6, #28]
	mem_cpy(dst, src, 11);
   1fdb2:	4b7c      	ldr	r3, [pc, #496]	; (1ffa4 <dir_register+0x218>)
   1fdb4:	220b      	movs	r2, #11
   1fdb6:	a905      	add	r1, sp, #20
   1fdb8:	0038      	movs	r0, r7
   1fdba:	4798      	blx	r3
	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
   1fdbc:	002b      	movs	r3, r5
   1fdbe:	2d05      	cmp	r5, #5
   1fdc0:	d90a      	bls.n	1fdd8 <dir_register+0x4c>
   1fdc2:	9900      	ldr	r1, [sp, #0]
		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
   1fdc4:	085a      	lsrs	r2, r3, #1
   1fdc6:	03db      	lsls	r3, r3, #15
   1fdc8:	4313      	orrs	r3, r2
   1fdca:	880a      	ldrh	r2, [r1, #0]
   1fdcc:	3102      	adds	r1, #2
   1fdce:	189b      	adds	r3, r3, r2
   1fdd0:	880a      	ldrh	r2, [r1, #0]
   1fdd2:	b29b      	uxth	r3, r3
   1fdd4:	2a00      	cmp	r2, #0
   1fdd6:	d1f5      	bne.n	1fdc4 <dir_register+0x38>
	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
   1fdd8:	2207      	movs	r2, #7
		ns[i--] = c;
   1fdda:	a803      	add	r0, sp, #12
		c = (seq % 16) + '0';
   1fddc:	240f      	movs	r4, #15
   1fdde:	401c      	ands	r4, r3
   1fde0:	0021      	movs	r1, r4
   1fde2:	3130      	adds	r1, #48	; 0x30
		if (c > '9') c += 7;
   1fde4:	2939      	cmp	r1, #57	; 0x39
   1fde6:	d900      	bls.n	1fdea <dir_register+0x5e>
   1fde8:	3107      	adds	r1, #7
		ns[i--] = c;
   1fdea:	3a01      	subs	r2, #1
		seq /= 16;
   1fdec:	091b      	lsrs	r3, r3, #4
		ns[i--] = c;
   1fdee:	1884      	adds	r4, r0, r2
		seq /= 16;
   1fdf0:	b29b      	uxth	r3, r3
		ns[i--] = c;
   1fdf2:	7061      	strb	r1, [r4, #1]
	} while (seq);
   1fdf4:	2b00      	cmp	r3, #0
   1fdf6:	d1f1      	bne.n	1fddc <dir_register+0x50>
	ns[i] = '~';
   1fdf8:	217e      	movs	r1, #126	; 0x7e
   1fdfa:	5481      	strb	r1, [r0, r2]
	for (j = 0; j < i && dst[j] != ' '; j++) {
   1fdfc:	429a      	cmp	r2, r3
   1fdfe:	d021      	beq.n	1fe44 <dir_register+0xb8>
   1fe00:	5cf9      	ldrb	r1, [r7, r3]
   1fe02:	2920      	cmp	r1, #32
   1fe04:	d11c      	bne.n	1fe40 <dir_register+0xb4>
		dst[j++] = (i < 8) ? ns[i++] : ' ';
   1fe06:	a803      	add	r0, sp, #12
   1fe08:	2120      	movs	r1, #32
   1fe0a:	2a07      	cmp	r2, #7
   1fe0c:	d801      	bhi.n	1fe12 <dir_register+0x86>
   1fe0e:	5c81      	ldrb	r1, [r0, r2]
   1fe10:	3201      	adds	r2, #1
   1fe12:	54f9      	strb	r1, [r7, r3]
   1fe14:	3301      	adds	r3, #1
	} while (j < 8);
   1fe16:	2b07      	cmp	r3, #7
   1fe18:	d9f6      	bls.n	1fe08 <dir_register+0x7c>
	res = dir_sdi(dj, 0);			/* Rewind directory object */
   1fe1a:	2100      	movs	r1, #0
   1fe1c:	0030      	movs	r0, r6
   1fe1e:	4b62      	ldr	r3, [pc, #392]	; (1ffa8 <dir_register+0x21c>)
   1fe20:	4798      	blx	r3
   1fe22:	1e04      	subs	r4, r0, #0
	if (res != FR_OK) return res;
   1fe24:	d11f      	bne.n	1fe66 <dir_register+0xda>
   1fe26:	0030      	movs	r0, r6
   1fe28:	4b60      	ldr	r3, [pc, #384]	; (1ffac <dir_register+0x220>)
   1fe2a:	4798      	blx	r3
   1fe2c:	1e04      	subs	r4, r0, #0
			if (res != FR_OK) break;
   1fe2e:	d11a      	bne.n	1fe66 <dir_register+0xda>
		for (n = 1; n < 100; n++) {
   1fe30:	3501      	adds	r5, #1
   1fe32:	b2ad      	uxth	r5, r5
   1fe34:	2d64      	cmp	r5, #100	; 0x64
   1fe36:	d1bc      	bne.n	1fdb2 <dir_register+0x26>
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
   1fe38:	3407      	adds	r4, #7
}
   1fe3a:	0020      	movs	r0, r4
   1fe3c:	b009      	add	sp, #36	; 0x24
   1fe3e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	for (j = 0; j < i && dst[j] != ' '; j++) {
   1fe40:	3301      	adds	r3, #1
   1fe42:	e7db      	b.n	1fdfc <dir_register+0x70>
   1fe44:	0013      	movs	r3, r2
   1fe46:	e7de      	b.n	1fe06 <dir_register+0x7a>
		for (ne = 0; lfn[ne]; ne++) ;
   1fe48:	3001      	adds	r0, #1
   1fe4a:	b280      	uxth	r0, r0
   1fe4c:	9a00      	ldr	r2, [sp, #0]
   1fe4e:	0043      	lsls	r3, r0, #1
   1fe50:	5a9b      	ldrh	r3, [r3, r2]
   1fe52:	2b00      	cmp	r3, #0
   1fe54:	d1f8      	bne.n	1fe48 <dir_register+0xbc>
		ne = (ne + 25) / 13;
   1fe56:	3019      	adds	r0, #25
   1fe58:	210d      	movs	r1, #13
   1fe5a:	4b55      	ldr	r3, [pc, #340]	; (1ffb0 <dir_register+0x224>)
   1fe5c:	4798      	blx	r3
   1fe5e:	b285      	uxth	r5, r0
   1fe60:	e00e      	b.n	1fe80 <dir_register+0xf4>
			n = 0;					/* Not a blank entry. Restart to search */
   1fe62:	0007      	movs	r7, r0
   1fe64:	e029      	b.n	1feba <dir_register+0x12e>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
   1fe66:	2c04      	cmp	r4, #4
   1fe68:	d1e7      	bne.n	1fe3a <dir_register+0xae>
		fn[NS] = sn[NS]; dj->lfn = lfn;
   1fe6a:	ab02      	add	r3, sp, #8
   1fe6c:	7ddb      	ldrb	r3, [r3, #23]
   1fe6e:	72fb      	strb	r3, [r7, #11]
   1fe70:	9b00      	ldr	r3, [sp, #0]
   1fe72:	61f3      	str	r3, [r6, #28]
	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
   1fe74:	ab02      	add	r3, sp, #8
   1fe76:	7ddb      	ldrb	r3, [r3, #23]
		ne = 1;
   1fe78:	2501      	movs	r5, #1
   1fe7a:	2000      	movs	r0, #0
	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
   1fe7c:	079b      	lsls	r3, r3, #30
   1fe7e:	d4e5      	bmi.n	1fe4c <dir_register+0xc0>
	res = dir_sdi(dj, 0);
   1fe80:	2100      	movs	r1, #0
   1fe82:	0030      	movs	r0, r6
   1fe84:	4b48      	ldr	r3, [pc, #288]	; (1ffa8 <dir_register+0x21c>)
   1fe86:	4798      	blx	r3
   1fe88:	1e04      	subs	r4, r0, #0
	if (res != FR_OK) return res;
   1fe8a:	d1d6      	bne.n	1fe3a <dir_register+0xae>
   1fe8c:	0007      	movs	r7, r0
   1fe8e:	9000      	str	r0, [sp, #0]
		res = move_window(dj->fs, dj->sect);
   1fe90:	6931      	ldr	r1, [r6, #16]
   1fe92:	6830      	ldr	r0, [r6, #0]
   1fe94:	4b47      	ldr	r3, [pc, #284]	; (1ffb4 <dir_register+0x228>)
   1fe96:	4798      	blx	r3
   1fe98:	1e04      	subs	r4, r0, #0
		if (res != FR_OK) break;
   1fe9a:	d1ce      	bne.n	1fe3a <dir_register+0xae>
		c = *dj->dir;				/* Check the entry status */
   1fe9c:	6973      	ldr	r3, [r6, #20]
   1fe9e:	781b      	ldrb	r3, [r3, #0]
		if (c == DDE || c == 0) {	/* Is it a blank entry? */
   1fea0:	2be5      	cmp	r3, #229	; 0xe5
   1fea2:	d001      	beq.n	1fea8 <dir_register+0x11c>
   1fea4:	2b00      	cmp	r3, #0
   1fea6:	d1dc      	bne.n	1fe62 <dir_register+0xd6>
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
   1fea8:	2f00      	cmp	r7, #0
   1feaa:	d101      	bne.n	1feb0 <dir_register+0x124>
   1feac:	88f3      	ldrh	r3, [r6, #6]
   1feae:	9300      	str	r3, [sp, #0]
			if (++n == ne) break;	/* A contiguous entry that required count is found */
   1feb0:	1c7b      	adds	r3, r7, #1
   1feb2:	b29b      	uxth	r3, r3
   1feb4:	429d      	cmp	r5, r3
   1feb6:	d007      	beq.n	1fec8 <dir_register+0x13c>
   1feb8:	001f      	movs	r7, r3
		res = dir_next(dj, 1);		/* Next entry with table stretch */
   1feba:	2101      	movs	r1, #1
   1febc:	0030      	movs	r0, r6
   1febe:	4b3e      	ldr	r3, [pc, #248]	; (1ffb8 <dir_register+0x22c>)
   1fec0:	4798      	blx	r3
   1fec2:	1e04      	subs	r4, r0, #0
	} while (res == FR_OK);
   1fec4:	d0e4      	beq.n	1fe90 <dir_register+0x104>
   1fec6:	e7b8      	b.n	1fe3a <dir_register+0xae>
	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
   1fec8:	2d01      	cmp	r5, #1
   1feca:	d94f      	bls.n	1ff6c <dir_register+0x1e0>
		res = dir_sdi(dj, is);
   1fecc:	9900      	ldr	r1, [sp, #0]
   1fece:	0030      	movs	r0, r6
   1fed0:	4b35      	ldr	r3, [pc, #212]	; (1ffa8 <dir_register+0x21c>)
   1fed2:	4798      	blx	r3
   1fed4:	1e04      	subs	r4, r0, #0
		if (res == FR_OK) {
   1fed6:	d1b0      	bne.n	1fe3a <dir_register+0xae>
			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
   1fed8:	69b0      	ldr	r0, [r6, #24]
   1feda:	4b38      	ldr	r3, [pc, #224]	; (1ffbc <dir_register+0x230>)
   1fedc:	4798      	blx	r3
   1fede:	9001      	str	r0, [sp, #4]
				res = move_window(dj->fs, dj->sect);
   1fee0:	6931      	ldr	r1, [r6, #16]
   1fee2:	6830      	ldr	r0, [r6, #0]
   1fee4:	4b33      	ldr	r3, [pc, #204]	; (1ffb4 <dir_register+0x228>)
   1fee6:	4798      	blx	r3
   1fee8:	1e04      	subs	r4, r0, #0
				if (res != FR_OK) break;
   1feea:	d1a6      	bne.n	1fe3a <dir_register+0xae>
	dir[LDIR_Chksum] = sum;			/* Set check sum */
   1feec:	466a      	mov	r2, sp
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
   1feee:	69f3      	ldr	r3, [r6, #28]
	dir[LDIR_Chksum] = sum;			/* Set check sum */
   1fef0:	7912      	ldrb	r2, [r2, #4]
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
   1fef2:	469c      	mov	ip, r3
   1fef4:	6973      	ldr	r3, [r6, #20]
	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
   1fef6:	240d      	movs	r4, #13
	dir[LDIR_Chksum] = sum;			/* Set check sum */
   1fef8:	735a      	strb	r2, [r3, #13]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
   1fefa:	220f      	movs	r2, #15
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
   1fefc:	b2f9      	uxtb	r1, r7
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
   1fefe:	72da      	strb	r2, [r3, #11]
	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
   1ff00:	1e4a      	subs	r2, r1, #1
   1ff02:	4354      	muls	r4, r2
   1ff04:	9400      	str	r4, [sp, #0]
	s = wc = 0;
   1ff06:	0004      	movs	r4, r0
	dir[LDIR_Type] = 0;
   1ff08:	7318      	strb	r0, [r3, #12]
	ST_WORD(dir+LDIR_FstClusLO, 0);
   1ff0a:	7698      	strb	r0, [r3, #26]
   1ff0c:	76d8      	strb	r0, [r3, #27]
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
   1ff0e:	4d2c      	ldr	r5, [pc, #176]	; (1ffc0 <dir_register+0x234>)
   1ff10:	42a8      	cmp	r0, r5
   1ff12:	d005      	beq.n	1ff20 <dir_register+0x194>
   1ff14:	4665      	mov	r5, ip
   1ff16:	9a00      	ldr	r2, [sp, #0]
   1ff18:	0050      	lsls	r0, r2, #1
   1ff1a:	5b40      	ldrh	r0, [r0, r5]
   1ff1c:	3201      	adds	r2, #1
   1ff1e:	9200      	str	r2, [sp, #0]
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
   1ff20:	4d28      	ldr	r5, [pc, #160]	; (1ffc4 <dir_register+0x238>)
   1ff22:	5d65      	ldrb	r5, [r4, r5]
   1ff24:	5558      	strb	r0, [r3, r5]
   1ff26:	195a      	adds	r2, r3, r5
   1ff28:	0a05      	lsrs	r5, r0, #8
   1ff2a:	7055      	strb	r5, [r2, #1]
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
   1ff2c:	2800      	cmp	r0, #0
   1ff2e:	d100      	bne.n	1ff32 <dir_register+0x1a6>
   1ff30:	4823      	ldr	r0, [pc, #140]	; (1ffc0 <dir_register+0x234>)
	} while (++s < 13);
   1ff32:	3401      	adds	r4, #1
   1ff34:	2c0d      	cmp	r4, #13
   1ff36:	d1ea      	bne.n	1ff0e <dir_register+0x182>
	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
   1ff38:	4c21      	ldr	r4, [pc, #132]	; (1ffc0 <dir_register+0x234>)
   1ff3a:	42a0      	cmp	r0, r4
   1ff3c:	d005      	beq.n	1ff4a <dir_register+0x1be>
   1ff3e:	4660      	mov	r0, ip
   1ff40:	9a00      	ldr	r2, [sp, #0]
   1ff42:	0052      	lsls	r2, r2, #1
   1ff44:	5a12      	ldrh	r2, [r2, r0]
   1ff46:	2a00      	cmp	r2, #0
   1ff48:	d101      	bne.n	1ff4e <dir_register+0x1c2>
   1ff4a:	2240      	movs	r2, #64	; 0x40
   1ff4c:	4311      	orrs	r1, r2
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
   1ff4e:	7019      	strb	r1, [r3, #0]
				dj->fs->wflag = 1;
   1ff50:	2301      	movs	r3, #1
   1ff52:	6832      	ldr	r2, [r6, #0]
				res = dir_next(dj, 0);	/* Next entry */
   1ff54:	2100      	movs	r1, #0
				dj->fs->wflag = 1;
   1ff56:	7113      	strb	r3, [r2, #4]
				res = dir_next(dj, 0);	/* Next entry */
   1ff58:	0030      	movs	r0, r6
   1ff5a:	4b17      	ldr	r3, [pc, #92]	; (1ffb8 <dir_register+0x22c>)
   1ff5c:	4798      	blx	r3
   1ff5e:	1e04      	subs	r4, r0, #0
			} while (res == FR_OK && --ne);
   1ff60:	d000      	beq.n	1ff64 <dir_register+0x1d8>
   1ff62:	e76a      	b.n	1fe3a <dir_register+0xae>
   1ff64:	3f01      	subs	r7, #1
   1ff66:	b2bf      	uxth	r7, r7
   1ff68:	2f00      	cmp	r7, #0
   1ff6a:	d1b9      	bne.n	1fee0 <dir_register+0x154>
		res = move_window(dj->fs, dj->sect);
   1ff6c:	6931      	ldr	r1, [r6, #16]
   1ff6e:	6830      	ldr	r0, [r6, #0]
   1ff70:	4b10      	ldr	r3, [pc, #64]	; (1ffb4 <dir_register+0x228>)
   1ff72:	4798      	blx	r3
   1ff74:	1e04      	subs	r4, r0, #0
		if (res == FR_OK) {
   1ff76:	d000      	beq.n	1ff7a <dir_register+0x1ee>
   1ff78:	e75f      	b.n	1fe3a <dir_register+0xae>
			dir = dj->dir;
   1ff7a:	6975      	ldr	r5, [r6, #20]
			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
   1ff7c:	0001      	movs	r1, r0
   1ff7e:	2220      	movs	r2, #32
   1ff80:	0028      	movs	r0, r5
   1ff82:	4b11      	ldr	r3, [pc, #68]	; (1ffc8 <dir_register+0x23c>)
   1ff84:	4798      	blx	r3
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
   1ff86:	220b      	movs	r2, #11
   1ff88:	4b06      	ldr	r3, [pc, #24]	; (1ffa4 <dir_register+0x218>)
   1ff8a:	69b1      	ldr	r1, [r6, #24]
   1ff8c:	0028      	movs	r0, r5
   1ff8e:	4798      	blx	r3
			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
   1ff90:	2218      	movs	r2, #24
   1ff92:	69b3      	ldr	r3, [r6, #24]
   1ff94:	7adb      	ldrb	r3, [r3, #11]
   1ff96:	4013      	ands	r3, r2
   1ff98:	732b      	strb	r3, [r5, #12]
			dj->fs->wflag = 1;
   1ff9a:	6833      	ldr	r3, [r6, #0]
   1ff9c:	3a17      	subs	r2, #23
   1ff9e:	711a      	strb	r2, [r3, #4]
   1ffa0:	e74b      	b.n	1fe3a <dir_register+0xae>
   1ffa2:	46c0      	nop			; (mov r8, r8)
   1ffa4:	0001f2d5 	.word	0x0001f2d5
   1ffa8:	0001f8a1 	.word	0x0001f8a1
   1ffac:	0001fc3d 	.word	0x0001fc3d
   1ffb0:	000259d1 	.word	0x000259d1
   1ffb4:	0001f329 	.word	0x0001f329
   1ffb8:	0001fadd 	.word	0x0001fadd
   1ffbc:	0001f30d 	.word	0x0001f30d
   1ffc0:	0000ffff 	.word	0x0000ffff
   1ffc4:	0002acfb 	.word	0x0002acfb
   1ffc8:	0001f2e7 	.word	0x0001f2e7

0001ffcc <follow_path>:
{
   1ffcc:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
   1ffce:	780b      	ldrb	r3, [r1, #0]
{
   1ffd0:	b087      	sub	sp, #28
   1ffd2:	0007      	movs	r7, r0
   1ffd4:	9101      	str	r1, [sp, #4]
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
   1ffd6:	2b2f      	cmp	r3, #47	; 0x2f
   1ffd8:	d001      	beq.n	1ffde <follow_path+0x12>
   1ffda:	2b5c      	cmp	r3, #92	; 0x5c
   1ffdc:	d102      	bne.n	1ffe4 <follow_path+0x18>
		path++;
   1ffde:	9b01      	ldr	r3, [sp, #4]
   1ffe0:	3301      	adds	r3, #1
   1ffe2:	9301      	str	r3, [sp, #4]
	dj->sclust = 0;						/* Start from the root dir */
   1ffe4:	2400      	movs	r4, #0
	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
   1ffe6:	9b01      	ldr	r3, [sp, #4]
	dj->sclust = 0;						/* Start from the root dir */
   1ffe8:	60bc      	str	r4, [r7, #8]
	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
   1ffea:	781b      	ldrb	r3, [r3, #0]
   1ffec:	2b1f      	cmp	r3, #31
   1ffee:	d809      	bhi.n	20004 <follow_path+0x38>
		res = dir_sdi(dj, 0);
   1fff0:	0021      	movs	r1, r4
   1fff2:	0038      	movs	r0, r7
   1fff4:	4b94      	ldr	r3, [pc, #592]	; (20248 <follow_path+0x27c>)
   1fff6:	4798      	blx	r3
		dj->dir = 0;
   1fff8:	617c      	str	r4, [r7, #20]
}
   1fffa:	b007      	add	sp, #28
   1fffc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   1fffe:	9b01      	ldr	r3, [sp, #4]
   20000:	3301      	adds	r3, #1
   20002:	9301      	str	r3, [sp, #4]
   20004:	9b01      	ldr	r3, [sp, #4]
   20006:	781b      	ldrb	r3, [r3, #0]
   20008:	2b2f      	cmp	r3, #47	; 0x2f
   2000a:	d0f8      	beq.n	1fffe <follow_path+0x32>
   2000c:	2b5c      	cmp	r3, #92	; 0x5c
   2000e:	d0f6      	beq.n	1fffe <follow_path+0x32>
	lfn = dj->lfn;
   20010:	2400      	movs	r4, #0
   20012:	69fb      	ldr	r3, [r7, #28]
   20014:	9305      	str	r3, [sp, #20]
		w = p[si++];					/* Get a character */
   20016:	9b01      	ldr	r3, [sp, #4]
   20018:	0026      	movs	r6, r4
   2001a:	5d18      	ldrb	r0, [r3, r4]
   2001c:	1c65      	adds	r5, r4, #1
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
   2001e:	281f      	cmp	r0, #31
   20020:	d91b      	bls.n	2005a <follow_path+0x8e>
   20022:	282f      	cmp	r0, #47	; 0x2f
   20024:	d019      	beq.n	2005a <follow_path+0x8e>
   20026:	285c      	cmp	r0, #92	; 0x5c
   20028:	d017      	beq.n	2005a <follow_path+0x8e>
		if (di >= _MAX_LFN)				/* Reject too long name */
   2002a:	2cff      	cmp	r4, #255	; 0xff
   2002c:	d00e      	beq.n	2004c <follow_path+0x80>
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
   2002e:	2101      	movs	r1, #1
   20030:	4b86      	ldr	r3, [pc, #536]	; (2024c <follow_path+0x280>)
   20032:	4798      	blx	r3
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
   20034:	2800      	cmp	r0, #0
   20036:	d009      	beq.n	2004c <follow_path+0x80>
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
   20038:	287f      	cmp	r0, #127	; 0x7f
   2003a:	d809      	bhi.n	20050 <follow_path+0x84>
   2003c:	2300      	movs	r3, #0
	while (*str && *str != chr) str++;
   2003e:	4984      	ldr	r1, [pc, #528]	; (20250 <follow_path+0x284>)
   20040:	5cca      	ldrb	r2, [r1, r3]
   20042:	2a00      	cmp	r2, #0
   20044:	d004      	beq.n	20050 <follow_path+0x84>
   20046:	3301      	adds	r3, #1
   20048:	4282      	cmp	r2, r0
   2004a:	d1f9      	bne.n	20040 <follow_path+0x74>
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
   2004c:	2006      	movs	r0, #6
   2004e:	e7d4      	b.n	1fffa <follow_path+0x2e>
		lfn[di++] = w;					/* Store the Unicode char */
   20050:	9b05      	ldr	r3, [sp, #20]
   20052:	0064      	lsls	r4, r4, #1
   20054:	5318      	strh	r0, [r3, r4]
   20056:	002c      	movs	r4, r5
   20058:	e7dd      	b.n	20016 <follow_path+0x4a>
	*path = &p[si];						/* Return pointer to the next segment */
   2005a:	9b01      	ldr	r3, [sp, #4]
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   2005c:	2400      	movs	r4, #0
	*path = &p[si];						/* Return pointer to the next segment */
   2005e:	195b      	adds	r3, r3, r5
   20060:	9301      	str	r3, [sp, #4]
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   20062:	231f      	movs	r3, #31
   20064:	4283      	cmp	r3, r0
   20066:	4164      	adcs	r4, r4
   20068:	00a4      	lsls	r4, r4, #2
	while (di) {						/* Strip trailing spaces and dots */
   2006a:	2e00      	cmp	r6, #0
   2006c:	d0ee      	beq.n	2004c <follow_path+0x80>
   2006e:	9a05      	ldr	r2, [sp, #20]
   20070:	0073      	lsls	r3, r6, #1
   20072:	18d3      	adds	r3, r2, r3
		w = lfn[di-1];
   20074:	1e9a      	subs	r2, r3, #2
   20076:	8812      	ldrh	r2, [r2, #0]
		if (w != ' ' && w != '.') break;
   20078:	2a20      	cmp	r2, #32
   2007a:	d002      	beq.n	20082 <follow_path+0xb6>
   2007c:	2a2e      	cmp	r2, #46	; 0x2e
   2007e:	d000      	beq.n	20082 <follow_path+0xb6>
   20080:	e085      	b.n	2018e <follow_path+0x1c2>
		di--;
   20082:	3e01      	subs	r6, #1
   20084:	e7f1      	b.n	2006a <follow_path+0x9e>
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
   20086:	3301      	adds	r3, #1
   20088:	9905      	ldr	r1, [sp, #20]
   2008a:	005a      	lsls	r2, r3, #1
   2008c:	5a8a      	ldrh	r2, [r1, r2]
   2008e:	2a20      	cmp	r2, #32
   20090:	d0f9      	beq.n	20086 <follow_path+0xba>
   20092:	2a2e      	cmp	r2, #46	; 0x2e
   20094:	d0f7      	beq.n	20086 <follow_path+0xba>
	if (si) cf |= NS_LOSS | NS_LFN;
   20096:	2b00      	cmp	r3, #0
   20098:	d002      	beq.n	200a0 <follow_path+0xd4>
   2009a:	2203      	movs	r2, #3
   2009c:	4314      	orrs	r4, r2
   2009e:	b2e4      	uxtb	r4, r4
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
   200a0:	0072      	lsls	r2, r6, #1
   200a2:	9905      	ldr	r1, [sp, #20]
   200a4:	3a02      	subs	r2, #2
   200a6:	5a8a      	ldrh	r2, [r1, r2]
   200a8:	2a2e      	cmp	r2, #46	; 0x2e
   200aa:	d002      	beq.n	200b2 <follow_path+0xe6>
   200ac:	3e01      	subs	r6, #1
   200ae:	2e00      	cmp	r6, #0
   200b0:	d1f6      	bne.n	200a0 <follow_path+0xd4>
		dj->fn[i++] = (BYTE)w;
   200b2:	2208      	movs	r2, #8
   200b4:	9202      	str	r2, [sp, #8]
   200b6:	2200      	movs	r2, #0
   200b8:	0015      	movs	r5, r2
   200ba:	9204      	str	r2, [sp, #16]
		w = lfn[si++];					/* Get an LFN char */
   200bc:	1c5a      	adds	r2, r3, #1
   200be:	9203      	str	r2, [sp, #12]
   200c0:	9a05      	ldr	r2, [sp, #20]
   200c2:	005b      	lsls	r3, r3, #1
   200c4:	5a98      	ldrh	r0, [r3, r2]
		if (!w) break;					/* Break on end of the LFN */
   200c6:	2800      	cmp	r0, #0
   200c8:	d076      	beq.n	201b8 <follow_path+0x1ec>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
   200ca:	2820      	cmp	r0, #32
   200cc:	d004      	beq.n	200d8 <follow_path+0x10c>
   200ce:	282e      	cmp	r0, #46	; 0x2e
   200d0:	d107      	bne.n	200e2 <follow_path+0x116>
   200d2:	9b03      	ldr	r3, [sp, #12]
   200d4:	42b3      	cmp	r3, r6
   200d6:	d063      	beq.n	201a0 <follow_path+0x1d4>
			cf |= NS_LOSS | NS_LFN; continue;
   200d8:	2303      	movs	r3, #3
   200da:	431c      	orrs	r4, r3
   200dc:	b2e4      	uxtb	r4, r4
		dj->fn[i++] = (BYTE)w;
   200de:	9b03      	ldr	r3, [sp, #12]
   200e0:	e7ec      	b.n	200bc <follow_path+0xf0>
		if (i >= ni || si == di) {		/* Extension or end of SFN */
   200e2:	9b04      	ldr	r3, [sp, #16]
   200e4:	9a02      	ldr	r2, [sp, #8]
   200e6:	4293      	cmp	r3, r2
   200e8:	d25e      	bcs.n	201a8 <follow_path+0x1dc>
   200ea:	9b03      	ldr	r3, [sp, #12]
   200ec:	42b3      	cmp	r3, r6
   200ee:	d114      	bne.n	2011a <follow_path+0x14e>
			if (ni == 11) {				/* Long extension */
   200f0:	9b02      	ldr	r3, [sp, #8]
   200f2:	2b0b      	cmp	r3, #11
   200f4:	d109      	bne.n	2010a <follow_path+0x13e>
   200f6:	e05a      	b.n	201ae <follow_path+0x1e2>
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
   200f8:	9b03      	ldr	r3, [sp, #12]
   200fa:	42b3      	cmp	r3, r6
   200fc:	d005      	beq.n	2010a <follow_path+0x13e>
   200fe:	2303      	movs	r3, #3
   20100:	431c      	orrs	r4, r3
			if (si > di) break;			/* No extension */
   20102:	9b03      	ldr	r3, [sp, #12]
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
   20104:	b2e4      	uxtb	r4, r4
			if (si > di) break;			/* No extension */
   20106:	42b3      	cmp	r3, r6
   20108:	d856      	bhi.n	201b8 <follow_path+0x1ec>
			si = di; i = 8; ni = 11;	/* Enter extension section */
   2010a:	230b      	movs	r3, #11
			b <<= 2; continue;
   2010c:	00ad      	lsls	r5, r5, #2
			si = di; i = 8; ni = 11;	/* Enter extension section */
   2010e:	9302      	str	r3, [sp, #8]
			b <<= 2; continue;
   20110:	b2ed      	uxtb	r5, r5
   20112:	9603      	str	r6, [sp, #12]
			si = di; i = 8; ni = 11;	/* Enter extension section */
   20114:	3b03      	subs	r3, #3
		dj->fn[i++] = (BYTE)w;
   20116:	9304      	str	r3, [sp, #16]
   20118:	e7e1      	b.n	200de <follow_path+0x112>
		if (w >= 0x80) {				/* Non ASCII char */
   2011a:	287f      	cmp	r0, #127	; 0x7f
   2011c:	d90f      	bls.n	2013e <follow_path+0x172>
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
   2011e:	4b4b      	ldr	r3, [pc, #300]	; (2024c <follow_path+0x280>)
   20120:	2100      	movs	r1, #0
   20122:	4798      	blx	r3
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
   20124:	2300      	movs	r3, #0
   20126:	4298      	cmp	r0, r3
   20128:	d003      	beq.n	20132 <follow_path+0x166>
   2012a:	4b4a      	ldr	r3, [pc, #296]	; (20254 <follow_path+0x288>)
   2012c:	1818      	adds	r0, r3, r0
   2012e:	3880      	subs	r0, #128	; 0x80
   20130:	7803      	ldrb	r3, [r0, #0]
   20132:	b298      	uxth	r0, r3
			cf |= NS_LFN;				/* Force create LFN entry */
   20134:	2302      	movs	r3, #2
   20136:	431c      	orrs	r4, r3
   20138:	b2e4      	uxtb	r4, r4
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
   2013a:	2800      	cmp	r0, #0
   2013c:	d007      	beq.n	2014e <follow_path+0x182>
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
   2013e:	2300      	movs	r3, #0
	while (*str && *str != chr) str++;
   20140:	4945      	ldr	r1, [pc, #276]	; (20258 <follow_path+0x28c>)
   20142:	5cca      	ldrb	r2, [r1, r3]
   20144:	2a00      	cmp	r2, #0
   20146:	d072      	beq.n	2022e <follow_path+0x262>
   20148:	3301      	adds	r3, #1
   2014a:	4282      	cmp	r2, r0
   2014c:	d1f9      	bne.n	20142 <follow_path+0x176>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
   2014e:	2303      	movs	r3, #3
   20150:	205f      	movs	r0, #95	; 0x5f
   20152:	431c      	orrs	r4, r3
   20154:	b2e4      	uxtb	r4, r4
		dj->fn[i++] = (BYTE)w;
   20156:	69bb      	ldr	r3, [r7, #24]
   20158:	9a04      	ldr	r2, [sp, #16]
   2015a:	5498      	strb	r0, [r3, r2]
   2015c:	0013      	movs	r3, r2
   2015e:	3301      	adds	r3, #1
   20160:	e7d9      	b.n	20116 <follow_path+0x14a>
					b |= 2;
   20162:	2302      	movs	r3, #2
   20164:	431d      	orrs	r5, r3
   20166:	e7f6      	b.n	20156 <follow_path+0x18a>
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
   20168:	075b      	lsls	r3, r3, #29
   2016a:	d500      	bpl.n	2016e <follow_path+0x1a2>
   2016c:	e745      	b.n	1fffa <follow_path+0x2e>
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
   2016e:	697b      	ldr	r3, [r7, #20]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
   20170:	7ada      	ldrb	r2, [r3, #11]
   20172:	06d2      	lsls	r2, r2, #27
   20174:	d559      	bpl.n	2022a <follow_path+0x25e>
			dj->sclust = LD_CLUST(dir);
   20176:	7d59      	ldrb	r1, [r3, #21]
   20178:	7d1a      	ldrb	r2, [r3, #20]
   2017a:	0209      	lsls	r1, r1, #8
   2017c:	430a      	orrs	r2, r1
   2017e:	7ed9      	ldrb	r1, [r3, #27]
   20180:	7e9b      	ldrb	r3, [r3, #26]
   20182:	0209      	lsls	r1, r1, #8
   20184:	0412      	lsls	r2, r2, #16
   20186:	430b      	orrs	r3, r1
   20188:	4313      	orrs	r3, r2
   2018a:	60bb      	str	r3, [r7, #8]
			res = create_name(dj, &path);	/* Get a segment */
   2018c:	e73a      	b.n	20004 <follow_path+0x38>
	lfn[di] = 0;						/* LFN is created */
   2018e:	2500      	movs	r5, #0
   20190:	801d      	strh	r5, [r3, #0]
	mem_set(dj->fn, ' ', 11);
   20192:	220b      	movs	r2, #11
   20194:	4b31      	ldr	r3, [pc, #196]	; (2025c <follow_path+0x290>)
   20196:	2120      	movs	r1, #32
   20198:	69b8      	ldr	r0, [r7, #24]
   2019a:	4798      	blx	r3
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
   2019c:	002b      	movs	r3, r5
   2019e:	e773      	b.n	20088 <follow_path+0xbc>
		if (i >= ni || si == di) {		/* Extension or end of SFN */
   201a0:	9b04      	ldr	r3, [sp, #16]
   201a2:	9a02      	ldr	r2, [sp, #8]
   201a4:	4293      	cmp	r3, r2
   201a6:	d3a3      	bcc.n	200f0 <follow_path+0x124>
			if (ni == 11) {				/* Long extension */
   201a8:	9b02      	ldr	r3, [sp, #8]
   201aa:	2b0b      	cmp	r3, #11
   201ac:	d1a4      	bne.n	200f8 <follow_path+0x12c>
				cf |= NS_LOSS | NS_LFN; break;
   201ae:	2303      	movs	r3, #3
   201b0:	431c      	orrs	r4, r3
   201b2:	3308      	adds	r3, #8
   201b4:	b2e4      	uxtb	r4, r4
   201b6:	9302      	str	r3, [sp, #8]
	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
   201b8:	69bb      	ldr	r3, [r7, #24]
   201ba:	781a      	ldrb	r2, [r3, #0]
   201bc:	2ae5      	cmp	r2, #229	; 0xe5
   201be:	d101      	bne.n	201c4 <follow_path+0x1f8>
   201c0:	3ae0      	subs	r2, #224	; 0xe0
   201c2:	701a      	strb	r2, [r3, #0]
	if (ni == 8) b <<= 2;
   201c4:	9b02      	ldr	r3, [sp, #8]
   201c6:	2b08      	cmp	r3, #8
   201c8:	d101      	bne.n	201ce <follow_path+0x202>
   201ca:	00ad      	lsls	r5, r5, #2
   201cc:	b2ed      	uxtb	r5, r5
   201ce:	230c      	movs	r3, #12
   201d0:	402b      	ands	r3, r5
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
   201d2:	2b0c      	cmp	r3, #12
   201d4:	d003      	beq.n	201de <follow_path+0x212>
   201d6:	2203      	movs	r2, #3
   201d8:	402a      	ands	r2, r5
   201da:	2a03      	cmp	r2, #3
   201dc:	d102      	bne.n	201e4 <follow_path+0x218>
		cf |= NS_LFN;
   201de:	2202      	movs	r2, #2
   201e0:	4314      	orrs	r4, r2
   201e2:	b2e4      	uxtb	r4, r4
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
   201e4:	07a2      	lsls	r2, r4, #30
   201e6:	d40b      	bmi.n	20200 <follow_path+0x234>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
   201e8:	2203      	movs	r2, #3
   201ea:	4015      	ands	r5, r2
   201ec:	2d01      	cmp	r5, #1
   201ee:	d102      	bne.n	201f6 <follow_path+0x22a>
   201f0:	320d      	adds	r2, #13
   201f2:	4314      	orrs	r4, r2
   201f4:	b2e4      	uxtb	r4, r4
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
   201f6:	2b04      	cmp	r3, #4
   201f8:	d102      	bne.n	20200 <follow_path+0x234>
   201fa:	3304      	adds	r3, #4
   201fc:	431c      	orrs	r4, r3
   201fe:	b2e4      	uxtb	r4, r4
	dj->fn[NS] = cf;	/* SFN is created */
   20200:	69bb      	ldr	r3, [r7, #24]
	res = dir_sdi(dj, 0);			/* Rewind directory object */
   20202:	2100      	movs	r1, #0
	dj->fn[NS] = cf;	/* SFN is created */
   20204:	72dc      	strb	r4, [r3, #11]
	res = dir_sdi(dj, 0);			/* Rewind directory object */
   20206:	0038      	movs	r0, r7
   20208:	4b0f      	ldr	r3, [pc, #60]	; (20248 <follow_path+0x27c>)
   2020a:	4798      	blx	r3
	if (res != FR_OK) return res;
   2020c:	2800      	cmp	r0, #0
   2020e:	d102      	bne.n	20216 <follow_path+0x24a>
   20210:	0038      	movs	r0, r7
   20212:	4b13      	ldr	r3, [pc, #76]	; (20260 <follow_path+0x294>)
   20214:	4798      	blx	r3
			ns = *(dj->fn+NS);
   20216:	69bb      	ldr	r3, [r7, #24]
   20218:	7adb      	ldrb	r3, [r3, #11]
			if (res != FR_OK) {				/* Failed to find the object */
   2021a:	2800      	cmp	r0, #0
   2021c:	d0a4      	beq.n	20168 <follow_path+0x19c>
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
   2021e:	2804      	cmp	r0, #4
   20220:	d000      	beq.n	20224 <follow_path+0x258>
   20222:	e6ea      	b.n	1fffa <follow_path+0x2e>
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
   20224:	4203      	tst	r3, r0
   20226:	d000      	beq.n	2022a <follow_path+0x25e>
   20228:	e6e7      	b.n	1fffa <follow_path+0x2e>
   2022a:	2005      	movs	r0, #5
	return res;
   2022c:	e6e5      	b.n	1fffa <follow_path+0x2e>
				if (IsUpper(w)) {		/* ASCII large capital */
   2022e:	0003      	movs	r3, r0
   20230:	3b41      	subs	r3, #65	; 0x41
   20232:	2b19      	cmp	r3, #25
   20234:	d995      	bls.n	20162 <follow_path+0x196>
					if (IsLower(w)) {	/* ASCII small capital */
   20236:	0003      	movs	r3, r0
   20238:	3b61      	subs	r3, #97	; 0x61
   2023a:	2b19      	cmp	r3, #25
   2023c:	d88b      	bhi.n	20156 <follow_path+0x18a>
						b |= 1; w -= 0x20;
   2023e:	2301      	movs	r3, #1
   20240:	3820      	subs	r0, #32
   20242:	431d      	orrs	r5, r3
   20244:	b280      	uxth	r0, r0
   20246:	e786      	b.n	20156 <follow_path+0x18a>
   20248:	0001f8a1 	.word	0x0001f8a1
   2024c:	0002064d 	.word	0x0002064d
   20250:	0002ad88 	.word	0x0002ad88
   20254:	0002ad08 	.word	0x0002ad08
   20258:	0002ad91 	.word	0x0002ad91
   2025c:	0001f2e7 	.word	0x0001f2e7
   20260:	0001fc3d 	.word	0x0001fc3d

00020264 <f_mount>:

FRESULT f_mount (
	BYTE vol,		/* Logical drive number to be mounted/unmounted */
	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
)
{
   20264:	b510      	push	{r4, lr}
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
   20266:	230b      	movs	r3, #11
	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
   20268:	2807      	cmp	r0, #7
   2026a:	d80b      	bhi.n	20284 <f_mount+0x20>
   2026c:	2200      	movs	r2, #0
	rfs = FatFs[vol];			/* Get current fs object */
   2026e:	4b06      	ldr	r3, [pc, #24]	; (20288 <f_mount+0x24>)
   20270:	0080      	lsls	r0, r0, #2
   20272:	58c4      	ldr	r4, [r0, r3]

	if (rfs) {
   20274:	4294      	cmp	r4, r2
   20276:	d000      	beq.n	2027a <f_mount+0x16>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
   20278:	7022      	strb	r2, [r4, #0]
	}

	if (fs) {
   2027a:	2900      	cmp	r1, #0
   2027c:	d000      	beq.n	20280 <f_mount+0x1c>
		fs->fs_type = 0;		/* Clear new fs object */
   2027e:	700a      	strb	r2, [r1, #0]
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
   20280:	5019      	str	r1, [r3, r0]

	return FR_OK;
   20282:	2300      	movs	r3, #0
}
   20284:	0018      	movs	r0, r3
   20286:	bd10      	pop	{r4, pc}
   20288:	20003dcc 	.word	0x20003dcc

0002028c <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
   2028c:	b5f0      	push	{r4, r5, r6, r7, lr}


	fp->fs = 0;			/* Clear file object */

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
   2028e:	271f      	movs	r7, #31
{
   20290:	0015      	movs	r5, r2
	fp->fs = 0;			/* Clear file object */
   20292:	2300      	movs	r3, #0
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
   20294:	4017      	ands	r7, r2
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
   20296:	221e      	movs	r2, #30
{
   20298:	4c4d      	ldr	r4, [pc, #308]	; (203d0 <f_open+0x144>)
	fp->fs = 0;			/* Clear file object */
   2029a:	6003      	str	r3, [r0, #0]
{
   2029c:	44a5      	add	sp, r4
   2029e:	9101      	str	r1, [sp, #4]
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
   202a0:	4b4c      	ldr	r3, [pc, #304]	; (203d4 <f_open+0x148>)
{
   202a2:	0006      	movs	r6, r0
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
   202a4:	402a      	ands	r2, r5
   202a6:	a905      	add	r1, sp, #20
   202a8:	a801      	add	r0, sp, #4
   202aa:	4798      	blx	r3
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
   202ac:	ab02      	add	r3, sp, #8
   202ae:	930b      	str	r3, [sp, #44]	; 0x2c
   202b0:	ab0e      	add	r3, sp, #56	; 0x38
   202b2:	930c      	str	r3, [sp, #48]	; 0x30
	if (res == FR_OK)
   202b4:	2800      	cmp	r0, #0
   202b6:	d103      	bne.n	202c0 <f_open+0x34>
		res = follow_path(&dj, path);	/* Follow the file path */
   202b8:	9901      	ldr	r1, [sp, #4]
   202ba:	a805      	add	r0, sp, #20
   202bc:	4b46      	ldr	r3, [pc, #280]	; (203d8 <f_open+0x14c>)
   202be:	4798      	blx	r3
	dir = dj.dir;
   202c0:	9c0a      	ldr	r4, [sp, #40]	; 0x28

#if !_FS_READONLY	/* R/W configuration */
	if (res == FR_OK) {
   202c2:	2800      	cmp	r0, #0
   202c4:	d102      	bne.n	202cc <f_open+0x40>
		if (!dir)	/* Current dir itself */
   202c6:	2c00      	cmp	r4, #0
   202c8:	d100      	bne.n	202cc <f_open+0x40>
			res = FR_INVALID_NAME;
   202ca:	3006      	adds	r0, #6
		else
			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
	}
	/* Create or Open a file */
	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
   202cc:	231c      	movs	r3, #28
   202ce:	421d      	tst	r5, r3
   202d0:	d100      	bne.n	202d4 <f_open+0x48>
   202d2:	e06f      	b.n	203b4 <f_open+0x128>
		DWORD dw, cl;

		if (res != FR_OK) {					/* No file, create new */
   202d4:	2800      	cmp	r0, #0
   202d6:	d00d      	beq.n	202f4 <f_open+0x68>
			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
   202d8:	2804      	cmp	r0, #4
   202da:	d102      	bne.n	202e2 <f_open+0x56>
#if _FS_SHARE
				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
				res = dir_register(&dj);
   202dc:	a805      	add	r0, sp, #20
   202de:	4b3f      	ldr	r3, [pc, #252]	; (203dc <f_open+0x150>)
   202e0:	4798      	blx	r3
#endif
			mode |= FA_CREATE_ALWAYS;		/* File is created */
   202e2:	2308      	movs	r3, #8
			dir = dj.dir;					/* New entry */
   202e4:	9c0a      	ldr	r4, [sp, #40]	; 0x28
			mode |= FA_CREATE_ALWAYS;		/* File is created */
   202e6:	431f      	orrs	r7, r3
			} else {
				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
   202e8:	2800      	cmp	r0, #0
   202ea:	d00b      	beq.n	20304 <f_open+0x78>
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
   202ec:	238f      	movs	r3, #143	; 0x8f
   202ee:	009b      	lsls	r3, r3, #2
   202f0:	449d      	add	sp, r3
   202f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
   202f4:	2311      	movs	r3, #17
   202f6:	7ae2      	ldrb	r2, [r4, #11]
				res = FR_DENIED;
   202f8:	2007      	movs	r0, #7
			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
   202fa:	421a      	tst	r2, r3
   202fc:	d1f6      	bne.n	202ec <f_open+0x60>
					res = FR_EXIST;
   202fe:	3001      	adds	r0, #1
				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
   20300:	076b      	lsls	r3, r5, #29
   20302:	d4f3      	bmi.n	202ec <f_open+0x60>
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
   20304:	073b      	lsls	r3, r7, #28
   20306:	d52f      	bpl.n	20368 <f_open+0xdc>
			dw = get_fattime();					/* Created time */
   20308:	4b35      	ldr	r3, [pc, #212]	; (203e0 <f_open+0x154>)
   2030a:	4798      	blx	r3
			ST_DWORD(dir+DIR_CrtTime, dw);
   2030c:	0a03      	lsrs	r3, r0, #8
   2030e:	73e3      	strb	r3, [r4, #15]
   20310:	0c03      	lsrs	r3, r0, #16
   20312:	7423      	strb	r3, [r4, #16]
			dir[DIR_Attr] = 0;					/* Reset attribute */
   20314:	2300      	movs	r3, #0
			cl = LD_CLUST(dir);					/* Get start cluster */
   20316:	7d62      	ldrb	r2, [r4, #21]
   20318:	7d25      	ldrb	r5, [r4, #20]
   2031a:	7ee1      	ldrb	r1, [r4, #27]
   2031c:	0212      	lsls	r2, r2, #8
			ST_DWORD(dir+DIR_CrtTime, dw);
   2031e:	73a0      	strb	r0, [r4, #14]
			cl = LD_CLUST(dir);					/* Get start cluster */
   20320:	4315      	orrs	r5, r2
			ST_DWORD(dir+DIR_CrtTime, dw);
   20322:	0e00      	lsrs	r0, r0, #24
			cl = LD_CLUST(dir);					/* Get start cluster */
   20324:	7ea2      	ldrb	r2, [r4, #26]
			ST_DWORD(dir+DIR_CrtTime, dw);
   20326:	7460      	strb	r0, [r4, #17]
			cl = LD_CLUST(dir);					/* Get start cluster */
   20328:	0209      	lsls	r1, r1, #8
			dj.fs->wflag = 1;
   2032a:	9805      	ldr	r0, [sp, #20]
			dir[DIR_Attr] = 0;					/* Reset attribute */
   2032c:	72e3      	strb	r3, [r4, #11]
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
   2032e:	7723      	strb	r3, [r4, #28]
   20330:	7763      	strb	r3, [r4, #29]
   20332:	77a3      	strb	r3, [r4, #30]
   20334:	77e3      	strb	r3, [r4, #31]
			ST_CLUST(dir, 0);					/* cluster = 0 */
   20336:	76a3      	strb	r3, [r4, #26]
   20338:	76e3      	strb	r3, [r4, #27]
   2033a:	7523      	strb	r3, [r4, #20]
   2033c:	7563      	strb	r3, [r4, #21]
			cl = LD_CLUST(dir);					/* Get start cluster */
   2033e:	042d      	lsls	r5, r5, #16
   20340:	430a      	orrs	r2, r1
			dj.fs->wflag = 1;
   20342:	3301      	adds	r3, #1
			cl = LD_CLUST(dir);					/* Get start cluster */
   20344:	4315      	orrs	r5, r2
			dj.fs->wflag = 1;
   20346:	7103      	strb	r3, [r0, #4]
			if (cl) {							/* Remove the cluster chain if exist */
   20348:	d00e      	beq.n	20368 <f_open+0xdc>
				dw = dj.fs->winsect;
   2034a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
				res = remove_chain(dj.fs, cl);
   2034c:	0029      	movs	r1, r5
				dw = dj.fs->winsect;
   2034e:	9300      	str	r3, [sp, #0]
				res = remove_chain(dj.fs, cl);
   20350:	4b24      	ldr	r3, [pc, #144]	; (203e4 <f_open+0x158>)
   20352:	4798      	blx	r3
				if (res == FR_OK) {
   20354:	2800      	cmp	r0, #0
   20356:	d1c9      	bne.n	202ec <f_open+0x60>
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
   20358:	9805      	ldr	r0, [sp, #20]
   2035a:	3d01      	subs	r5, #1
   2035c:	60c5      	str	r5, [r0, #12]
					res = move_window(dj.fs, dw);
   2035e:	9900      	ldr	r1, [sp, #0]
   20360:	4b21      	ldr	r3, [pc, #132]	; (203e8 <f_open+0x15c>)
   20362:	4798      	blx	r3
	if (res == FR_OK) {
   20364:	2800      	cmp	r0, #0
   20366:	d1c1      	bne.n	202ec <f_open+0x60>
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
   20368:	073b      	lsls	r3, r7, #28
   2036a:	d501      	bpl.n	20370 <f_open+0xe4>
			mode |= FA__WRITTEN;
   2036c:	2320      	movs	r3, #32
   2036e:	431f      	orrs	r7, r3
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
   20370:	9a05      	ldr	r2, [sp, #20]
   20372:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
		fp->dir_ptr = dir;
   20374:	6234      	str	r4, [r6, #32]
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
   20376:	61f3      	str	r3, [r6, #28]
		fp->flag = mode;					/* File access mode */
   20378:	71b7      	strb	r7, [r6, #6]
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
   2037a:	7d61      	ldrb	r1, [r4, #21]
   2037c:	7d23      	ldrb	r3, [r4, #20]
   2037e:	7ee0      	ldrb	r0, [r4, #27]
   20380:	0209      	lsls	r1, r1, #8
   20382:	430b      	orrs	r3, r1
   20384:	7ea1      	ldrb	r1, [r4, #26]
   20386:	0200      	lsls	r0, r0, #8
   20388:	4301      	orrs	r1, r0
		fp->fptr = 0;						/* File pointer */
   2038a:	2000      	movs	r0, #0
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
   2038c:	041b      	lsls	r3, r3, #16
   2038e:	430b      	orrs	r3, r1
   20390:	6133      	str	r3, [r6, #16]
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
   20392:	7f61      	ldrb	r1, [r4, #29]
   20394:	7f23      	ldrb	r3, [r4, #28]
   20396:	0209      	lsls	r1, r1, #8
   20398:	4319      	orrs	r1, r3
   2039a:	7fa3      	ldrb	r3, [r4, #30]
   2039c:	041b      	lsls	r3, r3, #16
   2039e:	4319      	orrs	r1, r3
   203a0:	7fe3      	ldrb	r3, [r4, #31]
		fp->fptr = 0;						/* File pointer */
   203a2:	60b0      	str	r0, [r6, #8]
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
   203a4:	061b      	lsls	r3, r3, #24
   203a6:	430b      	orrs	r3, r1
   203a8:	60f3      	str	r3, [r6, #12]
		fp->dsect = 0;
   203aa:	61b0      	str	r0, [r6, #24]
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
   203ac:	6032      	str	r2, [r6, #0]
   203ae:	88d3      	ldrh	r3, [r2, #6]
   203b0:	80b3      	strh	r3, [r6, #4]
   203b2:	e79b      	b.n	202ec <f_open+0x60>
		if (res == FR_OK) {						/* Follow succeeded */
   203b4:	2800      	cmp	r0, #0
   203b6:	d199      	bne.n	202ec <f_open+0x60>
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
   203b8:	7ae3      	ldrb	r3, [r4, #11]
				res = FR_NO_FILE;
   203ba:	3004      	adds	r0, #4
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
   203bc:	06da      	lsls	r2, r3, #27
   203be:	d500      	bpl.n	203c2 <f_open+0x136>
   203c0:	e794      	b.n	202ec <f_open+0x60>
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
   203c2:	07aa      	lsls	r2, r5, #30
   203c4:	d5d0      	bpl.n	20368 <f_open+0xdc>
				res = FR_DENIED;
   203c6:	3003      	adds	r0, #3
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
   203c8:	07db      	lsls	r3, r3, #31
   203ca:	d500      	bpl.n	203ce <f_open+0x142>
   203cc:	e78e      	b.n	202ec <f_open+0x60>
   203ce:	e7cb      	b.n	20368 <f_open+0xdc>
   203d0:	fffffdc4 	.word	0xfffffdc4
   203d4:	0001f549 	.word	0x0001f549
   203d8:	0001ffcd 	.word	0x0001ffcd
   203dc:	0001fd8d 	.word	0x0001fd8d
   203e0:	0001f28d 	.word	0x0001f28d
   203e4:	0001fbdd 	.word	0x0001fbdd
   203e8:	0001f329 	.word	0x0001f329

000203ec <f_write>:
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
   203ec:	b5f0      	push	{r4, r5, r6, r7, lr}
   203ee:	b087      	sub	sp, #28
   203f0:	9305      	str	r3, [sp, #20]
	UINT wcnt, cc;
	const BYTE *wbuff = buff;
	BYTE csect;


	*bw = 0;	/* Initialize byte counter */
   203f2:	2300      	movs	r3, #0
{
   203f4:	9201      	str	r2, [sp, #4]
	*bw = 0;	/* Initialize byte counter */
   203f6:	9a05      	ldr	r2, [sp, #20]
{
   203f8:	0004      	movs	r4, r0
	*bw = 0;	/* Initialize byte counter */
   203fa:	6013      	str	r3, [r2, #0]
{
   203fc:	000d      	movs	r5, r1

	res = validate(fp->fs, fp->id);			/* Check validity */
   203fe:	4b65      	ldr	r3, [pc, #404]	; (20594 <f_write+0x1a8>)
   20400:	8881      	ldrh	r1, [r0, #4]
   20402:	6800      	ldr	r0, [r0, #0]
   20404:	4798      	blx	r3
   20406:	1e06      	subs	r6, r0, #0
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   20408:	d13a      	bne.n	20480 <f_write+0x94>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
   2040a:	79a2      	ldrb	r2, [r4, #6]
   2040c:	2302      	movs	r3, #2
   2040e:	b251      	sxtb	r1, r2
   20410:	2900      	cmp	r1, #0
   20412:	db34      	blt.n	2047e <f_write+0x92>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
   20414:	421a      	tst	r2, r3
   20416:	d100      	bne.n	2041a <f_write+0x2e>
   20418:	e0ba      	b.n	20590 <f_write+0x1a4>
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
   2041a:	68e3      	ldr	r3, [r4, #12]
   2041c:	9a01      	ldr	r2, [sp, #4]
   2041e:	18d2      	adds	r2, r2, r3
   20420:	4293      	cmp	r3, r2
   20422:	d803      	bhi.n	2042c <f_write+0x40>
   20424:	9502      	str	r5, [sp, #8]

	for ( ;  btw;							/* Repeat until all data written */
   20426:	9b01      	ldr	r3, [sp, #4]
   20428:	2b00      	cmp	r3, #0
   2042a:	d109      	bne.n	20440 <f_write+0x54>
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
   2042c:	68a3      	ldr	r3, [r4, #8]
   2042e:	68e2      	ldr	r2, [r4, #12]
   20430:	4293      	cmp	r3, r2
   20432:	d900      	bls.n	20436 <f_write+0x4a>
   20434:	e0aa      	b.n	2058c <f_write+0x1a0>
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
   20436:	2320      	movs	r3, #32
   20438:	79a2      	ldrb	r2, [r4, #6]
   2043a:	4313      	orrs	r3, r2
   2043c:	71a3      	strb	r3, [r4, #6]
   2043e:	e01f      	b.n	20480 <f_write+0x94>
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
   20440:	68a3      	ldr	r3, [r4, #8]
   20442:	05da      	lsls	r2, r3, #23
   20444:	d000      	beq.n	20448 <f_write+0x5c>
   20446:	e083      	b.n	20550 <f_write+0x164>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   20448:	6820      	ldr	r0, [r4, #0]
   2044a:	0a5a      	lsrs	r2, r3, #9
   2044c:	7881      	ldrb	r1, [r0, #2]
   2044e:	3901      	subs	r1, #1
   20450:	400a      	ands	r2, r1
   20452:	b2d2      	uxtb	r2, r2
   20454:	9203      	str	r2, [sp, #12]
			if (!csect) {					/* On the cluster boundary? */
   20456:	2a00      	cmp	r2, #0
   20458:	d124      	bne.n	204a4 <f_write+0xb8>
				if (fp->fptr == 0) {		/* On the top of the file? */
   2045a:	2b00      	cmp	r3, #0
   2045c:	d113      	bne.n	20486 <f_write+0x9a>
					clst = fp->sclust;		/* Follow from the origin */
   2045e:	6921      	ldr	r1, [r4, #16]
					if (clst == 0)			/* When no cluster is allocated, */
   20460:	2900      	cmp	r1, #0
   20462:	d105      	bne.n	20470 <f_write+0x84>
						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
   20464:	4b4c      	ldr	r3, [pc, #304]	; (20598 <f_write+0x1ac>)
   20466:	4798      	blx	r3
   20468:	0001      	movs	r1, r0
   2046a:	6120      	str	r0, [r4, #16]
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
   2046c:	2900      	cmp	r1, #0
   2046e:	d0dd      	beq.n	2042c <f_write+0x40>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   20470:	2901      	cmp	r1, #1
   20472:	d10d      	bne.n	20490 <f_write+0xa4>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   20474:	2380      	movs	r3, #128	; 0x80
   20476:	79a2      	ldrb	r2, [r4, #6]
   20478:	425b      	negs	r3, r3
   2047a:	4313      	orrs	r3, r2
   2047c:	71a3      	strb	r3, [r4, #6]
   2047e:	2602      	movs	r6, #2

	LEAVE_FF(fp->fs, FR_OK);
}
   20480:	0030      	movs	r0, r6
   20482:	b007      	add	sp, #28
   20484:	bdf0      	pop	{r4, r5, r6, r7, pc}
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
   20486:	6961      	ldr	r1, [r4, #20]
   20488:	4b43      	ldr	r3, [pc, #268]	; (20598 <f_write+0x1ac>)
   2048a:	4798      	blx	r3
   2048c:	0001      	movs	r1, r0
   2048e:	e7ed      	b.n	2046c <f_write+0x80>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   20490:	1c4b      	adds	r3, r1, #1
   20492:	d106      	bne.n	204a2 <f_write+0xb6>
			ABORT(fp->fs, FR_DISK_ERR);
   20494:	2380      	movs	r3, #128	; 0x80
   20496:	79a2      	ldrb	r2, [r4, #6]
   20498:	425b      	negs	r3, r3
   2049a:	4313      	orrs	r3, r2
   2049c:	71a3      	strb	r3, [r4, #6]
   2049e:	2601      	movs	r6, #1
   204a0:	e7ee      	b.n	20480 <f_write+0x94>
				fp->clust = clst;			/* Update current cluster */
   204a2:	6161      	str	r1, [r4, #20]
			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
   204a4:	6820      	ldr	r0, [r4, #0]
   204a6:	69a2      	ldr	r2, [r4, #24]
   204a8:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   204aa:	4293      	cmp	r3, r2
   204ac:	d104      	bne.n	204b8 <f_write+0xcc>
   204ae:	2100      	movs	r1, #0
   204b0:	4b3a      	ldr	r3, [pc, #232]	; (2059c <f_write+0x1b0>)
   204b2:	4798      	blx	r3
   204b4:	2800      	cmp	r0, #0
   204b6:	d1ed      	bne.n	20494 <f_write+0xa8>
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   204b8:	6827      	ldr	r7, [r4, #0]
   204ba:	6961      	ldr	r1, [r4, #20]
   204bc:	0038      	movs	r0, r7
   204be:	4b38      	ldr	r3, [pc, #224]	; (205a0 <f_write+0x1b4>)
   204c0:	4798      	blx	r3
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   204c2:	2800      	cmp	r0, #0
   204c4:	d0d6      	beq.n	20474 <f_write+0x88>
			sect += csect;
   204c6:	9b03      	ldr	r3, [sp, #12]
   204c8:	18c3      	adds	r3, r0, r3
   204ca:	9304      	str	r3, [sp, #16]
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
   204cc:	9b01      	ldr	r3, [sp, #4]
   204ce:	0a5d      	lsrs	r5, r3, #9
			if (cc) {						/* Write maximum contiguous sectors directly */
   204d0:	d02f      	beq.n	20532 <f_write+0x146>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   204d2:	9a03      	ldr	r2, [sp, #12]
   204d4:	78bb      	ldrb	r3, [r7, #2]
   204d6:	1952      	adds	r2, r2, r5
   204d8:	429a      	cmp	r2, r3
   204da:	d901      	bls.n	204e0 <f_write+0xf4>
					cc = fp->fs->csize - csect;
   204dc:	9a03      	ldr	r2, [sp, #12]
   204de:	1a9d      	subs	r5, r3, r2
				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
   204e0:	7878      	ldrb	r0, [r7, #1]
   204e2:	b2eb      	uxtb	r3, r5
   204e4:	4f2f      	ldr	r7, [pc, #188]	; (205a4 <f_write+0x1b8>)
   204e6:	9a04      	ldr	r2, [sp, #16]
   204e8:	9902      	ldr	r1, [sp, #8]
   204ea:	47b8      	blx	r7
   204ec:	1e07      	subs	r7, r0, #0
   204ee:	d1d1      	bne.n	20494 <f_write+0xa8>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
   204f0:	6820      	ldr	r0, [r4, #0]
   204f2:	9a04      	ldr	r2, [sp, #16]
   204f4:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   204f6:	1a99      	subs	r1, r3, r2
   204f8:	428d      	cmp	r5, r1
   204fa:	d909      	bls.n	20510 <f_write+0x124>
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
   204fc:	2280      	movs	r2, #128	; 0x80
   204fe:	9b02      	ldr	r3, [sp, #8]
   20500:	0249      	lsls	r1, r1, #9
   20502:	1859      	adds	r1, r3, r1
   20504:	3030      	adds	r0, #48	; 0x30
   20506:	4b28      	ldr	r3, [pc, #160]	; (205a8 <f_write+0x1bc>)
   20508:	0092      	lsls	r2, r2, #2
   2050a:	4798      	blx	r3
					fp->fs->wflag = 0;
   2050c:	6823      	ldr	r3, [r4, #0]
   2050e:	711f      	strb	r7, [r3, #4]
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
   20510:	026d      	lsls	r5, r5, #9
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
   20512:	9b02      	ldr	r3, [sp, #8]
   20514:	9a05      	ldr	r2, [sp, #20]
   20516:	195b      	adds	r3, r3, r5
   20518:	9302      	str	r3, [sp, #8]
   2051a:	68a3      	ldr	r3, [r4, #8]
   2051c:	195b      	adds	r3, r3, r5
   2051e:	60a3      	str	r3, [r4, #8]
   20520:	9b05      	ldr	r3, [sp, #20]
   20522:	681b      	ldr	r3, [r3, #0]
   20524:	9303      	str	r3, [sp, #12]
   20526:	195b      	adds	r3, r3, r5
   20528:	6013      	str	r3, [r2, #0]
   2052a:	9b01      	ldr	r3, [sp, #4]
   2052c:	1b5b      	subs	r3, r3, r5
   2052e:	9301      	str	r3, [sp, #4]
   20530:	e779      	b.n	20426 <f_write+0x3a>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
   20532:	68a3      	ldr	r3, [r4, #8]
   20534:	68e2      	ldr	r2, [r4, #12]
   20536:	4293      	cmp	r3, r2
   20538:	d308      	bcc.n	2054c <f_write+0x160>
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
   2053a:	0029      	movs	r1, r5
   2053c:	0038      	movs	r0, r7
   2053e:	4b17      	ldr	r3, [pc, #92]	; (2059c <f_write+0x1b0>)
   20540:	4798      	blx	r3
   20542:	2800      	cmp	r0, #0
   20544:	d1a6      	bne.n	20494 <f_write+0xa8>
				fp->fs->winsect = sect;
   20546:	6823      	ldr	r3, [r4, #0]
   20548:	9a04      	ldr	r2, [sp, #16]
   2054a:	62da      	str	r2, [r3, #44]	; 0x2c
			fp->dsect = sect;
   2054c:	9b04      	ldr	r3, [sp, #16]
   2054e:	61a3      	str	r3, [r4, #24]
		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
   20550:	2280      	movs	r2, #128	; 0x80
   20552:	68a3      	ldr	r3, [r4, #8]
   20554:	9d01      	ldr	r5, [sp, #4]
   20556:	05db      	lsls	r3, r3, #23
   20558:	0ddb      	lsrs	r3, r3, #23
   2055a:	0092      	lsls	r2, r2, #2
   2055c:	1ad3      	subs	r3, r2, r3
   2055e:	429d      	cmp	r5, r3
   20560:	d900      	bls.n	20564 <f_write+0x178>
   20562:	001d      	movs	r5, r3
		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
   20564:	69a1      	ldr	r1, [r4, #24]
   20566:	6820      	ldr	r0, [r4, #0]
   20568:	4b0c      	ldr	r3, [pc, #48]	; (2059c <f_write+0x1b0>)
   2056a:	4798      	blx	r3
   2056c:	2800      	cmp	r0, #0
   2056e:	d191      	bne.n	20494 <f_write+0xa8>
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   20570:	68a3      	ldr	r3, [r4, #8]
   20572:	002a      	movs	r2, r5
   20574:	05d8      	lsls	r0, r3, #23
   20576:	0dc0      	lsrs	r0, r0, #23
   20578:	6823      	ldr	r3, [r4, #0]
   2057a:	3030      	adds	r0, #48	; 0x30
   2057c:	1818      	adds	r0, r3, r0
   2057e:	9902      	ldr	r1, [sp, #8]
   20580:	4b09      	ldr	r3, [pc, #36]	; (205a8 <f_write+0x1bc>)
   20582:	4798      	blx	r3
		fp->fs->wflag = 1;
   20584:	2201      	movs	r2, #1
   20586:	6823      	ldr	r3, [r4, #0]
   20588:	711a      	strb	r2, [r3, #4]
   2058a:	e7c2      	b.n	20512 <f_write+0x126>
	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
   2058c:	60e3      	str	r3, [r4, #12]
   2058e:	e752      	b.n	20436 <f_write+0x4a>
		LEAVE_FF(fp->fs, FR_DENIED);
   20590:	2607      	movs	r6, #7
   20592:	e775      	b.n	20480 <f_write+0x94>
   20594:	0001f49d 	.word	0x0001f49d
   20598:	0001fa39 	.word	0x0001fa39
   2059c:	0001f329 	.word	0x0001f329
   205a0:	0001f2f5 	.word	0x0001f2f5
   205a4:	0001f1b5 	.word	0x0001f1b5
   205a8:	0001f2d5 	.word	0x0001f2d5

000205ac <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
   205ac:	b570      	push	{r4, r5, r6, lr}
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
   205ae:	4b1e      	ldr	r3, [pc, #120]	; (20628 <f_sync+0x7c>)
{
   205b0:	0004      	movs	r4, r0
	res = validate(fp->fs, fp->id);		/* Check validity of the object */
   205b2:	8881      	ldrh	r1, [r0, #4]
   205b4:	6800      	ldr	r0, [r0, #0]
   205b6:	4798      	blx	r3
	if (res == FR_OK) {
   205b8:	2800      	cmp	r0, #0
   205ba:	d133      	bne.n	20624 <f_sync+0x78>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
   205bc:	2620      	movs	r6, #32
   205be:	79a3      	ldrb	r3, [r4, #6]
   205c0:	4233      	tst	r3, r6
   205c2:	d02f      	beq.n	20624 <f_sync+0x78>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
   205c4:	69e1      	ldr	r1, [r4, #28]
   205c6:	6820      	ldr	r0, [r4, #0]
   205c8:	4b18      	ldr	r3, [pc, #96]	; (2062c <f_sync+0x80>)
   205ca:	4798      	blx	r3
			if (res == FR_OK) {
   205cc:	2800      	cmp	r0, #0
   205ce:	d129      	bne.n	20624 <f_sync+0x78>
				dir = fp->dir_ptr;
   205d0:	6a25      	ldr	r5, [r4, #32]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
   205d2:	7aeb      	ldrb	r3, [r5, #11]
   205d4:	4333      	orrs	r3, r6
   205d6:	72eb      	strb	r3, [r5, #11]
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
   205d8:	7b23      	ldrb	r3, [r4, #12]
   205da:	772b      	strb	r3, [r5, #28]
   205dc:	7b63      	ldrb	r3, [r4, #13]
   205de:	776b      	strb	r3, [r5, #29]
   205e0:	68e3      	ldr	r3, [r4, #12]
   205e2:	0c1b      	lsrs	r3, r3, #16
   205e4:	77ab      	strb	r3, [r5, #30]
   205e6:	68e3      	ldr	r3, [r4, #12]
   205e8:	0e1b      	lsrs	r3, r3, #24
   205ea:	77eb      	strb	r3, [r5, #31]
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
   205ec:	7c23      	ldrb	r3, [r4, #16]
   205ee:	76ab      	strb	r3, [r5, #26]
   205f0:	7c63      	ldrb	r3, [r4, #17]
   205f2:	76eb      	strb	r3, [r5, #27]
   205f4:	6923      	ldr	r3, [r4, #16]
   205f6:	0c1b      	lsrs	r3, r3, #16
   205f8:	752b      	strb	r3, [r5, #20]
   205fa:	6923      	ldr	r3, [r4, #16]
   205fc:	0e1b      	lsrs	r3, r3, #24
   205fe:	756b      	strb	r3, [r5, #21]
				tim = get_fattime();						/* Update updated time */
   20600:	4b0b      	ldr	r3, [pc, #44]	; (20630 <f_sync+0x84>)
   20602:	4798      	blx	r3
				ST_DWORD(dir+DIR_WrtTime, tim);
   20604:	0a03      	lsrs	r3, r0, #8
   20606:	75a8      	strb	r0, [r5, #22]
   20608:	75eb      	strb	r3, [r5, #23]
   2060a:	0c03      	lsrs	r3, r0, #16
   2060c:	0e00      	lsrs	r0, r0, #24
   2060e:	762b      	strb	r3, [r5, #24]
   20610:	7668      	strb	r0, [r5, #25]
				fp->flag &= ~FA__WRITTEN;
   20612:	79a3      	ldrb	r3, [r4, #6]
				fp->fs->wflag = 1;
   20614:	6822      	ldr	r2, [r4, #0]
				fp->flag &= ~FA__WRITTEN;
   20616:	43b3      	bics	r3, r6
   20618:	71a3      	strb	r3, [r4, #6]
				fp->fs->wflag = 1;
   2061a:	2301      	movs	r3, #1
   2061c:	7113      	strb	r3, [r2, #4]
				res = sync(fp->fs);
   2061e:	6820      	ldr	r0, [r4, #0]
   20620:	4b04      	ldr	r3, [pc, #16]	; (20634 <f_sync+0x88>)
   20622:	4798      	blx	r3
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
   20624:	bd70      	pop	{r4, r5, r6, pc}
   20626:	46c0      	nop			; (mov r8, r8)
   20628:	0001f49d 	.word	0x0001f49d
   2062c:	0001f329 	.word	0x0001f329
   20630:	0001f28d 	.word	0x0001f28d
   20634:	0001f3a9 	.word	0x0001f3a9

00020638 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
   20638:	b510      	push	{r4, lr}
	res = validate(fs, fp->id);
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	LEAVE_FF(fs, res);

#else
	res = f_sync(fp);		/* Flush cached data */
   2063a:	4b03      	ldr	r3, [pc, #12]	; (20648 <f_close+0x10>)
{
   2063c:	0004      	movs	r4, r0
	res = f_sync(fp);		/* Flush cached data */
   2063e:	4798      	blx	r3
#else
		res = dec_lock(fp->lockid);
#endif
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
   20640:	2800      	cmp	r0, #0
   20642:	d100      	bne.n	20646 <f_close+0xe>
   20644:	6020      	str	r0, [r4, #0]
	return res;
#endif
}
   20646:	bd10      	pop	{r4, pc}
   20648:	000205ad 	.word	0x000205ad

0002064c <ff_convert>:

WCHAR ff_convert (	/* Converted character, Returns zero on error */
	WCHAR	src,	/* Character code to be converted */
	UINT	dir		/* 0: Unicode to OEMCP, 1: OEMCP to Unicode */
)
{
   2064c:	b510      	push	{r4, lr}
	WCHAR c;


	if (src < 0x80) {	/* ASCII */
   2064e:	287f      	cmp	r0, #127	; 0x7f
   20650:	d907      	bls.n	20662 <ff_convert+0x16>
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
   20652:	2900      	cmp	r1, #0
   20654:	d006      	beq.n	20664 <ff_convert+0x18>
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
   20656:	28ff      	cmp	r0, #255	; 0xff
   20658:	d811      	bhi.n	2067e <ff_convert+0x32>
   2065a:	3880      	subs	r0, #128	; 0x80
   2065c:	4b09      	ldr	r3, [pc, #36]	; (20684 <ff_convert+0x38>)
   2065e:	0040      	lsls	r0, r0, #1
   20660:	5ac0      	ldrh	r0, [r0, r3]
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
   20662:	bd10      	pop	{r4, pc}
				if (src == Tbl[c]) break;
   20664:	4a07      	ldr	r2, [pc, #28]	; (20684 <ff_convert+0x38>)
   20666:	004c      	lsls	r4, r1, #1
   20668:	5aa4      	ldrh	r4, [r4, r2]
   2066a:	b28b      	uxth	r3, r1
   2066c:	4284      	cmp	r4, r0
   2066e:	d003      	beq.n	20678 <ff_convert+0x2c>
   20670:	3101      	adds	r1, #1
			for (c = 0; c < 0x80; c++) {
   20672:	2980      	cmp	r1, #128	; 0x80
   20674:	d1f7      	bne.n	20666 <ff_convert+0x1a>
   20676:	000b      	movs	r3, r1
			c = (c + 0x80) & 0xFF;
   20678:	3380      	adds	r3, #128	; 0x80
   2067a:	b2d8      	uxtb	r0, r3
   2067c:	e7f1      	b.n	20662 <ff_convert+0x16>
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
   2067e:	2000      	movs	r0, #0
   20680:	e7ef      	b.n	20662 <ff_convert+0x16>
   20682:	46c0      	nop			; (mov r8, r8)
   20684:	0002ad98 	.word	0x0002ad98

00020688 <ff_wtoupper>:
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
   20688:	2300      	movs	r3, #0
{
   2068a:	b510      	push	{r4, lr}
	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
   2068c:	4c05      	ldr	r4, [pc, #20]	; (206a4 <ff_wtoupper+0x1c>)
   2068e:	005a      	lsls	r2, r3, #1
   20690:	5b11      	ldrh	r1, [r2, r4]
   20692:	2900      	cmp	r1, #0
   20694:	d003      	beq.n	2069e <ff_wtoupper+0x16>
   20696:	4281      	cmp	r1, r0
   20698:	d102      	bne.n	206a0 <ff_wtoupper+0x18>

	return tbl_lower[i] ? tbl_upper[i] : chr;
   2069a:	4b03      	ldr	r3, [pc, #12]	; (206a8 <ff_wtoupper+0x20>)
   2069c:	5ad0      	ldrh	r0, [r2, r3]
}
   2069e:	bd10      	pop	{r4, pc}
	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
   206a0:	3301      	adds	r3, #1
   206a2:	e7f4      	b.n	2068e <ff_wtoupper+0x6>
   206a4:	0002ae98 	.word	0x0002ae98
   206a8:	0002b078 	.word	0x0002b078

000206ac <sendPacket>:
    return c->next_packetid = (c->next_packetid == MAX_PACKET_ID) ? 1 : c->next_packetid + 1;
}


static int sendPacket(MQTTClient* c, int length, Timer* timer)
{
   206ac:	b5f0      	push	{r4, r5, r6, r7, lr}
   206ae:	0005      	movs	r5, r0
   206b0:	000e      	movs	r6, r1
    int rc = FAILURE, 
        sent = 0;
   206b2:	2400      	movs	r4, #0
{
   206b4:	b085      	sub	sp, #20
   206b6:	9201      	str	r2, [sp, #4]
    
    while (sent < length && !TimerIsExpired(timer))
   206b8:	42b4      	cmp	r4, r6
   206ba:	da1b      	bge.n	206f4 <sendPacket+0x48>
   206bc:	9801      	ldr	r0, [sp, #4]
   206be:	4b12      	ldr	r3, [pc, #72]	; (20708 <sendPacket+0x5c>)
   206c0:	4798      	blx	r3
   206c2:	2800      	cmp	r0, #0
   206c4:	d110      	bne.n	206e8 <sendPacket+0x3c>
    {
        rc = c->ipstack->mqttwrite(c->ipstack, &c->buf[sent], length, TimerLeftMS(timer));
   206c6:	6d2f      	ldr	r7, [r5, #80]	; 0x50
   206c8:	9801      	ldr	r0, [sp, #4]
   206ca:	68fb      	ldr	r3, [r7, #12]
   206cc:	9302      	str	r3, [sp, #8]
   206ce:	692b      	ldr	r3, [r5, #16]
   206d0:	191b      	adds	r3, r3, r4
   206d2:	9303      	str	r3, [sp, #12]
   206d4:	4b0d      	ldr	r3, [pc, #52]	; (2070c <sendPacket+0x60>)
   206d6:	4798      	blx	r3
   206d8:	0032      	movs	r2, r6
   206da:	0003      	movs	r3, r0
   206dc:	9903      	ldr	r1, [sp, #12]
   206de:	0038      	movs	r0, r7
   206e0:	9f02      	ldr	r7, [sp, #8]
   206e2:	47b8      	blx	r7
        if (rc < 0)  // there was an error writing the data
   206e4:	2800      	cmp	r0, #0
   206e6:	da03      	bge.n	206f0 <sendPacket+0x44>
    {
        TimerCountdown(&c->ping_timer, c->keepAliveInterval); // record the fact that we have successfully sent the packet
        rc = SUCCESS;
    }
    else
        rc = FAILURE;
   206e8:	2001      	movs	r0, #1
   206ea:	4240      	negs	r0, r0
    return rc;
}
   206ec:	b005      	add	sp, #20
   206ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
        sent += rc;
   206f0:	1824      	adds	r4, r4, r0
   206f2:	e7e1      	b.n	206b8 <sendPacket+0xc>
    if (sent == length)
   206f4:	42b4      	cmp	r4, r6
   206f6:	d1f7      	bne.n	206e8 <sendPacket+0x3c>
        TimerCountdown(&c->ping_timer, c->keepAliveInterval); // record the fact that we have successfully sent the packet
   206f8:	0028      	movs	r0, r5
   206fa:	69a9      	ldr	r1, [r5, #24]
   206fc:	3054      	adds	r0, #84	; 0x54
   206fe:	4b04      	ldr	r3, [pc, #16]	; (20710 <sendPacket+0x64>)
   20700:	4798      	blx	r3
        rc = SUCCESS;
   20702:	2000      	movs	r0, #0
    return rc;
   20704:	e7f2      	b.n	206ec <sendPacket+0x40>
   20706:	46c0      	nop			; (mov r8, r8)
   20708:	00020ed9 	.word	0x00020ed9
   2070c:	00020f15 	.word	0x00020f15
   20710:	00020f01 	.word	0x00020f01

00020714 <MQTTClientInit>:


void MQTTClientInit(MQTTClient* c, Network* network, unsigned int command_timeout_ms,
		unsigned char* sendbuf, size_t sendbuf_size, unsigned char* readbuf, size_t readbuf_size)
{
   20714:	b510      	push	{r4, lr}
    c->ipstack = network;
    
    for (i = 0; i < MAX_MESSAGE_HANDLERS; ++i)
        c->messageHandlers[i].topicFilter = 0;
    c->command_timeout_ms = command_timeout_ms;
    c->buf = sendbuf;
   20716:	6103      	str	r3, [r0, #16]
    c->buf_size = sendbuf_size;
   20718:	9b02      	ldr	r3, [sp, #8]
    c->ipstack = network;
   2071a:	6501      	str	r1, [r0, #80]	; 0x50
    c->buf_size = sendbuf_size;
   2071c:	6083      	str	r3, [r0, #8]
    c->readbuf = readbuf;
   2071e:	9b03      	ldr	r3, [sp, #12]
        c->messageHandlers[i].topicFilter = 0;
   20720:	2100      	movs	r1, #0
    c->readbuf = readbuf;
   20722:	6143      	str	r3, [r0, #20]
    c->readbuf_size = readbuf_size;
   20724:	9b04      	ldr	r3, [sp, #16]
        c->messageHandlers[i].topicFilter = 0;
   20726:	6241      	str	r1, [r0, #36]	; 0x24
    c->readbuf_size = readbuf_size;
   20728:	60c3      	str	r3, [r0, #12]
    c->isconnected = 0;
    c->ping_outstanding = 0;
    c->defaultMessageHandler = NULL;
	c->next_packetid = 1;
   2072a:	2301      	movs	r3, #1
        c->messageHandlers[i].topicFilter = 0;
   2072c:	62c1      	str	r1, [r0, #44]	; 0x2c
	c->next_packetid = 1;
   2072e:	6003      	str	r3, [r0, #0]
        c->messageHandlers[i].topicFilter = 0;
   20730:	6341      	str	r1, [r0, #52]	; 0x34
   20732:	63c1      	str	r1, [r0, #60]	; 0x3c
   20734:	6441      	str	r1, [r0, #68]	; 0x44
    c->command_timeout_ms = command_timeout_ms;
   20736:	6042      	str	r2, [r0, #4]
    c->isconnected = 0;
   20738:	6201      	str	r1, [r0, #32]
    c->ping_outstanding = 0;
   2073a:	7701      	strb	r1, [r0, #28]
    c->defaultMessageHandler = NULL;
   2073c:	64c1      	str	r1, [r0, #76]	; 0x4c
    TimerInit(&c->ping_timer);
   2073e:	4b02      	ldr	r3, [pc, #8]	; (20748 <MQTTClientInit+0x34>)
   20740:	3054      	adds	r0, #84	; 0x54
   20742:	4798      	blx	r3
#if defined(MQTT_TASK)
	MutexInit(&c->mutex);
#endif
}
   20744:	bd10      	pop	{r4, pc}
   20746:	46c0      	nop			; (mov r8, r8)
   20748:	00020f29 	.word	0x00020f29

0002074c <deliverMessage>:
    return (curn == curn_end) && (*curf == '\0');
}


int deliverMessage(MQTTClient* c, MQTTString* topicName, MQTTMessage* message)
{
   2074c:	0003      	movs	r3, r0
   2074e:	b5f0      	push	{r4, r5, r6, r7, lr}
   20750:	0004      	movs	r4, r0
    int i;
    int rc = FAILURE;
   20752:	2501      	movs	r5, #1
{
   20754:	0007      	movs	r7, r0
   20756:	000e      	movs	r6, r1
   20758:	b087      	sub	sp, #28
   2075a:	334c      	adds	r3, #76	; 0x4c
   2075c:	9201      	str	r2, [sp, #4]
   2075e:	3424      	adds	r4, #36	; 0x24
   20760:	9302      	str	r3, [sp, #8]
    int rc = FAILURE;
   20762:	426d      	negs	r5, r5

    // we have to find the right message handler - indexed by topic
    for (i = 0; i < MAX_MESSAGE_HANDLERS; ++i)
    {
        if (c->messageHandlers[i].topicFilter != 0 && (MQTTPacket_equals(topicName, (char*)c->messageHandlers[i].topicFilter) ||
   20764:	6821      	ldr	r1, [r4, #0]
   20766:	2900      	cmp	r1, #0
   20768:	d037      	beq.n	207da <deliverMessage+0x8e>
   2076a:	0030      	movs	r0, r6
   2076c:	4b24      	ldr	r3, [pc, #144]	; (20800 <deliverMessage+0xb4>)
   2076e:	4798      	blx	r3
   20770:	2800      	cmp	r0, #0
   20772:	d10c      	bne.n	2078e <deliverMessage+0x42>
    char* curn = topicName->lenstring.data;
   20774:	68b3      	ldr	r3, [r6, #8]
    char* curn_end = curn + topicName->lenstring.len;
   20776:	6872      	ldr	r2, [r6, #4]
    char* curf = topicFilter;
   20778:	6821      	ldr	r1, [r4, #0]
    char* curn_end = curn + topicName->lenstring.len;
   2077a:	189a      	adds	r2, r3, r2
    char* curf = topicFilter;
   2077c:	9100      	str	r1, [sp, #0]
   2077e:	1e51      	subs	r1, r2, #1
   20780:	9103      	str	r1, [sp, #12]
    while (*curf && curn < curn_end)
   20782:	9900      	ldr	r1, [sp, #0]
   20784:	7809      	ldrb	r1, [r1, #0]
   20786:	2900      	cmp	r1, #0
   20788:	d120      	bne.n	207cc <deliverMessage+0x80>
    return (curn == curn_end) && (*curf == '\0');
   2078a:	429a      	cmp	r2, r3
   2078c:	d125      	bne.n	207da <deliverMessage+0x8e>
                isTopicMatched((char*)c->messageHandlers[i].topicFilter, topicName)))
        {
            if (c->messageHandlers[i].fp != NULL)
   2078e:	6863      	ldr	r3, [r4, #4]
   20790:	2b00      	cmp	r3, #0
   20792:	d022      	beq.n	207da <deliverMessage+0x8e>
    md->message = aMessage;
   20794:	9a01      	ldr	r2, [sp, #4]
    md->topicName = aTopicName;
   20796:	9605      	str	r6, [sp, #20]
    md->message = aMessage;
   20798:	9204      	str	r2, [sp, #16]
            {
                MessageData md;
                NewMessageData(&md, topicName, message);
                c->messageHandlers[i].fp(&md);
   2079a:	a804      	add	r0, sp, #16
   2079c:	4798      	blx	r3
                rc = SUCCESS;
   2079e:	2500      	movs	r5, #0
   207a0:	e01b      	b.n	207da <deliverMessage+0x8e>
        if (*curf != '+' && *curf != '#' && *curf != *curn)
   207a2:	292b      	cmp	r1, #43	; 0x2b
   207a4:	d009      	beq.n	207ba <deliverMessage+0x6e>
   207a6:	2923      	cmp	r1, #35	; 0x23
   207a8:	d00e      	beq.n	207c8 <deliverMessage+0x7c>
   207aa:	4288      	cmp	r0, r1
   207ac:	d115      	bne.n	207da <deliverMessage+0x8e>
        curf++;
   207ae:	9900      	ldr	r1, [sp, #0]
        curn++;
   207b0:	3301      	adds	r3, #1
        curf++;
   207b2:	3101      	adds	r1, #1
   207b4:	9100      	str	r1, [sp, #0]
   207b6:	e7e4      	b.n	20782 <deliverMessage+0x36>
                nextpos = ++curn + 1;
   207b8:	3301      	adds	r3, #1
            while (nextpos < curn_end && *nextpos != '/')
   207ba:	9903      	ldr	r1, [sp, #12]
   207bc:	428b      	cmp	r3, r1
   207be:	d0f6      	beq.n	207ae <deliverMessage+0x62>
   207c0:	7859      	ldrb	r1, [r3, #1]
   207c2:	292f      	cmp	r1, #47	; 0x2f
   207c4:	d1f8      	bne.n	207b8 <deliverMessage+0x6c>
   207c6:	e7f2      	b.n	207ae <deliverMessage+0x62>
            curn = curn_end - 1;    // skip until end of string
   207c8:	1e53      	subs	r3, r2, #1
   207ca:	e7f0      	b.n	207ae <deliverMessage+0x62>
    while (*curf && curn < curn_end)
   207cc:	429a      	cmp	r2, r3
   207ce:	d904      	bls.n	207da <deliverMessage+0x8e>
        if (*curn == '/' && *curf != '/')
   207d0:	7818      	ldrb	r0, [r3, #0]
   207d2:	282f      	cmp	r0, #47	; 0x2f
   207d4:	d1e5      	bne.n	207a2 <deliverMessage+0x56>
   207d6:	292f      	cmp	r1, #47	; 0x2f
   207d8:	d0e9      	beq.n	207ae <deliverMessage+0x62>
    for (i = 0; i < MAX_MESSAGE_HANDLERS; ++i)
   207da:	9b02      	ldr	r3, [sp, #8]
   207dc:	3408      	adds	r4, #8
   207de:	42a3      	cmp	r3, r4
   207e0:	d1c0      	bne.n	20764 <deliverMessage+0x18>
            }
        }
    }
    
    if (rc == FAILURE && c->defaultMessageHandler != NULL) 
   207e2:	1c6b      	adds	r3, r5, #1
   207e4:	d107      	bne.n	207f6 <deliverMessage+0xaa>
   207e6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   207e8:	2b00      	cmp	r3, #0
   207ea:	d005      	beq.n	207f8 <deliverMessage+0xac>
    md->message = aMessage;
   207ec:	9a01      	ldr	r2, [sp, #4]
    md->topicName = aTopicName;
   207ee:	9605      	str	r6, [sp, #20]
    md->message = aMessage;
   207f0:	9204      	str	r2, [sp, #16]
    {
        MessageData md;
        NewMessageData(&md, topicName, message);
        c->defaultMessageHandler(&md);
   207f2:	a804      	add	r0, sp, #16
   207f4:	4798      	blx	r3
   207f6:	2500      	movs	r5, #0
        rc = SUCCESS;
    }   
    
    return rc;
}
   207f8:	0028      	movs	r0, r5
   207fa:	b007      	add	sp, #28
   207fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   207fe:	46c0      	nop			; (mov r8, r8)
   20800:	00021755 	.word	0x00021755

00020804 <keepalive>:


int keepalive(MQTTClient* c)
{
   20804:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   20806:	0004      	movs	r4, r0
    int rc = FAILURE;

    if (c->keepAliveInterval == 0)
    {
        rc = SUCCESS;
   20808:	2000      	movs	r0, #0
    if (c->keepAliveInterval == 0)
   2080a:	69a3      	ldr	r3, [r4, #24]
   2080c:	4283      	cmp	r3, r0
   2080e:	d01e      	beq.n	2084e <keepalive+0x4a>
        goto exit;
    }

    if (TimerIsExpired(&c->ping_timer))
   20810:	0020      	movs	r0, r4
   20812:	4b11      	ldr	r3, [pc, #68]	; (20858 <keepalive+0x54>)
   20814:	3054      	adds	r0, #84	; 0x54
   20816:	4798      	blx	r3
   20818:	2800      	cmp	r0, #0
   2081a:	d01a      	beq.n	20852 <keepalive+0x4e>
    {
        if (!c->ping_outstanding)
   2081c:	7f23      	ldrb	r3, [r4, #28]
   2081e:	2b00      	cmp	r3, #0
   20820:	d117      	bne.n	20852 <keepalive+0x4e>
        {
            Timer timer;
            TimerInit(&timer);
   20822:	a801      	add	r0, sp, #4
   20824:	4b0d      	ldr	r3, [pc, #52]	; (2085c <keepalive+0x58>)
   20826:	4798      	blx	r3
            TimerCountdownMS(&timer, 1000);
   20828:	21fa      	movs	r1, #250	; 0xfa
   2082a:	a801      	add	r0, sp, #4
   2082c:	0089      	lsls	r1, r1, #2
   2082e:	4b0c      	ldr	r3, [pc, #48]	; (20860 <keepalive+0x5c>)
   20830:	4798      	blx	r3
            int len = MQTTSerialize_pingreq(c->buf, c->buf_size);
   20832:	68a1      	ldr	r1, [r4, #8]
   20834:	6920      	ldr	r0, [r4, #16]
   20836:	4b0b      	ldr	r3, [pc, #44]	; (20864 <keepalive+0x60>)
   20838:	4798      	blx	r3
   2083a:	1e01      	subs	r1, r0, #0
            if (len > 0 && (rc = sendPacket(c, len, &timer)) == SUCCESS) // send the ping packet
   2083c:	dd09      	ble.n	20852 <keepalive+0x4e>
   2083e:	aa01      	add	r2, sp, #4
   20840:	0020      	movs	r0, r4
   20842:	4b09      	ldr	r3, [pc, #36]	; (20868 <keepalive+0x64>)
   20844:	4798      	blx	r3
   20846:	2800      	cmp	r0, #0
   20848:	d101      	bne.n	2084e <keepalive+0x4a>
                c->ping_outstanding = 1;
   2084a:	2301      	movs	r3, #1
   2084c:	7723      	strb	r3, [r4, #28]
        }
    }

exit:
    return rc;
}
   2084e:	b004      	add	sp, #16
   20850:	bd10      	pop	{r4, pc}
    int rc = FAILURE;
   20852:	2001      	movs	r0, #1
   20854:	4240      	negs	r0, r0
    return rc;
   20856:	e7fa      	b.n	2084e <keepalive+0x4a>
   20858:	00020ed9 	.word	0x00020ed9
   2085c:	00020f29 	.word	0x00020f29
   20860:	00020ef1 	.word	0x00020ef1
   20864:	00021451 	.word	0x00021451
   20868:	000206ad 	.word	0x000206ad

0002086c <cycle>:


int cycle(MQTTClient* c, Timer* timer)
{
   2086c:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (c->ipstack->mqttread(c->ipstack, c->readbuf, 1, TimerLeftMS(timer)) != 1)
   2086e:	6d05      	ldr	r5, [r0, #80]	; 0x50
{
   20870:	b093      	sub	sp, #76	; 0x4c
    if (c->ipstack->mqttread(c->ipstack, c->readbuf, 1, TimerLeftMS(timer)) != 1)
   20872:	6947      	ldr	r7, [r0, #20]
   20874:	4b61      	ldr	r3, [pc, #388]	; (209fc <cycle+0x190>)
{
   20876:	0004      	movs	r4, r0
    if (c->ipstack->mqttread(c->ipstack, c->readbuf, 1, TimerLeftMS(timer)) != 1)
   20878:	0008      	movs	r0, r1
   2087a:	68ae      	ldr	r6, [r5, #8]
{
   2087c:	9107      	str	r1, [sp, #28]
    if (c->ipstack->mqttread(c->ipstack, c->readbuf, 1, TimerLeftMS(timer)) != 1)
   2087e:	4798      	blx	r3
   20880:	2201      	movs	r2, #1
   20882:	0003      	movs	r3, r0
   20884:	0039      	movs	r1, r7
   20886:	0028      	movs	r0, r5
   20888:	47b0      	blx	r6
   2088a:	0006      	movs	r6, r0
   2088c:	2801      	cmp	r0, #1
   2088e:	d04b      	beq.n	20928 <cycle+0xbc>
    int rc = FAILURE;
   20890:	2301      	movs	r3, #1
   20892:	425b      	negs	r3, r3
   20894:	b29f      	uxth	r7, r3
    unsigned short packet_type = readPacket(c, timer);
    
    int len = 0,
        rc = SUCCESS;

    switch (packet_type)
   20896:	2f05      	cmp	r7, #5
   20898:	d100      	bne.n	2089c <cycle+0x30>
   2089a:	e08d      	b.n	209b8 <cycle+0x14c>
   2089c:	2f0d      	cmp	r7, #13
   2089e:	d100      	bne.n	208a2 <cycle+0x36>
   208a0:	e0a6      	b.n	209f0 <cycle+0x184>
   208a2:	2f03      	cmp	r7, #3
   208a4:	d000      	beq.n	208a8 <cycle+0x3c>
   208a6:	e0a6      	b.n	209f6 <cycle+0x18a>
        case PUBLISH:
        {
            MQTTString topicName;
            MQTTMessage msg;
            int intQoS;
            if (MQTTDeserialize_publish(&msg.dup, &intQoS, &msg.retained, &msg.id, &topicName,
   208a8:	2229      	movs	r2, #41	; 0x29
   208aa:	202a      	movs	r0, #42	; 0x2a
   208ac:	68e3      	ldr	r3, [r4, #12]
   208ae:	a904      	add	r1, sp, #16
   208b0:	9304      	str	r3, [sp, #16]
   208b2:	6963      	ldr	r3, [r4, #20]
   208b4:	ae04      	add	r6, sp, #16
   208b6:	9303      	str	r3, [sp, #12]
   208b8:	ab11      	add	r3, sp, #68	; 0x44
   208ba:	9302      	str	r3, [sp, #8]
   208bc:	ab10      	add	r3, sp, #64	; 0x40
   208be:	9301      	str	r3, [sp, #4]
   208c0:	ab0b      	add	r3, sp, #44	; 0x2c
   208c2:	9300      	str	r3, [sp, #0]
   208c4:	1852      	adds	r2, r2, r1
   208c6:	1980      	adds	r0, r0, r6
   208c8:	ab0f      	add	r3, sp, #60	; 0x3c
   208ca:	a90a      	add	r1, sp, #40	; 0x28
   208cc:	4e4c      	ldr	r6, [pc, #304]	; (20a00 <cycle+0x194>)
   208ce:	ad0e      	add	r5, sp, #56	; 0x38
   208d0:	47b0      	blx	r6
   208d2:	2801      	cmp	r0, #1
   208d4:	d124      	bne.n	20920 <cycle+0xb4>
               (unsigned char**)&msg.payload, (int*)&msg.payloadlen, c->readbuf, c->readbuf_size) != 1)
                goto exit;
            msg.qos = (enum QoS)intQoS;
   208d6:	ab04      	add	r3, sp, #16
   208d8:	7e1b      	ldrb	r3, [r3, #24]
            deliverMessage(c, &topicName, &msg);
   208da:	002a      	movs	r2, r5
            msg.qos = (enum QoS)intQoS;
   208dc:	702b      	strb	r3, [r5, #0]
            deliverMessage(c, &topicName, &msg);
   208de:	a90b      	add	r1, sp, #44	; 0x2c
   208e0:	4b48      	ldr	r3, [pc, #288]	; (20a04 <cycle+0x198>)
   208e2:	0020      	movs	r0, r4
   208e4:	4798      	blx	r3
            if (msg.qos != QOS0)
   208e6:	782b      	ldrb	r3, [r5, #0]
   208e8:	2b00      	cmp	r3, #0
   208ea:	d100      	bne.n	208ee <cycle+0x82>
   208ec:	e083      	b.n	209f6 <cycle+0x18a>
            {
                if (msg.qos == QOS1)
   208ee:	2b01      	cmp	r3, #1
   208f0:	d158      	bne.n	209a4 <cycle+0x138>
                    len = MQTTSerialize_ack(c->buf, c->buf_size, PUBACK, 0, msg.id);
   208f2:	88ab      	ldrh	r3, [r5, #4]
   208f4:	2204      	movs	r2, #4
   208f6:	9300      	str	r3, [sp, #0]
   208f8:	2300      	movs	r3, #0
                else if (msg.qos == QOS2)
                    len = MQTTSerialize_ack(c->buf, c->buf_size, PUBREC, 0, msg.id);
   208fa:	68a1      	ldr	r1, [r4, #8]
   208fc:	6920      	ldr	r0, [r4, #16]
   208fe:	4d42      	ldr	r5, [pc, #264]	; (20a08 <cycle+0x19c>)
   20900:	47a8      	blx	r5
                if (len <= 0)
   20902:	2800      	cmp	r0, #0
   20904:	dd50      	ble.n	209a8 <cycle+0x13c>
                    rc = FAILURE;
                else
                    rc = sendPacket(c, len, timer);
   20906:	0001      	movs	r1, r0
   20908:	9a07      	ldr	r2, [sp, #28]
   2090a:	0020      	movs	r0, r4
   2090c:	4b3f      	ldr	r3, [pc, #252]	; (20a0c <cycle+0x1a0>)
   2090e:	4798      	blx	r3
   20910:	0005      	movs	r5, r0
                if (rc == FAILURE)
   20912:	1c43      	adds	r3, r0, #1
   20914:	d048      	beq.n	209a8 <cycle+0x13c>
            break;
        case PINGRESP:
            c->ping_outstanding = 0;
            break;
    }
    keepalive(c);
   20916:	0020      	movs	r0, r4
   20918:	4b3d      	ldr	r3, [pc, #244]	; (20a10 <cycle+0x1a4>)
   2091a:	4798      	blx	r3
exit:
    if (rc == SUCCESS)
   2091c:	2d00      	cmp	r5, #0
   2091e:	d100      	bne.n	20922 <cycle+0xb6>
   20920:	003d      	movs	r5, r7
        rc = packet_type;
    return rc;
}
   20922:	0028      	movs	r0, r5
   20924:	b013      	add	sp, #76	; 0x4c
   20926:	bdf0      	pop	{r4, r5, r6, r7, pc}
    decodePacket(c, &rem_len, TimerLeftMS(timer));
   20928:	4b34      	ldr	r3, [pc, #208]	; (209fc <cycle+0x190>)
   2092a:	9807      	ldr	r0, [sp, #28]
   2092c:	4798      	blx	r3
   2092e:	2305      	movs	r3, #5
    *value = 0;
   20930:	2700      	movs	r7, #0
    decodePacket(c, &rem_len, TimerLeftMS(timer));
   20932:	9009      	str	r0, [sp, #36]	; 0x24
   20934:	9308      	str	r3, [sp, #32]
   20936:	9b08      	ldr	r3, [sp, #32]
   20938:	3b01      	subs	r3, #1
   2093a:	9308      	str	r3, [sp, #32]
        if (++len > MAX_NO_OF_REMAINING_LENGTH_BYTES)
   2093c:	2b00      	cmp	r3, #0
   2093e:	d014      	beq.n	2096a <cycle+0xfe>
        rc = c->ipstack->mqttread(c->ipstack, &i, 1, timeout);
   20940:	6d20      	ldr	r0, [r4, #80]	; 0x50
   20942:	2201      	movs	r2, #1
   20944:	6883      	ldr	r3, [r0, #8]
   20946:	a90e      	add	r1, sp, #56	; 0x38
   20948:	001d      	movs	r5, r3
   2094a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   2094c:	47a8      	blx	r5
        if (rc != 1)
   2094e:	2801      	cmp	r0, #1
   20950:	d10b      	bne.n	2096a <cycle+0xfe>
        *value += (i & 127) * multiplier;
   20952:	2228      	movs	r2, #40	; 0x28
   20954:	ab04      	add	r3, sp, #16
   20956:	189b      	adds	r3, r3, r2
   20958:	781b      	ldrb	r3, [r3, #0]
   2095a:	3257      	adds	r2, #87	; 0x57
   2095c:	401a      	ands	r2, r3
   2095e:	4372      	muls	r2, r6
    } while ((i & 128) != 0);
   20960:	b25b      	sxtb	r3, r3
        *value += (i & 127) * multiplier;
   20962:	18bf      	adds	r7, r7, r2
        multiplier *= 128;
   20964:	01f6      	lsls	r6, r6, #7
    } while ((i & 128) != 0);
   20966:	2b00      	cmp	r3, #0
   20968:	dbe5      	blt.n	20936 <cycle+0xca>
    len += MQTTPacket_encode(c->readbuf + 1, rem_len); /* put the original remaining length back into the buffer */
   2096a:	6963      	ldr	r3, [r4, #20]
   2096c:	0039      	movs	r1, r7
   2096e:	1c58      	adds	r0, r3, #1
   20970:	4b28      	ldr	r3, [pc, #160]	; (20a14 <cycle+0x1a8>)
   20972:	4798      	blx	r3
    if (rem_len > 0 && (c->ipstack->mqttread(c->ipstack, c->readbuf + len, rem_len, TimerLeftMS(timer)) != rem_len))
   20974:	2f00      	cmp	r7, #0
   20976:	dc03      	bgt.n	20980 <cycle+0x114>
    header.byte = c->readbuf[0];
   20978:	6963      	ldr	r3, [r4, #20]
   2097a:	781b      	ldrb	r3, [r3, #0]
    rc = header.bits.type;
   2097c:	091b      	lsrs	r3, r3, #4
   2097e:	e789      	b.n	20894 <cycle+0x28>
    if (rem_len > 0 && (c->ipstack->mqttread(c->ipstack, c->readbuf + len, rem_len, TimerLeftMS(timer)) != rem_len))
   20980:	6d26      	ldr	r6, [r4, #80]	; 0x50
    len += MQTTPacket_encode(c->readbuf + 1, rem_len); /* put the original remaining length back into the buffer */
   20982:	1c45      	adds	r5, r0, #1
    if (rem_len > 0 && (c->ipstack->mqttread(c->ipstack, c->readbuf + len, rem_len, TimerLeftMS(timer)) != rem_len))
   20984:	68b3      	ldr	r3, [r6, #8]
   20986:	9807      	ldr	r0, [sp, #28]
   20988:	9308      	str	r3, [sp, #32]
   2098a:	6963      	ldr	r3, [r4, #20]
   2098c:	195d      	adds	r5, r3, r5
   2098e:	4b1b      	ldr	r3, [pc, #108]	; (209fc <cycle+0x190>)
   20990:	4798      	blx	r3
   20992:	0029      	movs	r1, r5
   20994:	0003      	movs	r3, r0
   20996:	003a      	movs	r2, r7
   20998:	0030      	movs	r0, r6
   2099a:	9d08      	ldr	r5, [sp, #32]
   2099c:	47a8      	blx	r5
   2099e:	42b8      	cmp	r0, r7
   209a0:	d0ea      	beq.n	20978 <cycle+0x10c>
   209a2:	e775      	b.n	20890 <cycle+0x24>
                else if (msg.qos == QOS2)
   209a4:	2b02      	cmp	r3, #2
   209a6:	d002      	beq.n	209ae <cycle+0x142>
   209a8:	2501      	movs	r5, #1
   209aa:	426d      	negs	r5, r5
   209ac:	e7b9      	b.n	20922 <cycle+0xb6>
                    len = MQTTSerialize_ack(c->buf, c->buf_size, PUBREC, 0, msg.id);
   209ae:	88ab      	ldrh	r3, [r5, #4]
   209b0:	2205      	movs	r2, #5
   209b2:	9300      	str	r3, [sp, #0]
   209b4:	2300      	movs	r3, #0
   209b6:	e7a0      	b.n	208fa <cycle+0x8e>
            if (MQTTDeserialize_ack(&type, &dup, &mypacketid, c->readbuf, c->readbuf_size) != 1)
   209b8:	68e3      	ldr	r3, [r4, #12]
   209ba:	ad0e      	add	r5, sp, #56	; 0x38
   209bc:	9300      	str	r3, [sp, #0]
   209be:	002a      	movs	r2, r5
   209c0:	6963      	ldr	r3, [r4, #20]
   209c2:	a90a      	add	r1, sp, #40	; 0x28
   209c4:	a80b      	add	r0, sp, #44	; 0x2c
   209c6:	4e14      	ldr	r6, [pc, #80]	; (20a18 <cycle+0x1ac>)
   209c8:	47b0      	blx	r6
   209ca:	2801      	cmp	r0, #1
   209cc:	d1ec      	bne.n	209a8 <cycle+0x13c>
            else if ((len = MQTTSerialize_ack(c->buf, c->buf_size, PUBREL, 0, mypacketid)) <= 0)
   209ce:	882b      	ldrh	r3, [r5, #0]
   209d0:	68a1      	ldr	r1, [r4, #8]
   209d2:	9300      	str	r3, [sp, #0]
   209d4:	2206      	movs	r2, #6
   209d6:	2300      	movs	r3, #0
   209d8:	6920      	ldr	r0, [r4, #16]
   209da:	4d0b      	ldr	r5, [pc, #44]	; (20a08 <cycle+0x19c>)
   209dc:	47a8      	blx	r5
   209de:	1e01      	subs	r1, r0, #0
   209e0:	dde2      	ble.n	209a8 <cycle+0x13c>
            else if ((rc = sendPacket(c, len, timer)) != SUCCESS) // send the PUBREL packet
   209e2:	9a07      	ldr	r2, [sp, #28]
   209e4:	0020      	movs	r0, r4
   209e6:	4b09      	ldr	r3, [pc, #36]	; (20a0c <cycle+0x1a0>)
   209e8:	4798      	blx	r3
   209ea:	1e05      	subs	r5, r0, #0
   209ec:	d1dc      	bne.n	209a8 <cycle+0x13c>
   209ee:	e792      	b.n	20916 <cycle+0xaa>
            c->ping_outstanding = 0;
   209f0:	2500      	movs	r5, #0
   209f2:	7725      	strb	r5, [r4, #28]
            break;
   209f4:	e78f      	b.n	20916 <cycle+0xaa>
        rc = SUCCESS;
   209f6:	2500      	movs	r5, #0
   209f8:	e78d      	b.n	20916 <cycle+0xaa>
   209fa:	46c0      	nop			; (mov r8, r8)
   209fc:	00020f15 	.word	0x00020f15
   20a00:	00021461 	.word	0x00021461
   20a04:	0002074d 	.word	0x0002074d
   20a08:	0002186d 	.word	0x0002186d
   20a0c:	000206ad 	.word	0x000206ad
   20a10:	00020805 	.word	0x00020805
   20a14:	0002156d 	.word	0x0002156d
   20a18:	000214f1 	.word	0x000214f1

00020a1c <MQTTYield>:


int MQTTYield(MQTTClient* c, int timeout_ms)
{
   20a1c:	b530      	push	{r4, r5, lr}
   20a1e:	000d      	movs	r5, r1
   20a20:	b085      	sub	sp, #20
    int rc = SUCCESS;
    Timer timer;

    TimerInit(&timer);
   20a22:	4b0b      	ldr	r3, [pc, #44]	; (20a50 <MQTTYield+0x34>)
{
   20a24:	0004      	movs	r4, r0
    TimerInit(&timer);
   20a26:	a801      	add	r0, sp, #4
   20a28:	4798      	blx	r3
    TimerCountdownMS(&timer, timeout_ms);
   20a2a:	0029      	movs	r1, r5
   20a2c:	a801      	add	r0, sp, #4
   20a2e:	4b09      	ldr	r3, [pc, #36]	; (20a54 <MQTTYield+0x38>)
   20a30:	4798      	blx	r3

	do
    {
        if (cycle(c, &timer) == FAILURE)
   20a32:	4b09      	ldr	r3, [pc, #36]	; (20a58 <MQTTYield+0x3c>)
   20a34:	a901      	add	r1, sp, #4
   20a36:	0020      	movs	r0, r4
   20a38:	4798      	blx	r3
   20a3a:	1c43      	adds	r3, r0, #1
   20a3c:	d005      	beq.n	20a4a <MQTTYield+0x2e>
        {
            rc = FAILURE;
            break;
        }
	} while (!TimerIsExpired(&timer));
   20a3e:	a801      	add	r0, sp, #4
   20a40:	4b06      	ldr	r3, [pc, #24]	; (20a5c <MQTTYield+0x40>)
   20a42:	4798      	blx	r3
   20a44:	2800      	cmp	r0, #0
   20a46:	d0f4      	beq.n	20a32 <MQTTYield+0x16>
    int rc = SUCCESS;
   20a48:	2000      	movs	r0, #0
        
    return rc;
}
   20a4a:	b005      	add	sp, #20
   20a4c:	bd30      	pop	{r4, r5, pc}
   20a4e:	46c0      	nop			; (mov r8, r8)
   20a50:	00020f29 	.word	0x00020f29
   20a54:	00020ef1 	.word	0x00020ef1
   20a58:	0002086d 	.word	0x0002086d
   20a5c:	00020ed9 	.word	0x00020ed9

00020a60 <waitfor>:
}
#endif


int waitfor(MQTTClient* c, int packet_type, Timer* timer)
{
   20a60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int rc = FAILURE;
   20a62:	2401      	movs	r4, #1
{
   20a64:	0007      	movs	r7, r0
   20a66:	000e      	movs	r6, r1
   20a68:	0015      	movs	r5, r2
    int rc = FAILURE;
   20a6a:	4264      	negs	r4, r4
    
    do
    {
        if (TimerIsExpired(timer))
   20a6c:	0028      	movs	r0, r5
   20a6e:	4b06      	ldr	r3, [pc, #24]	; (20a88 <waitfor+0x28>)
   20a70:	4798      	blx	r3
   20a72:	2800      	cmp	r0, #0
   20a74:	d106      	bne.n	20a84 <waitfor+0x24>
            break; // we timed out
    }
    while ((rc = cycle(c, timer)) != packet_type);  
   20a76:	0029      	movs	r1, r5
   20a78:	0038      	movs	r0, r7
   20a7a:	4b04      	ldr	r3, [pc, #16]	; (20a8c <waitfor+0x2c>)
   20a7c:	4798      	blx	r3
   20a7e:	0004      	movs	r4, r0
   20a80:	42b0      	cmp	r0, r6
   20a82:	d1f3      	bne.n	20a6c <waitfor+0xc>
    
    return rc;
}
   20a84:	0020      	movs	r0, r4
   20a86:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   20a88:	00020ed9 	.word	0x00020ed9
   20a8c:	0002086d 	.word	0x0002086d

00020a90 <MQTTConnect>:


int MQTTConnect(MQTTClient* c, MQTTPacket_connectData* options)
{
   20a90:	b570      	push	{r4, r5, r6, lr}
   20a92:	0004      	movs	r4, r0
   20a94:	b09a      	sub	sp, #104	; 0x68
    Timer connect_timer;
    int rc = FAILURE;
    MQTTPacket_connectData default_options = MQTTPacket_connectData_initializer;
   20a96:	4b22      	ldr	r3, [pc, #136]	; (20b20 <MQTTConnect+0x90>)
{
   20a98:	000d      	movs	r5, r1
    MQTTPacket_connectData default_options = MQTTPacket_connectData_initializer;
   20a9a:	2258      	movs	r2, #88	; 0x58
   20a9c:	4921      	ldr	r1, [pc, #132]	; (20b24 <MQTTConnect+0x94>)
   20a9e:	a804      	add	r0, sp, #16
   20aa0:	4798      	blx	r3
    int len = 0;

#if defined(MQTT_TASK)
	MutexLock(&c->mutex);
#endif
	if (c->isconnected) /* don't send connect packet again if we are already connected */
   20aa2:	6a23      	ldr	r3, [r4, #32]
   20aa4:	2b00      	cmp	r3, #0
   20aa6:	d002      	beq.n	20aae <MQTTConnect+0x1e>
        unsigned char connack_rc = 255;
        unsigned char sessionPresent = 0;
        if (MQTTDeserialize_connack(&sessionPresent, &connack_rc, c->readbuf, c->readbuf_size) == 1)
            rc = connack_rc;
        else
            rc = FAILURE;
   20aa8:	2501      	movs	r5, #1
   20aaa:	426d      	negs	r5, r5
   20aac:	e035      	b.n	20b1a <MQTTConnect+0x8a>
    TimerInit(&connect_timer);
   20aae:	a801      	add	r0, sp, #4
   20ab0:	4b1d      	ldr	r3, [pc, #116]	; (20b28 <MQTTConnect+0x98>)
   20ab2:	4798      	blx	r3
    TimerCountdownMS(&connect_timer, c->command_timeout_ms);
   20ab4:	6861      	ldr	r1, [r4, #4]
   20ab6:	a801      	add	r0, sp, #4
   20ab8:	4b1c      	ldr	r3, [pc, #112]	; (20b2c <MQTTConnect+0x9c>)
   20aba:	4798      	blx	r3
    if (options == 0)
   20abc:	2d00      	cmp	r5, #0
   20abe:	d100      	bne.n	20ac2 <MQTTConnect+0x32>
        options = &default_options; /* set default options if none were supplied */
   20ac0:	ad04      	add	r5, sp, #16
    TimerCountdown(&c->ping_timer, c->keepAliveInterval);
   20ac2:	0020      	movs	r0, r4
    c->keepAliveInterval = options->keepAliveInterval;
   20ac4:	8b29      	ldrh	r1, [r5, #24]
    TimerCountdown(&c->ping_timer, c->keepAliveInterval);
   20ac6:	3054      	adds	r0, #84	; 0x54
    c->keepAliveInterval = options->keepAliveInterval;
   20ac8:	61a1      	str	r1, [r4, #24]
    TimerCountdown(&c->ping_timer, c->keepAliveInterval);
   20aca:	4b19      	ldr	r3, [pc, #100]	; (20b30 <MQTTConnect+0xa0>)
   20acc:	4798      	blx	r3
    if ((len = MQTTSerialize_connect(c->buf, c->buf_size, options)) <= 0)
   20ace:	68a1      	ldr	r1, [r4, #8]
   20ad0:	002a      	movs	r2, r5
   20ad2:	6920      	ldr	r0, [r4, #16]
   20ad4:	4b17      	ldr	r3, [pc, #92]	; (20b34 <MQTTConnect+0xa4>)
   20ad6:	4798      	blx	r3
   20ad8:	1e01      	subs	r1, r0, #0
   20ada:	dde5      	ble.n	20aa8 <MQTTConnect+0x18>
    if ((rc = sendPacket(c, len, &connect_timer)) != SUCCESS)  // send the connect packet
   20adc:	aa01      	add	r2, sp, #4
   20ade:	0020      	movs	r0, r4
   20ae0:	4b15      	ldr	r3, [pc, #84]	; (20b38 <MQTTConnect+0xa8>)
   20ae2:	4798      	blx	r3
   20ae4:	1e05      	subs	r5, r0, #0
   20ae6:	d118      	bne.n	20b1a <MQTTConnect+0x8a>
    if (waitfor(c, CONNACK, &connect_timer) == CONNACK)
   20ae8:	aa01      	add	r2, sp, #4
   20aea:	2102      	movs	r1, #2
   20aec:	0020      	movs	r0, r4
   20aee:	4b13      	ldr	r3, [pc, #76]	; (20b3c <MQTTConnect+0xac>)
   20af0:	4798      	blx	r3
   20af2:	2802      	cmp	r0, #2
   20af4:	d1d8      	bne.n	20aa8 <MQTTConnect+0x18>
        unsigned char connack_rc = 255;
   20af6:	466b      	mov	r3, sp
   20af8:	1c9e      	adds	r6, r3, #2
   20afa:	23ff      	movs	r3, #255	; 0xff
   20afc:	7033      	strb	r3, [r6, #0]
        unsigned char sessionPresent = 0;
   20afe:	466b      	mov	r3, sp
   20b00:	1cd8      	adds	r0, r3, #3
   20b02:	7005      	strb	r5, [r0, #0]
        if (MQTTDeserialize_connack(&sessionPresent, &connack_rc, c->readbuf, c->readbuf_size) == 1)
   20b04:	68e3      	ldr	r3, [r4, #12]
   20b06:	6962      	ldr	r2, [r4, #20]
   20b08:	0031      	movs	r1, r6
   20b0a:	4d0d      	ldr	r5, [pc, #52]	; (20b40 <MQTTConnect+0xb0>)
   20b0c:	47a8      	blx	r5
   20b0e:	2801      	cmp	r0, #1
   20b10:	d1ca      	bne.n	20aa8 <MQTTConnect+0x18>
            rc = connack_rc;
   20b12:	7835      	ldrb	r5, [r6, #0]
    }
    else
        rc = FAILURE;
    
exit:
    if (rc == SUCCESS)
   20b14:	2d00      	cmp	r5, #0
   20b16:	d100      	bne.n	20b1a <MQTTConnect+0x8a>
        c->isconnected = 1;
   20b18:	6220      	str	r0, [r4, #32]
#if defined(MQTT_TASK)
	MutexUnlock(&c->mutex);
#endif

    return rc;
}
   20b1a:	0028      	movs	r0, r5
   20b1c:	b01a      	add	sp, #104	; 0x68
   20b1e:	bd70      	pop	{r4, r5, r6, pc}
   20b20:	00022c11 	.word	0x00022c11
   20b24:	0002b258 	.word	0x0002b258
   20b28:	00020f29 	.word	0x00020f29
   20b2c:	00020ef1 	.word	0x00020ef1
   20b30:	00020f01 	.word	0x00020f01
   20b34:	00021299 	.word	0x00021299
   20b38:	000206ad 	.word	0x000206ad
   20b3c:	00020a61 	.word	0x00020a61
   20b40:	000213c5 	.word	0x000213c5

00020b44 <MQTTSubscribe>:


int MQTTSubscribe(MQTTClient* c, const char* topicFilter, enum QoS qos, messageHandler msgHandler)
{ 
   20b44:	b5f0      	push	{r4, r5, r6, r7, lr}
   20b46:	b091      	sub	sp, #68	; 0x44
   20b48:	9305      	str	r3, [sp, #20]
    int rc = FAILURE;  
    Timer timer;
    int len = 0;
    MQTTString topic = MQTTString_initializer;
   20b4a:	2300      	movs	r3, #0
   20b4c:	ac0d      	add	r4, sp, #52	; 0x34
   20b4e:	6063      	str	r3, [r4, #4]
   20b50:	60a3      	str	r3, [r4, #8]
    topic.cstring = (char *)topicFilter;
    
#if defined(MQTT_TASK)
	MutexLock(&c->mutex);
#endif
	if (!c->isconnected)
   20b52:	6a03      	ldr	r3, [r0, #32]
{ 
   20b54:	0005      	movs	r5, r0
   20b56:	000e      	movs	r6, r1
	int Qoss = (int) qos;
   20b58:	9207      	str	r2, [sp, #28]
    topic.cstring = (char *)topicFilter;
   20b5a:	910d      	str	r1, [sp, #52]	; 0x34
	if (!c->isconnected)
   20b5c:	2b00      	cmp	r3, #0
   20b5e:	d104      	bne.n	20b6a <MQTTSubscribe+0x26>
    int rc = FAILURE;  
   20b60:	2401      	movs	r4, #1
   20b62:	4264      	negs	r4, r4
exit:
#if defined(MQTT_TASK)
	MutexUnlock(&c->mutex);
#endif
    return rc;
}
   20b64:	0020      	movs	r0, r4
   20b66:	b011      	add	sp, #68	; 0x44
   20b68:	bdf0      	pop	{r4, r5, r6, r7, pc}
    TimerInit(&timer);
   20b6a:	a80a      	add	r0, sp, #40	; 0x28
   20b6c:	4b25      	ldr	r3, [pc, #148]	; (20c04 <MQTTSubscribe+0xc0>)
   20b6e:	4798      	blx	r3
    TimerCountdownMS(&timer, c->command_timeout_ms);
   20b70:	6869      	ldr	r1, [r5, #4]
   20b72:	a80a      	add	r0, sp, #40	; 0x28
   20b74:	4b24      	ldr	r3, [pc, #144]	; (20c08 <MQTTSubscribe+0xc4>)
   20b76:	4798      	blx	r3
    return c->next_packetid = (c->next_packetid == MAX_PACKET_ID) ? 1 : c->next_packetid + 1;
   20b78:	4f24      	ldr	r7, [pc, #144]	; (20c0c <MQTTSubscribe+0xc8>)
   20b7a:	682a      	ldr	r2, [r5, #0]
	len = MQTTSerialize_subscribe(c->buf, c->buf_size, 0, getNextPacketId(c), 1, &topic, (int*)&Qoss);
   20b7c:	6928      	ldr	r0, [r5, #16]
   20b7e:	68a9      	ldr	r1, [r5, #8]
    return c->next_packetid = (c->next_packetid == MAX_PACKET_ID) ? 1 : c->next_packetid + 1;
   20b80:	2301      	movs	r3, #1
   20b82:	42ba      	cmp	r2, r7
   20b84:	d000      	beq.n	20b88 <MQTTSubscribe+0x44>
   20b86:	18d3      	adds	r3, r2, r3
	len = MQTTSerialize_subscribe(c->buf, c->buf_size, 0, getNextPacketId(c), 1, &topic, (int*)&Qoss);
   20b88:	2701      	movs	r7, #1
   20b8a:	aa07      	add	r2, sp, #28
    return c->next_packetid = (c->next_packetid == MAX_PACKET_ID) ? 1 : c->next_packetid + 1;
   20b8c:	602b      	str	r3, [r5, #0]
	len = MQTTSerialize_subscribe(c->buf, c->buf_size, 0, getNextPacketId(c), 1, &topic, (int*)&Qoss);
   20b8e:	9202      	str	r2, [sp, #8]
   20b90:	9401      	str	r4, [sp, #4]
   20b92:	b29b      	uxth	r3, r3
   20b94:	9700      	str	r7, [sp, #0]
   20b96:	2200      	movs	r2, #0
   20b98:	4c1d      	ldr	r4, [pc, #116]	; (20c10 <MQTTSubscribe+0xcc>)
   20b9a:	47a0      	blx	r4
   20b9c:	1e01      	subs	r1, r0, #0
    if (len <= 0)
   20b9e:	dddf      	ble.n	20b60 <MQTTSubscribe+0x1c>
    if ((rc = sendPacket(c, len, &timer)) != SUCCESS) // send the subscribe packet
   20ba0:	aa0a      	add	r2, sp, #40	; 0x28
   20ba2:	0028      	movs	r0, r5
   20ba4:	4b1b      	ldr	r3, [pc, #108]	; (20c14 <MQTTSubscribe+0xd0>)
   20ba6:	4798      	blx	r3
   20ba8:	1e04      	subs	r4, r0, #0
   20baa:	d1db      	bne.n	20b64 <MQTTSubscribe+0x20>
    if (waitfor(c, SUBACK, &timer) == SUBACK)      // wait for suback 
   20bac:	aa0a      	add	r2, sp, #40	; 0x28
   20bae:	2109      	movs	r1, #9
   20bb0:	0028      	movs	r0, r5
   20bb2:	4b19      	ldr	r3, [pc, #100]	; (20c18 <MQTTSubscribe+0xd4>)
   20bb4:	4798      	blx	r3
   20bb6:	2809      	cmp	r0, #9
   20bb8:	d1d2      	bne.n	20b60 <MQTTSubscribe+0x1c>
        int count = 0, grantedQoS = -1;
   20bba:	2301      	movs	r3, #1
   20bbc:	425b      	negs	r3, r3
   20bbe:	9309      	str	r3, [sp, #36]	; 0x24
        if (MQTTDeserialize_suback(&mypacketid, 1, &count, &grantedQoS, c->readbuf, c->readbuf_size) == 1)
   20bc0:	68eb      	ldr	r3, [r5, #12]
   20bc2:	0039      	movs	r1, r7
   20bc4:	9301      	str	r3, [sp, #4]
   20bc6:	696b      	ldr	r3, [r5, #20]
   20bc8:	af02      	add	r7, sp, #8
   20bca:	3009      	adds	r0, #9
   20bcc:	9300      	str	r3, [sp, #0]
   20bce:	19c0      	adds	r0, r0, r7
   20bd0:	ab09      	add	r3, sp, #36	; 0x24
   20bd2:	aa08      	add	r2, sp, #32
   20bd4:	4f11      	ldr	r7, [pc, #68]	; (20c1c <MQTTSubscribe+0xd8>)
        int count = 0, grantedQoS = -1;
   20bd6:	9408      	str	r4, [sp, #32]
        if (MQTTDeserialize_suback(&mypacketid, 1, &count, &grantedQoS, c->readbuf, c->readbuf_size) == 1)
   20bd8:	47b8      	blx	r7
   20bda:	2801      	cmp	r0, #1
   20bdc:	d102      	bne.n	20be4 <MQTTSubscribe+0xa0>
            rc = grantedQoS; // 0, 1, 2 or 0x80 
   20bde:	9c09      	ldr	r4, [sp, #36]	; 0x24
        if (rc != 0x80)
   20be0:	2c80      	cmp	r4, #128	; 0x80
   20be2:	d0bf      	beq.n	20b64 <MQTTSubscribe+0x20>
   20be4:	2200      	movs	r2, #0
   20be6:	00d3      	lsls	r3, r2, #3
   20be8:	18eb      	adds	r3, r5, r3
                if (c->messageHandlers[i].topicFilter == 0)
   20bea:	6a59      	ldr	r1, [r3, #36]	; 0x24
   20bec:	2900      	cmp	r1, #0
   20bee:	d104      	bne.n	20bfa <MQTTSubscribe+0xb6>
                    c->messageHandlers[i].fp = msgHandler;
   20bf0:	9a05      	ldr	r2, [sp, #20]
                    c->messageHandlers[i].topicFilter = topicFilter;
   20bf2:	625e      	str	r6, [r3, #36]	; 0x24
                    c->messageHandlers[i].fp = msgHandler;
   20bf4:	629a      	str	r2, [r3, #40]	; 0x28
                    rc = 0;
   20bf6:	000c      	movs	r4, r1
                    break;
   20bf8:	e7b4      	b.n	20b64 <MQTTSubscribe+0x20>
            for (i = 0; i < MAX_MESSAGE_HANDLERS; ++i)
   20bfa:	3201      	adds	r2, #1
   20bfc:	2a05      	cmp	r2, #5
   20bfe:	d1f2      	bne.n	20be6 <MQTTSubscribe+0xa2>
   20c00:	e7b0      	b.n	20b64 <MQTTSubscribe+0x20>
   20c02:	46c0      	nop			; (mov r8, r8)
   20c04:	00020f29 	.word	0x00020f29
   20c08:	00020ef1 	.word	0x00020ef1
   20c0c:	0000ffff 	.word	0x0000ffff
   20c10:	000218f9 	.word	0x000218f9
   20c14:	000206ad 	.word	0x000206ad
   20c18:	00020a61 	.word	0x00020a61
   20c1c:	00021999 	.word	0x00021999

00020c20 <MQTTPublish>:

int MQTTPublish(MQTTClient* c, const char* topicName, MQTTMessage* message)
{
    int rc = FAILURE;
    Timer timer;   
    MQTTString topic = MQTTString_initializer;
   20c20:	2300      	movs	r3, #0
{
   20c22:	b5f0      	push	{r4, r5, r6, r7, lr}
   20c24:	b091      	sub	sp, #68	; 0x44
    MQTTString topic = MQTTString_initializer;
   20c26:	ae0d      	add	r6, sp, #52	; 0x34
   20c28:	6073      	str	r3, [r6, #4]
   20c2a:	60b3      	str	r3, [r6, #8]
    int len = 0;

#if defined(MQTT_TASK)
	MutexLock(&c->mutex);
#endif
	if (!c->isconnected)
   20c2c:	6a03      	ldr	r3, [r0, #32]
{
   20c2e:	0004      	movs	r4, r0
   20c30:	0015      	movs	r5, r2
    topic.cstring = (char *)topicName;
   20c32:	910d      	str	r1, [sp, #52]	; 0x34
	if (!c->isconnected)
   20c34:	2b00      	cmp	r3, #0
   20c36:	d103      	bne.n	20c40 <MQTTPublish+0x20>
    int rc = FAILURE;
   20c38:	2001      	movs	r0, #1
    {
        if (waitfor(c, PUBCOMP, &timer) == PUBCOMP)
        {
            unsigned short mypacketid;
            unsigned char dup, type;
            if (MQTTDeserialize_ack(&type, &dup, &mypacketid, c->readbuf, c->readbuf_size) != 1)
   20c3a:	4240      	negs	r0, r0
exit:
#if defined(MQTT_TASK)
	MutexUnlock(&c->mutex);
#endif
    return rc;
}
   20c3c:	b011      	add	sp, #68	; 0x44
   20c3e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    TimerInit(&timer);
   20c40:	a80a      	add	r0, sp, #40	; 0x28
   20c42:	4b2a      	ldr	r3, [pc, #168]	; (20cec <MQTTPublish+0xcc>)
   20c44:	4798      	blx	r3
    TimerCountdownMS(&timer, c->command_timeout_ms);
   20c46:	4b2a      	ldr	r3, [pc, #168]	; (20cf0 <MQTTPublish+0xd0>)
   20c48:	6861      	ldr	r1, [r4, #4]
   20c4a:	a80a      	add	r0, sp, #40	; 0x28
   20c4c:	4798      	blx	r3
    if (message->qos == QOS1 || message->qos == QOS2)
   20c4e:	782b      	ldrb	r3, [r5, #0]
   20c50:	3b01      	subs	r3, #1
   20c52:	2b01      	cmp	r3, #1
   20c54:	d807      	bhi.n	20c66 <MQTTPublish+0x46>
    return c->next_packetid = (c->next_packetid == MAX_PACKET_ID) ? 1 : c->next_packetid + 1;
   20c56:	6822      	ldr	r2, [r4, #0]
   20c58:	4926      	ldr	r1, [pc, #152]	; (20cf4 <MQTTPublish+0xd4>)
   20c5a:	2301      	movs	r3, #1
   20c5c:	428a      	cmp	r2, r1
   20c5e:	d000      	beq.n	20c62 <MQTTPublish+0x42>
   20c60:	18d3      	adds	r3, r2, r3
   20c62:	6023      	str	r3, [r4, #0]
        message->id = getNextPacketId(c);
   20c64:	80ab      	strh	r3, [r5, #4]
    len = MQTTSerialize_publish(c->buf, c->buf_size, 0, message->qos, message->retained, message->id, 
   20c66:	68ea      	ldr	r2, [r5, #12]
   20c68:	782b      	ldrb	r3, [r5, #0]
   20c6a:	9206      	str	r2, [sp, #24]
   20c6c:	68aa      	ldr	r2, [r5, #8]
   20c6e:	9205      	str	r2, [sp, #20]
   20c70:	aa02      	add	r2, sp, #8
   20c72:	ce83      	ldmia	r6!, {r0, r1, r7}
   20c74:	c283      	stmia	r2!, {r0, r1, r7}
   20c76:	88aa      	ldrh	r2, [r5, #4]
   20c78:	4e1f      	ldr	r6, [pc, #124]	; (20cf8 <MQTTPublish+0xd8>)
   20c7a:	9201      	str	r2, [sp, #4]
   20c7c:	786a      	ldrb	r2, [r5, #1]
   20c7e:	9200      	str	r2, [sp, #0]
   20c80:	68a1      	ldr	r1, [r4, #8]
   20c82:	2200      	movs	r2, #0
   20c84:	6920      	ldr	r0, [r4, #16]
   20c86:	47b0      	blx	r6
   20c88:	1e01      	subs	r1, r0, #0
    if (len <= 0)
   20c8a:	ddd5      	ble.n	20c38 <MQTTPublish+0x18>
    if ((rc = sendPacket(c, len, &timer)) != SUCCESS) // send the subscribe packet
   20c8c:	aa0a      	add	r2, sp, #40	; 0x28
   20c8e:	0020      	movs	r0, r4
   20c90:	4b1a      	ldr	r3, [pc, #104]	; (20cfc <MQTTPublish+0xdc>)
   20c92:	4798      	blx	r3
   20c94:	2800      	cmp	r0, #0
   20c96:	d1d1      	bne.n	20c3c <MQTTPublish+0x1c>
    if (message->qos == QOS1)
   20c98:	782b      	ldrb	r3, [r5, #0]
   20c9a:	2b01      	cmp	r3, #1
   20c9c:	d114      	bne.n	20cc8 <MQTTPublish+0xa8>
        if (waitfor(c, PUBACK, &timer) == PUBACK)
   20c9e:	aa0a      	add	r2, sp, #40	; 0x28
   20ca0:	2104      	movs	r1, #4
   20ca2:	0020      	movs	r0, r4
   20ca4:	4b16      	ldr	r3, [pc, #88]	; (20d00 <MQTTPublish+0xe0>)
   20ca6:	4798      	blx	r3
   20ca8:	2804      	cmp	r0, #4
   20caa:	d1c5      	bne.n	20c38 <MQTTPublish+0x18>
            if (MQTTDeserialize_ack(&type, &dup, &mypacketid, c->readbuf, c->readbuf_size) != 1)
   20cac:	2226      	movs	r2, #38	; 0x26
   20cae:	68e3      	ldr	r3, [r4, #12]
   20cb0:	446a      	add	r2, sp
   20cb2:	9300      	str	r3, [sp, #0]
   20cb4:	6963      	ldr	r3, [r4, #20]
   20cb6:	a909      	add	r1, sp, #36	; 0x24
   20cb8:	3021      	adds	r0, #33	; 0x21
            if (MQTTDeserialize_ack(&type, &dup, &mypacketid, c->readbuf, c->readbuf_size) != 1)
   20cba:	4468      	add	r0, sp
   20cbc:	4c11      	ldr	r4, [pc, #68]	; (20d04 <MQTTPublish+0xe4>)
   20cbe:	47a0      	blx	r4
   20cc0:	3801      	subs	r0, #1
   20cc2:	1e43      	subs	r3, r0, #1
   20cc4:	4198      	sbcs	r0, r3
   20cc6:	e7b8      	b.n	20c3a <MQTTPublish+0x1a>
    else if (message->qos == QOS2)
   20cc8:	2b02      	cmp	r3, #2
   20cca:	d1b7      	bne.n	20c3c <MQTTPublish+0x1c>
        if (waitfor(c, PUBCOMP, &timer) == PUBCOMP)
   20ccc:	aa0a      	add	r2, sp, #40	; 0x28
   20cce:	2107      	movs	r1, #7
   20cd0:	0020      	movs	r0, r4
   20cd2:	4b0b      	ldr	r3, [pc, #44]	; (20d00 <MQTTPublish+0xe0>)
   20cd4:	4798      	blx	r3
   20cd6:	2807      	cmp	r0, #7
   20cd8:	d1ae      	bne.n	20c38 <MQTTPublish+0x18>
            if (MQTTDeserialize_ack(&type, &dup, &mypacketid, c->readbuf, c->readbuf_size) != 1)
   20cda:	2226      	movs	r2, #38	; 0x26
   20cdc:	68e3      	ldr	r3, [r4, #12]
   20cde:	446a      	add	r2, sp
   20ce0:	9300      	str	r3, [sp, #0]
   20ce2:	6963      	ldr	r3, [r4, #20]
   20ce4:	a909      	add	r1, sp, #36	; 0x24
   20ce6:	301e      	adds	r0, #30
   20ce8:	e7e7      	b.n	20cba <MQTTPublish+0x9a>
   20cea:	46c0      	nop			; (mov r8, r8)
   20cec:	00020f29 	.word	0x00020f29
   20cf0:	00020ef1 	.word	0x00020ef1
   20cf4:	0000ffff 	.word	0x0000ffff
   20cf8:	000217b9 	.word	0x000217b9
   20cfc:	000206ad 	.word	0x000206ad
   20d00:	00020a61 	.word	0x00020a61
   20d04:	000214f1 	.word	0x000214f1

00020d08 <MQTTDisconnect>:


int MQTTDisconnect(MQTTClient* c)
{  
   20d08:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   20d0a:	0004      	movs	r4, r0
    int len = 0;

#if defined(MQTT_TASK)
	MutexLock(&c->mutex);
#endif
    TimerInit(&timer);
   20d0c:	4b0b      	ldr	r3, [pc, #44]	; (20d3c <MQTTDisconnect+0x34>)
   20d0e:	a801      	add	r0, sp, #4
   20d10:	4798      	blx	r3
    TimerCountdownMS(&timer, c->command_timeout_ms);
   20d12:	6861      	ldr	r1, [r4, #4]
   20d14:	a801      	add	r0, sp, #4
   20d16:	4b0a      	ldr	r3, [pc, #40]	; (20d40 <MQTTDisconnect+0x38>)
   20d18:	4798      	blx	r3

	len = MQTTSerialize_disconnect(c->buf, c->buf_size);
   20d1a:	68a1      	ldr	r1, [r4, #8]
   20d1c:	6920      	ldr	r0, [r4, #16]
   20d1e:	4b09      	ldr	r3, [pc, #36]	; (20d44 <MQTTDisconnect+0x3c>)
   20d20:	4798      	blx	r3
   20d22:	1e01      	subs	r1, r0, #0
    if (len > 0)
   20d24:	dd07      	ble.n	20d36 <MQTTDisconnect+0x2e>
        rc = sendPacket(c, len, &timer);            // send the disconnect packet
   20d26:	aa01      	add	r2, sp, #4
   20d28:	0020      	movs	r0, r4
   20d2a:	4b07      	ldr	r3, [pc, #28]	; (20d48 <MQTTDisconnect+0x40>)
   20d2c:	4798      	blx	r3
        
    c->isconnected = 0;
   20d2e:	2300      	movs	r3, #0
   20d30:	6223      	str	r3, [r4, #32]

#if defined(MQTT_TASK)
	MutexUnlock(&c->mutex);
#endif
    return rc;
}
   20d32:	b004      	add	sp, #16
   20d34:	bd10      	pop	{r4, pc}
    int rc = FAILURE;
   20d36:	2001      	movs	r0, #1
   20d38:	4240      	negs	r0, r0
   20d3a:	e7f8      	b.n	20d2e <MQTTDisconnect+0x26>
   20d3c:	00020f29 	.word	0x00020f29
   20d40:	00020ef1 	.word	0x00020ef1
   20d44:	00021441 	.word	0x00021441
   20d48:	000206ad 	.word	0x000206ad

00020d4c <WINC1500_disconnect>:
  //return gu32MQTTBrokerSendLen;
  return len;
}


static void WINC1500_disconnect(Network* n) {
   20d4c:	b510      	push	{r4, lr}
   20d4e:	0004      	movs	r4, r0
	close(n->socket);
   20d50:	2000      	movs	r0, #0
   20d52:	4b05      	ldr	r3, [pc, #20]	; (20d68 <WINC1500_disconnect+0x1c>)
   20d54:	5620      	ldrsb	r0, [r4, r0]
   20d56:	4798      	blx	r3
	n->socket=-1;
   20d58:	2301      	movs	r3, #1
	gbMQTTBrokerConnected=false;
   20d5a:	2200      	movs	r2, #0
	n->socket=-1;
   20d5c:	425b      	negs	r3, r3
   20d5e:	6023      	str	r3, [r4, #0]
	gbMQTTBrokerConnected=false;
   20d60:	4b02      	ldr	r3, [pc, #8]	; (20d6c <WINC1500_disconnect+0x20>)
   20d62:	701a      	strb	r2, [r3, #0]
}
   20d64:	bd10      	pop	{r4, pc}
   20d66:	46c0      	nop			; (mov r8, r8)
   20d68:	0001cc19 	.word	0x0001cc19
   20d6c:	20003dee 	.word	0x20003dee

00020d70 <WINC1500_read>:
static int WINC1500_read(Network* n, unsigned char* buffer, int len, int timeout_ms) { 
   20d70:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   20d72:	0014      	movs	r4, r2
   20d74:	9101      	str	r1, [sp, #4]
  if(0==timeout_ms) timeout_ms=10;
   20d76:	2b00      	cmp	r3, #0
   20d78:	d100      	bne.n	20d7c <WINC1500_read+0xc>
   20d7a:	330a      	adds	r3, #10
  if(0==gu32MQTTRxFIFOLen){ //no data in internal FIFO
   20d7c:	4d1a      	ldr	r5, [pc, #104]	; (20de8 <WINC1500_read+0x78>)
   20d7e:	682a      	ldr	r2, [r5, #0]
   20d80:	2a00      	cmp	r2, #0
   20d82:	d11b      	bne.n	20dbc <WINC1500_read+0x4c>
	  gbMQTTBrokerRecvDone=false;
   20d84:	4e19      	ldr	r6, [pc, #100]	; (20dec <WINC1500_read+0x7c>)
	  if (SOCK_ERR_NO_ERROR!=recv(n->socket,gcMQTTRxFIFO,MQTT_RX_POOL_SIZE,timeout_ms)){
   20d86:	7800      	ldrb	r0, [r0, #0]
	  gbMQTTBrokerRecvDone=false;
   20d88:	7032      	strb	r2, [r6, #0]
	  if (SOCK_ERR_NO_ERROR!=recv(n->socket,gcMQTTRxFIFO,MQTT_RX_POOL_SIZE,timeout_ms)){
   20d8a:	3201      	adds	r2, #1
   20d8c:	b240      	sxtb	r0, r0
   20d8e:	32ff      	adds	r2, #255	; 0xff
   20d90:	4917      	ldr	r1, [pc, #92]	; (20df0 <WINC1500_read+0x80>)
   20d92:	4f18      	ldr	r7, [pc, #96]	; (20df4 <WINC1500_read+0x84>)
   20d94:	47b8      	blx	r7
   20d96:	2800      	cmp	r0, #0
   20d98:	d005      	beq.n	20da6 <WINC1500_read+0x36>
		  return -1;
   20d9a:	2401      	movs	r4, #1
   20d9c:	4264      	negs	r4, r4
}
   20d9e:	0020      	movs	r0, r4
   20da0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		  m2m_wifi_handle_events(NULL);
   20da2:	4b15      	ldr	r3, [pc, #84]	; (20df8 <WINC1500_read+0x88>)
   20da4:	4798      	blx	r3
	  while (false==gbMQTTBrokerRecvDone){
   20da6:	7830      	ldrb	r0, [r6, #0]
   20da8:	2800      	cmp	r0, #0
   20daa:	d0fa      	beq.n	20da2 <WINC1500_read+0x32>
   20dac:	2200      	movs	r2, #0
	  if(gi32MQTTBrokerRxLen>0){ //data recieved form network
   20dae:	4b13      	ldr	r3, [pc, #76]	; (20dfc <WINC1500_read+0x8c>)
   20db0:	4913      	ldr	r1, [pc, #76]	; (20e00 <WINC1500_read+0x90>)
   20db2:	681b      	ldr	r3, [r3, #0]
   20db4:	4293      	cmp	r3, r2
   20db6:	dd13      	ble.n	20de0 <WINC1500_read+0x70>
		gu32MQTTRxFIFOLen=gi32MQTTBrokerRxLen;
   20db8:	602b      	str	r3, [r5, #0]
		gu32MQTTRxFIFOPtr=0;
   20dba:	600a      	str	r2, [r1, #0]
  if(len>(int)gu32MQTTRxFIFOLen){
   20dbc:	682f      	ldr	r7, [r5, #0]
   20dbe:	42a7      	cmp	r7, r4
   20dc0:	dbeb      	blt.n	20d9a <WINC1500_read+0x2a>
  memcpy((void*)buffer, (const void*)&gcMQTTRxFIFO[gu32MQTTRxFIFOPtr],len);
   20dc2:	4e0f      	ldr	r6, [pc, #60]	; (20e00 <WINC1500_read+0x90>)
   20dc4:	490a      	ldr	r1, [pc, #40]	; (20df0 <WINC1500_read+0x80>)
   20dc6:	6833      	ldr	r3, [r6, #0]
   20dc8:	0022      	movs	r2, r4
   20dca:	9300      	str	r3, [sp, #0]
   20dcc:	18c9      	adds	r1, r1, r3
   20dce:	9801      	ldr	r0, [sp, #4]
   20dd0:	4b0c      	ldr	r3, [pc, #48]	; (20e04 <WINC1500_read+0x94>)
   20dd2:	4798      	blx	r3
  gu32MQTTRxFIFOPtr+=len;
   20dd4:	9b00      	ldr	r3, [sp, #0]
  gu32MQTTRxFIFOLen-=len;
   20dd6:	1b3f      	subs	r7, r7, r4
  gu32MQTTRxFIFOPtr+=len;
   20dd8:	191b      	adds	r3, r3, r4
  gu32MQTTRxFIFOLen-=len;
   20dda:	602f      	str	r7, [r5, #0]
  gu32MQTTRxFIFOPtr+=len;
   20ddc:	6033      	str	r3, [r6, #0]
  return len;
   20dde:	e7de      	b.n	20d9e <WINC1500_read+0x2e>
		  gu32MQTTRxFIFOLen=0;
   20de0:	602a      	str	r2, [r5, #0]
		  gu32MQTTRxFIFOPtr=0;
   20de2:	600a      	str	r2, [r1, #0]
		  return gi32MQTTBrokerRxLen; //this corresponds to the error code.
   20de4:	001c      	movs	r4, r3
   20de6:	e7da      	b.n	20d9e <WINC1500_read+0x2e>
   20de8:	20003f00 	.word	0x20003f00
   20dec:	20003df0 	.word	0x20003df0
   20df0:	20003df2 	.word	0x20003df2
   20df4:	0001cba1 	.word	0x0001cba1
   20df8:	0001b181 	.word	0x0001b181
   20dfc:	20003ef8 	.word	0x20003ef8
   20e00:	20003f04 	.word	0x20003f04
   20e04:	00022c11 	.word	0x00022c11

00020e08 <WINC1500_write>:
  gbMQTTBrokerSendDone=false;
   20e08:	2300      	movs	r3, #0
static int WINC1500_write(Network* n, unsigned char* buffer, int len, int timeout_ms) {
   20e0a:	b570      	push	{r4, r5, r6, lr}
  if (SOCK_ERR_NO_ERROR!=send(n->socket,buffer,len,0)){
   20e0c:	7800      	ldrb	r0, [r0, #0]
  gbMQTTBrokerSendDone=false;
   20e0e:	4d09      	ldr	r5, [pc, #36]	; (20e34 <WINC1500_write+0x2c>)
static int WINC1500_write(Network* n, unsigned char* buffer, int len, int timeout_ms) {
   20e10:	0014      	movs	r4, r2
  if (SOCK_ERR_NO_ERROR!=send(n->socket,buffer,len,0)){
   20e12:	b240      	sxtb	r0, r0
   20e14:	b292      	uxth	r2, r2
   20e16:	4e08      	ldr	r6, [pc, #32]	; (20e38 <WINC1500_write+0x30>)
  gbMQTTBrokerSendDone=false;
   20e18:	702b      	strb	r3, [r5, #0]
  if (SOCK_ERR_NO_ERROR!=send(n->socket,buffer,len,0)){
   20e1a:	47b0      	blx	r6
   20e1c:	2800      	cmp	r0, #0
   20e1e:	d004      	beq.n	20e2a <WINC1500_write+0x22>
	  return -1;
   20e20:	2401      	movs	r4, #1
   20e22:	4264      	negs	r4, r4
   20e24:	e004      	b.n	20e30 <WINC1500_write+0x28>
	  m2m_wifi_handle_events(NULL);
   20e26:	4b05      	ldr	r3, [pc, #20]	; (20e3c <WINC1500_write+0x34>)
   20e28:	4798      	blx	r3
  while (false==gbMQTTBrokerSendDone){
   20e2a:	7828      	ldrb	r0, [r5, #0]
   20e2c:	2800      	cmp	r0, #0
   20e2e:	d0fa      	beq.n	20e26 <WINC1500_write+0x1e>
}
   20e30:	0020      	movs	r0, r4
   20e32:	bd70      	pop	{r4, r5, r6, pc}
   20e34:	20003df1 	.word	0x20003df1
   20e38:	0001cb31 	.word	0x0001cb31
   20e3c:	0001b181 	.word	0x0001b181

00020e40 <dnsResolveCallback>:
{
   20e40:	b570      	push	{r4, r5, r6, lr}
	if((gbMQTTBrokerIpresolved == false) && (!strcmp((const char *)gpcHostAddr, (const char *)hostName)))
   20e42:	4c08      	ldr	r4, [pc, #32]	; (20e64 <dnsResolveCallback+0x24>)
{
   20e44:	000d      	movs	r5, r1
	if((gbMQTTBrokerIpresolved == false) && (!strcmp((const char *)gpcHostAddr, (const char *)hostName)))
   20e46:	7823      	ldrb	r3, [r4, #0]
   20e48:	2b00      	cmp	r3, #0
   20e4a:	d10a      	bne.n	20e62 <dnsResolveCallback+0x22>
   20e4c:	4b06      	ldr	r3, [pc, #24]	; (20e68 <dnsResolveCallback+0x28>)
   20e4e:	0001      	movs	r1, r0
   20e50:	6818      	ldr	r0, [r3, #0]
   20e52:	4b06      	ldr	r3, [pc, #24]	; (20e6c <dnsResolveCallback+0x2c>)
   20e54:	4798      	blx	r3
   20e56:	2800      	cmp	r0, #0
   20e58:	d103      	bne.n	20e62 <dnsResolveCallback+0x22>
		gi32MQTTBrokerIp = hostIp;
   20e5a:	4b05      	ldr	r3, [pc, #20]	; (20e70 <dnsResolveCallback+0x30>)
   20e5c:	601d      	str	r5, [r3, #0]
		gbMQTTBrokerIpresolved = true;
   20e5e:	2301      	movs	r3, #1
   20e60:	7023      	strb	r3, [r4, #0]
}
   20e62:	bd70      	pop	{r4, r5, r6, pc}
   20e64:	20003def 	.word	0x20003def
   20e68:	20003efc 	.word	0x20003efc
   20e6c:	00023865 	.word	0x00023865
   20e70:	20003ef4 	.word	0x20003ef4

00020e74 <tcpClientSocketEventHandler>:
{
   20e74:	b5f0      	push	{r4, r5, r6, r7, lr}
		if(mqttClientPool[cIdx].mqtt_instance != NULL)
   20e76:	2564      	movs	r5, #100	; 0x64
{
   20e78:	2307      	movs	r3, #7
		if(mqttClientPool[cIdx].mqtt_instance != NULL)
   20e7a:	4e12      	ldr	r6, [pc, #72]	; (20ec4 <tcpClientSocketEventHandler+0x50>)
   20e7c:	426d      	negs	r5, r5
   20e7e:	002c      	movs	r4, r5
   20e80:	27c7      	movs	r7, #199	; 0xc7
   20e82:	435c      	muls	r4, r3
   20e84:	00bf      	lsls	r7, r7, #2
   20e86:	19e4      	adds	r4, r4, r7
   20e88:	5934      	ldr	r4, [r6, r4]
   20e8a:	2c00      	cmp	r4, #0
   20e8c:	d002      	beq.n	20e94 <tcpClientSocketEventHandler+0x20>
			if(mqttInstance->network.socket == sock)
   20e8e:	6a24      	ldr	r4, [r4, #32]
   20e90:	4284      	cmp	r4, r0
   20e92:	d00d      	beq.n	20eb0 <tcpClientSocketEventHandler+0x3c>
   20e94:	3b01      	subs	r3, #1
	for(cIdx = 0; cIdx < MQTT_MAX_CLIENTS; cIdx++)
   20e96:	2b00      	cmp	r3, #0
   20e98:	d1f1      	bne.n	20e7e <tcpClientSocketEventHandler+0xa>
}
   20e9a:	bdf0      	pop	{r4, r5, r6, r7, pc}
				gbMQTTBrokerSendDone=true;
   20e9c:	2201      	movs	r2, #1
   20e9e:	4b0a      	ldr	r3, [pc, #40]	; (20ec8 <tcpClientSocketEventHandler+0x54>)
   20ea0:	e00e      	b.n	20ec0 <tcpClientSocketEventHandler+0x4c>
				gi32MQTTBrokerRxLen = pstrRx->s16BufferSize;
   20ea2:	2304      	movs	r3, #4
   20ea4:	5ed2      	ldrsh	r2, [r2, r3]
   20ea6:	4b09      	ldr	r3, [pc, #36]	; (20ecc <tcpClientSocketEventHandler+0x58>)
   20ea8:	601a      	str	r2, [r3, #0]
				gbMQTTBrokerRecvDone=true;
   20eaa:	2201      	movs	r2, #1
   20eac:	4b08      	ldr	r3, [pc, #32]	; (20ed0 <tcpClientSocketEventHandler+0x5c>)
   20eae:	e007      	b.n	20ec0 <tcpClientSocketEventHandler+0x4c>
		switch (u8Msg) {
   20eb0:	2906      	cmp	r1, #6
   20eb2:	d0f6      	beq.n	20ea2 <tcpClientSocketEventHandler+0x2e>
   20eb4:	2907      	cmp	r1, #7
   20eb6:	d0f1      	beq.n	20e9c <tcpClientSocketEventHandler+0x28>
   20eb8:	2905      	cmp	r1, #5
   20eba:	d1ee      	bne.n	20e9a <tcpClientSocketEventHandler+0x26>
				gbMQTTBrokerConnected=true;
   20ebc:	2201      	movs	r2, #1
   20ebe:	4b05      	ldr	r3, [pc, #20]	; (20ed4 <tcpClientSocketEventHandler+0x60>)
				gbMQTTBrokerRecvDone=true;
   20ec0:	701a      	strb	r2, [r3, #0]
}
   20ec2:	e7ea      	b.n	20e9a <tcpClientSocketEventHandler+0x26>
   20ec4:	20003f08 	.word	0x20003f08
   20ec8:	20003df1 	.word	0x20003df1
   20ecc:	20003ef8 	.word	0x20003ef8
   20ed0:	20003df0 	.word	0x20003df0
   20ed4:	20003dee 	.word	0x20003dee

00020ed8 <TimerIsExpired>:
char TimerIsExpired(Timer* timer) {
   20ed8:	b510      	push	{r4, lr}
   20eda:	0001      	movs	r1, r0
	return xTaskCheckForTimeOut(&timer->xTimeOut, &timer->xTicksToWait) == pdTRUE;
   20edc:	4b03      	ldr	r3, [pc, #12]	; (20eec <TimerIsExpired+0x14>)
   20ede:	3004      	adds	r0, #4
   20ee0:	4798      	blx	r3
   20ee2:	3801      	subs	r0, #1
   20ee4:	4243      	negs	r3, r0
   20ee6:	4158      	adcs	r0, r3
   20ee8:	b2c0      	uxtb	r0, r0
}
   20eea:	bd10      	pop	{r4, pc}
   20eec:	000189c1 	.word	0x000189c1

00020ef0 <TimerCountdownMS>:
void TimerCountdownMS(Timer* timer, unsigned int timeout_ms) {
   20ef0:	b510      	push	{r4, lr}
	timer->xTicksToWait = timeout_ms / portTICK_PERIOD_MS; /* convert milliseconds to ticks */
   20ef2:	c002      	stmia	r0!, {r1}
	vTaskSetTimeOutState(&timer->xTimeOut); /* Record the time at which this function was entered. */
   20ef4:	4b01      	ldr	r3, [pc, #4]	; (20efc <TimerCountdownMS+0xc>)
   20ef6:	4798      	blx	r3
}
   20ef8:	bd10      	pop	{r4, pc}
   20efa:	46c0      	nop			; (mov r8, r8)
   20efc:	00018979 	.word	0x00018979

00020f00 <TimerCountdown>:
	TimerCountdownMS(timer, timeout * 1000);
   20f00:	23fa      	movs	r3, #250	; 0xfa
   20f02:	009b      	lsls	r3, r3, #2
   20f04:	4359      	muls	r1, r3
void TimerCountdown(Timer* timer, unsigned int timeout) {
   20f06:	b510      	push	{r4, lr}
	timer->xTicksToWait = timeout_ms / portTICK_PERIOD_MS; /* convert milliseconds to ticks */
   20f08:	c002      	stmia	r0!, {r1}
	vTaskSetTimeOutState(&timer->xTimeOut); /* Record the time at which this function was entered. */
   20f0a:	4b01      	ldr	r3, [pc, #4]	; (20f10 <TimerCountdown+0x10>)
   20f0c:	4798      	blx	r3
}
   20f0e:	bd10      	pop	{r4, pc}
   20f10:	00018979 	.word	0x00018979

00020f14 <TimerLeftMS>:
int TimerLeftMS(Timer* timer) {
   20f14:	b510      	push	{r4, lr}
   20f16:	0004      	movs	r4, r0
	xTaskCheckForTimeOut(&timer->xTimeOut, &timer->xTicksToWait); /* updates xTicksToWait to the number left */
   20f18:	4b02      	ldr	r3, [pc, #8]	; (20f24 <TimerLeftMS+0x10>)
   20f1a:	0021      	movs	r1, r4
   20f1c:	3004      	adds	r0, #4
   20f1e:	4798      	blx	r3
	return (timer->xTicksToWait < 0) ? 0 : (timer->xTicksToWait * portTICK_PERIOD_MS);
   20f20:	6820      	ldr	r0, [r4, #0]
}
   20f22:	bd10      	pop	{r4, pc}
   20f24:	000189c1 	.word	0x000189c1

00020f28 <TimerInit>:
	timer->xTicksToWait = 0;
   20f28:	2100      	movs	r1, #0
void TimerInit(Timer* timer) {
   20f2a:	b510      	push	{r4, lr}
	memset(&timer->xTimeOut, '\0', sizeof(timer->xTimeOut));
   20f2c:	2208      	movs	r2, #8
	timer->xTicksToWait = 0;
   20f2e:	c002      	stmia	r0!, {r1}
	memset(&timer->xTimeOut, '\0', sizeof(timer->xTimeOut));
   20f30:	4b01      	ldr	r3, [pc, #4]	; (20f38 <TimerInit+0x10>)
   20f32:	4798      	blx	r3
}
   20f34:	bd10      	pop	{r4, pc}
   20f36:	46c0      	nop			; (mov r8, r8)
   20f38:	00022c47 	.word	0x00022c47

00020f3c <NetworkInit>:


void NetworkInit(Network* n) {
	n->socket = -1;
   20f3c:	2301      	movs	r3, #1
   20f3e:	425b      	negs	r3, r3
   20f40:	6003      	str	r3, [r0, #0]
	n->mqttread = WINC1500_read;
   20f42:	4b03      	ldr	r3, [pc, #12]	; (20f50 <NetworkInit+0x14>)
   20f44:	6083      	str	r3, [r0, #8]
	n->mqttwrite = WINC1500_write;
   20f46:	4b03      	ldr	r3, [pc, #12]	; (20f54 <NetworkInit+0x18>)
   20f48:	60c3      	str	r3, [r0, #12]
	n->disconnect = WINC1500_disconnect;
   20f4a:	4b03      	ldr	r3, [pc, #12]	; (20f58 <NetworkInit+0x1c>)
   20f4c:	6103      	str	r3, [r0, #16]
}
   20f4e:	4770      	bx	lr
   20f50:	00020d71 	.word	0x00020d71
   20f54:	00020e09 	.word	0x00020e09
   20f58:	00020d4d 	.word	0x00020d4d

00020f5c <ConnectNetwork>:

int ConnectNetwork(Network* n, char* addr, int port, int TLSFlag){
   20f5c:	b5f0      	push	{r4, r5, r6, r7, lr}
   20f5e:	001d      	movs	r5, r3

  //Resolve Server URL.
  gbMQTTBrokerIpresolved = false;
   20f60:	2300      	movs	r3, #0
int ConnectNetwork(Network* n, char* addr, int port, int TLSFlag){
   20f62:	0004      	movs	r4, r0
   20f64:	0016      	movs	r6, r2
  gpcHostAddr = addr;
  gethostbyname((uint8*)addr);
   20f66:	0008      	movs	r0, r1
  gbMQTTBrokerIpresolved = false;
   20f68:	4f1b      	ldr	r7, [pc, #108]	; (20fd8 <ConnectNetwork+0x7c>)
int ConnectNetwork(Network* n, char* addr, int port, int TLSFlag){
   20f6a:	b085      	sub	sp, #20
  gbMQTTBrokerIpresolved = false;
   20f6c:	703b      	strb	r3, [r7, #0]
  gpcHostAddr = addr;
   20f6e:	4b1b      	ldr	r3, [pc, #108]	; (20fdc <ConnectNetwork+0x80>)
   20f70:	6019      	str	r1, [r3, #0]
  gethostbyname((uint8*)addr);
   20f72:	4b1b      	ldr	r3, [pc, #108]	; (20fe0 <ConnectNetwork+0x84>)
 
  //wait for resolver callback
  while (false==gbMQTTBrokerIpresolved){
	  m2m_wifi_handle_events(NULL);
   20f74:	4798      	blx	r3
  while (false==gbMQTTBrokerIpresolved){
   20f76:	7838      	ldrb	r0, [r7, #0]
   20f78:	2800      	cmp	r0, #0
   20f7a:	d018      	beq.n	20fae <ConnectNetwork+0x52>
  
  n->hostIP = gi32MQTTBrokerIp;
  
  //connect to socket
  struct sockaddr_in addr_in;
  addr_in.sin_family = AF_INET;
   20f7c:	466a      	mov	r2, sp
   20f7e:	2002      	movs	r0, #2
  n->hostIP = gi32MQTTBrokerIp;
   20f80:	4b18      	ldr	r3, [pc, #96]	; (20fe4 <ConnectNetwork+0x88>)
  addr_in.sin_port = _htons(port);
   20f82:	ba76      	rev16	r6, r6
  n->hostIP = gi32MQTTBrokerIp;
   20f84:	681b      	ldr	r3, [r3, #0]
  addr_in.sin_family = AF_INET;
   20f86:	8010      	strh	r0, [r2, #0]
  n->hostIP = gi32MQTTBrokerIp;
   20f88:	6063      	str	r3, [r4, #4]
  addr_in.sin_addr.s_addr = gi32MQTTBrokerIp;
   20f8a:	9301      	str	r3, [sp, #4]

  /* Create secure socket */ 
  if(n->socket < 0)
   20f8c:	6823      	ldr	r3, [r4, #0]
  addr_in.sin_port = _htons(port);
   20f8e:	8056      	strh	r6, [r2, #2]
  if(n->socket < 0)
   20f90:	2b00      	cmp	r3, #0
   20f92:	da04      	bge.n	20f9e <ConnectNetwork+0x42>
	n->socket = socket(AF_INET, SOCK_STREAM, TLSFlag);
   20f94:	b2ea      	uxtb	r2, r5
   20f96:	2101      	movs	r1, #1
   20f98:	4b13      	ldr	r3, [pc, #76]	; (20fe8 <ConnectNetwork+0x8c>)
   20f9a:	4798      	blx	r3
   20f9c:	6020      	str	r0, [r4, #0]
  
  /* Check if socket was created successfully */
  if (n->socket == -1) {
   20f9e:	6820      	ldr	r0, [r4, #0]
   20fa0:	1c43      	adds	r3, r0, #1
   20fa2:	d106      	bne.n	20fb2 <ConnectNetwork+0x56>
   #ifdef MQTT_PLATFORM_DBG
   printf("ERROR >> socket error.\r\n");
   #endif
   close(n->socket);
   20fa4:	4b11      	ldr	r3, [pc, #68]	; (20fec <ConnectNetwork+0x90>)
   20fa6:	4798      	blx	r3
  /* If success, connect to socket */
  if (connect(n->socket, (struct sockaddr *)&addr_in, sizeof(struct sockaddr_in)) != SOCK_ERR_NO_ERROR) {
   #ifdef MQTT_PLATFORM_DBG  
   printf("ERROR >> connect error.\r\n");
   #endif
   return SOCK_ERR_INVALID;
   20fa8:	2009      	movs	r0, #9
   20faa:	4240      	negs	r0, r0
   20fac:	e00e      	b.n	20fcc <ConnectNetwork+0x70>
	  m2m_wifi_handle_events(NULL);
   20fae:	4b10      	ldr	r3, [pc, #64]	; (20ff0 <ConnectNetwork+0x94>)
   20fb0:	e7e0      	b.n	20f74 <ConnectNetwork+0x18>
  if (connect(n->socket, (struct sockaddr *)&addr_in, sizeof(struct sockaddr_in)) != SOCK_ERR_NO_ERROR) {
   20fb2:	b240      	sxtb	r0, r0
   20fb4:	2210      	movs	r2, #16
   20fb6:	4669      	mov	r1, sp
   20fb8:	4b0e      	ldr	r3, [pc, #56]	; (20ff4 <ConnectNetwork+0x98>)
   20fba:	4798      	blx	r3
   20fbc:	2800      	cmp	r0, #0
   20fbe:	d1f3      	bne.n	20fa8 <ConnectNetwork+0x4c>
  }
  
  gbMQTTBrokerConnected = false;
   20fc0:	4c0d      	ldr	r4, [pc, #52]	; (20ff8 <ConnectNetwork+0x9c>)
   20fc2:	7020      	strb	r0, [r4, #0]
  
  /*wait for SOCKET_MSG_CONNECT event */
  while(false==gbMQTTBrokerConnected){
   20fc4:	7820      	ldrb	r0, [r4, #0]
   20fc6:	2800      	cmp	r0, #0
   20fc8:	d002      	beq.n	20fd0 <ConnectNetwork+0x74>
  
  /* Success */
  #ifdef MQTT_PLATFORM_DBG
  printf("INFO >> ConnectNetwork successful\r\n");
  #endif
  return SOCK_ERR_NO_ERROR;
   20fca:	2000      	movs	r0, #0
   20fcc:	b005      	add	sp, #20
   20fce:	bdf0      	pop	{r4, r5, r6, r7, pc}
    m2m_wifi_handle_events(NULL);
   20fd0:	4b07      	ldr	r3, [pc, #28]	; (20ff0 <ConnectNetwork+0x94>)
   20fd2:	4798      	blx	r3
   20fd4:	e7f6      	b.n	20fc4 <ConnectNetwork+0x68>
   20fd6:	46c0      	nop			; (mov r8, r8)
   20fd8:	20003def 	.word	0x20003def
   20fdc:	20003efc 	.word	0x20003efc
   20fe0:	0001ccf9 	.word	0x0001ccf9
   20fe4:	20003ef4 	.word	0x20003ef4
   20fe8:	0001c9a5 	.word	0x0001c9a5
   20fec:	0001cc19 	.word	0x0001cc19
   20ff0:	0001b181 	.word	0x0001b181
   20ff4:	0001cab9 	.word	0x0001cab9
   20ff8:	20003dee 	.word	0x20003dee

00020ffc <mqtt_init>:
		}
	}
}

int mqtt_init(struct mqtt_module *module, struct mqtt_config *config)
{
   20ffc:	b5f0      	push	{r4, r5, r6, r7, lr}
   20ffe:	0005      	movs	r5, r0
   21000:	b085      	sub	sp, #20
   21002:	000c      	movs	r4, r1
	unsigned int timeout_ms;
	
	if(NULL == module || NULL == config || NULL == config->send_buffer || NULL == config->read_buffer)
   21004:	2800      	cmp	r0, #0
   21006:	d103      	bne.n	21010 <mqtt_init+0x14>
		return FAILURE;
   21008:	2001      	movs	r0, #1
   2100a:	4240      	negs	r0, r0
		MQTTClientInit(module->client, &(module->network), timeout_ms, config->send_buffer, config->send_buffer_size, config->read_buffer, config->read_buffer_size);
		return SUCCESS;
	}
	else
		return FAILURE;
}
   2100c:	b005      	add	sp, #20
   2100e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if(NULL == module || NULL == config || NULL == config->send_buffer || NULL == config->read_buffer)
   21010:	2900      	cmp	r1, #0
   21012:	d0f9      	beq.n	21008 <mqtt_init+0xc>
   21014:	690b      	ldr	r3, [r1, #16]
   21016:	2b00      	cmp	r3, #0
   21018:	d0f6      	beq.n	21008 <mqtt_init+0xc>
   2101a:	688b      	ldr	r3, [r1, #8]
   2101c:	2b00      	cmp	r3, #0
   2101e:	d0f3      	beq.n	21008 <mqtt_init+0xc>
	NetworkInit(&(module->network));
   21020:	0007      	movs	r7, r0
	timeout_ms = config->keep_alive * 1000;
   21022:	26fa      	movs	r6, #250	; 0xfa
   21024:	888b      	ldrh	r3, [r1, #4]
   21026:	00b6      	lsls	r6, r6, #2
	NetworkInit(&(module->network));
   21028:	3720      	adds	r7, #32
   2102a:	0038      	movs	r0, r7
	timeout_ms = config->keep_alive * 1000;
   2102c:	435e      	muls	r6, r3
	NetworkInit(&(module->network));
   2102e:	4b13      	ldr	r3, [pc, #76]	; (2107c <mqtt_init+0x80>)
   21030:	4798      	blx	r3
	memcpy((void *)&(module->config), config, sizeof(struct mqtt_config));
   21032:	2218      	movs	r2, #24
   21034:	4b12      	ldr	r3, [pc, #72]	; (21080 <mqtt_init+0x84>)
   21036:	1d28      	adds	r0, r5, #4
   21038:	0021      	movs	r1, r4
   2103a:	4798      	blx	r3
   2103c:	4b11      	ldr	r3, [pc, #68]	; (21084 <mqtt_init+0x88>)
   2103e:	2200      	movs	r2, #0
   21040:	469c      	mov	ip, r3
   21042:	2064      	movs	r0, #100	; 0x64
   21044:	0003      	movs	r3, r0
   21046:	4353      	muls	r3, r2
   21048:	4463      	add	r3, ip
		if(mqttClientPool[cIdx].mqtt_instance == NULL)
   2104a:	6e19      	ldr	r1, [r3, #96]	; 0x60
   2104c:	2900      	cmp	r1, #0
   2104e:	d111      	bne.n	21074 <mqtt_init+0x78>
			mqttClientPool[cIdx].mqtt_instance = module;
   21050:	661d      	str	r5, [r3, #96]	; 0x60
			module->client = &(mqttClientPool[cIdx].client);
   21052:	61eb      	str	r3, [r5, #28]
	if(module->client)
   21054:	69e8      	ldr	r0, [r5, #28]
   21056:	2800      	cmp	r0, #0
   21058:	d0d6      	beq.n	21008 <mqtt_init+0xc>
		MQTTClientInit(module->client, &(module->network), timeout_ms, config->send_buffer, config->send_buffer_size, config->read_buffer, config->read_buffer_size);
   2105a:	68e3      	ldr	r3, [r4, #12]
   2105c:	0032      	movs	r2, r6
   2105e:	9302      	str	r3, [sp, #8]
   21060:	68a3      	ldr	r3, [r4, #8]
   21062:	0039      	movs	r1, r7
   21064:	9301      	str	r3, [sp, #4]
   21066:	6963      	ldr	r3, [r4, #20]
   21068:	9300      	str	r3, [sp, #0]
   2106a:	6923      	ldr	r3, [r4, #16]
   2106c:	4c06      	ldr	r4, [pc, #24]	; (21088 <mqtt_init+0x8c>)
   2106e:	47a0      	blx	r4
		return SUCCESS;
   21070:	2000      	movs	r0, #0
   21072:	e7cb      	b.n	2100c <mqtt_init+0x10>
	for(cIdx = 0; cIdx < MQTT_MAX_CLIENTS; cIdx++)
   21074:	3201      	adds	r2, #1
   21076:	2a07      	cmp	r2, #7
   21078:	d1e4      	bne.n	21044 <mqtt_init+0x48>
   2107a:	e7eb      	b.n	21054 <mqtt_init+0x58>
   2107c:	00020f3d 	.word	0x00020f3d
   21080:	00022c11 	.word	0x00022c11
   21084:	20003f08 	.word	0x20003f08
   21088:	00020715 	.word	0x00020715

0002108c <mqtt_get_config_defaults>:
		return FAILURE;
}

void mqtt_get_config_defaults(struct mqtt_config *const config)
{
	config->port = 1883;
   2108c:	4b05      	ldr	r3, [pc, #20]	; (210a4 <mqtt_get_config_defaults+0x18>)
	config->tls = 0;
	config->keep_alive = 60;
   2108e:	223c      	movs	r2, #60	; 0x3c
	config->port = 1883;
   21090:	8003      	strh	r3, [r0, #0]
	config->tls = 0;
   21092:	2300      	movs	r3, #0
	config->keep_alive = 60;
   21094:	8082      	strh	r2, [r0, #4]
	config->tls = 0;
   21096:	7083      	strb	r3, [r0, #2]
	/* Below configuration must be initialized by Application */
	config->read_buffer = NULL;
   21098:	6083      	str	r3, [r0, #8]
	config->send_buffer = NULL;
   2109a:	6103      	str	r3, [r0, #16]
	config->read_buffer_size = 0;
   2109c:	60c3      	str	r3, [r0, #12]
	config->send_buffer_size = 0;
   2109e:	6143      	str	r3, [r0, #20]
}
   210a0:	4770      	bx	lr
   210a2:	46c0      	nop			; (mov r8, r8)
   210a4:	0000075b 	.word	0x0000075b

000210a8 <mqtt_register_callback>:

int mqtt_register_callback(struct mqtt_module *module, mqtt_callback_t callback)
{
	if(module)
   210a8:	2800      	cmp	r0, #0
   210aa:	d002      	beq.n	210b2 <mqtt_register_callback+0xa>
	{
		module->callback = callback;
   210ac:	6001      	str	r1, [r0, #0]
		return SUCCESS;
   210ae:	2000      	movs	r0, #0
	}
	else
		return FAILURE;
}
   210b0:	4770      	bx	lr
		return FAILURE;
   210b2:	2001      	movs	r0, #1
   210b4:	4240      	negs	r0, r0
   210b6:	e7fb      	b.n	210b0 <mqtt_register_callback+0x8>

000210b8 <mqtt_socket_event_handler>:
	module->callback = NULL;
	return SUCCESS;
}

void mqtt_socket_event_handler(SOCKET sock, uint8_t msg_type, void *msg_data)
{
   210b8:	b510      	push	{r4, lr}
	tcpClientSocketEventHandler(sock, msg_type, msg_data);
   210ba:	4b01      	ldr	r3, [pc, #4]	; (210c0 <mqtt_socket_event_handler+0x8>)
   210bc:	4798      	blx	r3
}
   210be:	bd10      	pop	{r4, pc}
   210c0:	00020e75 	.word	0x00020e75

000210c4 <mqtt_socket_resolve_handler>:

void mqtt_socket_resolve_handler(uint8_t *domain_name, uint32_t server_ip)
{
   210c4:	b510      	push	{r4, lr}
	dnsResolveCallback(domain_name, server_ip);
   210c6:	4b01      	ldr	r3, [pc, #4]	; (210cc <mqtt_socket_resolve_handler+0x8>)
   210c8:	4798      	blx	r3
}
   210ca:	bd10      	pop	{r4, pc}
   210cc:	00020e41 	.word	0x00020e41

000210d0 <mqtt_connect>:

int mqtt_connect(struct mqtt_module *module, const char *host)
{
   210d0:	b537      	push	{r0, r1, r2, r4, r5, lr}
   210d2:	0004      	movs	r4, r0
	union mqtt_data connResult;
	connResult.sock_connected.result = ConnectNetwork(&(module->network), (char *)host, module->config.port, module->config.tls);
   210d4:	7983      	ldrb	r3, [r0, #6]
   210d6:	8882      	ldrh	r2, [r0, #4]
   210d8:	4d06      	ldr	r5, [pc, #24]	; (210f4 <mqtt_connect+0x24>)
   210da:	3020      	adds	r0, #32
   210dc:	47a8      	blx	r5
	if(module->callback)
   210de:	6823      	ldr	r3, [r4, #0]
	connResult.sock_connected.result = ConnectNetwork(&(module->network), (char *)host, module->config.port, module->config.tls);
   210e0:	9001      	str	r0, [sp, #4]
	if(module->callback)
   210e2:	2b00      	cmp	r3, #0
   210e4:	d003      	beq.n	210ee <mqtt_connect+0x1e>
		module->callback(module, MQTT_CALLBACK_SOCK_CONNECTED, &connResult);
   210e6:	aa01      	add	r2, sp, #4
   210e8:	2100      	movs	r1, #0
   210ea:	0020      	movs	r0, r4
   210ec:	4798      	blx	r3
	return connResult.sock_connected.result;
}
   210ee:	9801      	ldr	r0, [sp, #4]
   210f0:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
   210f2:	46c0      	nop			; (mov r8, r8)
   210f4:	00020f5d 	.word	0x00020f5d

000210f8 <mqtt_connect_broker>:

int mqtt_connect_broker(struct mqtt_module *const module, uint8_t clean_session, const char *id, const char *password, const char *client_id, const char *will_topic, const char *will_msg, uint32_t will_msg_len, uint8_t will_qos, uint8_t will_retain)
{
   210f8:	b5f0      	push	{r4, r5, r6, r7, lr}
   210fa:	b09d      	sub	sp, #116	; 0x74
   210fc:	9301      	str	r3, [sp, #4]
   210fe:	ab26      	add	r3, sp, #152	; 0x98
   21100:	781b      	ldrb	r3, [r3, #0]
	// Will Message length is not used by Paho MQTT. 
	int rc;
	union mqtt_data connBrokerResult;
	MQTTPacket_connectData connectData = MQTTPacket_connectData_initializer;
   21102:	ac06      	add	r4, sp, #24
{
   21104:	9302      	str	r3, [sp, #8]
   21106:	ab27      	add	r3, sp, #156	; 0x9c
   21108:	781b      	ldrb	r3, [r3, #0]
   2110a:	000e      	movs	r6, r1
   2110c:	0017      	movs	r7, r2
   2110e:	9303      	str	r3, [sp, #12]
	MQTTPacket_connectData connectData = MQTTPacket_connectData_initializer;
   21110:	2258      	movs	r2, #88	; 0x58
   21112:	4b1a      	ldr	r3, [pc, #104]	; (2117c <mqtt_connect_broker+0x84>)
{
   21114:	0005      	movs	r5, r0
	MQTTPacket_connectData connectData = MQTTPacket_connectData_initializer;
   21116:	491a      	ldr	r1, [pc, #104]	; (21180 <mqtt_connect_broker+0x88>)
   21118:	0020      	movs	r0, r4
   2111a:	4798      	blx	r3
	connectData.username.cstring = (char *)id;
	connectData.password.cstring = (char *)password;
	connectData.cleansession = clean_session;
	connectData.will.topicName.cstring = (char *)will_topic;
	connectData.will.message.cstring = (char *)will_msg;
	connectData.will.retained = will_retain;
   2111c:	466a      	mov	r2, sp
	connectData.clientID.cstring = (char *)client_id;
   2111e:	9b22      	ldr	r3, [sp, #136]	; 0x88
	connectData.will.retained = will_retain;
   21120:	7b12      	ldrb	r2, [r2, #12]
	connectData.clientID.cstring = (char *)client_id;
   21122:	60e3      	str	r3, [r4, #12]
	connectData.password.cstring = (char *)password;
   21124:	9b01      	ldr	r3, [sp, #4]
	connectData.username.cstring = (char *)id;
   21126:	6427      	str	r7, [r4, #64]	; 0x40
	connectData.password.cstring = (char *)password;
   21128:	64e3      	str	r3, [r4, #76]	; 0x4c
	connectData.will.topicName.cstring = (char *)will_topic;
   2112a:	9b23      	ldr	r3, [sp, #140]	; 0x8c
	connectData.cleansession = clean_session;
   2112c:	76a6      	strb	r6, [r4, #26]
	connectData.will.topicName.cstring = (char *)will_topic;
   2112e:	6263      	str	r3, [r4, #36]	; 0x24
	connectData.will.message.cstring = (char *)will_msg;
   21130:	9b24      	ldr	r3, [sp, #144]	; 0x90
   21132:	6323      	str	r3, [r4, #48]	; 0x30
	connectData.will.retained = will_retain;
   21134:	ab15      	add	r3, sp, #84	; 0x54
   21136:	701a      	strb	r2, [r3, #0]
	connectData.will.qos = will_qos;
   21138:	2345      	movs	r3, #69	; 0x45
   2113a:	aa04      	add	r2, sp, #16
   2113c:	189b      	adds	r3, r3, r2
   2113e:	466a      	mov	r2, sp
   21140:	7a12      	ldrb	r2, [r2, #8]
   21142:	701a      	strb	r2, [r3, #0]
	
	if(will_topic && will_msg)
   21144:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   21146:	2b00      	cmp	r3, #0
   21148:	d004      	beq.n	21154 <mqtt_connect_broker+0x5c>
   2114a:	9b24      	ldr	r3, [sp, #144]	; 0x90
   2114c:	2b00      	cmp	r3, #0
   2114e:	d001      	beq.n	21154 <mqtt_connect_broker+0x5c>
		connectData.willFlag = 1;
   21150:	2301      	movs	r3, #1
   21152:	76e3      	strb	r3, [r4, #27]
		
	rc = MQTTConnect(module->client, &connectData);
   21154:	0021      	movs	r1, r4
   21156:	4b0b      	ldr	r3, [pc, #44]	; (21184 <mqtt_connect_broker+0x8c>)
   21158:	69e8      	ldr	r0, [r5, #28]
   2115a:	4798      	blx	r3
	
	connBrokerResult.connected.result = rc;
	if(module->callback)
   2115c:	682b      	ldr	r3, [r5, #0]
	connBrokerResult.connected.result = rc;
   2115e:	aa05      	add	r2, sp, #20
	rc = MQTTConnect(module->client, &connectData);
   21160:	0004      	movs	r4, r0
	connBrokerResult.connected.result = rc;
   21162:	7010      	strb	r0, [r2, #0]
	if(module->callback)
   21164:	2b00      	cmp	r3, #0
   21166:	d002      	beq.n	2116e <mqtt_connect_broker+0x76>
		module->callback(module, MQTT_CALLBACK_CONNECTED, &connBrokerResult);
   21168:	2101      	movs	r1, #1
   2116a:	0028      	movs	r0, r5
   2116c:	4798      	blx	r3
	
	module->isConnected = true;
   2116e:	2301      	movs	r3, #1
	return rc;
}
   21170:	0020      	movs	r0, r4
	module->isConnected = true;
   21172:	3534      	adds	r5, #52	; 0x34
   21174:	702b      	strb	r3, [r5, #0]
}
   21176:	b01d      	add	sp, #116	; 0x74
   21178:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2117a:	46c0      	nop			; (mov r8, r8)
   2117c:	00022c11 	.word	0x00022c11
   21180:	0002b2b0 	.word	0x0002b2b0
   21184:	00020a91 	.word	0x00020a91

00021188 <mqtt_disconnect>:

int mqtt_disconnect(struct mqtt_module *const module, int force_close)
{
   21188:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2118a:	0004      	movs	r4, r0
	//force_close is not used by Paho MQTT
	int rc;
	union mqtt_data disconnectResult;
	
	rc = MQTTDisconnect(module->client);
   2118c:	4b08      	ldr	r3, [pc, #32]	; (211b0 <mqtt_disconnect+0x28>)
   2118e:	69c0      	ldr	r0, [r0, #28]
   21190:	4798      	blx	r3
	
	disconnectResult.disconnected.reason = rc;
	
	if(module->callback)
   21192:	6823      	ldr	r3, [r4, #0]
	rc = MQTTDisconnect(module->client);
   21194:	0005      	movs	r5, r0
	disconnectResult.disconnected.reason = rc;
   21196:	9001      	str	r0, [sp, #4]
	if(module->callback)
   21198:	2b00      	cmp	r3, #0
   2119a:	d003      	beq.n	211a4 <mqtt_disconnect+0x1c>
		module->callback(module, MQTT_CALLBACK_DISCONNECTED, &disconnectResult);
   2119c:	aa01      	add	r2, sp, #4
   2119e:	2105      	movs	r1, #5
   211a0:	0020      	movs	r0, r4
   211a2:	4798      	blx	r3
	
	module->isConnected = false;
   211a4:	2300      	movs	r3, #0
   211a6:	3434      	adds	r4, #52	; 0x34
	return rc;
}
   211a8:	0028      	movs	r0, r5
	module->isConnected = false;
   211aa:	7023      	strb	r3, [r4, #0]
}
   211ac:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
   211ae:	46c0      	nop			; (mov r8, r8)
   211b0:	00020d09 	.word	0x00020d09

000211b4 <mqtt_publish>:

int mqtt_publish(struct mqtt_module *const module, const char *topic, const char *msg, uint32_t msg_len, uint8_t qos, uint8_t retain)
{
   211b4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   211b6:	0004      	movs	r4, r0
	int rc;
	MQTTMessage mqttMsg;	
	
	mqttMsg.qos = qos;
   211b8:	466e      	mov	r6, sp
{
   211ba:	a808      	add	r0, sp, #32
   211bc:	7805      	ldrb	r5, [r0, #0]
   211be:	a809      	add	r0, sp, #36	; 0x24
   211c0:	7800      	ldrb	r0, [r0, #0]
	mqttMsg.payload = (char *)msg;
   211c2:	9202      	str	r2, [sp, #8]
	mqttMsg.payloadlen = (size_t)msg_len;
   211c4:	9303      	str	r3, [sp, #12]
	mqttMsg.retained = retain;
   211c6:	7070      	strb	r0, [r6, #1]
	
	rc = MQTTPublish(module->client, topic, &mqttMsg);
   211c8:	4b07      	ldr	r3, [pc, #28]	; (211e8 <mqtt_publish+0x34>)
   211ca:	466a      	mov	r2, sp
   211cc:	69e0      	ldr	r0, [r4, #28]
	mqttMsg.qos = qos;
   211ce:	7035      	strb	r5, [r6, #0]
	rc = MQTTPublish(module->client, topic, &mqttMsg);
   211d0:	4798      	blx	r3
	
	if(module->callback)
   211d2:	6823      	ldr	r3, [r4, #0]
	rc = MQTTPublish(module->client, topic, &mqttMsg);
   211d4:	0005      	movs	r5, r0
	if(module->callback)
   211d6:	2b00      	cmp	r3, #0
   211d8:	d003      	beq.n	211e2 <mqtt_publish+0x2e>
		module->callback(module, MQTT_CALLBACK_PUBLISHED, NULL);
   211da:	2200      	movs	r2, #0
   211dc:	2102      	movs	r1, #2
   211de:	0020      	movs	r0, r4
   211e0:	4798      	blx	r3
	
	return rc;
}
   211e2:	0028      	movs	r0, r5
   211e4:	b004      	add	sp, #16
   211e6:	bd70      	pop	{r4, r5, r6, pc}
   211e8:	00020c21 	.word	0x00020c21

000211ec <mqtt_subscribe>:

int mqtt_subscribe(struct mqtt_module *module, const char *topic, uint8_t qos, messageHandler msgHandler)
{
   211ec:	b570      	push	{r4, r5, r6, lr}
   211ee:	0004      	movs	r4, r0
	int rc;
	
	rc = MQTTSubscribe(module->client, topic, qos, msgHandler);
   211f0:	4d06      	ldr	r5, [pc, #24]	; (2120c <mqtt_subscribe+0x20>)
   211f2:	69c0      	ldr	r0, [r0, #28]
   211f4:	47a8      	blx	r5
	
	if(module->callback)
   211f6:	6823      	ldr	r3, [r4, #0]
	rc = MQTTSubscribe(module->client, topic, qos, msgHandler);
   211f8:	0005      	movs	r5, r0
	if(module->callback)
   211fa:	2b00      	cmp	r3, #0
   211fc:	d003      	beq.n	21206 <mqtt_subscribe+0x1a>
		module->callback(module, MQTT_CALLBACK_SUBSCRIBED, NULL);	
   211fe:	2200      	movs	r2, #0
   21200:	2103      	movs	r1, #3
   21202:	0020      	movs	r0, r4
   21204:	4798      	blx	r3
	
	return rc;
}
   21206:	0028      	movs	r0, r5
   21208:	bd70      	pop	{r4, r5, r6, pc}
   2120a:	46c0      	nop			; (mov r8, r8)
   2120c:	00020b45 	.word	0x00020b45

00021210 <mqtt_yield>:
	
	return rc;
}

int mqtt_yield(struct mqtt_module *module, int timeout_ms)
{
   21210:	b510      	push	{r4, lr}
	return MQTTYield(module->client, timeout_ms);
   21212:	4b02      	ldr	r3, [pc, #8]	; (2121c <mqtt_yield+0xc>)
   21214:	69c0      	ldr	r0, [r0, #28]
   21216:	4798      	blx	r3
   21218:	bd10      	pop	{r4, pc}
   2121a:	46c0      	nop			; (mov r8, r8)
   2121c:	00020a1d 	.word	0x00020a1d

00021220 <MQTTSerialize_connectLength>:
  * Determines the length of the MQTT connect packet that would be produced using the supplied connect options.
  * @param options the options to be used to build the connect packet
  * @return the length of buffer needed to contain the serialized version of the packet
  */
int MQTTSerialize_connectLength(MQTTPacket_connectData* options)
{
   21220:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int len = 0;

	FUNC_ENTRY;

	if (options->MQTTVersion == 3)
   21222:	7a03      	ldrb	r3, [r0, #8]
{
   21224:	0004      	movs	r4, r0
		len = 12; /* variable depending on MQTT or MQIsdp */
   21226:	270c      	movs	r7, #12
	if (options->MQTTVersion == 3)
   21228:	2b03      	cmp	r3, #3
   2122a:	d003      	beq.n	21234 <MQTTSerialize_connectLength+0x14>
	int len = 0;
   2122c:	2700      	movs	r7, #0
	else if (options->MQTTVersion == 4)
   2122e:	2b04      	cmp	r3, #4
   21230:	d100      	bne.n	21234 <MQTTSerialize_connectLength+0x14>
		len = 10;
   21232:	370a      	adds	r7, #10

	len += MQTTstrlen(options->clientID)+2;
   21234:	68e0      	ldr	r0, [r4, #12]
   21236:	6921      	ldr	r1, [r4, #16]
   21238:	6962      	ldr	r2, [r4, #20]
   2123a:	4e16      	ldr	r6, [pc, #88]	; (21294 <MQTTSerialize_connectLength+0x74>)
   2123c:	47b0      	blx	r6
	if (options->willFlag)
   2123e:	7ee3      	ldrb	r3, [r4, #27]
	len += MQTTstrlen(options->clientID)+2;
   21240:	1c85      	adds	r5, r0, #2
   21242:	19ed      	adds	r5, r5, r7
	if (options->willFlag)
   21244:	2b00      	cmp	r3, #0
   21246:	d00b      	beq.n	21260 <MQTTSerialize_connectLength+0x40>
		len += MQTTstrlen(options->will.topicName)+2 + MQTTstrlen(options->will.message)+2;
   21248:	6aa1      	ldr	r1, [r4, #40]	; 0x28
   2124a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   2124c:	6a60      	ldr	r0, [r4, #36]	; 0x24
   2124e:	47b0      	blx	r6
   21250:	6b61      	ldr	r1, [r4, #52]	; 0x34
   21252:	0007      	movs	r7, r0
   21254:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   21256:	6b20      	ldr	r0, [r4, #48]	; 0x30
   21258:	47b0      	blx	r6
   2125a:	183f      	adds	r7, r7, r0
   2125c:	3704      	adds	r7, #4
   2125e:	19ed      	adds	r5, r5, r7
	if (options->username.cstring || options->username.lenstring.data)
   21260:	6c23      	ldr	r3, [r4, #64]	; 0x40
   21262:	2b00      	cmp	r3, #0
   21264:	d102      	bne.n	2126c <MQTTSerialize_connectLength+0x4c>
   21266:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   21268:	2b00      	cmp	r3, #0
   2126a:	d005      	beq.n	21278 <MQTTSerialize_connectLength+0x58>
		len += MQTTstrlen(options->username)+2;
   2126c:	6c20      	ldr	r0, [r4, #64]	; 0x40
   2126e:	6c61      	ldr	r1, [r4, #68]	; 0x44
   21270:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   21272:	47b0      	blx	r6
   21274:	3002      	adds	r0, #2
   21276:	182d      	adds	r5, r5, r0
	if (options->password.cstring || options->password.lenstring.data)
   21278:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   2127a:	2b00      	cmp	r3, #0
   2127c:	d102      	bne.n	21284 <MQTTSerialize_connectLength+0x64>
   2127e:	6d63      	ldr	r3, [r4, #84]	; 0x54
   21280:	2b00      	cmp	r3, #0
   21282:	d004      	beq.n	2128e <MQTTSerialize_connectLength+0x6e>
		len += MQTTstrlen(options->password)+2;
   21284:	344c      	adds	r4, #76	; 0x4c
   21286:	cc07      	ldmia	r4!, {r0, r1, r2}
   21288:	47b0      	blx	r6
   2128a:	3002      	adds	r0, #2
   2128c:	182d      	adds	r5, r5, r0

	FUNC_EXIT_RC(len);
	return len;
}
   2128e:	0028      	movs	r0, r5
   21290:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   21292:	46c0      	nop			; (mov r8, r8)
   21294:	0002173d 	.word	0x0002173d

00021298 <MQTTSerialize_connect>:
  * @param len the length in bytes of the supplied buffer
  * @param options the options to be used to build the connect packet
  * @return serialized length, or error if 0
  */
int MQTTSerialize_connect(unsigned char* buf, int buflen, MQTTPacket_connectData* options)
{
   21298:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	MQTTConnectFlags flags = {0};
	int len = 0;
	int rc = -1;

	FUNC_ENTRY;
	if (MQTTPacket_len(len = MQTTSerialize_connectLength(options)) > buflen)
   2129a:	4b41      	ldr	r3, [pc, #260]	; (213a0 <MQTTSerialize_connect+0x108>)
	unsigned char *ptr = buf;
   2129c:	9001      	str	r0, [sp, #4]
{
   2129e:	0005      	movs	r5, r0
	if (MQTTPacket_len(len = MQTTSerialize_connectLength(options)) > buflen)
   212a0:	0010      	movs	r0, r2
{
   212a2:	000e      	movs	r6, r1
   212a4:	0014      	movs	r4, r2
	if (MQTTPacket_len(len = MQTTSerialize_connectLength(options)) > buflen)
   212a6:	4798      	blx	r3
   212a8:	4b3e      	ldr	r3, [pc, #248]	; (213a4 <MQTTSerialize_connect+0x10c>)
   212aa:	0007      	movs	r7, r0
   212ac:	4798      	blx	r3
   212ae:	42b0      	cmp	r0, r6
   212b0:	dd00      	ble.n	212b4 <MQTTSerialize_connect+0x1c>
   212b2:	e071      	b.n	21398 <MQTTSerialize_connect+0x100>
		goto exit;
	}

	header.byte = 0;
	header.bits.type = CONNECT;
	writeChar(&ptr, header.byte); /* write header */
   212b4:	2110      	movs	r1, #16
   212b6:	a801      	add	r0, sp, #4
   212b8:	4e3b      	ldr	r6, [pc, #236]	; (213a8 <MQTTSerialize_connect+0x110>)
   212ba:	47b0      	blx	r6

	ptr += MQTTPacket_encode(ptr, len); /* write remaining length */
   212bc:	0039      	movs	r1, r7
   212be:	4b3b      	ldr	r3, [pc, #236]	; (213ac <MQTTSerialize_connect+0x114>)
   212c0:	9801      	ldr	r0, [sp, #4]
   212c2:	4798      	blx	r3
   212c4:	9b01      	ldr	r3, [sp, #4]
   212c6:	1818      	adds	r0, r3, r0
   212c8:	9001      	str	r0, [sp, #4]

	if (options->MQTTVersion == 4)
   212ca:	7a27      	ldrb	r7, [r4, #8]
   212cc:	4b38      	ldr	r3, [pc, #224]	; (213b0 <MQTTSerialize_connect+0x118>)
   212ce:	2f04      	cmp	r7, #4
   212d0:	d15d      	bne.n	2138e <MQTTSerialize_connect+0xf6>
	{
		writeCString(&ptr, "MQTT");
   212d2:	4938      	ldr	r1, [pc, #224]	; (213b4 <MQTTSerialize_connect+0x11c>)
   212d4:	a801      	add	r0, sp, #4
   212d6:	4798      	blx	r3
		writeChar(&ptr, (char) 4);
   212d8:	0039      	movs	r1, r7
	}
	else
	{
		writeCString(&ptr, "MQIsdp");
		writeChar(&ptr, (char) 3);
   212da:	a801      	add	r0, sp, #4
   212dc:	47b0      	blx	r6
	}

	flags.all = 0;
	flags.bits.cleansession = options->cleansession;
   212de:	2201      	movs	r2, #1
	flags.bits.will = (options->willFlag) ? 1 : 0;
   212e0:	7ee3      	ldrb	r3, [r4, #27]
	flags.bits.cleansession = options->cleansession;
   212e2:	7ea1      	ldrb	r1, [r4, #26]
	flags.bits.will = (options->willFlag) ? 1 : 0;
   212e4:	1e58      	subs	r0, r3, #1
   212e6:	4183      	sbcs	r3, r0
	flags.bits.cleansession = options->cleansession;
   212e8:	4011      	ands	r1, r2
	flags.bits.will = (options->willFlag) ? 1 : 0;
   212ea:	4091      	lsls	r1, r2
   212ec:	4013      	ands	r3, r2
   212ee:	009b      	lsls	r3, r3, #2
   212f0:	4319      	orrs	r1, r3
	if (flags.bits.will)
   212f2:	2b00      	cmp	r3, #0
   212f4:	d00c      	beq.n	21310 <MQTTSerialize_connect+0x78>
	{
		flags.bits.willQoS = options->will.qos;
   212f6:	0023      	movs	r3, r4
   212f8:	2003      	movs	r0, #3
   212fa:	333d      	adds	r3, #61	; 0x3d
   212fc:	781b      	ldrb	r3, [r3, #0]
   212fe:	4003      	ands	r3, r0
   21300:	4083      	lsls	r3, r0
		flags.bits.willRetain = options->will.retained;
   21302:	0020      	movs	r0, r4
   21304:	303c      	adds	r0, #60	; 0x3c
   21306:	7800      	ldrb	r0, [r0, #0]
   21308:	4319      	orrs	r1, r3
   2130a:	4002      	ands	r2, r0
   2130c:	0152      	lsls	r2, r2, #5
   2130e:	4311      	orrs	r1, r2
	}

	if (options->username.cstring || options->username.lenstring.data)
   21310:	6c23      	ldr	r3, [r4, #64]	; 0x40
   21312:	2b00      	cmp	r3, #0
   21314:	d102      	bne.n	2131c <MQTTSerialize_connect+0x84>
   21316:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   21318:	2b00      	cmp	r3, #0
   2131a:	d001      	beq.n	21320 <MQTTSerialize_connect+0x88>
		flags.bits.username = 1;
   2131c:	2380      	movs	r3, #128	; 0x80
   2131e:	4319      	orrs	r1, r3
	if (options->password.cstring || options->password.lenstring.data)
   21320:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   21322:	2b00      	cmp	r3, #0
   21324:	d102      	bne.n	2132c <MQTTSerialize_connect+0x94>
   21326:	6d63      	ldr	r3, [r4, #84]	; 0x54
   21328:	2b00      	cmp	r3, #0
   2132a:	d001      	beq.n	21330 <MQTTSerialize_connect+0x98>
		flags.bits.password = 1;
   2132c:	2340      	movs	r3, #64	; 0x40
   2132e:	4319      	orrs	r1, r3

	writeChar(&ptr, flags.all);
   21330:	b2ce      	uxtb	r6, r1
   21332:	0031      	movs	r1, r6
   21334:	a801      	add	r0, sp, #4
   21336:	4b1c      	ldr	r3, [pc, #112]	; (213a8 <MQTTSerialize_connect+0x110>)
   21338:	4798      	blx	r3
	writeInt(&ptr, options->keepAliveInterval);
   2133a:	8b21      	ldrh	r1, [r4, #24]
   2133c:	a801      	add	r0, sp, #4
   2133e:	4b1e      	ldr	r3, [pc, #120]	; (213b8 <MQTTSerialize_connect+0x120>)
   21340:	4798      	blx	r3
	writeMQTTString(&ptr, options->clientID);
   21342:	6963      	ldr	r3, [r4, #20]
   21344:	68e1      	ldr	r1, [r4, #12]
   21346:	6922      	ldr	r2, [r4, #16]
   21348:	a801      	add	r0, sp, #4
   2134a:	4f1c      	ldr	r7, [pc, #112]	; (213bc <MQTTSerialize_connect+0x124>)
   2134c:	47b8      	blx	r7
	if (options->willFlag)
   2134e:	7ee3      	ldrb	r3, [r4, #27]
   21350:	2b00      	cmp	r3, #0
   21352:	d009      	beq.n	21368 <MQTTSerialize_connect+0xd0>
	{
		writeMQTTString(&ptr, options->will.topicName);
   21354:	6a61      	ldr	r1, [r4, #36]	; 0x24
   21356:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   21358:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   2135a:	a801      	add	r0, sp, #4
   2135c:	47b8      	blx	r7
		writeMQTTString(&ptr, options->will.message);
   2135e:	6b21      	ldr	r1, [r4, #48]	; 0x30
   21360:	6b62      	ldr	r2, [r4, #52]	; 0x34
   21362:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   21364:	a801      	add	r0, sp, #4
   21366:	47b8      	blx	r7
	}
	if (flags.bits.username)
   21368:	b273      	sxtb	r3, r6
   2136a:	2b00      	cmp	r3, #0
   2136c:	da05      	bge.n	2137a <MQTTSerialize_connect+0xe2>
		writeMQTTString(&ptr, options->username);
   2136e:	6c21      	ldr	r1, [r4, #64]	; 0x40
   21370:	6c62      	ldr	r2, [r4, #68]	; 0x44
   21372:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   21374:	a801      	add	r0, sp, #4
   21376:	4f11      	ldr	r7, [pc, #68]	; (213bc <MQTTSerialize_connect+0x124>)
   21378:	47b8      	blx	r7
	if (flags.bits.password)
   2137a:	0673      	lsls	r3, r6, #25
   2137c:	d504      	bpl.n	21388 <MQTTSerialize_connect+0xf0>
		writeMQTTString(&ptr, options->password);
   2137e:	344c      	adds	r4, #76	; 0x4c
   21380:	cc0e      	ldmia	r4!, {r1, r2, r3}
   21382:	a801      	add	r0, sp, #4
   21384:	4c0d      	ldr	r4, [pc, #52]	; (213bc <MQTTSerialize_connect+0x124>)
   21386:	47a0      	blx	r4

	rc = ptr - buf;
   21388:	9b01      	ldr	r3, [sp, #4]
   2138a:	1b58      	subs	r0, r3, r5

	exit: FUNC_EXIT_RC(rc);
	return rc;
}
   2138c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		writeCString(&ptr, "MQIsdp");
   2138e:	490c      	ldr	r1, [pc, #48]	; (213c0 <MQTTSerialize_connect+0x128>)
   21390:	a801      	add	r0, sp, #4
   21392:	4798      	blx	r3
		writeChar(&ptr, (char) 3);
   21394:	2103      	movs	r1, #3
   21396:	e7a0      	b.n	212da <MQTTSerialize_connect+0x42>
		rc = MQTTPACKET_BUFFER_TOO_SHORT;
   21398:	2002      	movs	r0, #2
   2139a:	4240      	negs	r0, r0
	return rc;
   2139c:	e7f6      	b.n	2138c <MQTTSerialize_connect+0xf4>
   2139e:	46c0      	nop			; (mov r8, r8)
   213a0:	00021221 	.word	0x00021221
   213a4:	000215e9 	.word	0x000215e9
   213a8:	0002164b 	.word	0x0002164b
   213ac:	0002156d 	.word	0x0002156d
   213b0:	0002168d 	.word	0x0002168d
   213b4:	0002b308 	.word	0x0002b308
   213b8:	00021659 	.word	0x00021659
   213bc:	000216c1 	.word	0x000216c1
   213c0:	0002b30d 	.word	0x0002b30d

000213c4 <MQTTDeserialize_connack>:
  * @param buf the raw buffer data, of the correct length determined by the remaining length field
  * @param len the length in bytes of the data in the supplied buffer
  * @return error code.  1 is success, 0 is failure
  */
int MQTTDeserialize_connack(unsigned char* sessionPresent, unsigned char* connack_rc, unsigned char* buf, int buflen)
{
   213c4:	b573      	push	{r0, r1, r4, r5, r6, lr}
   213c6:	0006      	movs	r6, r0
	int rc = 0;
	int mylen;
	MQTTConnackFlags flags = {0};

	FUNC_ENTRY;
	header.byte = readChar(&curdata);
   213c8:	4c0e      	ldr	r4, [pc, #56]	; (21404 <MQTTDeserialize_connack+0x40>)
   213ca:	4668      	mov	r0, sp
{
   213cc:	000d      	movs	r5, r1
	unsigned char* curdata = buf;
   213ce:	9200      	str	r2, [sp, #0]
	header.byte = readChar(&curdata);
   213d0:	47a0      	blx	r4
	if (header.bits.type != CONNACK)
   213d2:	23f0      	movs	r3, #240	; 0xf0
   213d4:	4003      	ands	r3, r0
	int rc = 0;
   213d6:	2000      	movs	r0, #0
	if (header.bits.type != CONNACK)
   213d8:	2b20      	cmp	r3, #32
   213da:	d112      	bne.n	21402 <MQTTDeserialize_connack+0x3e>
		goto exit;

	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
   213dc:	4b0a      	ldr	r3, [pc, #40]	; (21408 <MQTTDeserialize_connack+0x44>)
   213de:	a901      	add	r1, sp, #4
   213e0:	9800      	ldr	r0, [sp, #0]
   213e2:	4798      	blx	r3
   213e4:	9b00      	ldr	r3, [sp, #0]
   213e6:	181b      	adds	r3, r3, r0
   213e8:	9300      	str	r3, [sp, #0]
	enddata = curdata + mylen;
	if (enddata - curdata < 2)
   213ea:	9b01      	ldr	r3, [sp, #4]
   213ec:	2b01      	cmp	r3, #1
   213ee:	dd08      	ble.n	21402 <MQTTDeserialize_connack+0x3e>
		goto exit;

	flags.all = readChar(&curdata);
   213f0:	4668      	mov	r0, sp
   213f2:	47a0      	blx	r4
	*sessionPresent = flags.bits.sessionpresent;
   213f4:	0600      	lsls	r0, r0, #24
   213f6:	0fc0      	lsrs	r0, r0, #31
   213f8:	7030      	strb	r0, [r6, #0]
	*connack_rc = readChar(&curdata);
   213fa:	4668      	mov	r0, sp
   213fc:	47a0      	blx	r4
   213fe:	7028      	strb	r0, [r5, #0]

	rc = 1;
   21400:	2001      	movs	r0, #1
exit:
	FUNC_EXIT_RC(rc);
	return rc;
}
   21402:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
   21404:	0002163f 	.word	0x0002163f
   21408:	00021611 	.word	0x00021611

0002140c <MQTTSerialize_zero>:
  * @param buflen the length in bytes of the supplied buffer, to avoid overruns
  * @param packettype the message type
  * @return serialized length, or error if 0
  */
int MQTTSerialize_zero(unsigned char* buf, int buflen, unsigned char packettype)
{
   2140c:	b513      	push	{r0, r1, r4, lr}
   2140e:	0004      	movs	r4, r0
	MQTTHeader header = {0};
	int rc = -1;
	unsigned char *ptr = buf;
   21410:	9001      	str	r0, [sp, #4]

	FUNC_ENTRY;
	if (buflen < 2)
   21412:	2901      	cmp	r1, #1
   21414:	dd0d      	ble.n	21432 <MQTTSerialize_zero+0x26>
	{
		rc = MQTTPACKET_BUFFER_TOO_SHORT;
		goto exit;
	}
	header.byte = 0;
	header.bits.type = packettype;
   21416:	210f      	movs	r1, #15
   21418:	4011      	ands	r1, r2
	writeChar(&ptr, header.byte); /* write header */
   2141a:	0109      	lsls	r1, r1, #4
   2141c:	a801      	add	r0, sp, #4
   2141e:	4b06      	ldr	r3, [pc, #24]	; (21438 <MQTTSerialize_zero+0x2c>)
   21420:	4798      	blx	r3

	ptr += MQTTPacket_encode(ptr, 0); /* write remaining length */
   21422:	4b06      	ldr	r3, [pc, #24]	; (2143c <MQTTSerialize_zero+0x30>)
   21424:	2100      	movs	r1, #0
   21426:	9801      	ldr	r0, [sp, #4]
   21428:	4798      	blx	r3
   2142a:	9b01      	ldr	r3, [sp, #4]
   2142c:	1818      	adds	r0, r3, r0
	rc = ptr - buf;
   2142e:	1b00      	subs	r0, r0, r4
exit:
	FUNC_EXIT_RC(rc);
	return rc;
}
   21430:	bd16      	pop	{r1, r2, r4, pc}
		rc = MQTTPACKET_BUFFER_TOO_SHORT;
   21432:	2002      	movs	r0, #2
   21434:	4240      	negs	r0, r0
	return rc;
   21436:	e7fb      	b.n	21430 <MQTTSerialize_zero+0x24>
   21438:	0002164b 	.word	0x0002164b
   2143c:	0002156d 	.word	0x0002156d

00021440 <MQTTSerialize_disconnect>:
  * @param buf the buffer into which the packet will be serialized
  * @param buflen the length in bytes of the supplied buffer, to avoid overruns
  * @return serialized length, or error if 0
  */
int MQTTSerialize_disconnect(unsigned char* buf, int buflen)
{
   21440:	b510      	push	{r4, lr}
	return MQTTSerialize_zero(buf, buflen, DISCONNECT);
   21442:	220e      	movs	r2, #14
   21444:	4b01      	ldr	r3, [pc, #4]	; (2144c <MQTTSerialize_disconnect+0xc>)
   21446:	4798      	blx	r3
}
   21448:	bd10      	pop	{r4, pc}
   2144a:	46c0      	nop			; (mov r8, r8)
   2144c:	0002140d 	.word	0x0002140d

00021450 <MQTTSerialize_pingreq>:
  * @param buf the buffer into which the packet will be serialized
  * @param buflen the length in bytes of the supplied buffer, to avoid overruns
  * @return serialized length, or error if 0
  */
int MQTTSerialize_pingreq(unsigned char* buf, int buflen)
{
   21450:	b510      	push	{r4, lr}
	return MQTTSerialize_zero(buf, buflen, PINGREQ);
   21452:	220c      	movs	r2, #12
   21454:	4b01      	ldr	r3, [pc, #4]	; (2145c <MQTTSerialize_pingreq+0xc>)
   21456:	4798      	blx	r3
}
   21458:	bd10      	pop	{r4, pc}
   2145a:	46c0      	nop			; (mov r8, r8)
   2145c:	0002140d 	.word	0x0002140d

00021460 <MQTTDeserialize_publish>:
  * @param buflen the length in bytes of the data in the supplied buffer
  * @return error code.  1 is success
  */
int MQTTDeserialize_publish(unsigned char* dup, int* qos, unsigned char* retained, unsigned short* packetid, MQTTString* topicName,
		unsigned char** payload, int* payloadlen, unsigned char* buf, int buflen)
{
   21460:	b5f0      	push	{r4, r5, r6, r7, lr}
	MQTTHeader header = {0};
	unsigned char* curdata = buf;
	unsigned char* enddata = NULL;
	int rc = 0;
	int mylen = 0;
   21462:	2400      	movs	r4, #0
{
   21464:	b085      	sub	sp, #20
   21466:	9301      	str	r3, [sp, #4]
	unsigned char* curdata = buf;
   21468:	9b0d      	ldr	r3, [sp, #52]	; 0x34
{
   2146a:	0007      	movs	r7, r0
	unsigned char* curdata = buf;
   2146c:	9302      	str	r3, [sp, #8]

	FUNC_ENTRY;
	header.byte = readChar(&curdata);
   2146e:	a802      	add	r0, sp, #8
   21470:	4b1b      	ldr	r3, [pc, #108]	; (214e0 <MQTTDeserialize_publish+0x80>)
{
   21472:	000d      	movs	r5, r1
   21474:	0016      	movs	r6, r2
	int mylen = 0;
   21476:	9403      	str	r4, [sp, #12]
	header.byte = readChar(&curdata);
   21478:	4798      	blx	r3
	if (header.bits.type != PUBLISH)
   2147a:	23f0      	movs	r3, #240	; 0xf0
   2147c:	4003      	ands	r3, r0
   2147e:	2b30      	cmp	r3, #48	; 0x30
   21480:	d12b      	bne.n	214da <MQTTDeserialize_publish+0x7a>
		goto exit;
	*dup = header.bits.dup;
   21482:	0703      	lsls	r3, r0, #28
   21484:	0fdb      	lsrs	r3, r3, #31
   21486:	703b      	strb	r3, [r7, #0]
	*qos = header.bits.qos;
   21488:	0743      	lsls	r3, r0, #29
	*retained = header.bits.retain;
   2148a:	07c0      	lsls	r0, r0, #31
	*qos = header.bits.qos;
   2148c:	0f9b      	lsrs	r3, r3, #30
	*retained = header.bits.retain;
   2148e:	0fc0      	lsrs	r0, r0, #31
	*qos = header.bits.qos;
   21490:	602b      	str	r3, [r5, #0]

	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
   21492:	a903      	add	r1, sp, #12
	*retained = header.bits.retain;
   21494:	7030      	strb	r0, [r6, #0]
	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
   21496:	4b13      	ldr	r3, [pc, #76]	; (214e4 <MQTTDeserialize_publish+0x84>)
   21498:	9802      	ldr	r0, [sp, #8]
   2149a:	4798      	blx	r3
   2149c:	9b02      	ldr	r3, [sp, #8]
   2149e:	0004      	movs	r4, r0
   214a0:	181e      	adds	r6, r3, r0
	enddata = curdata + mylen;
   214a2:	9b03      	ldr	r3, [sp, #12]
	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
   214a4:	9602      	str	r6, [sp, #8]
	enddata = curdata + mylen;
   214a6:	18f6      	adds	r6, r6, r3

	if (!readMQTTLenString(topicName, &curdata, enddata) ||
   214a8:	0032      	movs	r2, r6
   214aa:	a902      	add	r1, sp, #8
   214ac:	980a      	ldr	r0, [sp, #40]	; 0x28
   214ae:	4b0e      	ldr	r3, [pc, #56]	; (214e8 <MQTTDeserialize_publish+0x88>)
   214b0:	4798      	blx	r3
   214b2:	2800      	cmp	r0, #0
   214b4:	d011      	beq.n	214da <MQTTDeserialize_publish+0x7a>
		enddata - curdata < 0) /* do we have enough data to read the protocol version byte? */
   214b6:	9b02      	ldr	r3, [sp, #8]
   214b8:	1af3      	subs	r3, r6, r3
	if (!readMQTTLenString(topicName, &curdata, enddata) ||
   214ba:	d40e      	bmi.n	214da <MQTTDeserialize_publish+0x7a>
		goto exit;

	if (*qos > 0)
   214bc:	682b      	ldr	r3, [r5, #0]
   214be:	2b00      	cmp	r3, #0
   214c0:	dd04      	ble.n	214cc <MQTTDeserialize_publish+0x6c>
		*packetid = readInt(&curdata);
   214c2:	4b0a      	ldr	r3, [pc, #40]	; (214ec <MQTTDeserialize_publish+0x8c>)
   214c4:	a802      	add	r0, sp, #8
   214c6:	4798      	blx	r3
   214c8:	9b01      	ldr	r3, [sp, #4]
   214ca:	8018      	strh	r0, [r3, #0]

	*payloadlen = enddata - curdata;
	*payload = curdata;
	rc = 1;
   214cc:	2401      	movs	r4, #1
	*payloadlen = enddata - curdata;
   214ce:	9b02      	ldr	r3, [sp, #8]
   214d0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   214d2:	1af6      	subs	r6, r6, r3
   214d4:	6016      	str	r6, [r2, #0]
	*payload = curdata;
   214d6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   214d8:	6013      	str	r3, [r2, #0]
exit:
	FUNC_EXIT_RC(rc);
	return rc;
}
   214da:	0020      	movs	r0, r4
   214dc:	b005      	add	sp, #20
   214de:	bdf0      	pop	{r4, r5, r6, r7, pc}
   214e0:	0002163f 	.word	0x0002163f
   214e4:	00021611 	.word	0x00021611
   214e8:	00021705 	.word	0x00021705
   214ec:	0002162d 	.word	0x0002162d

000214f0 <MQTTDeserialize_ack>:
  * @param buf the raw buffer data, of the correct length determined by the remaining length field
  * @param buflen the length in bytes of the data in the supplied buffer
  * @return error code.  1 is success, 0 is failure
  */
int MQTTDeserialize_ack(unsigned char* packettype, unsigned char* dup, unsigned short* packetid, unsigned char* buf, int buflen)
{
   214f0:	b573      	push	{r0, r1, r4, r5, r6, lr}
   214f2:	0005      	movs	r5, r0
	MQTTHeader header = {0};
	unsigned char* curdata = buf;
   214f4:	9300      	str	r3, [sp, #0]
	unsigned char* enddata = NULL;
	int rc = 0;
	int mylen;

	FUNC_ENTRY;
	header.byte = readChar(&curdata);
   214f6:	4668      	mov	r0, sp
   214f8:	4b0c      	ldr	r3, [pc, #48]	; (2152c <MQTTDeserialize_ack+0x3c>)
{
   214fa:	000e      	movs	r6, r1
   214fc:	0014      	movs	r4, r2
	header.byte = readChar(&curdata);
   214fe:	4798      	blx	r3
	*dup = header.bits.dup;
   21500:	0703      	lsls	r3, r0, #28
	*packettype = header.bits.type;
   21502:	0600      	lsls	r0, r0, #24
	*dup = header.bits.dup;
   21504:	0fdb      	lsrs	r3, r3, #31
	*packettype = header.bits.type;
   21506:	0f00      	lsrs	r0, r0, #28
	*dup = header.bits.dup;
   21508:	7033      	strb	r3, [r6, #0]

	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
   2150a:	a901      	add	r1, sp, #4
	*packettype = header.bits.type;
   2150c:	7028      	strb	r0, [r5, #0]
	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
   2150e:	4b08      	ldr	r3, [pc, #32]	; (21530 <MQTTDeserialize_ack+0x40>)
   21510:	9800      	ldr	r0, [sp, #0]
   21512:	4798      	blx	r3
   21514:	9b00      	ldr	r3, [sp, #0]
   21516:	181b      	adds	r3, r3, r0
   21518:	9300      	str	r3, [sp, #0]
	enddata = curdata + mylen;

	if (enddata - curdata < 2)
   2151a:	9b01      	ldr	r3, [sp, #4]
   2151c:	2b01      	cmp	r3, #1
   2151e:	dd04      	ble.n	2152a <MQTTDeserialize_ack+0x3a>
		goto exit;
	*packetid = readInt(&curdata);
   21520:	4668      	mov	r0, sp
   21522:	4b04      	ldr	r3, [pc, #16]	; (21534 <MQTTDeserialize_ack+0x44>)
   21524:	4798      	blx	r3
   21526:	8020      	strh	r0, [r4, #0]

	rc = 1;
   21528:	2001      	movs	r0, #1
exit:
	FUNC_EXIT_RC(rc);
	return rc;
}
   2152a:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
   2152c:	0002163f 	.word	0x0002163f
   21530:	00021611 	.word	0x00021611
   21534:	0002162d 	.word	0x0002162d

00021538 <bufchar>:


static unsigned char* bufptr;

int bufchar(unsigned char* c, int count)
{
   21538:	b5f0      	push	{r4, r5, r6, r7, lr}
   2153a:	4c0b      	ldr	r4, [pc, #44]	; (21568 <bufchar+0x30>)
	int i;

	for (i = 0; i < count; ++i)
   2153c:	2500      	movs	r5, #0
   2153e:	6823      	ldr	r3, [r4, #0]
   21540:	2701      	movs	r7, #1
   21542:	001a      	movs	r2, r3
   21544:	1ad6      	subs	r6, r2, r3
   21546:	42b1      	cmp	r1, r6
   21548:	dc08      	bgt.n	2155c <bufchar+0x24>
   2154a:	43ca      	mvns	r2, r1
   2154c:	17d2      	asrs	r2, r2, #31
   2154e:	400a      	ands	r2, r1
   21550:	189b      	adds	r3, r3, r2
   21552:	2d00      	cmp	r5, #0
   21554:	d000      	beq.n	21558 <bufchar+0x20>
   21556:	6023      	str	r3, [r4, #0]
		*c = *bufptr++;
	return count;
}
   21558:	0008      	movs	r0, r1
   2155a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		*c = *bufptr++;
   2155c:	7815      	ldrb	r5, [r2, #0]
   2155e:	3201      	adds	r2, #1
   21560:	7005      	strb	r5, [r0, #0]
   21562:	003d      	movs	r5, r7
   21564:	e7ee      	b.n	21544 <bufchar+0xc>
   21566:	46c0      	nop			; (mov r8, r8)
   21568:	200041c4 	.word	0x200041c4

0002156c <MQTTPacket_encode>:
{
   2156c:	b5f0      	push	{r4, r5, r6, r7, lr}
		char d = length % 128;
   2156e:	2480      	movs	r4, #128	; 0x80
	int rc = 0;
   21570:	2200      	movs	r2, #0
		length /= 128;
   21572:	267f      	movs	r6, #127	; 0x7f
		char d = length % 128;
   21574:	4d0b      	ldr	r5, [pc, #44]	; (215a4 <MQTTPacket_encode+0x38>)
   21576:	4264      	negs	r4, r4
   21578:	000b      	movs	r3, r1
   2157a:	402b      	ands	r3, r5
   2157c:	d502      	bpl.n	21584 <MQTTPacket_encode+0x18>
   2157e:	3b01      	subs	r3, #1
   21580:	4323      	orrs	r3, r4
   21582:	3301      	adds	r3, #1
		length /= 128;
   21584:	17cf      	asrs	r7, r1, #31
   21586:	4037      	ands	r7, r6
   21588:	1879      	adds	r1, r7, r1
		char d = length % 128;
   2158a:	b2db      	uxtb	r3, r3
		length /= 128;
   2158c:	11c9      	asrs	r1, r1, #7
		if (length > 0)
   2158e:	2900      	cmp	r1, #0
   21590:	dd01      	ble.n	21596 <MQTTPacket_encode+0x2a>
			d |= 0x80;
   21592:	4323      	orrs	r3, r4
   21594:	b2db      	uxtb	r3, r3
		buf[rc++] = d;
   21596:	3201      	adds	r2, #1
   21598:	1e57      	subs	r7, r2, #1
   2159a:	55c3      	strb	r3, [r0, r7]
	} while (length > 0);
   2159c:	2900      	cmp	r1, #0
   2159e:	dceb      	bgt.n	21578 <MQTTPacket_encode+0xc>
}
   215a0:	0010      	movs	r0, r2
   215a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   215a4:	8000007f 	.word	0x8000007f

000215a8 <MQTTPacket_decode>:
{
   215a8:	b5f0      	push	{r4, r5, r6, r7, lr}
	*value = 0;
   215aa:	2400      	movs	r4, #0
{
   215ac:	000e      	movs	r6, r1
	int multiplier = 1;
   215ae:	2501      	movs	r5, #1
{
   215b0:	b085      	sub	sp, #20
   215b2:	9001      	str	r0, [sp, #4]
	*value = 0;
   215b4:	600c      	str	r4, [r1, #0]
		if (++len > MAX_NO_OF_REMAINING_LENGTH_BYTES)
   215b6:	3401      	adds	r4, #1
   215b8:	2c05      	cmp	r4, #5
   215ba:	d012      	beq.n	215e2 <MQTTPacket_decode+0x3a>
		rc = (*getcharfn)(&c, 1);
   215bc:	ab02      	add	r3, sp, #8
   215be:	1ddf      	adds	r7, r3, #7
   215c0:	2101      	movs	r1, #1
   215c2:	0038      	movs	r0, r7
   215c4:	9b01      	ldr	r3, [sp, #4]
   215c6:	4798      	blx	r3
		if (rc != 1)
   215c8:	2801      	cmp	r0, #1
   215ca:	d10a      	bne.n	215e2 <MQTTPacket_decode+0x3a>
		*value += (c & 127) * multiplier;
   215cc:	227f      	movs	r2, #127	; 0x7f
   215ce:	783b      	ldrb	r3, [r7, #0]
   215d0:	6831      	ldr	r1, [r6, #0]
   215d2:	401a      	ands	r2, r3
   215d4:	436a      	muls	r2, r5
	} while ((c & 128) != 0);
   215d6:	b25b      	sxtb	r3, r3
		*value += (c & 127) * multiplier;
   215d8:	188a      	adds	r2, r1, r2
   215da:	6032      	str	r2, [r6, #0]
		multiplier *= 128;
   215dc:	01ed      	lsls	r5, r5, #7
	} while ((c & 128) != 0);
   215de:	2b00      	cmp	r3, #0
   215e0:	dbe9      	blt.n	215b6 <MQTTPacket_decode+0xe>
}
   215e2:	0020      	movs	r0, r4
   215e4:	b005      	add	sp, #20
   215e6:	bdf0      	pop	{r4, r5, r6, r7, pc}

000215e8 <MQTTPacket_len>:
	rem_len += 1; /* header byte */
   215e8:	1c42      	adds	r2, r0, #1
{
   215ea:	0003      	movs	r3, r0
		rem_len += 1;
   215ec:	3002      	adds	r0, #2
	if (rem_len < 128)
   215ee:	2a7f      	cmp	r2, #127	; 0x7f
   215f0:	dd08      	ble.n	21604 <MQTTPacket_len+0x1c>
	else if (rem_len < 16384)
   215f2:	4905      	ldr	r1, [pc, #20]	; (21608 <MQTTPacket_len+0x20>)
		rem_len += 2;
   215f4:	1cd8      	adds	r0, r3, #3
	else if (rem_len < 16384)
   215f6:	428a      	cmp	r2, r1
   215f8:	dd04      	ble.n	21604 <MQTTPacket_len+0x1c>
	else if (rem_len < 2097151)
   215fa:	4904      	ldr	r1, [pc, #16]	; (2160c <MQTTPacket_len+0x24>)
		rem_len += 4;
   215fc:	1d58      	adds	r0, r3, #5
	else if (rem_len < 2097151)
   215fe:	428a      	cmp	r2, r1
   21600:	dc00      	bgt.n	21604 <MQTTPacket_len+0x1c>
		rem_len += 3;
   21602:	1d18      	adds	r0, r3, #4
}
   21604:	4770      	bx	lr
   21606:	46c0      	nop			; (mov r8, r8)
   21608:	00003fff 	.word	0x00003fff
   2160c:	001ffffe 	.word	0x001ffffe

00021610 <MQTTPacket_decodeBuf>:


int MQTTPacket_decodeBuf(unsigned char* buf, int* value)
{
   21610:	b510      	push	{r4, lr}
	bufptr = buf;
   21612:	4b03      	ldr	r3, [pc, #12]	; (21620 <MQTTPacket_decodeBuf+0x10>)
   21614:	6018      	str	r0, [r3, #0]
	return MQTTPacket_decode(bufchar, value);
   21616:	4803      	ldr	r0, [pc, #12]	; (21624 <MQTTPacket_decodeBuf+0x14>)
   21618:	4b03      	ldr	r3, [pc, #12]	; (21628 <MQTTPacket_decodeBuf+0x18>)
   2161a:	4798      	blx	r3
}
   2161c:	bd10      	pop	{r4, pc}
   2161e:	46c0      	nop			; (mov r8, r8)
   21620:	200041c4 	.word	0x200041c4
   21624:	00021539 	.word	0x00021539
   21628:	000215a9 	.word	0x000215a9

0002162c <readInt>:
 * Calculates an integer from two bytes read from the input buffer
 * @param pptr pointer to the input buffer - incremented by the number of bytes used & returned
 * @return the integer value calculated
 */
int readInt(unsigned char** pptr)
{
   2162c:	0001      	movs	r1, r0
	unsigned char* ptr = *pptr;
   2162e:	6802      	ldr	r2, [r0, #0]
	int len = 256*(*ptr) + (*(ptr+1));
   21630:	7813      	ldrb	r3, [r2, #0]
   21632:	7850      	ldrb	r0, [r2, #1]
   21634:	021b      	lsls	r3, r3, #8
	*pptr += 2;
   21636:	3202      	adds	r2, #2
	int len = 256*(*ptr) + (*(ptr+1));
   21638:	1818      	adds	r0, r3, r0
	*pptr += 2;
   2163a:	600a      	str	r2, [r1, #0]
	return len;
}
   2163c:	4770      	bx	lr

0002163e <readChar>:
 * Reads one character from the input buffer.
 * @param pptr pointer to the input buffer - incremented by the number of bytes used & returned
 * @return the character read
 */
char readChar(unsigned char** pptr)
{
   2163e:	0002      	movs	r2, r0
	char c = **pptr;
   21640:	6803      	ldr	r3, [r0, #0]
   21642:	7818      	ldrb	r0, [r3, #0]
	(*pptr)++;
   21644:	3301      	adds	r3, #1
   21646:	6013      	str	r3, [r2, #0]
	return c;
}
   21648:	4770      	bx	lr

0002164a <writeChar>:
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param c the character to write
 */
void writeChar(unsigned char** pptr, char c)
{
	**pptr = c;
   2164a:	6803      	ldr	r3, [r0, #0]
   2164c:	7019      	strb	r1, [r3, #0]
	(*pptr)++;
   2164e:	6803      	ldr	r3, [r0, #0]
   21650:	3301      	adds	r3, #1
   21652:	6003      	str	r3, [r0, #0]
}
   21654:	4770      	bx	lr
	...

00021658 <writeInt>:
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param anInt the integer to write
 */
void writeInt(unsigned char** pptr, int anInt)
{
	**pptr = (unsigned char)(anInt / 256);
   21658:	17cb      	asrs	r3, r1, #31
   2165a:	b2db      	uxtb	r3, r3
   2165c:	6802      	ldr	r2, [r0, #0]
   2165e:	185b      	adds	r3, r3, r1
   21660:	121b      	asrs	r3, r3, #8
   21662:	7013      	strb	r3, [r2, #0]
	(*pptr)++;
   21664:	6803      	ldr	r3, [r0, #0]
   21666:	1c5a      	adds	r2, r3, #1
   21668:	6002      	str	r2, [r0, #0]
	**pptr = (unsigned char)(anInt % 256);
   2166a:	4a06      	ldr	r2, [pc, #24]	; (21684 <writeInt+0x2c>)
   2166c:	4011      	ands	r1, r2
   2166e:	d503      	bpl.n	21678 <writeInt+0x20>
   21670:	4a05      	ldr	r2, [pc, #20]	; (21688 <writeInt+0x30>)
   21672:	3901      	subs	r1, #1
   21674:	4311      	orrs	r1, r2
   21676:	3101      	adds	r1, #1
   21678:	7059      	strb	r1, [r3, #1]
	(*pptr)++;
   2167a:	6803      	ldr	r3, [r0, #0]
   2167c:	3301      	adds	r3, #1
   2167e:	6003      	str	r3, [r0, #0]
}
   21680:	4770      	bx	lr
   21682:	46c0      	nop			; (mov r8, r8)
   21684:	800000ff 	.word	0x800000ff
   21688:	ffffff00 	.word	0xffffff00

0002168c <writeCString>:
 * Writes a "UTF" string to an output buffer.  Converts C string to length-delimited.
 * @param pptr pointer to the output buffer - incremented by the number of bytes used & returned
 * @param string the C string to write
 */
void writeCString(unsigned char** pptr, const char* string)
{
   2168c:	b570      	push	{r4, r5, r6, lr}
	int len = strlen(string);
   2168e:	4b09      	ldr	r3, [pc, #36]	; (216b4 <writeCString+0x28>)
{
   21690:	0004      	movs	r4, r0
	int len = strlen(string);
   21692:	0008      	movs	r0, r1
{
   21694:	000e      	movs	r6, r1
	int len = strlen(string);
   21696:	4798      	blx	r3
   21698:	0005      	movs	r5, r0
	writeInt(pptr, len);
   2169a:	0001      	movs	r1, r0
   2169c:	4b06      	ldr	r3, [pc, #24]	; (216b8 <writeCString+0x2c>)
   2169e:	0020      	movs	r0, r4
   216a0:	4798      	blx	r3
	memcpy(*pptr, string, len);
   216a2:	002a      	movs	r2, r5
   216a4:	0031      	movs	r1, r6
   216a6:	6820      	ldr	r0, [r4, #0]
   216a8:	4b04      	ldr	r3, [pc, #16]	; (216bc <writeCString+0x30>)
   216aa:	4798      	blx	r3
	*pptr += len;
   216ac:	6823      	ldr	r3, [r4, #0]
   216ae:	195d      	adds	r5, r3, r5
   216b0:	6025      	str	r5, [r4, #0]
}
   216b2:	bd70      	pop	{r4, r5, r6, pc}
   216b4:	000238c3 	.word	0x000238c3
   216b8:	00021659 	.word	0x00021659
   216bc:	00022c11 	.word	0x00022c11

000216c0 <writeMQTTString>:
	return len;
}


void writeMQTTString(unsigned char** pptr, MQTTString mqttstring)
{
   216c0:	b530      	push	{r4, r5, lr}
   216c2:	b085      	sub	sp, #20
   216c4:	0004      	movs	r4, r0
   216c6:	9101      	str	r1, [sp, #4]
   216c8:	9303      	str	r3, [sp, #12]
   216ca:	1e15      	subs	r5, r2, #0
	if (mqttstring.lenstring.len > 0)
   216cc:	dd0c      	ble.n	216e8 <writeMQTTString+0x28>
	{
		writeInt(pptr, mqttstring.lenstring.len);
   216ce:	0011      	movs	r1, r2
   216d0:	4b09      	ldr	r3, [pc, #36]	; (216f8 <writeMQTTString+0x38>)
   216d2:	4798      	blx	r3
		memcpy(*pptr, mqttstring.lenstring.data, mqttstring.lenstring.len);
   216d4:	002a      	movs	r2, r5
   216d6:	4b09      	ldr	r3, [pc, #36]	; (216fc <writeMQTTString+0x3c>)
   216d8:	9903      	ldr	r1, [sp, #12]
   216da:	6820      	ldr	r0, [r4, #0]
   216dc:	4798      	blx	r3
		*pptr += mqttstring.lenstring.len;
   216de:	6823      	ldr	r3, [r4, #0]
   216e0:	195d      	adds	r5, r3, r5
   216e2:	6025      	str	r5, [r4, #0]
	}
	else if (mqttstring.cstring)
		writeCString(pptr, mqttstring.cstring);
	else
		writeInt(pptr, 0);
}
   216e4:	b005      	add	sp, #20
   216e6:	bd30      	pop	{r4, r5, pc}
   216e8:	9901      	ldr	r1, [sp, #4]
		writeCString(pptr, mqttstring.cstring);
   216ea:	4b05      	ldr	r3, [pc, #20]	; (21700 <writeMQTTString+0x40>)
	else if (mqttstring.cstring)
   216ec:	2900      	cmp	r1, #0
   216ee:	d100      	bne.n	216f2 <writeMQTTString+0x32>
		writeInt(pptr, 0);
   216f0:	4b01      	ldr	r3, [pc, #4]	; (216f8 <writeMQTTString+0x38>)
   216f2:	4798      	blx	r3
}
   216f4:	e7f6      	b.n	216e4 <writeMQTTString+0x24>
   216f6:	46c0      	nop			; (mov r8, r8)
   216f8:	00021659 	.word	0x00021659
   216fc:	00022c11 	.word	0x00022c11
   21700:	0002168d 	.word	0x0002168d

00021704 <readMQTTLenString>:
{
	int rc = 0;

	FUNC_ENTRY;
	/* the first two bytes are the length of the string */
	if (enddata - (*pptr) > 1) /* enough length to read the integer? */
   21704:	680b      	ldr	r3, [r1, #0]
{
   21706:	b570      	push	{r4, r5, r6, lr}
	if (enddata - (*pptr) > 1) /* enough length to read the integer? */
   21708:	1ad3      	subs	r3, r2, r3
{
   2170a:	0005      	movs	r5, r0
   2170c:	000c      	movs	r4, r1
   2170e:	0016      	movs	r6, r2
	if (enddata - (*pptr) > 1) /* enough length to read the integer? */
   21710:	2b01      	cmp	r3, #1
   21712:	dc03      	bgt.n	2171c <readMQTTLenString+0x18>
	int rc = 0;
   21714:	2000      	movs	r0, #0
			mqttstring->lenstring.data = (char*)*pptr;
			*pptr += mqttstring->lenstring.len;
			rc = 1;
		}
	}
	mqttstring->cstring = NULL;
   21716:	2300      	movs	r3, #0
   21718:	602b      	str	r3, [r5, #0]
	FUNC_EXIT_RC(rc);
	return rc;
}
   2171a:	bd70      	pop	{r4, r5, r6, pc}
		mqttstring->lenstring.len = readInt(pptr); /* increments pptr to point past length */
   2171c:	4b06      	ldr	r3, [pc, #24]	; (21738 <readMQTTLenString+0x34>)
   2171e:	0008      	movs	r0, r1
   21720:	4798      	blx	r3
   21722:	6068      	str	r0, [r5, #4]
		if (&(*pptr)[mqttstring->lenstring.len] <= enddata)
   21724:	6823      	ldr	r3, [r4, #0]
   21726:	181a      	adds	r2, r3, r0
   21728:	4296      	cmp	r6, r2
   2172a:	d3f3      	bcc.n	21714 <readMQTTLenString+0x10>
			mqttstring->lenstring.data = (char*)*pptr;
   2172c:	60ab      	str	r3, [r5, #8]
			*pptr += mqttstring->lenstring.len;
   2172e:	6823      	ldr	r3, [r4, #0]
   21730:	1818      	adds	r0, r3, r0
   21732:	6020      	str	r0, [r4, #0]
			rc = 1;
   21734:	2001      	movs	r0, #1
   21736:	e7ee      	b.n	21716 <readMQTTLenString+0x12>
   21738:	0002162d 	.word	0x0002162d

0002173c <MQTTstrlen>:
 * Return the length of the MQTTstring - C string if there is one, otherwise the length delimited string
 * @param mqttstring the string to return the length of
 * @return the length of the string
 */
int MQTTstrlen(MQTTString mqttstring)
{
   2173c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   2173e:	9102      	str	r1, [sp, #8]
	int rc = 0;

	if (mqttstring.cstring)
   21740:	2800      	cmp	r0, #0
   21742:	d003      	beq.n	2174c <MQTTstrlen+0x10>
		rc = strlen(mqttstring.cstring);
   21744:	4b02      	ldr	r3, [pc, #8]	; (21750 <MQTTstrlen+0x14>)
   21746:	4798      	blx	r3
	else
		rc = mqttstring.lenstring.len;
	return rc;
}
   21748:	b005      	add	sp, #20
   2174a:	bd00      	pop	{pc}
		rc = mqttstring.lenstring.len;
   2174c:	9802      	ldr	r0, [sp, #8]
	return rc;
   2174e:	e7fb      	b.n	21748 <MQTTstrlen+0xc>
   21750:	000238c3 	.word	0x000238c3

00021754 <MQTTPacket_equals>:
 * @param a the MQTTString to compare
 * @param bptr the C string to compare
 * @return boolean - equal or not
 */
int MQTTPacket_equals(MQTTString* a, char* bptr)
{
   21754:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int alen = 0,
		blen = 0;
	char *aptr;
	
	if (a->cstring)
   21756:	6804      	ldr	r4, [r0, #0]
{
   21758:	000e      	movs	r6, r1
   2175a:	4f0c      	ldr	r7, [pc, #48]	; (2178c <MQTTPacket_equals+0x38>)
	if (a->cstring)
   2175c:	2c00      	cmp	r4, #0
   2175e:	d011      	beq.n	21784 <MQTTPacket_equals+0x30>
	{
		aptr = a->cstring;
		alen = strlen(a->cstring);
   21760:	0020      	movs	r0, r4
   21762:	47b8      	blx	r7
   21764:	0005      	movs	r5, r0
	else
	{
		aptr = a->lenstring.data;
		alen = a->lenstring.len;
	}
	blen = strlen(bptr);
   21766:	0030      	movs	r0, r6
   21768:	47b8      	blx	r7
   2176a:	0003      	movs	r3, r0
   2176c:	2000      	movs	r0, #0
	
	return (alen == blen) && (strncmp(aptr, bptr, alen) == 0);
   2176e:	429d      	cmp	r5, r3
   21770:	d107      	bne.n	21782 <MQTTPacket_equals+0x2e>
   21772:	4b07      	ldr	r3, [pc, #28]	; (21790 <MQTTPacket_equals+0x3c>)
   21774:	002a      	movs	r2, r5
   21776:	0031      	movs	r1, r6
   21778:	0020      	movs	r0, r4
   2177a:	4798      	blx	r3
   2177c:	4243      	negs	r3, r0
   2177e:	4158      	adcs	r0, r3
   21780:	b2c0      	uxtb	r0, r0
}
   21782:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		aptr = a->lenstring.data;
   21784:	6884      	ldr	r4, [r0, #8]
		alen = a->lenstring.len;
   21786:	6845      	ldr	r5, [r0, #4]
   21788:	e7ed      	b.n	21766 <MQTTPacket_equals+0x12>
   2178a:	46c0      	nop			; (mov r8, r8)
   2178c:	000238c3 	.word	0x000238c3
   21790:	000238d1 	.word	0x000238d1

00021794 <MQTTSerialize_publishLength>:
  * @param topicName the topic name to be used in the publish  
  * @param payloadlen the length of the payload to be sent
  * @return the length of buffer needed to contain the serialized version of the packet
  */
int MQTTSerialize_publishLength(int qos, MQTTString topicName, int payloadlen)
{
   21794:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   21796:	0004      	movs	r4, r0
	int len = 0;

	len += 2 + MQTTstrlen(topicName) + payloadlen;
   21798:	0008      	movs	r0, r1
   2179a:	0011      	movs	r1, r2
   2179c:	001a      	movs	r2, r3
   2179e:	4b05      	ldr	r3, [pc, #20]	; (217b4 <MQTTSerialize_publishLength+0x20>)
   217a0:	4798      	blx	r3
   217a2:	9b06      	ldr	r3, [sp, #24]
   217a4:	3002      	adds	r0, #2
   217a6:	18c0      	adds	r0, r0, r3
	if (qos > 0)
   217a8:	2c00      	cmp	r4, #0
   217aa:	dd00      	ble.n	217ae <MQTTSerialize_publishLength+0x1a>
		len += 2; /* packetid */
   217ac:	3002      	adds	r0, #2
	return len;
}
   217ae:	b004      	add	sp, #16
   217b0:	bd10      	pop	{r4, pc}
   217b2:	46c0      	nop			; (mov r8, r8)
   217b4:	0002173d 	.word	0x0002173d

000217b8 <MQTTSerialize_publish>:
  * @param payloadlen integer - the length of the MQTT payload
  * @return the length of the serialized data.  <= 0 indicates error
  */
int MQTTSerialize_publish(unsigned char* buf, int buflen, unsigned char dup, int qos, unsigned char retained, unsigned short packetid,
		MQTTString topicName, unsigned char* payload, int payloadlen)
{
   217b8:	b5f0      	push	{r4, r5, r6, r7, lr}
   217ba:	001d      	movs	r5, r3
   217bc:	b089      	sub	sp, #36	; 0x24
   217be:	ab0e      	add	r3, sp, #56	; 0x38
   217c0:	781b      	ldrb	r3, [r3, #0]
   217c2:	9103      	str	r1, [sp, #12]
   217c4:	9305      	str	r3, [sp, #20]
   217c6:	ab0f      	add	r3, sp, #60	; 0x3c
   217c8:	881c      	ldrh	r4, [r3, #0]
	MQTTHeader header = {0};
	int rem_len = 0;
	int rc = 0;

	FUNC_ENTRY;
	if (MQTTPacket_len(rem_len = MQTTSerialize_publishLength(qos, topicName, payloadlen)) > buflen)
   217ca:	9b14      	ldr	r3, [sp, #80]	; 0x50
{
   217cc:	9204      	str	r2, [sp, #16]
	unsigned char *ptr = buf;
   217ce:	9007      	str	r0, [sp, #28]
	if (MQTTPacket_len(rem_len = MQTTSerialize_publishLength(qos, topicName, payloadlen)) > buflen)
   217d0:	9300      	str	r3, [sp, #0]
   217d2:	9910      	ldr	r1, [sp, #64]	; 0x40
   217d4:	9a11      	ldr	r2, [sp, #68]	; 0x44
   217d6:	9b12      	ldr	r3, [sp, #72]	; 0x48
   217d8:	4f1d      	ldr	r7, [pc, #116]	; (21850 <MQTTSerialize_publish+0x98>)
{
   217da:	0006      	movs	r6, r0
	if (MQTTPacket_len(rem_len = MQTTSerialize_publishLength(qos, topicName, payloadlen)) > buflen)
   217dc:	0028      	movs	r0, r5
   217de:	47b8      	blx	r7
   217e0:	4b1c      	ldr	r3, [pc, #112]	; (21854 <MQTTSerialize_publish+0x9c>)
   217e2:	0007      	movs	r7, r0
   217e4:	4798      	blx	r3
   217e6:	9b03      	ldr	r3, [sp, #12]
   217e8:	4298      	cmp	r0, r3
   217ea:	dc2d      	bgt.n	21848 <MQTTSerialize_publish+0x90>
		goto exit;
	}

	header.bits.type = PUBLISH;
	header.bits.dup = dup;
	header.bits.qos = qos;
   217ec:	2103      	movs	r1, #3
	header.bits.dup = dup;
   217ee:	2201      	movs	r2, #1
	header.bits.qos = qos;
   217f0:	4029      	ands	r1, r5
   217f2:	004b      	lsls	r3, r1, #1
   217f4:	2130      	movs	r1, #48	; 0x30
	header.bits.dup = dup;
   217f6:	9804      	ldr	r0, [sp, #16]
   217f8:	4010      	ands	r0, r2
   217fa:	00c0      	lsls	r0, r0, #3
	header.bits.qos = qos;
   217fc:	4301      	orrs	r1, r0
   217fe:	4319      	orrs	r1, r3
	header.bits.retain = retained;
   21800:	9b05      	ldr	r3, [sp, #20]
	writeChar(&ptr, header.byte); /* write header */
   21802:	a807      	add	r0, sp, #28
	header.bits.retain = retained;
   21804:	4013      	ands	r3, r2
	writeChar(&ptr, header.byte); /* write header */
   21806:	4319      	orrs	r1, r3
   21808:	4b13      	ldr	r3, [pc, #76]	; (21858 <MQTTSerialize_publish+0xa0>)
   2180a:	4798      	blx	r3

	ptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;
   2180c:	0039      	movs	r1, r7
   2180e:	4b13      	ldr	r3, [pc, #76]	; (2185c <MQTTSerialize_publish+0xa4>)
   21810:	9807      	ldr	r0, [sp, #28]
   21812:	4798      	blx	r3
   21814:	9b07      	ldr	r3, [sp, #28]

	writeMQTTString(&ptr, topicName);
   21816:	9910      	ldr	r1, [sp, #64]	; 0x40
	ptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;
   21818:	1818      	adds	r0, r3, r0
   2181a:	9007      	str	r0, [sp, #28]
	writeMQTTString(&ptr, topicName);
   2181c:	9a11      	ldr	r2, [sp, #68]	; 0x44
   2181e:	9b12      	ldr	r3, [sp, #72]	; 0x48
   21820:	a807      	add	r0, sp, #28
   21822:	4f0f      	ldr	r7, [pc, #60]	; (21860 <MQTTSerialize_publish+0xa8>)
   21824:	47b8      	blx	r7

	if (qos > 0)
   21826:	2d00      	cmp	r5, #0
   21828:	dd03      	ble.n	21832 <MQTTSerialize_publish+0x7a>
		writeInt(&ptr, packetid);
   2182a:	0021      	movs	r1, r4
   2182c:	a807      	add	r0, sp, #28
   2182e:	4b0d      	ldr	r3, [pc, #52]	; (21864 <MQTTSerialize_publish+0xac>)
   21830:	4798      	blx	r3

	memcpy(ptr, payload, payloadlen);
   21832:	9a14      	ldr	r2, [sp, #80]	; 0x50
   21834:	4b0c      	ldr	r3, [pc, #48]	; (21868 <MQTTSerialize_publish+0xb0>)
   21836:	9913      	ldr	r1, [sp, #76]	; 0x4c
   21838:	9807      	ldr	r0, [sp, #28]
   2183a:	4798      	blx	r3
	ptr += payloadlen;
   2183c:	9b07      	ldr	r3, [sp, #28]
   2183e:	9a14      	ldr	r2, [sp, #80]	; 0x50
   21840:	189c      	adds	r4, r3, r2

	rc = ptr - buf;
   21842:	1ba0      	subs	r0, r4, r6

exit:
	FUNC_EXIT_RC(rc);
	return rc;
}
   21844:	b009      	add	sp, #36	; 0x24
   21846:	bdf0      	pop	{r4, r5, r6, r7, pc}
		rc = MQTTPACKET_BUFFER_TOO_SHORT;
   21848:	2002      	movs	r0, #2
   2184a:	4240      	negs	r0, r0
	return rc;
   2184c:	e7fa      	b.n	21844 <MQTTSerialize_publish+0x8c>
   2184e:	46c0      	nop			; (mov r8, r8)
   21850:	00021795 	.word	0x00021795
   21854:	000215e9 	.word	0x000215e9
   21858:	0002164b 	.word	0x0002164b
   2185c:	0002156d 	.word	0x0002156d
   21860:	000216c1 	.word	0x000216c1
   21864:	00021659 	.word	0x00021659
   21868:	00022c11 	.word	0x00022c11

0002186c <MQTTSerialize_ack>:
  * @param dup the MQTT dup flag
  * @param packetid the MQTT packet identifier
  * @return serialized length, or error if 0
  */
int MQTTSerialize_ack(unsigned char* buf, int buflen, unsigned char packettype, unsigned char dup, unsigned short packetid)
{
   2186c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2186e:	0004      	movs	r4, r0
   21870:	a806      	add	r0, sp, #24
   21872:	8805      	ldrh	r5, [r0, #0]
	MQTTHeader header = {0};
	int rc = 0;
	unsigned char *ptr = buf;
   21874:	9401      	str	r4, [sp, #4]

	FUNC_ENTRY;
	if (buflen < 4)
   21876:	2903      	cmp	r1, #3
   21878:	dd1c      	ble.n	218b4 <MQTTSerialize_ack+0x48>
	{
		rc = MQTTPACKET_BUFFER_TOO_SHORT;
		goto exit;
	}
	header.bits.type = packettype;
   2187a:	210f      	movs	r1, #15
	header.bits.dup = dup;
   2187c:	2001      	movs	r0, #1
	header.bits.type = packettype;
   2187e:	4011      	ands	r1, r2
	header.bits.qos = (packettype == PUBREL) ? 1 : 0;
   21880:	3a06      	subs	r2, #6
	header.bits.dup = dup;
   21882:	4003      	ands	r3, r0
	header.bits.qos = (packettype == PUBREL) ? 1 : 0;
   21884:	4250      	negs	r0, r2
   21886:	4142      	adcs	r2, r0
	header.bits.dup = dup;
   21888:	00db      	lsls	r3, r3, #3
   2188a:	0109      	lsls	r1, r1, #4
	header.bits.qos = (packettype == PUBREL) ? 1 : 0;
   2188c:	0052      	lsls	r2, r2, #1
   2188e:	4319      	orrs	r1, r3
	writeChar(&ptr, header.byte); /* write header */
   21890:	4311      	orrs	r1, r2
   21892:	a801      	add	r0, sp, #4
   21894:	4b09      	ldr	r3, [pc, #36]	; (218bc <MQTTSerialize_ack+0x50>)
   21896:	4798      	blx	r3

	ptr += MQTTPacket_encode(ptr, 2); /* write remaining length */
   21898:	2102      	movs	r1, #2
   2189a:	4b09      	ldr	r3, [pc, #36]	; (218c0 <MQTTSerialize_ack+0x54>)
   2189c:	9801      	ldr	r0, [sp, #4]
   2189e:	4798      	blx	r3
   218a0:	9b01      	ldr	r3, [sp, #4]
	writeInt(&ptr, packetid);
   218a2:	0029      	movs	r1, r5
	ptr += MQTTPacket_encode(ptr, 2); /* write remaining length */
   218a4:	1818      	adds	r0, r3, r0
   218a6:	9001      	str	r0, [sp, #4]
	writeInt(&ptr, packetid);
   218a8:	4b06      	ldr	r3, [pc, #24]	; (218c4 <MQTTSerialize_ack+0x58>)
   218aa:	a801      	add	r0, sp, #4
   218ac:	4798      	blx	r3
	rc = ptr - buf;
   218ae:	9b01      	ldr	r3, [sp, #4]
   218b0:	1b18      	subs	r0, r3, r4
exit:
	FUNC_EXIT_RC(rc);
	return rc;
}
   218b2:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
		rc = MQTTPACKET_BUFFER_TOO_SHORT;
   218b4:	2002      	movs	r0, #2
   218b6:	4240      	negs	r0, r0
	return rc;
   218b8:	e7fb      	b.n	218b2 <MQTTSerialize_ack+0x46>
   218ba:	46c0      	nop			; (mov r8, r8)
   218bc:	0002164b 	.word	0x0002164b
   218c0:	0002156d 	.word	0x0002156d
   218c4:	00021659 	.word	0x00021659

000218c8 <MQTTSerialize_subscribeLength>:
  * @param count the number of topic filter strings in topicFilters
  * @param topicFilters the array of topic filter strings to be used in the publish
  * @return the length of buffer needed to contain the serialized version of the packet
  */
int MQTTSerialize_subscribeLength(int count, MQTTString topicFilters[])
{
   218c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   218ca:	0007      	movs	r7, r0
   218cc:	000e      	movs	r6, r1
	int i;
	int len = 2; /* packetid */
   218ce:	2502      	movs	r5, #2

	for (i = 0; i < count; ++i)
   218d0:	2400      	movs	r4, #0
   218d2:	42bc      	cmp	r4, r7
   218d4:	db01      	blt.n	218da <MQTTSerialize_subscribeLength+0x12>
		len += 2 + MQTTstrlen(topicFilters[i]) + 1; /* length + topic + req_qos */
	return len;
}
   218d6:	0028      	movs	r0, r5
   218d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		len += 2 + MQTTstrlen(topicFilters[i]) + 1; /* length + topic + req_qos */
   218da:	230c      	movs	r3, #12
   218dc:	4363      	muls	r3, r4
   218de:	5998      	ldr	r0, [r3, r6]
   218e0:	18f3      	adds	r3, r6, r3
   218e2:	6859      	ldr	r1, [r3, #4]
   218e4:	689a      	ldr	r2, [r3, #8]
   218e6:	4b03      	ldr	r3, [pc, #12]	; (218f4 <MQTTSerialize_subscribeLength+0x2c>)
   218e8:	4798      	blx	r3
   218ea:	3003      	adds	r0, #3
   218ec:	182d      	adds	r5, r5, r0
	for (i = 0; i < count; ++i)
   218ee:	3401      	adds	r4, #1
   218f0:	e7ef      	b.n	218d2 <MQTTSerialize_subscribeLength+0xa>
   218f2:	46c0      	nop			; (mov r8, r8)
   218f4:	0002173d 	.word	0x0002173d

000218f8 <MQTTSerialize_subscribe>:
  * @param requestedQoSs - array of requested QoS
  * @return the length of the serialized data.  <= 0 indicates error
  */
int MQTTSerialize_subscribe(unsigned char* buf, int buflen, unsigned char dup, unsigned short packetid, int count,
		MQTTString topicFilters[], int requestedQoSs[])
{
   218f8:	b5f0      	push	{r4, r5, r6, r7, lr}
   218fa:	b085      	sub	sp, #20
   218fc:	000f      	movs	r7, r1
	unsigned char *ptr = buf;
   218fe:	9003      	str	r0, [sp, #12]
{
   21900:	0004      	movs	r4, r0
   21902:	001e      	movs	r6, r3
	int rem_len = 0;
	int rc = 0;
	int i = 0;

	FUNC_ENTRY;
	if (MQTTPacket_len(rem_len = MQTTSerialize_subscribeLength(count, topicFilters)) > buflen)
   21904:	990b      	ldr	r1, [sp, #44]	; 0x2c
   21906:	4b1e      	ldr	r3, [pc, #120]	; (21980 <MQTTSerialize_subscribe+0x88>)
   21908:	980a      	ldr	r0, [sp, #40]	; 0x28
{
   2190a:	9201      	str	r2, [sp, #4]
	if (MQTTPacket_len(rem_len = MQTTSerialize_subscribeLength(count, topicFilters)) > buflen)
   2190c:	4798      	blx	r3
   2190e:	4b1d      	ldr	r3, [pc, #116]	; (21984 <MQTTSerialize_subscribe+0x8c>)
   21910:	0005      	movs	r5, r0
   21912:	4798      	blx	r3
   21914:	42b8      	cmp	r0, r7
   21916:	dc2f      	bgt.n	21978 <MQTTSerialize_subscribe+0x80>
		goto exit;
	}

	header.byte = 0;
	header.bits.type = SUBSCRIBE;
	header.bits.dup = dup;
   21918:	2101      	movs	r1, #1
   2191a:	9b01      	ldr	r3, [sp, #4]
	header.bits.qos = 1;
	writeChar(&ptr, header.byte); /* write header */
   2191c:	a803      	add	r0, sp, #12
	header.bits.dup = dup;
   2191e:	400b      	ands	r3, r1
   21920:	00d9      	lsls	r1, r3, #3
	writeChar(&ptr, header.byte); /* write header */
   21922:	2382      	movs	r3, #130	; 0x82
   21924:	4319      	orrs	r1, r3
   21926:	4b18      	ldr	r3, [pc, #96]	; (21988 <MQTTSerialize_subscribe+0x90>)
   21928:	4798      	blx	r3

	ptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;
   2192a:	0029      	movs	r1, r5
   2192c:	4b17      	ldr	r3, [pc, #92]	; (2198c <MQTTSerialize_subscribe+0x94>)
   2192e:	9803      	ldr	r0, [sp, #12]
   21930:	4798      	blx	r3
   21932:	9b03      	ldr	r3, [sp, #12]

	writeInt(&ptr, packetid);
   21934:	0031      	movs	r1, r6
	ptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;
   21936:	1818      	adds	r0, r3, r0
   21938:	9003      	str	r0, [sp, #12]
	writeInt(&ptr, packetid);
   2193a:	4b15      	ldr	r3, [pc, #84]	; (21990 <MQTTSerialize_subscribe+0x98>)
   2193c:	a803      	add	r0, sp, #12
   2193e:	4798      	blx	r3

	for (i = 0; i < count; ++i)
   21940:	2500      	movs	r5, #0
	{
		writeMQTTString(&ptr, topicFilters[i]);
   21942:	270c      	movs	r7, #12
	for (i = 0; i < count; ++i)
   21944:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   21946:	429d      	cmp	r5, r3
   21948:	db03      	blt.n	21952 <MQTTSerialize_subscribe+0x5a>
		writeChar(&ptr, requestedQoSs[i]);
	}

	rc = ptr - buf;
   2194a:	9b03      	ldr	r3, [sp, #12]
   2194c:	1b18      	subs	r0, r3, r4
exit:
	FUNC_EXIT_RC(rc);
	return rc;
}
   2194e:	b005      	add	sp, #20
   21950:	bdf0      	pop	{r4, r5, r6, r7, pc}
		writeMQTTString(&ptr, topicFilters[i]);
   21952:	003b      	movs	r3, r7
   21954:	436b      	muls	r3, r5
   21956:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   21958:	a803      	add	r0, sp, #12
   2195a:	5899      	ldr	r1, [r3, r2]
   2195c:	18d3      	adds	r3, r2, r3
   2195e:	685a      	ldr	r2, [r3, #4]
   21960:	4e0c      	ldr	r6, [pc, #48]	; (21994 <MQTTSerialize_subscribe+0x9c>)
   21962:	689b      	ldr	r3, [r3, #8]
   21964:	47b0      	blx	r6
		writeChar(&ptr, requestedQoSs[i]);
   21966:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   21968:	00ab      	lsls	r3, r5, #2
   2196a:	58d1      	ldr	r1, [r2, r3]
   2196c:	a803      	add	r0, sp, #12
   2196e:	b2c9      	uxtb	r1, r1
   21970:	4b05      	ldr	r3, [pc, #20]	; (21988 <MQTTSerialize_subscribe+0x90>)
   21972:	4798      	blx	r3
	for (i = 0; i < count; ++i)
   21974:	3501      	adds	r5, #1
   21976:	e7e5      	b.n	21944 <MQTTSerialize_subscribe+0x4c>
		rc = MQTTPACKET_BUFFER_TOO_SHORT;
   21978:	2002      	movs	r0, #2
   2197a:	4240      	negs	r0, r0
	return rc;
   2197c:	e7e7      	b.n	2194e <MQTTSerialize_subscribe+0x56>
   2197e:	46c0      	nop			; (mov r8, r8)
   21980:	000218c9 	.word	0x000218c9
   21984:	000215e9 	.word	0x000215e9
   21988:	0002164b 	.word	0x0002164b
   2198c:	0002156d 	.word	0x0002156d
   21990:	00021659 	.word	0x00021659
   21994:	000216c1 	.word	0x000216c1

00021998 <MQTTDeserialize_suback>:
  * @param buf the raw buffer data, of the correct length determined by the remaining length field
  * @param buflen the length in bytes of the data in the supplied buffer
  * @return error code.  1 is success, 0 is failure
  */
int MQTTDeserialize_suback(unsigned short* packetid, int maxcount, int* count, int grantedQoSs[], unsigned char* buf, int buflen)
{
   21998:	b5f0      	push	{r4, r5, r6, r7, lr}
   2199a:	b085      	sub	sp, #20
   2199c:	9301      	str	r3, [sp, #4]
	MQTTHeader header = {0};
	unsigned char* curdata = buf;
   2199e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
{
   219a0:	0004      	movs	r4, r0
	unsigned char* curdata = buf;
   219a2:	9302      	str	r3, [sp, #8]
	unsigned char* enddata = NULL;
	int rc = 0;
	int mylen;

	FUNC_ENTRY;
	header.byte = readChar(&curdata);
   219a4:	a802      	add	r0, sp, #8
   219a6:	4b18      	ldr	r3, [pc, #96]	; (21a08 <MQTTDeserialize_suback+0x70>)
{
   219a8:	9100      	str	r1, [sp, #0]
   219aa:	0016      	movs	r6, r2
	header.byte = readChar(&curdata);
   219ac:	4798      	blx	r3
	if (header.bits.type != SUBACK)
   219ae:	23f0      	movs	r3, #240	; 0xf0
   219b0:	4003      	ands	r3, r0
	int rc = 0;
   219b2:	2000      	movs	r0, #0
	if (header.bits.type != SUBACK)
   219b4:	2b90      	cmp	r3, #144	; 0x90
   219b6:	d114      	bne.n	219e2 <MQTTDeserialize_suback+0x4a>
		goto exit;

	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
   219b8:	4b14      	ldr	r3, [pc, #80]	; (21a0c <MQTTDeserialize_suback+0x74>)
   219ba:	a903      	add	r1, sp, #12
   219bc:	9802      	ldr	r0, [sp, #8]
   219be:	4798      	blx	r3
   219c0:	9b02      	ldr	r3, [sp, #8]
	enddata = curdata + mylen;
   219c2:	9f03      	ldr	r7, [sp, #12]
	curdata += (rc = MQTTPacket_decodeBuf(curdata, &mylen)); /* read remaining length */
   219c4:	181d      	adds	r5, r3, r0
   219c6:	9502      	str	r5, [sp, #8]
	if (enddata - curdata < 2)
   219c8:	2f01      	cmp	r7, #1
   219ca:	dd0a      	ble.n	219e2 <MQTTDeserialize_suback+0x4a>
		goto exit;

	*packetid = readInt(&curdata);
   219cc:	4b10      	ldr	r3, [pc, #64]	; (21a10 <MQTTDeserialize_suback+0x78>)
   219ce:	a802      	add	r0, sp, #8
   219d0:	4798      	blx	r3

	*count = 0;
   219d2:	2300      	movs	r3, #0
	*packetid = readInt(&curdata);
   219d4:	8020      	strh	r0, [r4, #0]
	*count = 0;
   219d6:	6033      	str	r3, [r6, #0]
	while (curdata < enddata)
   219d8:	9a02      	ldr	r2, [sp, #8]
	enddata = curdata + mylen;
   219da:	19eb      	adds	r3, r5, r7
	while (curdata < enddata)
   219dc:	429a      	cmp	r2, r3
   219de:	d302      	bcc.n	219e6 <MQTTDeserialize_suback+0x4e>
			goto exit;
		}
		grantedQoSs[(*count)++] = readChar(&curdata);
	}

	rc = 1;
   219e0:	2001      	movs	r0, #1
exit:
	FUNC_EXIT_RC(rc);
	return rc;
}
   219e2:	b005      	add	sp, #20
   219e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (*count > maxcount)
   219e6:	6834      	ldr	r4, [r6, #0]
   219e8:	9b00      	ldr	r3, [sp, #0]
   219ea:	429c      	cmp	r4, r3
   219ec:	dc09      	bgt.n	21a02 <MQTTDeserialize_suback+0x6a>
		grantedQoSs[(*count)++] = readChar(&curdata);
   219ee:	1c63      	adds	r3, r4, #1
   219f0:	6033      	str	r3, [r6, #0]
   219f2:	9b01      	ldr	r3, [sp, #4]
   219f4:	00a4      	lsls	r4, r4, #2
   219f6:	191c      	adds	r4, r3, r4
   219f8:	a802      	add	r0, sp, #8
   219fa:	4b03      	ldr	r3, [pc, #12]	; (21a08 <MQTTDeserialize_suback+0x70>)
   219fc:	4798      	blx	r3
   219fe:	6020      	str	r0, [r4, #0]
   21a00:	e7ea      	b.n	219d8 <MQTTDeserialize_suback+0x40>
			rc = -1;
   21a02:	2001      	movs	r0, #1
   21a04:	4240      	negs	r0, r0
	return rc;
   21a06:	e7ec      	b.n	219e2 <MQTTDeserialize_suback+0x4a>
   21a08:	0002163f 	.word	0x0002163f
   21a0c:	00021611 	.word	0x00021611
   21a10:	0002162d 	.word	0x0002162d

00021a14 <_hwerr_to_stderr>:

/**
 * \brief change HW error type to standard error.
 */
static inline int _hwerr_to_stderr(int err)
{
   21a14:	0003      	movs	r3, r0
	switch (err) {
   21a16:	300e      	adds	r0, #14
{
   21a18:	b500      	push	{lr}
	switch (err) {
   21a1a:	280e      	cmp	r0, #14
   21a1c:	d81a      	bhi.n	21a54 <_hwerr_to_stderr+0x40>
   21a1e:	f003 ff43 	bl	258a8 <__gnu_thumb1_case_uqi>
   21a22:	1517      	.short	0x1517
   21a24:	1c191113 	.word	0x1c191113
   21a28:	190d0f19 	.word	0x190d0f19
   21a2c:	080b0f0f 	.word	0x080b0f0f
   21a30:	1c          	.byte	0x1c
   21a31:	00          	.byte	0x00
		case 0:
			return -EIO;
		case SOCK_ERR_INVALID_ADDRESS:
			return -ENOENT;
   21a32:	2002      	movs	r0, #2
			return -EAGAIN;
		case SOCK_ERR_BUFFER_FULL:
			return -EBUSY; /* HW error occurred. Retry it*/
		default:
			if (err < 0) {
				return -EIO;
   21a34:	4240      	negs	r0, r0
			}
			return 0;
	}
}
   21a36:	bd00      	pop	{pc}
			return -EADDRINUSE;
   21a38:	2070      	movs	r0, #112	; 0x70
   21a3a:	e7fb      	b.n	21a34 <_hwerr_to_stderr+0x20>
			return -EINVAL;
   21a3c:	2016      	movs	r0, #22
   21a3e:	e7f9      	b.n	21a34 <_hwerr_to_stderr+0x20>
			return -ENOMEM;
   21a40:	200c      	movs	r0, #12
   21a42:	e7f7      	b.n	21a34 <_hwerr_to_stderr+0x20>
			return -EDESTADDRREQ;
   21a44:	2079      	movs	r0, #121	; 0x79
   21a46:	e7f5      	b.n	21a34 <_hwerr_to_stderr+0x20>
			return -ECONNRESET;
   21a48:	2068      	movs	r0, #104	; 0x68
   21a4a:	e7f3      	b.n	21a34 <_hwerr_to_stderr+0x20>
			return -EAGAIN;
   21a4c:	200b      	movs	r0, #11
   21a4e:	e7f1      	b.n	21a34 <_hwerr_to_stderr+0x20>
			return -EBUSY; /* HW error occurred. Retry it*/
   21a50:	2010      	movs	r0, #16
   21a52:	e7ef      	b.n	21a34 <_hwerr_to_stderr+0x20>
			return 0;
   21a54:	2000      	movs	r0, #0
			if (err < 0) {
   21a56:	2b00      	cmp	r3, #0
   21a58:	daed      	bge.n	21a36 <_hwerr_to_stderr+0x22>
				return -EIO;
   21a5a:	2005      	movs	r0, #5
   21a5c:	e7ea      	b.n	21a34 <_hwerr_to_stderr+0x20>
	...

00021a60 <_http_client_send_wait>:
		module->cb(module, HTTP_CLIENT_CALLBACK_DISCONNECTED, &data);
	}
}

int _http_client_send_wait(void *_module, char *buffer, size_t buffer_len)
{
   21a60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int result;
	struct http_client_module *const module = (struct http_client_module *const)_module;
	
	module->sending = 1;
   21a62:	0004      	movs	r4, r0
   21a64:	2601      	movs	r6, #1
{
   21a66:	0005      	movs	r5, r0

	if ((result = send(module->sock, (void*)buffer, buffer_len, 0)) < 0) {
   21a68:	2000      	movs	r0, #0
	module->sending = 1;
   21a6a:	3441      	adds	r4, #65	; 0x41
   21a6c:	7823      	ldrb	r3, [r4, #0]
	if ((result = send(module->sock, (void*)buffer, buffer_len, 0)) < 0) {
   21a6e:	b292      	uxth	r2, r2
	module->sending = 1;
   21a70:	4333      	orrs	r3, r6
   21a72:	7023      	strb	r3, [r4, #0]
	if ((result = send(module->sock, (void*)buffer, buffer_len, 0)) < 0) {
   21a74:	5628      	ldrsb	r0, [r5, r0]
   21a76:	2300      	movs	r3, #0
   21a78:	4f0a      	ldr	r7, [pc, #40]	; (21aa4 <_http_client_send_wait+0x44>)
   21a7a:	47b8      	blx	r7
   21a7c:	2800      	cmp	r0, #0
   21a7e:	db0d      	blt.n	21a9c <_http_client_send_wait+0x3c>
		module->sending = 0;
		return result;
	}
	while (module->sending == 1 && module->req.state > STATE_SOCK_CONNECTED){
   21a80:	7820      	ldrb	r0, [r4, #0]
   21a82:	4030      	ands	r0, r6
   21a84:	d003      	beq.n	21a8e <_http_client_send_wait+0x2e>
   21a86:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
		m2m_wifi_handle_events(NULL);
   21a88:	2000      	movs	r0, #0
	while (module->sending == 1 && module->req.state > STATE_SOCK_CONNECTED){
   21a8a:	2b02      	cmp	r3, #2
   21a8c:	d800      	bhi.n	21a90 <_http_client_send_wait+0x30>
		sw_timer_task(module->config.timer_inst);
	}

	return 0;
}
   21a8e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		m2m_wifi_handle_events(NULL);
   21a90:	4b05      	ldr	r3, [pc, #20]	; (21aa8 <_http_client_send_wait+0x48>)
   21a92:	4798      	blx	r3
		sw_timer_task(module->config.timer_inst);
   21a94:	6d68      	ldr	r0, [r5, #84]	; 0x54
   21a96:	4b05      	ldr	r3, [pc, #20]	; (21aac <_http_client_send_wait+0x4c>)
   21a98:	4798      	blx	r3
   21a9a:	e7f1      	b.n	21a80 <_http_client_send_wait+0x20>
		module->sending = 0;
   21a9c:	7823      	ldrb	r3, [r4, #0]
   21a9e:	43b3      	bics	r3, r6
   21aa0:	7023      	strb	r3, [r4, #0]
		return result;
   21aa2:	e7f4      	b.n	21a8e <_http_client_send_wait+0x2e>
   21aa4:	0001cb31 	.word	0x0001cb31
   21aa8:	0001b181 	.word	0x0001b181
   21aac:	000228f5 	.word	0x000228f5

00021ab0 <http_client_get_config_defaults>:
	config->port = 80;
   21ab0:	2350      	movs	r3, #80	; 0x50
   21ab2:	8003      	strh	r3, [r0, #0]
	config->tls = 0;
   21ab4:	2300      	movs	r3, #0
   21ab6:	7083      	strb	r3, [r0, #2]
	config->timer_inst = NULL;
   21ab8:	6043      	str	r3, [r0, #4]
	config->recv_buffer = NULL;
   21aba:	60c3      	str	r3, [r0, #12]
	config->recv_buffer_size = 256;
   21abc:	3301      	adds	r3, #1
   21abe:	33ff      	adds	r3, #255	; 0xff
   21ac0:	6103      	str	r3, [r0, #16]
	config->send_buffer_size = MIN_SEND_BUFFER_SIZE;
   21ac2:	3bae      	subs	r3, #174	; 0xae
	config->timeout = 20000;
   21ac4:	4a02      	ldr	r2, [pc, #8]	; (21ad0 <http_client_get_config_defaults+0x20>)
	config->send_buffer_size = MIN_SEND_BUFFER_SIZE;
   21ac6:	6143      	str	r3, [r0, #20]
	config->user_agent = DEFAULT_USER_AGENT;
   21ac8:	4b02      	ldr	r3, [pc, #8]	; (21ad4 <http_client_get_config_defaults+0x24>)
	config->timeout = 20000;
   21aca:	8102      	strh	r2, [r0, #8]
	config->user_agent = DEFAULT_USER_AGENT;
   21acc:	6183      	str	r3, [r0, #24]
}
   21ace:	4770      	bx	lr
   21ad0:	00004e20 	.word	0x00004e20
   21ad4:	0002b40b 	.word	0x0002b40b

00021ad8 <http_client_init>:
{
   21ad8:	b570      	push	{r4, r5, r6, lr}
   21ada:	0004      	movs	r4, r0
   21adc:	000d      	movs	r5, r1
	if (module == NULL || config == NULL) {
   21ade:	2800      	cmp	r0, #0
   21ae0:	d037      	beq.n	21b52 <http_client_init+0x7a>
   21ae2:	2900      	cmp	r1, #0
   21ae4:	d035      	beq.n	21b52 <http_client_init+0x7a>
	if (config->recv_buffer_size == 0) {
   21ae6:	690b      	ldr	r3, [r1, #16]
   21ae8:	2b00      	cmp	r3, #0
   21aea:	d032      	beq.n	21b52 <http_client_init+0x7a>
	if (config->timer_inst == NULL) {
   21aec:	684b      	ldr	r3, [r1, #4]
   21aee:	2b00      	cmp	r3, #0
   21af0:	d02f      	beq.n	21b52 <http_client_init+0x7a>
	if (config->send_buffer_size < MIN_SEND_BUFFER_SIZE) {
   21af2:	694b      	ldr	r3, [r1, #20]
   21af4:	2b51      	cmp	r3, #81	; 0x51
   21af6:	d92c      	bls.n	21b52 <http_client_init+0x7a>
	memset(module, 0, sizeof(struct http_client_module));
   21af8:	22e8      	movs	r2, #232	; 0xe8
   21afa:	2100      	movs	r1, #0
   21afc:	4b17      	ldr	r3, [pc, #92]	; (21b5c <http_client_init+0x84>)
   21afe:	4798      	blx	r3
	memcpy(&module->config, config, sizeof(struct http_client_config));
   21b00:	0020      	movs	r0, r4
   21b02:	4b17      	ldr	r3, [pc, #92]	; (21b60 <http_client_init+0x88>)
   21b04:	221c      	movs	r2, #28
   21b06:	0029      	movs	r1, r5
   21b08:	3050      	adds	r0, #80	; 0x50
   21b0a:	4798      	blx	r3
	if (module->config.recv_buffer == NULL) {
   21b0c:	6de3      	ldr	r3, [r4, #92]	; 0x5c
   21b0e:	2b00      	cmp	r3, #0
   21b10:	d10b      	bne.n	21b2a <http_client_init+0x52>
		module->config.recv_buffer = malloc(config->recv_buffer_size);
   21b12:	6928      	ldr	r0, [r5, #16]
   21b14:	4b13      	ldr	r3, [pc, #76]	; (21b64 <http_client_init+0x8c>)
   21b16:	4798      	blx	r3
   21b18:	65e0      	str	r0, [r4, #92]	; 0x5c
		if (module->config.recv_buffer == NULL) {
   21b1a:	2800      	cmp	r0, #0
   21b1c:	d01b      	beq.n	21b56 <http_client_init+0x7e>
		module->alloc_buffer = 1;
   21b1e:	0022      	movs	r2, r4
   21b20:	2304      	movs	r3, #4
   21b22:	3241      	adds	r2, #65	; 0x41
   21b24:	7811      	ldrb	r1, [r2, #0]
   21b26:	430b      	orrs	r3, r1
   21b28:	7013      	strb	r3, [r2, #0]
	if (config->timeout > 0) {
   21b2a:	892b      	ldrh	r3, [r5, #8]
   21b2c:	2b00      	cmp	r3, #0
   21b2e:	d104      	bne.n	21b3a <http_client_init+0x62>
	module->req.state = STATE_INIT;
   21b30:	2000      	movs	r0, #0
   21b32:	66e0      	str	r0, [r4, #108]	; 0x6c
	module->resp.state = STATE_PARSE_HEADER;
   21b34:	34d8      	adds	r4, #216	; 0xd8
   21b36:	6020      	str	r0, [r4, #0]
}
   21b38:	bd70      	pop	{r4, r5, r6, pc}
		module->timer_id = sw_timer_register_callback(config->timer_inst, http_client_timer_callback, (void *)module, 0);
   21b3a:	6868      	ldr	r0, [r5, #4]
   21b3c:	2300      	movs	r3, #0
   21b3e:	0022      	movs	r2, r4
   21b40:	4909      	ldr	r1, [pc, #36]	; (21b68 <http_client_init+0x90>)
   21b42:	4d0a      	ldr	r5, [pc, #40]	; (21b6c <http_client_init+0x94>)
   21b44:	47a8      	blx	r5
   21b46:	64a0      	str	r0, [r4, #72]	; 0x48
		if (module->timer_id < 0) {
   21b48:	2800      	cmp	r0, #0
   21b4a:	daf1      	bge.n	21b30 <http_client_init+0x58>
			return -ENOSPC;
   21b4c:	201c      	movs	r0, #28
			return -ENOMEM;
   21b4e:	4240      	negs	r0, r0
   21b50:	e7f2      	b.n	21b38 <http_client_init+0x60>
		return -EINVAL;
   21b52:	2016      	movs	r0, #22
   21b54:	e7fb      	b.n	21b4e <http_client_init+0x76>
			return -ENOMEM;
   21b56:	200c      	movs	r0, #12
   21b58:	e7f9      	b.n	21b4e <http_client_init+0x76>
   21b5a:	46c0      	nop			; (mov r8, r8)
   21b5c:	00022c47 	.word	0x00022c47
   21b60:	00022c11 	.word	0x00022c11
   21b64:	00022be9 	.word	0x00022be9
   21b68:	00021c7d 	.word	0x00021c7d
   21b6c:	00022881 	.word	0x00022881

00021b70 <http_client_register_callback>:
	if (module == NULL) {
   21b70:	2800      	cmp	r0, #0
   21b72:	d002      	beq.n	21b7a <http_client_register_callback+0xa>
	module->cb = callback;
   21b74:	64c1      	str	r1, [r0, #76]	; 0x4c
	return 0;
   21b76:	2000      	movs	r0, #0
}
   21b78:	4770      	bx	lr
		return -EINVAL;
   21b7a:	2016      	movs	r0, #22
   21b7c:	4240      	negs	r0, r0
   21b7e:	e7fb      	b.n	21b78 <http_client_register_callback+0x8>

00021b80 <_http_client_clear_conn>:
	if (module->req.entity.close) {
   21b80:	0003      	movs	r3, r0
{
   21b82:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (module->req.entity.close) {
   21b84:	33c0      	adds	r3, #192	; 0xc0
   21b86:	681b      	ldr	r3, [r3, #0]
{
   21b88:	b087      	sub	sp, #28
   21b8a:	0004      	movs	r4, r0
   21b8c:	9101      	str	r1, [sp, #4]
	if (module->req.entity.close) {
   21b8e:	2b00      	cmp	r3, #0
   21b90:	d003      	beq.n	21b9a <_http_client_clear_conn+0x1a>
		module->req.entity.close(module->req.entity.priv_data);
   21b92:	0002      	movs	r2, r0
   21b94:	32c4      	adds	r2, #196	; 0xc4
   21b96:	6810      	ldr	r0, [r2, #0]
   21b98:	4798      	blx	r3
	memset(&module->req.entity, 0, sizeof(struct http_entity));
   21b9a:	0020      	movs	r0, r4
   21b9c:	2218      	movs	r2, #24
   21b9e:	2100      	movs	r1, #0
   21ba0:	30b0      	adds	r0, #176	; 0xb0
   21ba2:	4f16      	ldr	r7, [pc, #88]	; (21bfc <_http_client_clear_conn+0x7c>)
   21ba4:	47b8      	blx	r7
	if (module->req.state >= STATE_TRY_SOCK_CONNECT) {
   21ba6:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   21ba8:	2b00      	cmp	r3, #0
   21baa:	d003      	beq.n	21bb4 <_http_client_clear_conn+0x34>
		close(module->sock);
   21bac:	2000      	movs	r0, #0
   21bae:	4b14      	ldr	r3, [pc, #80]	; (21c00 <_http_client_clear_conn+0x80>)
   21bb0:	5620      	ldrsb	r0, [r4, r0]
   21bb2:	4798      	blx	r3
	module_ref_inst[module->sock] = NULL;
   21bb4:	2300      	movs	r3, #0
   21bb6:	2500      	movs	r5, #0
   21bb8:	56e3      	ldrsb	r3, [r4, r3]
   21bba:	4a12      	ldr	r2, [pc, #72]	; (21c04 <_http_client_clear_conn+0x84>)
   21bbc:	009b      	lsls	r3, r3, #2
   21bbe:	509d      	str	r5, [r3, r2]
	memset(&module->resp, 0, sizeof(struct http_client_resp));
   21bc0:	0026      	movs	r6, r4
	memset(&module->req, 0, sizeof(struct http_client_req));
   21bc2:	226c      	movs	r2, #108	; 0x6c
   21bc4:	0029      	movs	r1, r5
   21bc6:	18a0      	adds	r0, r4, r2
	memset(&module->resp, 0, sizeof(struct http_client_resp));
   21bc8:	36d8      	adds	r6, #216	; 0xd8
	memset(&module->req, 0, sizeof(struct http_client_req));
   21bca:	47b8      	blx	r7
	memset(&module->resp, 0, sizeof(struct http_client_resp));
   21bcc:	2210      	movs	r2, #16
   21bce:	0029      	movs	r1, r5
   21bd0:	0030      	movs	r0, r6
   21bd2:	47b8      	blx	r7
	module->sending = 0;
   21bd4:	0022      	movs	r2, r4
	module->permanent = 0;
   21bd6:	21fc      	movs	r1, #252	; 0xfc
	module->req.state = STATE_INIT;
   21bd8:	66e5      	str	r5, [r4, #108]	; 0x6c
	module->sending = 0;
   21bda:	3241      	adds	r2, #65	; 0x41
	module->resp.state = STATE_PARSE_HEADER;
   21bdc:	6035      	str	r5, [r6, #0]
	module->sending = 0;
   21bde:	7813      	ldrb	r3, [r2, #0]
	module->permanent = 0;
   21be0:	400b      	ands	r3, r1
   21be2:	7013      	strb	r3, [r2, #0]
	data.disconnected.reason = reason;
   21be4:	9b01      	ldr	r3, [sp, #4]
   21be6:	9303      	str	r3, [sp, #12]
	if (module->cb) {
   21be8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   21bea:	42ab      	cmp	r3, r5
   21bec:	d003      	beq.n	21bf6 <_http_client_clear_conn+0x76>
		module->cb(module, HTTP_CLIENT_CALLBACK_DISCONNECTED, &data);
   21bee:	aa03      	add	r2, sp, #12
   21bf0:	39f8      	subs	r1, #248	; 0xf8
   21bf2:	0020      	movs	r0, r4
   21bf4:	4798      	blx	r3
}
   21bf6:	b007      	add	sp, #28
   21bf8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   21bfa:	46c0      	nop			; (mov r8, r8)
   21bfc:	00022c47 	.word	0x00022c47
   21c00:	0001cc19 	.word	0x0001cc19
   21c04:	200041c8 	.word	0x200041c8

00021c08 <http_client_socket_resolve_handler>:
{
   21c08:	b5f0      	push	{r4, r5, r6, r7, lr}
   21c0a:	0007      	movs	r7, r0
   21c0c:	000e      	movs	r6, r1
   21c0e:	2500      	movs	r5, #0
   21c10:	b085      	sub	sp, #20
		if (module_ref_inst[i] != NULL) {
   21c12:	4b16      	ldr	r3, [pc, #88]	; (21c6c <http_client_socket_resolve_handler+0x64>)
   21c14:	58ec      	ldr	r4, [r5, r3]
   21c16:	2c00      	cmp	r4, #0
   21c18:	d024      	beq.n	21c64 <http_client_socket_resolve_handler+0x5c>
			if (!strcmp((const char*)doamin_name, module->host) && module->req.state == STATE_TRY_SOCK_CONNECT) {
   21c1a:	1c61      	adds	r1, r4, #1
   21c1c:	0038      	movs	r0, r7
   21c1e:	4b14      	ldr	r3, [pc, #80]	; (21c70 <http_client_socket_resolve_handler+0x68>)
   21c20:	4798      	blx	r3
   21c22:	2800      	cmp	r0, #0
   21c24:	d11e      	bne.n	21c64 <http_client_socket_resolve_handler+0x5c>
   21c26:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   21c28:	2b01      	cmp	r3, #1
   21c2a:	d11b      	bne.n	21c64 <http_client_socket_resolve_handler+0x5c>
				if (server_ip == 0) { /* Host was not found or was not reachable. */ 
   21c2c:	2e00      	cmp	r6, #0
   21c2e:	d106      	bne.n	21c3e <http_client_socket_resolve_handler+0x36>
					_http_client_clear_conn(module, -EHOSTUNREACH);
   21c30:	2176      	movs	r1, #118	; 0x76
   21c32:	0020      	movs	r0, r4
   21c34:	4249      	negs	r1, r1
   21c36:	4b0f      	ldr	r3, [pc, #60]	; (21c74 <http_client_socket_resolve_handler+0x6c>)
   21c38:	4798      	blx	r3
}
   21c3a:	b005      	add	sp, #20
   21c3c:	bdf0      	pop	{r4, r5, r6, r7, pc}
				addr_in.sin_family = AF_INET;
   21c3e:	466a      	mov	r2, sp
   21c40:	2302      	movs	r3, #2
   21c42:	8013      	strh	r3, [r2, #0]
				addr_in.sin_port = _htons(module->config.port);
   21c44:	0023      	movs	r3, r4
   21c46:	3350      	adds	r3, #80	; 0x50
   21c48:	881b      	ldrh	r3, [r3, #0]
				connect(module->sock, (struct sockaddr *)&addr_in, sizeof(struct sockaddr_in));
   21c4a:	2000      	movs	r0, #0
				addr_in.sin_port = _htons(module->config.port);
   21c4c:	021a      	lsls	r2, r3, #8
   21c4e:	0a1b      	lsrs	r3, r3, #8
   21c50:	4313      	orrs	r3, r2
   21c52:	466a      	mov	r2, sp
				addr_in.sin_addr.s_addr = server_ip;
   21c54:	9601      	str	r6, [sp, #4]
				addr_in.sin_port = _htons(module->config.port);
   21c56:	8053      	strh	r3, [r2, #2]
				connect(module->sock, (struct sockaddr *)&addr_in, sizeof(struct sockaddr_in));
   21c58:	5620      	ldrsb	r0, [r4, r0]
   21c5a:	2210      	movs	r2, #16
   21c5c:	4669      	mov	r1, sp
   21c5e:	4b06      	ldr	r3, [pc, #24]	; (21c78 <http_client_socket_resolve_handler+0x70>)
   21c60:	4798      	blx	r3
				return;
   21c62:	e7ea      	b.n	21c3a <http_client_socket_resolve_handler+0x32>
   21c64:	3504      	adds	r5, #4
	for (i = 0; i < TCP_SOCK_MAX; i++) {
   21c66:	2d1c      	cmp	r5, #28
   21c68:	d1d3      	bne.n	21c12 <http_client_socket_resolve_handler+0xa>
   21c6a:	e7e6      	b.n	21c3a <http_client_socket_resolve_handler+0x32>
   21c6c:	200041c8 	.word	0x200041c8
   21c70:	00023865 	.word	0x00023865
   21c74:	00021b81 	.word	0x00021b81
   21c78:	0001cab9 	.word	0x0001cab9

00021c7c <http_client_timer_callback>:
{
   21c7c:	b510      	push	{r4, lr}
	if (module_inst == NULL) {
   21c7e:	2a00      	cmp	r2, #0
   21c80:	d004      	beq.n	21c8c <http_client_timer_callback+0x10>
	_http_client_clear_conn(module_inst, -ETIME);
   21c82:	213e      	movs	r1, #62	; 0x3e
   21c84:	0010      	movs	r0, r2
   21c86:	4249      	negs	r1, r1
   21c88:	4b01      	ldr	r3, [pc, #4]	; (21c90 <http_client_timer_callback+0x14>)
   21c8a:	4798      	blx	r3
}
   21c8c:	bd10      	pop	{r4, pc}
   21c8e:	46c0      	nop			; (mov r8, r8)
   21c90:	00021b81 	.word	0x00021b81

00021c94 <_http_client_request>:

void _http_client_request(struct http_client_module *const module)
{
   21c94:	b5f0      	push	{r4, r5, r6, r7, lr}
   21c96:	b097      	sub	sp, #92	; 0x5c
   21c98:	466b      	mov	r3, sp
   21c9a:	af02      	add	r7, sp, #8
	struct stream_writer writer;
	int size;
	int result;
	char length[11];
	char *ptr;
	const char CH_LUT[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
   21c9c:	2210      	movs	r2, #16
{
   21c9e:	607b      	str	r3, [r7, #4]
	const char CH_LUT[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
   21ca0:	231c      	movs	r3, #28
{
   21ca2:	0004      	movs	r4, r0
	const char CH_LUT[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
   21ca4:	18b8      	adds	r0, r7, r2
   21ca6:	49cf      	ldr	r1, [pc, #828]	; (21fe4 <_http_client_request+0x350>)
   21ca8:	18c0      	adds	r0, r0, r3
   21caa:	4bcf      	ldr	r3, [pc, #828]	; (21fe8 <_http_client_request+0x354>)
   21cac:	4798      	blx	r3
	struct http_entity * entity;
	union http_client_data data;
#define HTTP_CHUNKED_MAX_LENGTH 3 /*TCP MTU is 1400(0x578) */
	char buffer[module->config.send_buffer_size];
   21cae:	4669      	mov	r1, sp
   21cb0:	6e62      	ldr	r2, [r4, #100]	; 0x64
   21cb2:	1dd3      	adds	r3, r2, #7
   21cb4:	08db      	lsrs	r3, r3, #3
   21cb6:	00db      	lsls	r3, r3, #3
   21cb8:	1acb      	subs	r3, r1, r3
   21cba:	469d      	mov	sp, r3
   21cbc:	ab02      	add	r3, sp, #8
   21cbe:	60fb      	str	r3, [r7, #12]

	if (module == NULL) {
		return;
	}

	if (module->sending != 0) {
   21cc0:	0023      	movs	r3, r4
   21cc2:	2101      	movs	r1, #1
   21cc4:	3341      	adds	r3, #65	; 0x41
   21cc6:	781b      	ldrb	r3, [r3, #0]
   21cc8:	400b      	ands	r3, r1
   21cca:	d105      	bne.n	21cd8 <_http_client_request+0x44>
		return;
	}

	entity = &module->req.entity;

	switch (module->req.state) {
   21ccc:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
   21cce:	2903      	cmp	r1, #3
   21cd0:	d007      	beq.n	21ce2 <_http_client_request+0x4e>
   21cd2:	2904      	cmp	r1, #4
   21cd4:	d100      	bne.n	21cd8 <_http_client_request+0x44>
   21cd6:	e0d0      	b.n	21e7a <_http_client_request+0x1e6>
   21cd8:	687b      	ldr	r3, [r7, #4]
   21cda:	469d      	mov	sp, r3
		break;
	default:
		/* Invalid status. */
		break;
	}
}
   21cdc:	46bd      	mov	sp, r7
   21cde:	b015      	add	sp, #84	; 0x54
   21ce0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		module->req.content_length = 0;
   21ce2:	0021      	movs	r1, r4
		stream_writer_init(&writer, buffer, module->config.send_buffer_size, _http_client_send_wait, (void *)module);
   21ce4:	2510      	movs	r5, #16
   21ce6:	202c      	movs	r0, #44	; 0x2c
		module->req.content_length = 0;
   21ce8:	31cc      	adds	r1, #204	; 0xcc
   21cea:	600b      	str	r3, [r1, #0]
		module->req.sent_length = 0;
   21cec:	604b      	str	r3, [r1, #4]
		stream_writer_init(&writer, buffer, module->config.send_buffer_size, _http_client_send_wait, (void *)module);
   21cee:	197d      	adds	r5, r7, r5
   21cf0:	9400      	str	r4, [sp, #0]
   21cf2:	4bbe      	ldr	r3, [pc, #760]	; (21fec <_http_client_request+0x358>)
   21cf4:	1828      	adds	r0, r5, r0
   21cf6:	68f9      	ldr	r1, [r7, #12]
   21cf8:	4dbd      	ldr	r5, [pc, #756]	; (21ff0 <_http_client_request+0x35c>)
   21cfa:	47a8      	blx	r5
		if (module->req.method == HTTP_METHOD_GET) {
   21cfc:	0023      	movs	r3, r4
   21cfe:	33c8      	adds	r3, #200	; 0xc8
   21d00:	781a      	ldrb	r2, [r3, #0]
   21d02:	4bbc      	ldr	r3, [pc, #752]	; (21ff4 <_http_client_request+0x360>)
   21d04:	2a01      	cmp	r2, #1
   21d06:	d174      	bne.n	21df2 <_http_client_request+0x15e>
			stream_writer_send_buffer(&writer, "GET ", 4);
   21d08:	49bb      	ldr	r1, [pc, #748]	; (21ff8 <_http_client_request+0x364>)
   21d0a:	3203      	adds	r2, #3
			stream_writer_send_buffer(&writer, "HEAD ", 5);
   21d0c:	2510      	movs	r5, #16
   21d0e:	202c      	movs	r0, #44	; 0x2c
   21d10:	197d      	adds	r5, r7, r5
   21d12:	1828      	adds	r0, r5, r0
   21d14:	4798      	blx	r3
		stream_writer_send_buffer(&writer, module->req.uri, strlen(module->req.uri));
   21d16:	0025      	movs	r5, r4
   21d18:	3570      	adds	r5, #112	; 0x70
   21d1a:	4bb8      	ldr	r3, [pc, #736]	; (21ffc <_http_client_request+0x368>)
   21d1c:	0028      	movs	r0, r5
   21d1e:	4798      	blx	r3
   21d20:	0002      	movs	r2, r0
   21d22:	2010      	movs	r0, #16
   21d24:	232c      	movs	r3, #44	; 0x2c
   21d26:	1838      	adds	r0, r7, r0
   21d28:	0029      	movs	r1, r5
   21d2a:	18c0      	adds	r0, r0, r3
   21d2c:	4db1      	ldr	r5, [pc, #708]	; (21ff4 <_http_client_request+0x360>)
   21d2e:	47a8      	blx	r5
		stream_writer_send_buffer(&writer, " "HTTP_PROTO_NAME"\r\n", strlen(" "HTTP_PROTO_NAME"\r\n"));
   21d30:	2010      	movs	r0, #16
   21d32:	232c      	movs	r3, #44	; 0x2c
   21d34:	1838      	adds	r0, r7, r0
   21d36:	18c0      	adds	r0, r0, r3
   21d38:	220b      	movs	r2, #11
   21d3a:	49b1      	ldr	r1, [pc, #708]	; (22000 <_http_client_request+0x36c>)
   21d3c:	47a8      	blx	r5
		stream_writer_send_buffer(&writer, "User-Agent: ", strlen("User-agent: "));
   21d3e:	2010      	movs	r0, #16
   21d40:	232c      	movs	r3, #44	; 0x2c
   21d42:	1838      	adds	r0, r7, r0
   21d44:	220c      	movs	r2, #12
   21d46:	49af      	ldr	r1, [pc, #700]	; (22004 <_http_client_request+0x370>)
   21d48:	18c0      	adds	r0, r0, r3
   21d4a:	47a8      	blx	r5
		stream_writer_send_buffer(&writer, (char *)module->config.user_agent, strlen(module->config.user_agent));
   21d4c:	6ea6      	ldr	r6, [r4, #104]	; 0x68
   21d4e:	4bab      	ldr	r3, [pc, #684]	; (21ffc <_http_client_request+0x368>)
   21d50:	0030      	movs	r0, r6
   21d52:	4798      	blx	r3
   21d54:	0002      	movs	r2, r0
   21d56:	2010      	movs	r0, #16
   21d58:	232c      	movs	r3, #44	; 0x2c
   21d5a:	1838      	adds	r0, r7, r0
   21d5c:	0031      	movs	r1, r6
   21d5e:	18c0      	adds	r0, r0, r3
   21d60:	47a8      	blx	r5
		stream_writer_send_buffer(&writer, "\r\n", strlen("\r\n"));
   21d62:	2010      	movs	r0, #16
   21d64:	232c      	movs	r3, #44	; 0x2c
   21d66:	1838      	adds	r0, r7, r0
   21d68:	18c0      	adds	r0, r0, r3
   21d6a:	2202      	movs	r2, #2
   21d6c:	49a6      	ldr	r1, [pc, #664]	; (22008 <_http_client_request+0x374>)
   21d6e:	47a8      	blx	r5
		stream_writer_send_buffer(&writer, "Host: ", strlen("Host: "));
   21d70:	2010      	movs	r0, #16
   21d72:	232c      	movs	r3, #44	; 0x2c
   21d74:	1838      	adds	r0, r7, r0
   21d76:	2206      	movs	r2, #6
   21d78:	49a4      	ldr	r1, [pc, #656]	; (2200c <_http_client_request+0x378>)
   21d7a:	18c0      	adds	r0, r0, r3
		stream_writer_send_buffer(&writer, module->host, strlen(module->host));
   21d7c:	1c66      	adds	r6, r4, #1
		stream_writer_send_buffer(&writer, "Host: ", strlen("Host: "));
   21d7e:	47a8      	blx	r5
		stream_writer_send_buffer(&writer, module->host, strlen(module->host));
   21d80:	4b9e      	ldr	r3, [pc, #632]	; (21ffc <_http_client_request+0x368>)
   21d82:	0030      	movs	r0, r6
   21d84:	4798      	blx	r3
   21d86:	0002      	movs	r2, r0
   21d88:	2010      	movs	r0, #16
   21d8a:	232c      	movs	r3, #44	; 0x2c
   21d8c:	1838      	adds	r0, r7, r0
   21d8e:	18c0      	adds	r0, r0, r3
   21d90:	0031      	movs	r1, r6
   21d92:	47a8      	blx	r5
		stream_writer_send_buffer(&writer, "\r\n", strlen("\r\n"));
   21d94:	2010      	movs	r0, #16
   21d96:	232c      	movs	r3, #44	; 0x2c
   21d98:	1838      	adds	r0, r7, r0
   21d9a:	18c0      	adds	r0, r0, r3
   21d9c:	2202      	movs	r2, #2
   21d9e:	499a      	ldr	r1, [pc, #616]	; (22008 <_http_client_request+0x374>)
   21da0:	47a8      	blx	r5
		stream_writer_send_buffer(&writer, "Connection: Keep-Alive\r\n", strlen("Connection: Keep-Alive\r\n"));
   21da2:	2010      	movs	r0, #16
   21da4:	232c      	movs	r3, #44	; 0x2c
   21da6:	1838      	adds	r0, r7, r0
   21da8:	18c0      	adds	r0, r0, r3
   21daa:	2218      	movs	r2, #24
   21dac:	4998      	ldr	r1, [pc, #608]	; (22010 <_http_client_request+0x37c>)
   21dae:	47a8      	blx	r5
		stream_writer_send_buffer(&writer, "Accept-Encoding: \r\n", strlen("Accept-Encoding: \r\n"));
   21db0:	2010      	movs	r0, #16
   21db2:	232c      	movs	r3, #44	; 0x2c
   21db4:	1838      	adds	r0, r7, r0
   21db6:	18c0      	adds	r0, r0, r3
   21db8:	2213      	movs	r2, #19
   21dba:	4996      	ldr	r1, [pc, #600]	; (22014 <_http_client_request+0x380>)
   21dbc:	47a8      	blx	r5
		stream_writer_send_buffer(&writer, "Accept-Charset: utf-8\r\n", strlen("Accept-Charset: utf-8\r\n"));
   21dbe:	2010      	movs	r0, #16
   21dc0:	232c      	movs	r3, #44	; 0x2c
   21dc2:	1838      	adds	r0, r7, r0
   21dc4:	2217      	movs	r2, #23
   21dc6:	18c0      	adds	r0, r0, r3
   21dc8:	4993      	ldr	r1, [pc, #588]	; (22018 <_http_client_request+0x384>)
   21dca:	47a8      	blx	r5
		if (entity->read != NULL) {
   21dcc:	0023      	movs	r3, r4
   21dce:	33b0      	adds	r3, #176	; 0xb0
   21dd0:	68da      	ldr	r2, [r3, #12]
   21dd2:	2a00      	cmp	r2, #0
   21dd4:	d031      	beq.n	21e3a <_http_client_request+0x1a6>
			if (entity->is_chunked) {
   21dd6:	781e      	ldrb	r6, [r3, #0]
   21dd8:	2e00      	cmp	r6, #0
   21dda:	d023      	beq.n	21e24 <_http_client_request+0x190>
				module->req.content_length = -1;
   21ddc:	2201      	movs	r2, #1
				stream_writer_send_buffer(&writer, "Transfer-Encoding: chunked\r\n", strlen("Transfer-Encoding: chunked\r\n"));
   21dde:	498f      	ldr	r1, [pc, #572]	; (2201c <_http_client_request+0x388>)
				module->req.content_length = -1;
   21de0:	4252      	negs	r2, r2
   21de2:	61da      	str	r2, [r3, #28]
				stream_writer_send_buffer(&writer, "Transfer-Encoding: chunked\r\n", strlen("Transfer-Encoding: chunked\r\n"));
   21de4:	321d      	adds	r2, #29
					stream_writer_send_buffer(&writer, "\r\n", strlen("\r\n"));
   21de6:	2010      	movs	r0, #16
   21de8:	232c      	movs	r3, #44	; 0x2c
   21dea:	1838      	adds	r0, r7, r0
   21dec:	18c0      	adds	r0, r0, r3
   21dee:	47a8      	blx	r5
   21df0:	e023      	b.n	21e3a <_http_client_request+0x1a6>
		} else if (module->req.method == HTTP_METHOD_POST) {
   21df2:	2a02      	cmp	r2, #2
   21df4:	d102      	bne.n	21dfc <_http_client_request+0x168>
			stream_writer_send_buffer(&writer, "POST ", 5);
   21df6:	3203      	adds	r2, #3
   21df8:	4989      	ldr	r1, [pc, #548]	; (22020 <_http_client_request+0x38c>)
   21dfa:	e787      	b.n	21d0c <_http_client_request+0x78>
		} else if (module->req.method == HTTP_METHOD_DELETE) {
   21dfc:	2a03      	cmp	r2, #3
   21dfe:	d102      	bne.n	21e06 <_http_client_request+0x172>
			stream_writer_send_buffer(&writer, "DELETE ", 7);
   21e00:	3204      	adds	r2, #4
   21e02:	4988      	ldr	r1, [pc, #544]	; (22024 <_http_client_request+0x390>)
   21e04:	e782      	b.n	21d0c <_http_client_request+0x78>
			stream_writer_send_buffer(&writer, "PUT ", 4);
   21e06:	4988      	ldr	r1, [pc, #544]	; (22028 <_http_client_request+0x394>)
		} else if (module->req.method == HTTP_METHOD_PUT) {
   21e08:	2a04      	cmp	r2, #4
   21e0a:	d100      	bne.n	21e0e <_http_client_request+0x17a>
   21e0c:	e77e      	b.n	21d0c <_http_client_request+0x78>
		} else if (module->req.method == HTTP_METHOD_OPTIONS) {
   21e0e:	2a05      	cmp	r2, #5
   21e10:	d102      	bne.n	21e18 <_http_client_request+0x184>
			stream_writer_send_buffer(&writer, "OPTIONS ", 8);
   21e12:	3203      	adds	r2, #3
   21e14:	4985      	ldr	r1, [pc, #532]	; (2202c <_http_client_request+0x398>)
   21e16:	e779      	b.n	21d0c <_http_client_request+0x78>
		} else if (module->req.method == HTTP_METHOD_HEAD) {
   21e18:	2a06      	cmp	r2, #6
   21e1a:	d000      	beq.n	21e1e <_http_client_request+0x18a>
   21e1c:	e77b      	b.n	21d16 <_http_client_request+0x82>
			stream_writer_send_buffer(&writer, "HEAD ", 5);
   21e1e:	3a01      	subs	r2, #1
   21e20:	4983      	ldr	r1, [pc, #524]	; (22030 <_http_client_request+0x39c>)
   21e22:	e773      	b.n	21d0c <_http_client_request+0x78>
			} else if(entity->get_contents_length) {
   21e24:	689a      	ldr	r2, [r3, #8]
   21e26:	2a00      	cmp	r2, #0
   21e28:	d007      	beq.n	21e3a <_http_client_request+0x1a6>
				module->req.content_length = entity->get_contents_length(entity->priv_data);
   21e2a:	6958      	ldr	r0, [r3, #20]
   21e2c:	4790      	blx	r2
   21e2e:	0023      	movs	r3, r4
   21e30:	33cc      	adds	r3, #204	; 0xcc
   21e32:	1e02      	subs	r2, r0, #0
   21e34:	6018      	str	r0, [r3, #0]
				if (module->req.content_length < 0) {
   21e36:	da64      	bge.n	21f02 <_http_client_request+0x26e>
					module->req.content_length = 0;
   21e38:	601e      	str	r6, [r3, #0]
		if (module->req.ext_header != NULL ) {
   21e3a:	0023      	movs	r3, r4
   21e3c:	33d4      	adds	r3, #212	; 0xd4
   21e3e:	681d      	ldr	r5, [r3, #0]
   21e40:	2d00      	cmp	r5, #0
   21e42:	d00a      	beq.n	21e5a <_http_client_request+0x1c6>
			stream_writer_send_buffer(&writer,
   21e44:	4b6d      	ldr	r3, [pc, #436]	; (21ffc <_http_client_request+0x368>)
   21e46:	0028      	movs	r0, r5
   21e48:	4798      	blx	r3
   21e4a:	0002      	movs	r2, r0
   21e4c:	2010      	movs	r0, #16
   21e4e:	232c      	movs	r3, #44	; 0x2c
   21e50:	1838      	adds	r0, r7, r0
   21e52:	18c0      	adds	r0, r0, r3
   21e54:	0029      	movs	r1, r5
   21e56:	4b67      	ldr	r3, [pc, #412]	; (21ff4 <_http_client_request+0x360>)
   21e58:	4798      	blx	r3
		stream_writer_send_buffer(&writer, "\r\n", strlen("\r\n"));
   21e5a:	2010      	movs	r0, #16
   21e5c:	232c      	movs	r3, #44	; 0x2c
   21e5e:	1838      	adds	r0, r7, r0
   21e60:	18c0      	adds	r0, r0, r3
   21e62:	2202      	movs	r2, #2
   21e64:	4968      	ldr	r1, [pc, #416]	; (22008 <_http_client_request+0x374>)
   21e66:	4b63      	ldr	r3, [pc, #396]	; (21ff4 <_http_client_request+0x360>)
   21e68:	4798      	blx	r3
		stream_writer_send_remain(&writer);
   21e6a:	2210      	movs	r2, #16
   21e6c:	232c      	movs	r3, #44	; 0x2c
   21e6e:	18ba      	adds	r2, r7, r2
   21e70:	18d0      	adds	r0, r2, r3
   21e72:	4b70      	ldr	r3, [pc, #448]	; (22034 <_http_client_request+0x3a0>)
   21e74:	4798      	blx	r3
		module->req.state = STATE_REQ_SEND_ENTITY;
   21e76:	2304      	movs	r3, #4
   21e78:	66e3      	str	r3, [r4, #108]	; 0x6c
		if (module->req.content_length < 0 && entity->read) {
   21e7a:	0025      	movs	r5, r4
   21e7c:	35cc      	adds	r5, #204	; 0xcc
   21e7e:	682a      	ldr	r2, [r5, #0]
   21e80:	60bd      	str	r5, [r7, #8]
   21e82:	2a00      	cmp	r2, #0
   21e84:	db00      	blt.n	21e88 <_http_client_request+0x1f4>
   21e86:	e084      	b.n	21f92 <_http_client_request+0x2fe>
   21e88:	0020      	movs	r0, r4
   21e8a:	30b0      	adds	r0, #176	; 0xb0
   21e8c:	68c5      	ldr	r5, [r0, #12]
   21e8e:	2d00      	cmp	r5, #0
   21e90:	d072      	beq.n	21f78 <_http_client_request+0x2e4>
				module->config.send_buffer_size - HTTP_CHUNKED_MAX_LENGTH - 4, module->req.sent_length);
   21e92:	0026      	movs	r6, r4
			size = entity->read(entity->priv_data, buffer + HTTP_CHUNKED_MAX_LENGTH + 2,
   21e94:	6e63      	ldr	r3, [r4, #100]	; 0x64
				module->config.send_buffer_size - HTTP_CHUNKED_MAX_LENGTH - 4, module->req.sent_length);
   21e96:	36d0      	adds	r6, #208	; 0xd0
			size = entity->read(entity->priv_data, buffer + HTTP_CHUNKED_MAX_LENGTH + 2,
   21e98:	1fda      	subs	r2, r3, #7
   21e9a:	68fb      	ldr	r3, [r7, #12]
   21e9c:	6940      	ldr	r0, [r0, #20]
   21e9e:	1d59      	adds	r1, r3, #5
   21ea0:	6833      	ldr	r3, [r6, #0]
				module->config.send_buffer_size - HTTP_CHUNKED_MAX_LENGTH - 4, module->req.sent_length);
   21ea2:	60be      	str	r6, [r7, #8]
			size = entity->read(entity->priv_data, buffer + HTTP_CHUNKED_MAX_LENGTH + 2,
   21ea4:	47a8      	blx	r5
   21ea6:	43c3      	mvns	r3, r0
   21ea8:	0005      	movs	r5, r0
			buffer[HTTP_CHUNKED_MAX_LENGTH + 1] = '\n';
   21eaa:	220a      	movs	r2, #10
			buffer[HTTP_CHUNKED_MAX_LENGTH] = '\r';
   21eac:	210d      	movs	r1, #13
   21eae:	17db      	asrs	r3, r3, #31
   21eb0:	401d      	ands	r5, r3
			buffer[HTTP_CHUNKED_MAX_LENGTH + 1] = '\n';
   21eb2:	68fb      	ldr	r3, [r7, #12]
   21eb4:	711a      	strb	r2, [r3, #4]
			buffer[HTTP_CHUNKED_MAX_LENGTH] = '\r';
   21eb6:	68fb      	ldr	r3, [r7, #12]
   21eb8:	70d9      	strb	r1, [r3, #3]
			buffer[size + HTTP_CHUNKED_MAX_LENGTH + 2] = '\r';
   21eba:	68fb      	ldr	r3, [r7, #12]
				*ptr = CH_LUT[size % 16];
   21ebc:	68f8      	ldr	r0, [r7, #12]
			buffer[size + HTTP_CHUNKED_MAX_LENGTH + 2] = '\r';
   21ebe:	195b      	adds	r3, r3, r5
   21ec0:	7159      	strb	r1, [r3, #5]
			buffer[size + HTTP_CHUNKED_MAX_LENGTH + 3] = '\n';
   21ec2:	719a      	strb	r2, [r3, #6]
				*ptr = CH_LUT[size % 16];
   21ec4:	231c      	movs	r3, #28
   21ec6:	3206      	adds	r2, #6
   21ec8:	18ba      	adds	r2, r7, r2
   21eca:	18d2      	adds	r2, r2, r3
   21ecc:	002b      	movs	r3, r5
   21ece:	3102      	adds	r1, #2
   21ed0:	400b      	ands	r3, r1
   21ed2:	5cd3      	ldrb	r3, [r2, r3]
   21ed4:	7083      	strb	r3, [r0, #2]
			if (size >= 0x10) {
   21ed6:	428d      	cmp	r5, r1
   21ed8:	dc2d      	bgt.n	21f36 <_http_client_request+0x2a2>
				ptr = buffer + 2;
   21eda:	1c81      	adds	r1, r0, #2
			if ((result = send(module->sock, (void*)ptr, ptr + HTTP_CHUNKED_MAX_LENGTH - buffer + size + 4, 0)) < 0) {	
   21edc:	2000      	movs	r0, #0
   21ede:	68fb      	ldr	r3, [r7, #12]
   21ee0:	1cca      	adds	r2, r1, #3
   21ee2:	1ad2      	subs	r2, r2, r3
   21ee4:	1d2b      	adds	r3, r5, #4
   21ee6:	18d2      	adds	r2, r2, r3
   21ee8:	b292      	uxth	r2, r2
   21eea:	5620      	ldrsb	r0, [r4, r0]
   21eec:	2300      	movs	r3, #0
   21eee:	4e52      	ldr	r6, [pc, #328]	; (22038 <_http_client_request+0x3a4>)
   21ef0:	47b0      	blx	r6
   21ef2:	2800      	cmp	r0, #0
   21ef4:	da2f      	bge.n	21f56 <_http_client_request+0x2c2>
				_http_client_clear_conn(module, (size == 0)?-EBADMSG:-EIO);
   21ef6:	2105      	movs	r1, #5
   21ef8:	0020      	movs	r0, r4
   21efa:	4249      	negs	r1, r1
   21efc:	4b4f      	ldr	r3, [pc, #316]	; (2203c <_http_client_request+0x3a8>)
   21efe:	4798      	blx	r3
   21f00:	e6ea      	b.n	21cd8 <_http_client_request+0x44>
					sprintf(length, "%u", (unsigned int)module->req.content_length);
   21f02:	2314      	movs	r3, #20
   21f04:	494e      	ldr	r1, [pc, #312]	; (22040 <_http_client_request+0x3ac>)
   21f06:	18f8      	adds	r0, r7, r3
   21f08:	4b4e      	ldr	r3, [pc, #312]	; (22044 <_http_client_request+0x3b0>)
   21f0a:	4798      	blx	r3
					stream_writer_send_buffer(&writer, "Content-Length: ", strlen("Content-Length: "));
   21f0c:	2210      	movs	r2, #16
   21f0e:	232c      	movs	r3, #44	; 0x2c
   21f10:	18b8      	adds	r0, r7, r2
   21f12:	494d      	ldr	r1, [pc, #308]	; (22048 <_http_client_request+0x3b4>)
   21f14:	18c0      	adds	r0, r0, r3
   21f16:	47a8      	blx	r5
					stream_writer_send_buffer(&writer, length, strlen(length));
   21f18:	2314      	movs	r3, #20
   21f1a:	18f8      	adds	r0, r7, r3
   21f1c:	4b37      	ldr	r3, [pc, #220]	; (21ffc <_http_client_request+0x368>)
   21f1e:	4798      	blx	r3
   21f20:	2314      	movs	r3, #20
   21f22:	0002      	movs	r2, r0
   21f24:	2010      	movs	r0, #16
   21f26:	18f9      	adds	r1, r7, r3
   21f28:	1838      	adds	r0, r7, r0
   21f2a:	3318      	adds	r3, #24
   21f2c:	18c0      	adds	r0, r0, r3
   21f2e:	47a8      	blx	r5
					stream_writer_send_buffer(&writer, "\r\n", strlen("\r\n"));
   21f30:	2202      	movs	r2, #2
   21f32:	4935      	ldr	r1, [pc, #212]	; (22008 <_http_client_request+0x374>)
   21f34:	e757      	b.n	21de6 <_http_client_request+0x152>
				*ptr = CH_LUT[(size / 0x10) % 16];
   21f36:	112b      	asrs	r3, r5, #4
   21f38:	400b      	ands	r3, r1
   21f3a:	5cd3      	ldrb	r3, [r2, r3]
   21f3c:	68f8      	ldr	r0, [r7, #12]
   21f3e:	7043      	strb	r3, [r0, #1]
			if (size >= 0x100) {
   21f40:	2dff      	cmp	r5, #255	; 0xff
   21f42:	dc01      	bgt.n	21f48 <_http_client_request+0x2b4>
				ptr = buffer + 1;
   21f44:	1c41      	adds	r1, r0, #1
   21f46:	e7c9      	b.n	21edc <_http_client_request+0x248>
				*ptr = CH_LUT[(size / 0x100) % 16];
   21f48:	122b      	asrs	r3, r5, #8
   21f4a:	400b      	ands	r3, r1
   21f4c:	5cd3      	ldrb	r3, [r2, r3]
   21f4e:	68fa      	ldr	r2, [r7, #12]
   21f50:	7013      	strb	r3, [r2, #0]
   21f52:	0011      	movs	r1, r2
   21f54:	e7c2      	b.n	21edc <_http_client_request+0x248>
			module->req.sent_length += size;
   21f56:	68bb      	ldr	r3, [r7, #8]
   21f58:	68ba      	ldr	r2, [r7, #8]
   21f5a:	681b      	ldr	r3, [r3, #0]
   21f5c:	195b      	adds	r3, r3, r5
   21f5e:	6013      	str	r3, [r2, #0]
			if(size == 0) {
   21f60:	2d00      	cmp	r5, #0
   21f62:	d000      	beq.n	21f66 <_http_client_request+0x2d2>
   21f64:	e6b8      	b.n	21cd8 <_http_client_request+0x44>
				if (module->req.entity.close) {
   21f66:	0023      	movs	r3, r4
   21f68:	33c0      	adds	r3, #192	; 0xc0
   21f6a:	681b      	ldr	r3, [r3, #0]
   21f6c:	2b00      	cmp	r3, #0
   21f6e:	d003      	beq.n	21f78 <_http_client_request+0x2e4>
					module->req.entity.close(module->req.entity.priv_data);
   21f70:	0022      	movs	r2, r4
   21f72:	32c4      	adds	r2, #196	; 0xc4
   21f74:	6810      	ldr	r0, [r2, #0]
   21f76:	4798      	blx	r3
			module->req.state = STATE_SOCK_CONNECTED;
   21f78:	2302      	movs	r3, #2
   21f7a:	66e3      	str	r3, [r4, #108]	; 0x6c
			if (module->cb) {
   21f7c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   21f7e:	2b00      	cmp	r3, #0
   21f80:	d100      	bne.n	21f84 <_http_client_request+0x2f0>
   21f82:	e6a9      	b.n	21cd8 <_http_client_request+0x44>
				module->cb(module, HTTP_CLIENT_CALLBACK_REQUESTED, &data);
   21f84:	2210      	movs	r2, #16
   21f86:	18b9      	adds	r1, r7, r2
   21f88:	188a      	adds	r2, r1, r2
   21f8a:	0020      	movs	r0, r4
   21f8c:	2101      	movs	r1, #1
   21f8e:	4798      	blx	r3
   21f90:	e6a2      	b.n	21cd8 <_http_client_request+0x44>
		} else if (module->req.content_length > 0 && entity->read) {
   21f92:	2a00      	cmp	r2, #0
   21f94:	d0f0      	beq.n	21f78 <_http_client_request+0x2e4>
   21f96:	0020      	movs	r0, r4
   21f98:	30b0      	adds	r0, #176	; 0xb0
   21f9a:	68c3      	ldr	r3, [r0, #12]
   21f9c:	1e1d      	subs	r5, r3, #0
   21f9e:	d0eb      	beq.n	21f78 <_http_client_request+0x2e4>
			if (module->req.sent_length >= module->req.content_length) {
   21fa0:	0026      	movs	r6, r4
   21fa2:	36d0      	adds	r6, #208	; 0xd0
   21fa4:	6833      	ldr	r3, [r6, #0]
   21fa6:	429a      	cmp	r2, r3
   21fa8:	dddd      	ble.n	21f66 <_http_client_request+0x2d2>
			size = entity->read(entity->priv_data, buffer, module->config.send_buffer_size, module->req.sent_length);
   21faa:	6e62      	ldr	r2, [r4, #100]	; 0x64
   21fac:	68f9      	ldr	r1, [r7, #12]
   21fae:	6940      	ldr	r0, [r0, #20]
   21fb0:	47a8      	blx	r5
			if (size < 0) {
   21fb2:	2800      	cmp	r0, #0
   21fb4:	db9f      	blt.n	21ef6 <_http_client_request+0x262>
				if (size > module->req.content_length - module->req.sent_length) {
   21fb6:	68bb      	ldr	r3, [r7, #8]
   21fb8:	681d      	ldr	r5, [r3, #0]
   21fba:	6833      	ldr	r3, [r6, #0]
   21fbc:	1aeb      	subs	r3, r5, r3
   21fbe:	60bb      	str	r3, [r7, #8]
   21fc0:	4283      	cmp	r3, r0
   21fc2:	dd00      	ble.n	21fc6 <_http_client_request+0x332>
   21fc4:	60b8      	str	r0, [r7, #8]
				if ((result = send(module->sock, (void*)buffer, size, 0)) < 0) {
   21fc6:	2000      	movs	r0, #0
   21fc8:	893a      	ldrh	r2, [r7, #8]
   21fca:	5620      	ldrsb	r0, [r4, r0]
   21fcc:	2300      	movs	r3, #0
   21fce:	68f9      	ldr	r1, [r7, #12]
   21fd0:	4d19      	ldr	r5, [pc, #100]	; (22038 <_http_client_request+0x3a4>)
   21fd2:	47a8      	blx	r5
   21fd4:	2800      	cmp	r0, #0
   21fd6:	db8e      	blt.n	21ef6 <_http_client_request+0x262>
				module->req.sent_length += size;
   21fd8:	6833      	ldr	r3, [r6, #0]
   21fda:	68ba      	ldr	r2, [r7, #8]
   21fdc:	189d      	adds	r5, r3, r2
   21fde:	6035      	str	r5, [r6, #0]
   21fe0:	e67a      	b.n	21cd8 <_http_client_request+0x44>
   21fe2:	46c0      	nop			; (mov r8, r8)
   21fe4:	0002b314 	.word	0x0002b314
   21fe8:	00022c11 	.word	0x00022c11
   21fec:	00021a61 	.word	0x00021a61
   21ff0:	00022745 	.word	0x00022745
   21ff4:	00022791 	.word	0x00022791
   21ff8:	0002b34e 	.word	0x0002b34e
   21ffc:	000238c3 	.word	0x000238c3
   22000:	0002b375 	.word	0x0002b375
   22004:	0002b381 	.word	0x0002b381
   22008:	0002927a 	.word	0x0002927a
   2200c:	0002b38e 	.word	0x0002b38e
   22010:	0002b395 	.word	0x0002b395
   22014:	0002b3ae 	.word	0x0002b3ae
   22018:	0002b3c2 	.word	0x0002b3c2
   2201c:	0002b3da 	.word	0x0002b3da
   22020:	0002b353 	.word	0x0002b353
   22024:	0002b359 	.word	0x0002b359
   22028:	0002b361 	.word	0x0002b361
   2202c:	0002b366 	.word	0x0002b366
   22030:	0002b36f 	.word	0x0002b36f
   22034:	00022755 	.word	0x00022755
   22038:	0001cb31 	.word	0x0001cb31
   2203c:	00021b81 	.word	0x00021b81
   22040:	0002b3f7 	.word	0x0002b3f7
   22044:	000237e5 	.word	0x000237e5
   22048:	0002b3fa 	.word	0x0002b3fa

0002204c <http_client_send_request>:
{
   2204c:	b5f0      	push	{r4, r5, r6, r7, lr}
   2204e:	b08b      	sub	sp, #44	; 0x2c
   22050:	0004      	movs	r4, r0
   22052:	000f      	movs	r7, r1
   22054:	9205      	str	r2, [sp, #20]
   22056:	9302      	str	r3, [sp, #8]
	if (module == NULL) {
   22058:	2800      	cmp	r0, #0
   2205a:	d102      	bne.n	22062 <http_client_send_request+0x16>
		return -EINVAL;
   2205c:	2516      	movs	r5, #22
			return -ENOSPC;
   2205e:	426d      	negs	r5, r5
   22060:	e08b      	b.n	2217a <http_client_send_request+0x12e>
	if (module->req.state > STATE_SOCK_CONNECTED) {
   22062:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
   22064:	2b02      	cmp	r3, #2
   22066:	d900      	bls.n	2206a <http_client_send_request+0x1e>
   22068:	e0e2      	b.n	22230 <http_client_send_request+0x1e4>
	if (!strncmp(url, "http://", 7)) {
   2206a:	2207      	movs	r2, #7
   2206c:	4973      	ldr	r1, [pc, #460]	; (2223c <http_client_send_request+0x1f0>)
   2206e:	0038      	movs	r0, r7
   22070:	4d73      	ldr	r5, [pc, #460]	; (22240 <http_client_send_request+0x1f4>)
   22072:	47a8      	blx	r5
		i = 7;
   22074:	2307      	movs	r3, #7
   22076:	9301      	str	r3, [sp, #4]
	if (!strncmp(url, "http://", 7)) {
   22078:	2800      	cmp	r0, #0
   2207a:	d008      	beq.n	2208e <http_client_send_request+0x42>
	} else if (!strncmp(url, "https://", 8)) {
   2207c:	2208      	movs	r2, #8
   2207e:	4971      	ldr	r1, [pc, #452]	; (22244 <http_client_send_request+0x1f8>)
   22080:	0038      	movs	r0, r7
   22082:	47a8      	blx	r5
   22084:	0003      	movs	r3, r0
		i = 8;
   22086:	4258      	negs	r0, r3
   22088:	4158      	adcs	r0, r3
   2208a:	00c3      	lsls	r3, r0, #3
   2208c:	9301      	str	r3, [sp, #4]
	reconnect = strncmp(module->host, url + i, strlen(module->host));
   2208e:	9b01      	ldr	r3, [sp, #4]
   22090:	1c66      	adds	r6, r4, #1
   22092:	18fb      	adds	r3, r7, r3
   22094:	9304      	str	r3, [sp, #16]
   22096:	0030      	movs	r0, r6
   22098:	4b6b      	ldr	r3, [pc, #428]	; (22248 <http_client_send_request+0x1fc>)
   2209a:	4798      	blx	r3
   2209c:	4b68      	ldr	r3, [pc, #416]	; (22240 <http_client_send_request+0x1f4>)
   2209e:	0002      	movs	r2, r0
   220a0:	9904      	ldr	r1, [sp, #16]
   220a2:	0030      	movs	r0, r6
   220a4:	4798      	blx	r3
	int i = 0, j = 0, reconnect = 0;
   220a6:	2300      	movs	r3, #0
	reconnect = strncmp(module->host, url + i, strlen(module->host));
   220a8:	0005      	movs	r5, r0
   220aa:	9003      	str	r0, [sp, #12]
   220ac:	9a01      	ldr	r2, [sp, #4]
   220ae:	18d2      	adds	r2, r2, r3
   220b0:	18ba      	adds	r2, r7, r2
   220b2:	9200      	str	r2, [sp, #0]
	for (; url[i] != '\0' && url[i] != '/'; i++) {
   220b4:	9a04      	ldr	r2, [sp, #16]
   220b6:	5cd2      	ldrb	r2, [r2, r3]
   220b8:	2a00      	cmp	r2, #0
   220ba:	d11f      	bne.n	220fc <http_client_send_request+0xb0>
	module->host[j] = '\0';
   220bc:	2200      	movs	r2, #0
   220be:	18e3      	adds	r3, r4, r3
   220c0:	705a      	strb	r2, [r3, #1]
	if (strlen(module->host) == 0) {
   220c2:	7863      	ldrb	r3, [r4, #1]
   220c4:	4293      	cmp	r3, r2
   220c6:	d0c9      	beq.n	2205c <http_client_send_request+0x10>
	if (strlen(uri) >= HTTP_MAX_URI_LENGTH) {
   220c8:	9800      	ldr	r0, [sp, #0]
   220ca:	4b5f      	ldr	r3, [pc, #380]	; (22248 <http_client_send_request+0x1fc>)
   220cc:	4798      	blx	r3
   220ce:	283f      	cmp	r0, #63	; 0x3f
   220d0:	d900      	bls.n	220d4 <http_client_send_request+0x88>
   220d2:	e0af      	b.n	22234 <http_client_send_request+0x1e8>
	if (module->req.ext_header != NULL) {
   220d4:	0027      	movs	r7, r4
   220d6:	37d4      	adds	r7, #212	; 0xd4
   220d8:	6838      	ldr	r0, [r7, #0]
   220da:	2800      	cmp	r0, #0
   220dc:	d001      	beq.n	220e2 <http_client_send_request+0x96>
		free(module->req.ext_header);
   220de:	4b5b      	ldr	r3, [pc, #364]	; (2224c <http_client_send_request+0x200>)
   220e0:	4798      	blx	r3
	if (ext_header != NULL) {
   220e2:	9b10      	ldr	r3, [sp, #64]	; 0x40
   220e4:	2b00      	cmp	r3, #0
   220e6:	d00e      	beq.n	22106 <http_client_send_request+0xba>
		module->req.ext_header = strdup(ext_header);
   220e8:	0018      	movs	r0, r3
   220ea:	4b59      	ldr	r3, [pc, #356]	; (22250 <http_client_send_request+0x204>)
   220ec:	4798      	blx	r3
   220ee:	0023      	movs	r3, r4
   220f0:	33d4      	adds	r3, #212	; 0xd4
   220f2:	6018      	str	r0, [r3, #0]
		if (module->req.ext_header == NULL) {
   220f4:	2800      	cmp	r0, #0
   220f6:	d108      	bne.n	2210a <http_client_send_request+0xbe>
			return -ENOMEM;
   220f8:	250c      	movs	r5, #12
   220fa:	e7b0      	b.n	2205e <http_client_send_request+0x12>
	for (; url[i] != '\0' && url[i] != '/'; i++) {
   220fc:	2a2f      	cmp	r2, #47	; 0x2f
   220fe:	d0dd      	beq.n	220bc <http_client_send_request+0x70>
		module->host[j++] = url[i];
   22100:	3301      	adds	r3, #1
   22102:	54e2      	strb	r2, [r4, r3]
   22104:	e7d2      	b.n	220ac <http_client_send_request+0x60>
		module->req.ext_header = NULL;
   22106:	9b10      	ldr	r3, [sp, #64]	; 0x40
   22108:	603b      	str	r3, [r7, #0]
	module->sending = 0;
   2210a:	0022      	movs	r2, r4
   2210c:	2101      	movs	r1, #1
   2210e:	3241      	adds	r2, #65	; 0x41
   22110:	7813      	ldrb	r3, [r2, #0]
   22112:	0020      	movs	r0, r4
   22114:	438b      	bics	r3, r1
   22116:	7013      	strb	r3, [r2, #0]
	module->recved_size = 0;
   22118:	2300      	movs	r3, #0
   2211a:	6463      	str	r3, [r4, #68]	; 0x44
	if (uri[0] == '/') {
   2211c:	9b00      	ldr	r3, [sp, #0]
   2211e:	3070      	adds	r0, #112	; 0x70
   22120:	781b      	ldrb	r3, [r3, #0]
		strcpy(module->req.uri, uri);
   22122:	9900      	ldr	r1, [sp, #0]
	if (uri[0] == '/') {
   22124:	2b2f      	cmp	r3, #47	; 0x2f
   22126:	d008      	beq.n	2213a <http_client_send_request+0xee>
		module->req.uri[0] = '/';
   22128:	232f      	movs	r3, #47	; 0x2f
   2212a:	7003      	strb	r3, [r0, #0]
		if (uri[0] != 0) {
   2212c:	9b00      	ldr	r3, [sp, #0]
   2212e:	781b      	ldrb	r3, [r3, #0]
   22130:	2b00      	cmp	r3, #0
   22132:	d004      	beq.n	2213e <http_client_send_request+0xf2>
			strcpy(module->req.uri + 1, uri);
   22134:	0020      	movs	r0, r4
   22136:	9900      	ldr	r1, [sp, #0]
   22138:	3071      	adds	r0, #113	; 0x71
   2213a:	4b46      	ldr	r3, [pc, #280]	; (22254 <http_client_send_request+0x208>)
   2213c:	4798      	blx	r3
   2213e:	0020      	movs	r0, r4
	if (entity != NULL) {
   22140:	9b02      	ldr	r3, [sp, #8]
   22142:	30b0      	adds	r0, #176	; 0xb0
		memcpy(&module->req.entity, entity, sizeof(struct http_entity));
   22144:	2218      	movs	r2, #24
	if (entity != NULL) {
   22146:	2b00      	cmp	r3, #0
   22148:	d010      	beq.n	2216c <http_client_send_request+0x120>
		memcpy(&module->req.entity, entity, sizeof(struct http_entity));
   2214a:	0019      	movs	r1, r3
   2214c:	4b42      	ldr	r3, [pc, #264]	; (22258 <http_client_send_request+0x20c>)
   2214e:	4798      	blx	r3
	module->req.method = method;
   22150:	466a      	mov	r2, sp
   22152:	0023      	movs	r3, r4
   22154:	7d12      	ldrb	r2, [r2, #20]
   22156:	33c8      	adds	r3, #200	; 0xc8
   22158:	701a      	strb	r2, [r3, #0]
	switch (module->req.state) {
   2215a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   2215c:	2b01      	cmp	r3, #1
   2215e:	d009      	beq.n	22174 <http_client_send_request+0x128>
   22160:	2b00      	cmp	r3, #0
   22162:	d01a      	beq.n	2219a <http_client_send_request+0x14e>
   22164:	2b02      	cmp	r3, #2
   22166:	d00b      	beq.n	22180 <http_client_send_request+0x134>
		return -EAGAIN;
   22168:	250b      	movs	r5, #11
   2216a:	e778      	b.n	2205e <http_client_send_request+0x12>
		memset(&module->req.entity, 0, sizeof(struct http_entity));
   2216c:	9902      	ldr	r1, [sp, #8]
   2216e:	4b3b      	ldr	r3, [pc, #236]	; (2225c <http_client_send_request+0x210>)
   22170:	4798      	blx	r3
   22172:	e7ed      	b.n	22150 <http_client_send_request+0x104>
		if (!reconnect) {
   22174:	9b03      	ldr	r3, [sp, #12]
   22176:	2b00      	cmp	r3, #0
   22178:	d10b      	bne.n	22192 <http_client_send_request+0x146>
}
   2217a:	0028      	movs	r0, r5
   2217c:	b00b      	add	sp, #44	; 0x2c
   2217e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (!reconnect) {
   22180:	9b03      	ldr	r3, [sp, #12]
   22182:	2b00      	cmp	r3, #0
   22184:	d105      	bne.n	22192 <http_client_send_request+0x146>
			module->req.state = STATE_REQ_SEND_HEADER;
   22186:	3303      	adds	r3, #3
   22188:	66e3      	str	r3, [r4, #108]	; 0x6c
			_http_client_request(module);
   2218a:	0020      	movs	r0, r4
   2218c:	4b34      	ldr	r3, [pc, #208]	; (22260 <http_client_send_request+0x214>)
   2218e:	4798      	blx	r3
			break;
   22190:	e7f3      	b.n	2217a <http_client_send_request+0x12e>
			_http_client_clear_conn(module, 0);
   22192:	2100      	movs	r1, #0
   22194:	0020      	movs	r0, r4
   22196:	4b33      	ldr	r3, [pc, #204]	; (22264 <http_client_send_request+0x218>)
   22198:	4798      	blx	r3
		if (module->config.tls) {
   2219a:	0023      	movs	r3, r4
   2219c:	3352      	adds	r3, #82	; 0x52
   2219e:	781a      	ldrb	r2, [r3, #0]
		module->sock = socket(AF_INET, SOCK_STREAM, flag);
   221a0:	2101      	movs	r1, #1
		if (module->config.tls) {
   221a2:	1e53      	subs	r3, r2, #1
   221a4:	419a      	sbcs	r2, r3
		module->sock = socket(AF_INET, SOCK_STREAM, flag);
   221a6:	2002      	movs	r0, #2
   221a8:	b2d2      	uxtb	r2, r2
   221aa:	4b2f      	ldr	r3, [pc, #188]	; (22268 <http_client_send_request+0x21c>)
   221ac:	4798      	blx	r3
   221ae:	7020      	strb	r0, [r4, #0]
		if (module->sock >= 0) {
   221b0:	2800      	cmp	r0, #0
   221b2:	db41      	blt.n	22238 <http_client_send_request+0x1ec>
			module_ref_inst[module->sock] = module;
   221b4:	4b2d      	ldr	r3, [pc, #180]	; (2226c <http_client_send_request+0x220>)
   221b6:	0080      	lsls	r0, r0, #2
   221b8:	50c4      	str	r4, [r0, r3]
		if ((ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F') || ch == ':' || ch == '/') {
   221ba:	2320      	movs	r3, #32
			module_ref_inst[module->sock] = module;
   221bc:	0031      	movs	r1, r6
	uint32_t isv6 = 0;
   221be:	2200      	movs	r2, #0
		if ((ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F') || ch == ':' || ch == '/') {
   221c0:	469c      	mov	ip, r3
			isv6 = 1;
   221c2:	2001      	movs	r0, #1
	while (*host != '\0') {
   221c4:	780b      	ldrb	r3, [r1, #0]
   221c6:	2b00      	cmp	r3, #0
   221c8:	d118      	bne.n	221fc <http_client_send_request+0x1b0>
				addr_in.sin_family = AF_INET;
   221ca:	2302      	movs	r3, #2
   221cc:	aa06      	add	r2, sp, #24
   221ce:	8013      	strh	r3, [r2, #0]
				addr_in.sin_port = _htons(module->config.port);
   221d0:	0023      	movs	r3, r4
   221d2:	3350      	adds	r3, #80	; 0x50
   221d4:	881b      	ldrh	r3, [r3, #0]
				addr_in.sin_addr.s_addr = nmi_inet_addr((char *)module->host);
   221d6:	0030      	movs	r0, r6
				addr_in.sin_port = _htons(module->config.port);
   221d8:	021a      	lsls	r2, r3, #8
   221da:	0a1b      	lsrs	r3, r3, #8
   221dc:	4313      	orrs	r3, r2
   221de:	aa06      	add	r2, sp, #24
   221e0:	8053      	strh	r3, [r2, #2]
				addr_in.sin_addr.s_addr = nmi_inet_addr((char *)module->host);
   221e2:	4b23      	ldr	r3, [pc, #140]	; (22270 <http_client_send_request+0x224>)
   221e4:	4798      	blx	r3
   221e6:	9007      	str	r0, [sp, #28]
				connect(module->sock, (struct sockaddr *)&addr_in, sizeof(struct sockaddr_in));
   221e8:	2000      	movs	r0, #0
   221ea:	2210      	movs	r2, #16
   221ec:	5620      	ldrsb	r0, [r4, r0]
   221ee:	a906      	add	r1, sp, #24
   221f0:	4b20      	ldr	r3, [pc, #128]	; (22274 <http_client_send_request+0x228>)
   221f2:	4798      	blx	r3
			module->req.state = STATE_TRY_SOCK_CONNECT;
   221f4:	2301      	movs	r3, #1
	return 0;
   221f6:	2500      	movs	r5, #0
			module->req.state = STATE_TRY_SOCK_CONNECT;
   221f8:	66e3      	str	r3, [r4, #108]	; 0x6c
		break;
   221fa:	e7be      	b.n	2217a <http_client_send_request+0x12e>
		if ((ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F') || ch == ':' || ch == '/') {
   221fc:	001d      	movs	r5, r3
   221fe:	4667      	mov	r7, ip
   22200:	43bd      	bics	r5, r7
   22202:	3d41      	subs	r5, #65	; 0x41
		ch = *host++;
   22204:	3101      	adds	r1, #1
		if ((ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F') || ch == ':' || ch == '/') {
   22206:	2d05      	cmp	r5, #5
   22208:	d910      	bls.n	2222c <http_client_send_request+0x1e0>
   2220a:	2b3a      	cmp	r3, #58	; 0x3a
   2220c:	d00e      	beq.n	2222c <http_client_send_request+0x1e0>
   2220e:	2b2f      	cmp	r3, #47	; 0x2f
   22210:	d00c      	beq.n	2222c <http_client_send_request+0x1e0>
		} else if (ch == '.') {
   22212:	2b2e      	cmp	r3, #46	; 0x2e
   22214:	d105      	bne.n	22222 <http_client_send_request+0x1d6>
			if (isv6) {
   22216:	2a00      	cmp	r2, #0
   22218:	d0d4      	beq.n	221c4 <http_client_send_request+0x178>
				gethostbyname((uint8*)module->host);
   2221a:	0030      	movs	r0, r6
   2221c:	4b16      	ldr	r3, [pc, #88]	; (22278 <http_client_send_request+0x22c>)
   2221e:	4798      	blx	r3
   22220:	e7e8      	b.n	221f4 <http_client_send_request+0x1a8>
		} else if ((ch & 0x30) != 0x30) {
   22222:	2530      	movs	r5, #48	; 0x30
   22224:	402b      	ands	r3, r5
   22226:	42ab      	cmp	r3, r5
   22228:	d0cc      	beq.n	221c4 <http_client_send_request+0x178>
   2222a:	e7f6      	b.n	2221a <http_client_send_request+0x1ce>
			isv6 = 1;
   2222c:	0002      	movs	r2, r0
   2222e:	e7c9      	b.n	221c4 <http_client_send_request+0x178>
		return -EBUSY;
   22230:	2510      	movs	r5, #16
   22232:	e714      	b.n	2205e <http_client_send_request+0x12>
		return -ENAMETOOLONG;
   22234:	255b      	movs	r5, #91	; 0x5b
   22236:	e712      	b.n	2205e <http_client_send_request+0x12>
			return -ENOSPC;
   22238:	251c      	movs	r5, #28
   2223a:	e710      	b.n	2205e <http_client_send_request+0x12>
   2223c:	0002b417 	.word	0x0002b417
   22240:	000238d1 	.word	0x000238d1
   22244:	0002b41f 	.word	0x0002b41f
   22248:	000238c3 	.word	0x000238c3
   2224c:	00022bfd 	.word	0x00022bfd
   22250:	00023889 	.word	0x00023889
   22254:	00023879 	.word	0x00023879
   22258:	00022c11 	.word	0x00022c11
   2225c:	00022c47 	.word	0x00022c47
   22260:	00021c95 	.word	0x00021c95
   22264:	00021b81 	.word	0x00021b81
   22268:	0001c9a5 	.word	0x0001c9a5
   2226c:	200041c8 	.word	0x200041c8
   22270:	0001cca1 	.word	0x0001cca1
   22274:	0001cab9 	.word	0x0001cab9
   22278:	0001ccf9 	.word	0x0001ccf9

0002227c <_http_client_recv_packet>:

void _http_client_recv_packet(struct http_client_module *const module)
{
   2227c:	b510      	push	{r4, lr}
	if (module == NULL) {
   2227e:	2800      	cmp	r0, #0
   22280:	d007      	beq.n	22292 <_http_client_recv_packet+0x16>
		return;
	}
	
	if (module->recved_size >= module->config.recv_buffer_size) {
   22282:	6c41      	ldr	r1, [r0, #68]	; 0x44
   22284:	6e02      	ldr	r2, [r0, #96]	; 0x60
   22286:	4291      	cmp	r1, r2
   22288:	d304      	bcc.n	22294 <_http_client_recv_packet+0x18>
		/* Has not enough memory. */
		_http_client_clear_conn(module, -EOVERFLOW);
   2228a:	218b      	movs	r1, #139	; 0x8b
   2228c:	4b06      	ldr	r3, [pc, #24]	; (222a8 <_http_client_recv_packet+0x2c>)
   2228e:	4249      	negs	r1, r1
   22290:	4798      	blx	r3
		module->config.recv_buffer_size - module->recved_size, 0) != 0);
	*/
	recv(module->sock,
		module->config.recv_buffer + module->recved_size,
		module->config.recv_buffer_size - module->recved_size, 0);
}
   22292:	bd10      	pop	{r4, pc}
		module->config.recv_buffer + module->recved_size,
   22294:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
	recv(module->sock,
   22296:	7800      	ldrb	r0, [r0, #0]
   22298:	1a52      	subs	r2, r2, r1
   2229a:	b292      	uxth	r2, r2
		module->config.recv_buffer + module->recved_size,
   2229c:	1859      	adds	r1, r3, r1
	recv(module->sock,
   2229e:	4c03      	ldr	r4, [pc, #12]	; (222ac <_http_client_recv_packet+0x30>)
   222a0:	2300      	movs	r3, #0
   222a2:	b240      	sxtb	r0, r0
   222a4:	47a0      	blx	r4
   222a6:	e7f4      	b.n	22292 <_http_client_recv_packet+0x16>
   222a8:	00021b81 	.word	0x00021b81
   222ac:	0001cba1 	.word	0x0001cba1

000222b0 <_http_client_move_buffer>:

	return 0;
}

void _http_client_move_buffer(struct http_client_module *const module, char *base)
{
   222b0:	b570      	push	{r4, r5, r6, lr}
   222b2:	0005      	movs	r5, r0
	char *buffer = module->config.recv_buffer;
	int remain = (int)module->recved_size - (int)base + (int)buffer;
   222b4:	6c6b      	ldr	r3, [r5, #68]	; 0x44
	char *buffer = module->config.recv_buffer;
   222b6:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
	int remain = (int)module->recved_size - (int)base + (int)buffer;
   222b8:	1a5c      	subs	r4, r3, r1
   222ba:	1904      	adds	r4, r0, r4

	if (remain > 0) {
   222bc:	2c00      	cmp	r4, #0
   222be:	dd04      	ble.n	222ca <_http_client_move_buffer+0x1a>
		memmove(buffer, base, remain);
   222c0:	0022      	movs	r2, r4
   222c2:	4b03      	ldr	r3, [pc, #12]	; (222d0 <_http_client_move_buffer+0x20>)
   222c4:	4798      	blx	r3
		module->recved_size = remain;
   222c6:	646c      	str	r4, [r5, #68]	; 0x44
	} else {
		module->recved_size = 0;
	}
}
   222c8:	bd70      	pop	{r4, r5, r6, pc}
		module->recved_size = 0;
   222ca:	2300      	movs	r3, #0
   222cc:	646b      	str	r3, [r5, #68]	; 0x44
}
   222ce:	e7fb      	b.n	222c8 <_http_client_move_buffer+0x18>
   222d0:	00022c23 	.word	0x00022c23

000222d4 <_http_client_handle_header>:
{
   222d4:	b5f0      	push	{r4, r5, r6, r7, lr}
   222d6:	0005      	movs	r5, r0
	for (ptr = module->config.recv_buffer ; ; ) {
   222d8:	6dc4      	ldr	r4, [r0, #92]	; 0x5c
{
   222da:	b085      	sub	sp, #20
		ptr_line_end = strstr(ptr, new_line);
   222dc:	4e54      	ldr	r6, [pc, #336]	; (22430 <_http_client_handle_header+0x15c>)
   222de:	0020      	movs	r0, r4
   222e0:	0031      	movs	r1, r6
   222e2:	4b54      	ldr	r3, [pc, #336]	; (22434 <_http_client_handle_header+0x160>)
   222e4:	4798      	blx	r3
   222e6:	1e07      	subs	r7, r0, #0
		if (ptr_line_end == NULL || ptr_line_end >= module->config.recv_buffer + module->recved_size) {
   222e8:	d107      	bne.n	222fa <_http_client_handle_header+0x26>
			_http_client_move_buffer(module, ptr);
   222ea:	0021      	movs	r1, r4
   222ec:	0028      	movs	r0, r5
   222ee:	4b52      	ldr	r3, [pc, #328]	; (22438 <_http_client_handle_header+0x164>)
   222f0:	4798      	blx	r3
			return 0;
   222f2:	2600      	movs	r6, #0
}
   222f4:	0030      	movs	r0, r6
   222f6:	b005      	add	sp, #20
   222f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (ptr_line_end == NULL || ptr_line_end >= module->config.recv_buffer + module->recved_size) {
   222fa:	6deb      	ldr	r3, [r5, #92]	; 0x5c
   222fc:	6c6a      	ldr	r2, [r5, #68]	; 0x44
   222fe:	189b      	adds	r3, r3, r2
   22300:	4298      	cmp	r0, r3
   22302:	d2f2      	bcs.n	222ea <_http_client_handle_header+0x16>
		if (!strncmp(ptr, new_line, strlen(new_line))) {
   22304:	0031      	movs	r1, r6
   22306:	2202      	movs	r2, #2
   22308:	0020      	movs	r0, r4
   2230a:	4b4c      	ldr	r3, [pc, #304]	; (2243c <_http_client_handle_header+0x168>)
   2230c:	4798      	blx	r3
   2230e:	1e06      	subs	r6, r0, #0
   22310:	d129      	bne.n	22366 <_http_client_handle_header+0x92>
			_http_client_move_buffer(module, ptr + strlen(new_line));
   22312:	4b49      	ldr	r3, [pc, #292]	; (22438 <_http_client_handle_header+0x164>)
   22314:	1ca1      	adds	r1, r4, #2
   22316:	0028      	movs	r0, r5
   22318:	4798      	blx	r3
			if (module->cb && module->resp.response_code) {
   2231a:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
   2231c:	2b00      	cmp	r3, #0
   2231e:	d013      	beq.n	22348 <_http_client_handle_header+0x74>
   22320:	002a      	movs	r2, r5
   22322:	32e4      	adds	r2, #228	; 0xe4
   22324:	8810      	ldrh	r0, [r2, #0]
   22326:	2800      	cmp	r0, #0
   22328:	d00e      	beq.n	22348 <_http_client_handle_header+0x74>
				if (module->resp.content_length < 0) {
   2232a:	3a08      	subs	r2, #8
   2232c:	6811      	ldr	r1, [r2, #0]
   2232e:	2900      	cmp	r1, #0
   22330:	da0e      	bge.n	22350 <_http_client_handle_header+0x7c>
					data.recv_response.is_chunked = 1;
   22332:	2101      	movs	r1, #1
					data.recv_response.response_code = module->resp.response_code;
   22334:	aa01      	add	r2, sp, #4
					data.recv_response.is_chunked = 1;
   22336:	7091      	strb	r1, [r2, #2]
					module->resp.read_length = 0;
   22338:	0029      	movs	r1, r5
   2233a:	31e0      	adds	r1, #224	; 0xe0
					data.recv_response.response_code = module->resp.response_code;
   2233c:	8010      	strh	r0, [r2, #0]
					module->resp.read_length = 0;
   2233e:	600e      	str	r6, [r1, #0]
					data.recv_response.content = NULL;
   22340:	6096      	str	r6, [r2, #8]
					module->cb(module, HTTP_CLIENT_CALLBACK_RECV_RESPONSE, &data);
   22342:	2102      	movs	r1, #2
   22344:	0028      	movs	r0, r5
   22346:	4798      	blx	r3
			module->resp.state = STATE_PARSE_ENTITY;
   22348:	2601      	movs	r6, #1
   2234a:	35d8      	adds	r5, #216	; 0xd8
   2234c:	602e      	str	r6, [r5, #0]
			return 1;
   2234e:	e7d1      	b.n	222f4 <_http_client_handle_header+0x20>
				} else if (module->resp.content_length > (int)module->config.recv_buffer_size) {
   22350:	6e2a      	ldr	r2, [r5, #96]	; 0x60
   22352:	4291      	cmp	r1, r2
   22354:	ddf8      	ble.n	22348 <_http_client_handle_header+0x74>
					data.recv_response.response_code = module->resp.response_code;
   22356:	aa01      	add	r2, sp, #4
					data.recv_response.content_length = module->resp.content_length;
   22358:	6051      	str	r1, [r2, #4]
					module->resp.read_length = 0;
   2235a:	0029      	movs	r1, r5
   2235c:	31e0      	adds	r1, #224	; 0xe0
					data.recv_response.response_code = module->resp.response_code;
   2235e:	8010      	strh	r0, [r2, #0]
					data.recv_response.content = NULL;
   22360:	6096      	str	r6, [r2, #8]
					module->resp.read_length = 0;
   22362:	600e      	str	r6, [r1, #0]
   22364:	e7ed      	b.n	22342 <_http_client_handle_header+0x6e>
		} else if (!strncmp(ptr, "Content-Length: ", strlen("Content-Length: "))) {
   22366:	2210      	movs	r2, #16
   22368:	4935      	ldr	r1, [pc, #212]	; (22440 <_http_client_handle_header+0x16c>)
   2236a:	0020      	movs	r0, r4
   2236c:	4b33      	ldr	r3, [pc, #204]	; (2243c <_http_client_handle_header+0x168>)
   2236e:	4798      	blx	r3
   22370:	2800      	cmp	r0, #0
   22372:	d108      	bne.n	22386 <_http_client_handle_header+0xb2>
			module->resp.content_length = atoi(ptr + strlen("Content-Length: "));
   22374:	0020      	movs	r0, r4
   22376:	4b33      	ldr	r3, [pc, #204]	; (22444 <_http_client_handle_header+0x170>)
   22378:	3010      	adds	r0, #16
   2237a:	4798      	blx	r3
   2237c:	002b      	movs	r3, r5
   2237e:	33dc      	adds	r3, #220	; 0xdc
   22380:	6018      	str	r0, [r3, #0]
		ptr = ptr_line_end + strlen(new_line);
   22382:	1cbc      	adds	r4, r7, #2
		ptr_line_end = strstr(ptr, new_line);
   22384:	e7aa      	b.n	222dc <_http_client_handle_header+0x8>
		} else if (!strncmp(ptr, "Transfer-Encoding: ", strlen("Transfer-Encoding: "))) {
   22386:	2213      	movs	r2, #19
   22388:	492f      	ldr	r1, [pc, #188]	; (22448 <_http_client_handle_header+0x174>)
   2238a:	0020      	movs	r0, r4
   2238c:	4b2b      	ldr	r3, [pc, #172]	; (2243c <_http_client_handle_header+0x168>)
   2238e:	4798      	blx	r3
   22390:	1e06      	subs	r6, r0, #0
   22392:	d116      	bne.n	223c2 <_http_client_handle_header+0xee>
			char *type_ptr = ptr + strlen("Transfer-Encoding: ");
   22394:	3413      	adds	r4, #19
			for (; ptr_line_end > type_ptr; type_ptr++) {
   22396:	42bc      	cmp	r4, r7
   22398:	d2f3      	bcs.n	22382 <_http_client_handle_header+0xae>
				if (*type_ptr == ' ') {
   2239a:	7823      	ldrb	r3, [r4, #0]
   2239c:	2b20      	cmp	r3, #32
   2239e:	d101      	bne.n	223a4 <_http_client_handle_header+0xd0>
			for (; ptr_line_end > type_ptr; type_ptr++) {
   223a0:	3401      	adds	r4, #1
   223a2:	e7f8      	b.n	22396 <_http_client_handle_header+0xc2>
				} else if (*type_ptr == 'C' || *type_ptr == 'c') {
   223a4:	2220      	movs	r2, #32
   223a6:	4393      	bics	r3, r2
   223a8:	2b43      	cmp	r3, #67	; 0x43
   223aa:	d104      	bne.n	223b6 <_http_client_handle_header+0xe2>
					module->req.content_length = -1;
   223ac:	002b      	movs	r3, r5
   223ae:	3a21      	subs	r2, #33	; 0x21
   223b0:	33cc      	adds	r3, #204	; 0xcc
   223b2:	601a      	str	r2, [r3, #0]
				break;
   223b4:	e7e5      	b.n	22382 <_http_client_handle_header+0xae>
					_http_client_clear_conn(module, -ENOTSUP);
   223b6:	2186      	movs	r1, #134	; 0x86
   223b8:	0028      	movs	r0, r5
   223ba:	4249      	negs	r1, r1
   223bc:	4b23      	ldr	r3, [pc, #140]	; (2244c <_http_client_handle_header+0x178>)
   223be:	4798      	blx	r3
					return 0;
   223c0:	e798      	b.n	222f4 <_http_client_handle_header+0x20>
		} else if (!strncmp(ptr, "Connection: ", strlen("Connection: "))) {
   223c2:	220c      	movs	r2, #12
   223c4:	4922      	ldr	r1, [pc, #136]	; (22450 <_http_client_handle_header+0x17c>)
   223c6:	0020      	movs	r0, r4
   223c8:	4b1c      	ldr	r3, [pc, #112]	; (2243c <_http_client_handle_header+0x168>)
   223ca:	4798      	blx	r3
   223cc:	2800      	cmp	r0, #0
   223ce:	d112      	bne.n	223f6 <_http_client_handle_header+0x122>
			char *type_ptr = ptr + strlen("Connection: ");
   223d0:	340c      	adds	r4, #12
			for (; ptr_line_end > type_ptr; type_ptr++) {
   223d2:	42bc      	cmp	r4, r7
   223d4:	d2d5      	bcs.n	22382 <_http_client_handle_header+0xae>
				if (*type_ptr == ' ') {
   223d6:	7823      	ldrb	r3, [r4, #0]
   223d8:	2b20      	cmp	r3, #32
   223da:	d101      	bne.n	223e0 <_http_client_handle_header+0x10c>
			for (; ptr_line_end > type_ptr; type_ptr++) {
   223dc:	3401      	adds	r4, #1
   223de:	e7f8      	b.n	223d2 <_http_client_handle_header+0xfe>
				} else if (*type_ptr == 'K' || *type_ptr == 'k') {
   223e0:	2220      	movs	r2, #32
   223e2:	4393      	bics	r3, r2
   223e4:	2b4b      	cmp	r3, #75	; 0x4b
   223e6:	d11c      	bne.n	22422 <_http_client_handle_header+0x14e>
					module->permanent = 1;
   223e8:	002a      	movs	r2, r5
   223ea:	2302      	movs	r3, #2
   223ec:	3241      	adds	r2, #65	; 0x41
   223ee:	7811      	ldrb	r1, [r2, #0]
   223f0:	430b      	orrs	r3, r1
					module->permanent = 0;
   223f2:	7013      	strb	r3, [r2, #0]
   223f4:	e7c5      	b.n	22382 <_http_client_handle_header+0xae>
		} else if (!strncmp(ptr, "HTTP/", 5)) {
   223f6:	2205      	movs	r2, #5
   223f8:	4916      	ldr	r1, [pc, #88]	; (22454 <_http_client_handle_header+0x180>)
   223fa:	0020      	movs	r0, r4
   223fc:	4b0f      	ldr	r3, [pc, #60]	; (2243c <_http_client_handle_header+0x168>)
   223fe:	4798      	blx	r3
   22400:	1e06      	subs	r6, r0, #0
   22402:	d1be      	bne.n	22382 <_http_client_handle_header+0xae>
			module->resp.response_code = atoi(ptr + 9); /* HTTP/{Ver} {Code} {Desc} : HTTP/1.1 200 OK */
   22404:	0020      	movs	r0, r4
   22406:	4b0f      	ldr	r3, [pc, #60]	; (22444 <_http_client_handle_header+0x170>)
   22408:	3009      	adds	r0, #9
   2240a:	4798      	blx	r3
   2240c:	002b      	movs	r3, r5
   2240e:	33e4      	adds	r3, #228	; 0xe4
   22410:	8018      	strh	r0, [r3, #0]
			module->resp.content_length = 0;
   22412:	3b08      	subs	r3, #8
   22414:	601e      	str	r6, [r3, #0]
			if (ptr [5] > '1' || ptr[7] > '0') {
   22416:	7963      	ldrb	r3, [r4, #5]
   22418:	2b31      	cmp	r3, #49	; 0x31
   2241a:	d8e5      	bhi.n	223e8 <_http_client_handle_header+0x114>
   2241c:	79e3      	ldrb	r3, [r4, #7]
   2241e:	2b30      	cmp	r3, #48	; 0x30
   22420:	d8e2      	bhi.n	223e8 <_http_client_handle_header+0x114>
					module->permanent = 0;
   22422:	002a      	movs	r2, r5
   22424:	2102      	movs	r1, #2
   22426:	3241      	adds	r2, #65	; 0x41
   22428:	7813      	ldrb	r3, [r2, #0]
   2242a:	438b      	bics	r3, r1
   2242c:	e7e1      	b.n	223f2 <_http_client_handle_header+0x11e>
   2242e:	46c0      	nop			; (mov r8, r8)
   22430:	0002927a 	.word	0x0002927a
   22434:	00023941 	.word	0x00023941
   22438:	000222b1 	.word	0x000222b1
   2243c:	000238d1 	.word	0x000238d1
   22440:	0002b3fa 	.word	0x0002b3fa
   22444:	00022b95 	.word	0x00022b95
   22448:	0002b327 	.word	0x0002b327
   2244c:	00021b81 	.word	0x00021b81
   22450:	0002b33b 	.word	0x0002b33b
   22454:	0002b348 	.word	0x0002b348

00022458 <_http_client_handle_entity>:
{
   22458:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (module->resp.content_length >= 0 && module->resp.content_length <= (int)module->config.recv_buffer_size) {
   2245a:	0007      	movs	r7, r0
   2245c:	37dc      	adds	r7, #220	; 0xdc
   2245e:	6839      	ldr	r1, [r7, #0]
{
   22460:	b087      	sub	sp, #28
   22462:	0004      	movs	r4, r0
	char *buffer = module->config.recv_buffer;
   22464:	6dc6      	ldr	r6, [r0, #92]	; 0x5c
   22466:	6c45      	ldr	r5, [r0, #68]	; 0x44
	if (module->resp.content_length >= 0 && module->resp.content_length <= (int)module->config.recv_buffer_size) {
   22468:	2900      	cmp	r1, #0
   2246a:	db5c      	blt.n	22526 <_http_client_handle_entity+0xce>
   2246c:	6e03      	ldr	r3, [r0, #96]	; 0x60
   2246e:	4299      	cmp	r1, r3
   22470:	dc2d      	bgt.n	224ce <_http_client_handle_entity+0x76>
	return 0;
   22472:	2000      	movs	r0, #0
		if ((int)module->recved_size >= module->resp.content_length) {
   22474:	42a9      	cmp	r1, r5
   22476:	dc28      	bgt.n	224ca <_http_client_handle_entity+0x72>
   22478:	0025      	movs	r5, r4
			if (module->cb && module->resp.response_code) {
   2247a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   2247c:	35e4      	adds	r5, #228	; 0xe4
   2247e:	9301      	str	r3, [sp, #4]
   22480:	4283      	cmp	r3, r0
   22482:	d00d      	beq.n	224a0 <_http_client_handle_entity+0x48>
   22484:	882a      	ldrh	r2, [r5, #0]
   22486:	4694      	mov	ip, r2
   22488:	4282      	cmp	r2, r0
   2248a:	d009      	beq.n	224a0 <_http_client_handle_entity+0x48>
				data.recv_response.response_code = module->resp.response_code;
   2248c:	4663      	mov	r3, ip
   2248e:	aa03      	add	r2, sp, #12
   22490:	8013      	strh	r3, [r2, #0]
				data.recv_response.is_chunked = 0;
   22492:	7090      	strb	r0, [r2, #2]
				data.recv_response.content_length = module->resp.content_length;
   22494:	6051      	str	r1, [r2, #4]
				data.recv_response.content = buffer;
   22496:	6096      	str	r6, [r2, #8]
				module->cb(module, HTTP_CLIENT_CALLBACK_RECV_RESPONSE, &data);
   22498:	2102      	movs	r1, #2
   2249a:	0020      	movs	r0, r4
   2249c:	9b01      	ldr	r3, [sp, #4]
   2249e:	4798      	blx	r3
			module->resp.state = STATE_PARSE_HEADER;
   224a0:	0023      	movs	r3, r4
   224a2:	2200      	movs	r2, #0
			if (module->permanent == 0) {
   224a4:	2002      	movs	r0, #2
			module->resp.state = STATE_PARSE_HEADER;
   224a6:	33d8      	adds	r3, #216	; 0xd8
   224a8:	601a      	str	r2, [r3, #0]
			module->resp.response_code = 0;
   224aa:	802a      	strh	r2, [r5, #0]
			if (module->permanent == 0) {
   224ac:	3b97      	subs	r3, #151	; 0x97
   224ae:	781d      	ldrb	r5, [r3, #0]
   224b0:	4005      	ands	r5, r0
   224b2:	4295      	cmp	r5, r2
   224b4:	d103      	bne.n	224be <_http_client_handle_entity+0x66>
					_http_client_clear_conn(module, 0);
   224b6:	0029      	movs	r1, r5
				_http_client_clear_conn(module, -EOVERFLOW);
   224b8:	0020      	movs	r0, r4
   224ba:	4b57      	ldr	r3, [pc, #348]	; (22618 <_http_client_handle_entity+0x1c0>)
   224bc:	e030      	b.n	22520 <_http_client_handle_entity+0xc8>
				_http_client_move_buffer(module, buffer + module->resp.content_length);
   224be:	6839      	ldr	r1, [r7, #0]
   224c0:	0020      	movs	r0, r4
   224c2:	1871      	adds	r1, r6, r1
   224c4:	4b55      	ldr	r3, [pc, #340]	; (2261c <_http_client_handle_entity+0x1c4>)
   224c6:	4798      	blx	r3
				return module->recved_size;
   224c8:	6c60      	ldr	r0, [r4, #68]	; 0x44
}
   224ca:	b007      	add	sp, #28
   224cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
			module->resp.read_length += (int)module->recved_size;
   224ce:	0003      	movs	r3, r0
   224d0:	33e0      	adds	r3, #224	; 0xe0
   224d2:	681a      	ldr	r2, [r3, #0]
			data.recv_chunked_data.length = module->recved_size;
   224d4:	af03      	add	r7, sp, #12
   224d6:	9503      	str	r5, [sp, #12]
			module->resp.read_length += (int)module->recved_size;
   224d8:	18ad      	adds	r5, r5, r2
   224da:	601d      	str	r5, [r3, #0]
			data.recv_chunked_data.data = buffer;
   224dc:	607e      	str	r6, [r7, #4]
   224de:	2300      	movs	r3, #0
			if (module->resp.content_length <= module->resp.read_length) {
   224e0:	42a9      	cmp	r1, r5
   224e2:	dc04      	bgt.n	224ee <_http_client_handle_entity+0x96>
				module->resp.state = STATE_PARSE_HEADER;
   224e4:	0002      	movs	r2, r0
   224e6:	32d8      	adds	r2, #216	; 0xd8
   224e8:	6013      	str	r3, [r2, #0]
				module->resp.response_code = 0;
   224ea:	8193      	strh	r3, [r2, #12]
				data.recv_chunked_data.is_complete = 1;
   224ec:	3301      	adds	r3, #1
				data.recv_chunked_data.is_complete = 0;
   224ee:	723b      	strb	r3, [r7, #8]
			if (module->cb) {
   224f0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   224f2:	2b00      	cmp	r3, #0
   224f4:	d003      	beq.n	224fe <_http_client_handle_entity+0xa6>
				module->cb(module, HTTP_CLIENT_CALLBACK_RECV_CHUNKED_DATA, &data);
   224f6:	003a      	movs	r2, r7
   224f8:	2103      	movs	r1, #3
   224fa:	0020      	movs	r0, r4
   224fc:	4798      	blx	r3
			if (data.recv_chunked_data.is_complete == 1) {
   224fe:	7a3b      	ldrb	r3, [r7, #8]
   22500:	2b01      	cmp	r3, #1
   22502:	d109      	bne.n	22518 <_http_client_handle_entity+0xc0>
				if (module->permanent == 0) {
   22504:	0023      	movs	r3, r4
   22506:	2002      	movs	r0, #2
   22508:	3341      	adds	r3, #65	; 0x41
   2250a:	781d      	ldrb	r5, [r3, #0]
   2250c:	4005      	ands	r5, r0
   2250e:	d103      	bne.n	22518 <_http_client_handle_entity+0xc0>
					printf("1\r\n");
   22510:	4b43      	ldr	r3, [pc, #268]	; (22620 <_http_client_handle_entity+0x1c8>)
   22512:	4844      	ldr	r0, [pc, #272]	; (22624 <_http_client_handle_entity+0x1cc>)
   22514:	4798      	blx	r3
   22516:	e7ce      	b.n	224b6 <_http_client_handle_entity+0x5e>
			_http_client_move_buffer(module, buffer + module->recved_size);
   22518:	0020      	movs	r0, r4
   2251a:	6c63      	ldr	r3, [r4, #68]	; 0x44
   2251c:	18f1      	adds	r1, r6, r3
   2251e:	4b3f      	ldr	r3, [pc, #252]	; (2261c <_http_client_handle_entity+0x1c4>)
				_http_client_clear_conn(module, -EOVERFLOW);
   22520:	4798      	blx	r3
	return 0;
   22522:	2000      	movs	r0, #0
   22524:	e7d1      	b.n	224ca <_http_client_handle_entity+0x72>
	int extension = 0;
   22526:	2300      	movs	r3, #0
   22528:	9301      	str	r3, [sp, #4]
		if (module->resp.read_length >= 0) {
   2252a:	0027      	movs	r7, r4
   2252c:	37e0      	adds	r7, #224	; 0xe0
   2252e:	683b      	ldr	r3, [r7, #0]
   22530:	2b00      	cmp	r3, #0
   22532:	db36      	blt.n	225a2 <_http_client_handle_entity+0x14a>
			if (module->resp.read_length == 0) {
   22534:	d11c      	bne.n	22570 <_http_client_handle_entity+0x118>
				module->resp.state = STATE_PARSE_HEADER;
   22536:	0022      	movs	r2, r4
				data.recv_chunked_data.is_complete = 1;
   22538:	2101      	movs	r1, #1
				module->resp.state = STATE_PARSE_HEADER;
   2253a:	32d8      	adds	r2, #216	; 0xd8
   2253c:	6013      	str	r3, [r2, #0]
				module->resp.response_code = 0;
   2253e:	8193      	strh	r3, [r2, #12]
				data.recv_chunked_data.is_complete = 1;
   22540:	aa03      	add	r2, sp, #12
				data.recv_chunked_data.length = 0;
   22542:	9303      	str	r3, [sp, #12]
				data.recv_chunked_data.data = NULL;
   22544:	6053      	str	r3, [r2, #4]
				if (module->cb) {
   22546:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
				data.recv_chunked_data.is_complete = 1;
   22548:	7211      	strb	r1, [r2, #8]
				if (module->cb) {
   2254a:	2b00      	cmp	r3, #0
   2254c:	d002      	beq.n	22554 <_http_client_handle_entity+0xfc>
					module->cb(module, HTTP_CLIENT_CALLBACK_RECV_CHUNKED_DATA, &data);
   2254e:	2103      	movs	r1, #3
   22550:	0020      	movs	r0, r4
   22552:	4798      	blx	r3
				if (module->permanent == 0) {
   22554:	0023      	movs	r3, r4
   22556:	3341      	adds	r3, #65	; 0x41
   22558:	7819      	ldrb	r1, [r3, #0]
   2255a:	2302      	movs	r3, #2
   2255c:	4019      	ands	r1, r3
   2255e:	d0ab      	beq.n	224b8 <_http_client_handle_entity+0x60>
				_http_client_move_buffer(module, buffer + 2);
   22560:	1cb1      	adds	r1, r6, #2
   22562:	0020      	movs	r0, r4
   22564:	4b2d      	ldr	r3, [pc, #180]	; (2261c <_http_client_handle_entity+0x1c4>)
   22566:	4798      	blx	r3
	} while(module->recved_size > 0);
   22568:	6c63      	ldr	r3, [r4, #68]	; 0x44
   2256a:	2b00      	cmp	r3, #0
   2256c:	d1dd      	bne.n	2252a <_http_client_handle_entity+0xd2>
   2256e:	e7d8      	b.n	22522 <_http_client_handle_entity+0xca>
			} else if (module->resp.read_length <= length) {
   22570:	42ab      	cmp	r3, r5
   22572:	dcf9      	bgt.n	22568 <_http_client_handle_entity+0x110>
				data.recv_chunked_data.length = module->resp.read_length;
   22574:	9303      	str	r3, [sp, #12]
				data.recv_chunked_data.is_complete = 0;
   22576:	2300      	movs	r3, #0
				data.recv_chunked_data.length = module->resp.read_length;
   22578:	aa03      	add	r2, sp, #12
				data.recv_chunked_data.is_complete = 0;
   2257a:	7213      	strb	r3, [r2, #8]
				if (module->cb) {
   2257c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
				data.recv_chunked_data.data = buffer;
   2257e:	6056      	str	r6, [r2, #4]
				if (module->cb) {
   22580:	2b00      	cmp	r3, #0
   22582:	d002      	beq.n	2258a <_http_client_handle_entity+0x132>
					module->cb(module, HTTP_CLIENT_CALLBACK_RECV_CHUNKED_DATA, &data);
   22584:	2103      	movs	r1, #3
   22586:	0020      	movs	r0, r4
   22588:	4798      	blx	r3
				_http_client_move_buffer(module, buffer + module->resp.read_length + 2 /* sizeof newline character */);
   2258a:	683b      	ldr	r3, [r7, #0]
   2258c:	0020      	movs	r0, r4
   2258e:	1c99      	adds	r1, r3, #2
   22590:	1871      	adds	r1, r6, r1
   22592:	4b22      	ldr	r3, [pc, #136]	; (2261c <_http_client_handle_entity+0x1c4>)
   22594:	4798      	blx	r3
				module->resp.read_length = -1;
   22596:	2301      	movs	r3, #1
   22598:	425b      	negs	r3, r3
				length = (int)module->recved_size;
   2259a:	6c65      	ldr	r5, [r4, #68]	; 0x44
				buffer = module->config.recv_buffer;
   2259c:	6de6      	ldr	r6, [r4, #92]	; 0x5c
				module->resp.read_length = -1;
   2259e:	603b      	str	r3, [r7, #0]
   225a0:	e7e2      	b.n	22568 <_http_client_handle_entity+0x110>
			module->resp.read_length = 0;
   225a2:	2300      	movs	r3, #0
   225a4:	603b      	str	r3, [r7, #0]
			for (; length > 0; buffer++, length--) {
   225a6:	2d00      	cmp	r5, #0
   225a8:	dd04      	ble.n	225b4 <_http_client_handle_entity+0x15c>
				if (*buffer == '\n') {
   225aa:	7833      	ldrb	r3, [r6, #0]
   225ac:	3601      	adds	r6, #1
   225ae:	2b0a      	cmp	r3, #10
   225b0:	d107      	bne.n	225c2 <_http_client_handle_entity+0x16a>
					length--;
   225b2:	3d01      	subs	r5, #1
			if (module->resp.read_length > (int)module->config.recv_buffer_size) {
   225b4:	683b      	ldr	r3, [r7, #0]
   225b6:	6e22      	ldr	r2, [r4, #96]	; 0x60
   225b8:	4293      	cmp	r3, r2
   225ba:	dd27      	ble.n	2260c <_http_client_handle_entity+0x1b4>
				_http_client_clear_conn(module, -EOVERFLOW);
   225bc:	218b      	movs	r1, #139	; 0x8b
   225be:	4249      	negs	r1, r1
   225c0:	e77a      	b.n	224b8 <_http_client_handle_entity+0x60>
				if (extension != 0) {
   225c2:	9a01      	ldr	r2, [sp, #4]
   225c4:	2a00      	cmp	r2, #0
   225c6:	d108      	bne.n	225da <_http_client_handle_entity+0x182>
				if (*buffer >= '0' && *buffer <= '9') {
   225c8:	001a      	movs	r2, r3
   225ca:	3a30      	subs	r2, #48	; 0x30
   225cc:	2a09      	cmp	r2, #9
   225ce:	d806      	bhi.n	225de <_http_client_handle_entity+0x186>
					module->resp.read_length = module->resp.read_length * 0x10 + *buffer - '0';
   225d0:	683a      	ldr	r2, [r7, #0]
   225d2:	0112      	lsls	r2, r2, #4
   225d4:	18d3      	adds	r3, r2, r3
   225d6:	3b30      	subs	r3, #48	; 0x30
					module->resp.read_length = module->resp.read_length * 0x10 + *buffer - 'a';
   225d8:	603b      	str	r3, [r7, #0]
			for (; length > 0; buffer++, length--) {
   225da:	3d01      	subs	r5, #1
   225dc:	e7e3      	b.n	225a6 <_http_client_handle_entity+0x14e>
				} else if (*buffer >= 'a' && *buffer <= 'f') {
   225de:	001a      	movs	r2, r3
   225e0:	3a61      	subs	r2, #97	; 0x61
   225e2:	2a05      	cmp	r2, #5
   225e4:	d804      	bhi.n	225f0 <_http_client_handle_entity+0x198>
					module->resp.read_length = module->resp.read_length * 0x10 + *buffer - 'a';
   225e6:	683a      	ldr	r2, [r7, #0]
   225e8:	0112      	lsls	r2, r2, #4
   225ea:	18d3      	adds	r3, r2, r3
   225ec:	3b61      	subs	r3, #97	; 0x61
   225ee:	e7f3      	b.n	225d8 <_http_client_handle_entity+0x180>
				} else if (*buffer >= 'A' && *buffer <= 'F') {
   225f0:	001a      	movs	r2, r3
   225f2:	3a41      	subs	r2, #65	; 0x41
   225f4:	2a05      	cmp	r2, #5
   225f6:	d804      	bhi.n	22602 <_http_client_handle_entity+0x1aa>
					module->resp.read_length = module->resp.read_length * 0x10 + *buffer - 'A';
   225f8:	683a      	ldr	r2, [r7, #0]
   225fa:	0112      	lsls	r2, r2, #4
   225fc:	18d3      	adds	r3, r2, r3
   225fe:	3b41      	subs	r3, #65	; 0x41
   22600:	e7ea      	b.n	225d8 <_http_client_handle_entity+0x180>
				} else if (*buffer == ';') {
   22602:	3b3b      	subs	r3, #59	; 0x3b
   22604:	425a      	negs	r2, r3
   22606:	415a      	adcs	r2, r3
   22608:	9201      	str	r2, [sp, #4]
   2260a:	e7e6      	b.n	225da <_http_client_handle_entity+0x182>
			if (length  == 0) {
   2260c:	2d00      	cmp	r5, #0
   2260e:	d1ab      	bne.n	22568 <_http_client_handle_entity+0x110>
				module->resp.read_length = -1;
   22610:	2301      	movs	r3, #1
   22612:	425b      	negs	r3, r3
   22614:	603b      	str	r3, [r7, #0]
   22616:	e784      	b.n	22522 <_http_client_handle_entity+0xca>
   22618:	00021b81 	.word	0x00021b81
   2261c:	000222b1 	.word	0x000222b1
   22620:	00023749 	.word	0x00023749
   22624:	0002b324 	.word	0x0002b324

00022628 <_http_client_handle_response>:
	switch(module->resp.state) {
   22628:	0003      	movs	r3, r0
{
   2262a:	b510      	push	{r4, lr}
	switch(module->resp.state) {
   2262c:	33d8      	adds	r3, #216	; 0xd8
   2262e:	681b      	ldr	r3, [r3, #0]
   22630:	2b00      	cmp	r3, #0
   22632:	d003      	beq.n	2263c <_http_client_handle_response+0x14>
   22634:	2b01      	cmp	r3, #1
   22636:	d004      	beq.n	22642 <_http_client_handle_response+0x1a>
	return 0;
   22638:	2000      	movs	r0, #0
   2263a:	e001      	b.n	22640 <_http_client_handle_response+0x18>
		return _http_client_handle_header(module);
   2263c:	4b02      	ldr	r3, [pc, #8]	; (22648 <_http_client_handle_response+0x20>)
		return _http_client_handle_entity(module);
   2263e:	4798      	blx	r3
}
   22640:	bd10      	pop	{r4, pc}
		return _http_client_handle_entity(module);
   22642:	4b02      	ldr	r3, [pc, #8]	; (2264c <_http_client_handle_response+0x24>)
   22644:	e7fb      	b.n	2263e <_http_client_handle_response+0x16>
   22646:	46c0      	nop			; (mov r8, r8)
   22648:	000222d5 	.word	0x000222d5
   2264c:	00022459 	.word	0x00022459

00022650 <_http_client_recved_packet>:
{
   22650:	b510      	push	{r4, lr}
	module->recved_size += read_len;
   22652:	6c43      	ldr	r3, [r0, #68]	; 0x44
{
   22654:	0004      	movs	r4, r0
	module->recved_size += read_len;
   22656:	1859      	adds	r1, r3, r1
	if (module->config.timeout > 0) {
   22658:	0003      	movs	r3, r0
	module->recved_size += read_len;
   2265a:	6441      	str	r1, [r0, #68]	; 0x44
	if (module->config.timeout > 0) {
   2265c:	3358      	adds	r3, #88	; 0x58
   2265e:	881b      	ldrh	r3, [r3, #0]
   22660:	2b00      	cmp	r3, #0
   22662:	d003      	beq.n	2266c <_http_client_recved_packet+0x1c>
		sw_timer_disable_callback(module->config.timer_inst, module->timer_id);
   22664:	6c81      	ldr	r1, [r0, #72]	; 0x48
   22666:	4b04      	ldr	r3, [pc, #16]	; (22678 <_http_client_recved_packet+0x28>)
   22668:	6d40      	ldr	r0, [r0, #84]	; 0x54
   2266a:	4798      	blx	r3
	while(_http_client_handle_response(module) != 0);
   2266c:	0020      	movs	r0, r4
   2266e:	4b03      	ldr	r3, [pc, #12]	; (2267c <_http_client_recved_packet+0x2c>)
   22670:	4798      	blx	r3
   22672:	2800      	cmp	r0, #0
   22674:	d1fa      	bne.n	2266c <_http_client_recved_packet+0x1c>
}
   22676:	bd10      	pop	{r4, pc}
   22678:	000228e5 	.word	0x000228e5
   2267c:	00022629 	.word	0x00022629

00022680 <http_client_socket_event_handler>:
{
   22680:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct http_client_module *module = module_ref_inst[sock];
   22682:	4b29      	ldr	r3, [pc, #164]	; (22728 <http_client_socket_event_handler+0xa8>)
   22684:	0080      	lsls	r0, r0, #2
   22686:	58c4      	ldr	r4, [r0, r3]
	if (module == NULL) {
   22688:	2c00      	cmp	r4, #0
   2268a:	d010      	beq.n	226ae <http_client_socket_event_handler+0x2e>
	switch (msg_type) {
   2268c:	2906      	cmp	r1, #6
   2268e:	d026      	beq.n	226de <http_client_socket_event_handler+0x5e>
   22690:	2907      	cmp	r1, #7
   22692:	d035      	beq.n	22700 <http_client_socket_event_handler+0x80>
   22694:	2905      	cmp	r1, #5
   22696:	d10a      	bne.n	226ae <http_client_socket_event_handler+0x2e>
    	data.sock_connected.result = msg_connect->s8Error;
   22698:	2001      	movs	r0, #1
   2269a:	5610      	ldrsb	r0, [r2, r0]
   2269c:	9001      	str	r0, [sp, #4]
    	if (msg_connect->s8Error < 0) {
   2269e:	2800      	cmp	r0, #0
   226a0:	da06      	bge.n	226b0 <http_client_socket_event_handler+0x30>
			_http_client_clear_conn(module, _hwerr_to_stderr(msg_connect->s8Error));
   226a2:	4b22      	ldr	r3, [pc, #136]	; (2272c <http_client_socket_event_handler+0xac>)
   226a4:	4798      	blx	r3
   226a6:	4b22      	ldr	r3, [pc, #136]	; (22730 <http_client_socket_event_handler+0xb0>)
   226a8:	0001      	movs	r1, r0
   226aa:	0020      	movs	r0, r4
   226ac:	4798      	blx	r3
}
   226ae:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
			if (module->cb != NULL) {
   226b0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   226b2:	2b00      	cmp	r3, #0
   226b4:	d003      	beq.n	226be <http_client_socket_event_handler+0x3e>
				module->cb(module, HTTP_CLIENT_CALLBACK_SOCK_CONNECTED, &data);
   226b6:	aa01      	add	r2, sp, #4
   226b8:	2100      	movs	r1, #0
   226ba:	0020      	movs	r0, r4
   226bc:	4798      	blx	r3
			module->req.state = STATE_REQ_SEND_HEADER;
   226be:	2303      	movs	r3, #3
   226c0:	66e3      	str	r3, [r4, #108]	; 0x6c
			sw_timer_enable_callback(module->config.timer_inst, module->timer_id, module->config.timeout);
   226c2:	0023      	movs	r3, r4
   226c4:	3358      	adds	r3, #88	; 0x58
   226c6:	881a      	ldrh	r2, [r3, #0]
   226c8:	6ca1      	ldr	r1, [r4, #72]	; 0x48
   226ca:	6d60      	ldr	r0, [r4, #84]	; 0x54
   226cc:	4b19      	ldr	r3, [pc, #100]	; (22734 <http_client_socket_event_handler+0xb4>)
   226ce:	4798      	blx	r3
    		_http_client_recv_packet(module);
   226d0:	0020      	movs	r0, r4
   226d2:	4b19      	ldr	r3, [pc, #100]	; (22738 <http_client_socket_event_handler+0xb8>)
   226d4:	4798      	blx	r3
			_http_client_request(module);
   226d6:	0020      	movs	r0, r4
   226d8:	4b18      	ldr	r3, [pc, #96]	; (2273c <http_client_socket_event_handler+0xbc>)
		_http_client_recv_packet(module);
   226da:	4798      	blx	r3
		break;
   226dc:	e7e7      	b.n	226ae <http_client_socket_event_handler+0x2e>
    	if (msg_recv->s16BufferSize > 0) {
   226de:	2304      	movs	r3, #4
   226e0:	5ed1      	ldrsh	r1, [r2, r3]
   226e2:	2900      	cmp	r1, #0
   226e4:	dd05      	ble.n	226f2 <http_client_socket_event_handler+0x72>
    		_http_client_recved_packet(module, msg_recv->s16BufferSize);
   226e6:	0020      	movs	r0, r4
   226e8:	4b15      	ldr	r3, [pc, #84]	; (22740 <http_client_socket_event_handler+0xc0>)
			_http_client_clear_conn(module, _hwerr_to_stderr(msg_recv->s16BufferSize));
   226ea:	4798      	blx	r3
		_http_client_recv_packet(module);
   226ec:	0020      	movs	r0, r4
   226ee:	4b12      	ldr	r3, [pc, #72]	; (22738 <http_client_socket_event_handler+0xb8>)
   226f0:	e7f3      	b.n	226da <http_client_socket_event_handler+0x5a>
			_http_client_clear_conn(module, _hwerr_to_stderr(msg_recv->s16BufferSize));
   226f2:	0008      	movs	r0, r1
   226f4:	4b0d      	ldr	r3, [pc, #52]	; (2272c <http_client_socket_event_handler+0xac>)
   226f6:	4798      	blx	r3
   226f8:	4b0d      	ldr	r3, [pc, #52]	; (22730 <http_client_socket_event_handler+0xb0>)
   226fa:	0001      	movs	r1, r0
   226fc:	0020      	movs	r0, r4
   226fe:	e7f4      	b.n	226ea <http_client_socket_event_handler+0x6a>
		send_ret = *(int16_t*)msg_data;
   22700:	2300      	movs	r3, #0
   22702:	5ed0      	ldrsh	r0, [r2, r3]
		if (send_ret < 0) {
   22704:	2800      	cmp	r0, #0
   22706:	da0b      	bge.n	22720 <http_client_socket_event_handler+0xa0>
			_http_client_clear_conn(module, _hwerr_to_stderr(send_ret));
   22708:	4b08      	ldr	r3, [pc, #32]	; (2272c <http_client_socket_event_handler+0xac>)
   2270a:	4798      	blx	r3
   2270c:	4b08      	ldr	r3, [pc, #32]	; (22730 <http_client_socket_event_handler+0xb0>)
   2270e:	0001      	movs	r1, r0
   22710:	0020      	movs	r0, r4
   22712:	4798      	blx	r3
		module->sending = 0;
   22714:	2201      	movs	r2, #1
   22716:	3441      	adds	r4, #65	; 0x41
   22718:	7823      	ldrb	r3, [r4, #0]
   2271a:	4393      	bics	r3, r2
   2271c:	7023      	strb	r3, [r4, #0]
    	break;
   2271e:	e7c6      	b.n	226ae <http_client_socket_event_handler+0x2e>
    		_http_client_request(module);
   22720:	0020      	movs	r0, r4
   22722:	4b06      	ldr	r3, [pc, #24]	; (2273c <http_client_socket_event_handler+0xbc>)
   22724:	4798      	blx	r3
   22726:	e7f5      	b.n	22714 <http_client_socket_event_handler+0x94>
   22728:	200041c8 	.word	0x200041c8
   2272c:	00021a15 	.word	0x00021a15
   22730:	00021b81 	.word	0x00021b81
   22734:	000228b9 	.word	0x000228b9
   22738:	0002227d 	.word	0x0002227d
   2273c:	00021c95 	.word	0x00021c95
   22740:	00022651 	.word	0x00022651

00022744 <stream_writer_init>:
#include <string.h>
#include "iot/stream_writer.h"

void stream_writer_init(struct stream_writer * writer, char *buffer, size_t max_length, stream_writer_write_func_t func, void *priv_data)
{
	writer->max_size = max_length;
   22744:	6002      	str	r2, [r0, #0]
	writer->buffer = buffer;
	writer->written = 0;
   22746:	2200      	movs	r2, #0
	writer->write_func = func;
   22748:	6083      	str	r3, [r0, #8]
	writer->priv_data = priv_data;
   2274a:	9b00      	ldr	r3, [sp, #0]
	writer->buffer = buffer;
   2274c:	6101      	str	r1, [r0, #16]
	writer->written = 0;
   2274e:	6042      	str	r2, [r0, #4]
	writer->priv_data = priv_data;
   22750:	60c3      	str	r3, [r0, #12]
}
   22752:	4770      	bx	lr

00022754 <stream_writer_send_remain>:
		stream_writer_send_8(writer, *buffer);
	}
}

void stream_writer_send_remain(struct stream_writer * writer)
{
   22754:	b510      	push	{r4, lr}
	if(writer->written > 0) {
   22756:	6842      	ldr	r2, [r0, #4]
{
   22758:	0004      	movs	r4, r0
	if(writer->written > 0) {
   2275a:	2a00      	cmp	r2, #0
   2275c:	d005      	beq.n	2276a <stream_writer_send_remain+0x16>
		writer->write_func(writer->priv_data, writer->buffer, writer->written);
   2275e:	6901      	ldr	r1, [r0, #16]
   22760:	68a3      	ldr	r3, [r4, #8]
   22762:	68c0      	ldr	r0, [r0, #12]
   22764:	4798      	blx	r3
		writer->written = 0;
   22766:	2300      	movs	r3, #0
   22768:	6063      	str	r3, [r4, #4]
	}
}
   2276a:	bd10      	pop	{r4, pc}

0002276c <stream_writer_send_8>:
	int remain = writer->max_size - writer->written;
   2276c:	6803      	ldr	r3, [r0, #0]
   2276e:	6842      	ldr	r2, [r0, #4]
{
   22770:	b570      	push	{r4, r5, r6, lr}
	int remain = writer->max_size - writer->written;
   22772:	1a9b      	subs	r3, r3, r2
{
   22774:	0004      	movs	r4, r0
   22776:	000d      	movs	r5, r1
	if (remain < 1) {
   22778:	2b00      	cmp	r3, #0
   2277a:	dc01      	bgt.n	22780 <stream_writer_send_8+0x14>
		stream_writer_send_remain(writer);
   2277c:	4b03      	ldr	r3, [pc, #12]	; (2278c <stream_writer_send_8+0x20>)
   2277e:	4798      	blx	r3
	writer->buffer[writer->written++] = (char)value;
   22780:	6863      	ldr	r3, [r4, #4]
   22782:	6922      	ldr	r2, [r4, #16]
   22784:	1c59      	adds	r1, r3, #1
   22786:	6061      	str	r1, [r4, #4]
   22788:	54d5      	strb	r5, [r2, r3]
}
   2278a:	bd70      	pop	{r4, r5, r6, pc}
   2278c:	00022755 	.word	0x00022755

00022790 <stream_writer_send_buffer>:
{
   22790:	b570      	push	{r4, r5, r6, lr}
   22792:	0006      	movs	r6, r0
   22794:	000c      	movs	r4, r1
   22796:	188d      	adds	r5, r1, r2
	for (; length > 0; length--, buffer++) {
   22798:	42ac      	cmp	r4, r5
   2279a:	d100      	bne.n	2279e <stream_writer_send_buffer+0xe>
}
   2279c:	bd70      	pop	{r4, r5, r6, pc}
		stream_writer_send_8(writer, *buffer);
   2279e:	2100      	movs	r1, #0
   227a0:	0030      	movs	r0, r6
   227a2:	5661      	ldrsb	r1, [r4, r1]
   227a4:	4b01      	ldr	r3, [pc, #4]	; (227ac <stream_writer_send_buffer+0x1c>)
   227a6:	4798      	blx	r3
	for (; length > 0; length--, buffer++) {
   227a8:	3401      	adds	r4, #1
   227aa:	e7f5      	b.n	22798 <stream_writer_send_buffer+0x8>
   227ac:	0002276d 	.word	0x0002276d

000227b0 <sw_timer_tcc_callback>:
 * \param[in] module Instance of the TCC.
 */
#if (SAMD21)
static void sw_timer_tcc_callback(struct tcc_module *const module)
{
	sw_timer_tick++;
   227b0:	4a02      	ldr	r2, [pc, #8]	; (227bc <sw_timer_tcc_callback+0xc>)
   227b2:	6813      	ldr	r3, [r2, #0]
   227b4:	3301      	adds	r3, #1
   227b6:	6013      	str	r3, [r2, #0]
}
   227b8:	4770      	bx	lr
   227ba:	46c0      	nop			; (mov r8, r8)
   227bc:	200041e4 	.word	0x200041e4

000227c0 <sw_timer_get_config_defaults>:

void sw_timer_get_config_defaults(struct sw_timer_config *const config)
{
	Assert(config);

	config->accuracy = 100;
   227c0:	2364      	movs	r3, #100	; 0x64
   227c2:	8043      	strh	r3, [r0, #2]
	config->tcc_dev = 0;
   227c4:	2300      	movs	r3, #0
   227c6:	7003      	strb	r3, [r0, #0]
	config->tcc_callback_channel = 0;
   227c8:	7043      	strb	r3, [r0, #1]
}
   227ca:	4770      	bx	lr

000227cc <sw_timer_init>:

void sw_timer_init(struct sw_timer_module *const module_inst, struct sw_timer_config *const config)
{
   227cc:	b5f0      	push	{r4, r5, r6, r7, lr}
   227ce:	b0af      	sub	sp, #188	; 0xbc
#if (SAMD21)
	struct tcc_config tcc_conf;
	struct tcc_module *tcc_module;
	Tcc *hw[] = TCC_INSTS;
   227d0:	ae02      	add	r6, sp, #8
   227d2:	0032      	movs	r2, r6
{
   227d4:	000d      	movs	r5, r1
	Tcc *hw[] = TCC_INSTS;
   227d6:	4b1b      	ldr	r3, [pc, #108]	; (22844 <sw_timer_init+0x78>)
	Assert(config->tcc_callback_channel < TCC_NUM_CHANNELS);

	module_inst->accuracy = config->accuracy;
#if (SAMD21)
	/* Start the TCC module. */
	tcc_module = &module_inst->tcc_inst;
   227d8:	3014      	adds	r0, #20
	Tcc *hw[] = TCC_INSTS;
   227da:	cb92      	ldmia	r3!, {r1, r4, r7}
   227dc:	c292      	stmia	r2!, {r1, r4, r7}
	module_inst->accuracy = config->accuracy;
   227de:	886b      	ldrh	r3, [r5, #2]
	tcc_get_config_defaults(&tcc_conf, hw[config->tcc_dev]);
   227e0:	af05      	add	r7, sp, #20
	module_inst->accuracy = config->accuracy;
   227e2:	6403      	str	r3, [r0, #64]	; 0x40
	tcc_get_config_defaults(&tcc_conf, hw[config->tcc_dev]);
   227e4:	782b      	ldrb	r3, [r5, #0]
	tcc_module = &module_inst->tcc_inst;
   227e6:	0004      	movs	r4, r0
	tcc_get_config_defaults(&tcc_conf, hw[config->tcc_dev]);
   227e8:	009b      	lsls	r3, r3, #2
   227ea:	5999      	ldr	r1, [r3, r6]
   227ec:	0038      	movs	r0, r7
   227ee:	4b16      	ldr	r3, [pc, #88]	; (22848 <sw_timer_init+0x7c>)
   227f0:	4798      	blx	r3
	return (system_gclk_gen_get_hz(GCLK_GENERATOR_0) >> PM->CPUSEL.reg);
   227f2:	4b16      	ldr	r3, [pc, #88]	; (2284c <sw_timer_init+0x80>)
   227f4:	2000      	movs	r0, #0
   227f6:	4798      	blx	r3
   227f8:	4b15      	ldr	r3, [pc, #84]	; (22850 <sw_timer_init+0x84>)
	tcc_conf.counter.period = system_cpu_clock_get_hz() / (64 * 1000 / config->accuracy);
   227fa:	8869      	ldrh	r1, [r5, #2]
   227fc:	7a1b      	ldrb	r3, [r3, #8]
   227fe:	40d8      	lsrs	r0, r3
   22800:	9001      	str	r0, [sp, #4]
   22802:	20fa      	movs	r0, #250	; 0xfa
   22804:	4b13      	ldr	r3, [pc, #76]	; (22854 <sw_timer_init+0x88>)
   22806:	0200      	lsls	r0, r0, #8
   22808:	4798      	blx	r3
   2280a:	4b13      	ldr	r3, [pc, #76]	; (22858 <sw_timer_init+0x8c>)
   2280c:	0001      	movs	r1, r0
   2280e:	9801      	ldr	r0, [sp, #4]
   22810:	4798      	blx	r3
	tcc_conf.counter.clock_prescaler = TCC_CLOCK_PRESCALER_DIV64;
   22812:	2305      	movs	r3, #5
   22814:	72fb      	strb	r3, [r7, #11]
	tcc_init(tcc_module, hw[config->tcc_dev], &tcc_conf);
   22816:	782b      	ldrb	r3, [r5, #0]
	tcc_conf.counter.period = system_cpu_clock_get_hz() / (64 * 1000 / config->accuracy);
   22818:	6078      	str	r0, [r7, #4]
	tcc_init(tcc_module, hw[config->tcc_dev], &tcc_conf);
   2281a:	009b      	lsls	r3, r3, #2
   2281c:	5999      	ldr	r1, [r3, r6]
   2281e:	003a      	movs	r2, r7
   22820:	0020      	movs	r0, r4
   22822:	4b0e      	ldr	r3, [pc, #56]	; (2285c <sw_timer_init+0x90>)
   22824:	4798      	blx	r3
	tcc_register_callback(tcc_module, sw_timer_tcc_callback, config->tcc_callback_channel + TCC_CALLBACK_CHANNEL_0);
   22826:	786a      	ldrb	r2, [r5, #1]
   22828:	490d      	ldr	r1, [pc, #52]	; (22860 <sw_timer_init+0x94>)
   2282a:	3208      	adds	r2, #8
   2282c:	b2d2      	uxtb	r2, r2
   2282e:	0020      	movs	r0, r4
   22830:	4b0c      	ldr	r3, [pc, #48]	; (22864 <sw_timer_init+0x98>)
   22832:	4798      	blx	r3
	tcc_enable_callback(tcc_module, config->tcc_callback_channel + TCC_CALLBACK_CHANNEL_0);
   22834:	7869      	ldrb	r1, [r5, #1]
   22836:	0020      	movs	r0, r4
   22838:	3108      	adds	r1, #8
   2283a:	b2c9      	uxtb	r1, r1
   2283c:	4b0a      	ldr	r3, [pc, #40]	; (22868 <sw_timer_init+0x9c>)
   2283e:	4798      	blx	r3

	ul_previous_time = rtt_read_timer_value(RTT);
	while (ul_previous_time == rtt_read_timer_value(RTT)) {
	}
#endif
}
   22840:	b02f      	add	sp, #188	; 0xbc
   22842:	bdf0      	pop	{r4, r5, r6, r7, pc}
   22844:	0002b428 	.word	0x0002b428
   22848:	0001e9c9 	.word	0x0001e9c9
   2284c:	0001e729 	.word	0x0001e729
   22850:	40000400 	.word	0x40000400
   22854:	000259d1 	.word	0x000259d1
   22858:	000258bd 	.word	0x000258bd
   2285c:	0001eabd 	.word	0x0001eabd
   22860:	000227b1 	.word	0x000227b1
   22864:	0001edf9 	.word	0x0001edf9
   22868:	0001ee11 	.word	0x0001ee11

0002286c <sw_timer_enable>:
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	Tcc *const tcc_module = module_inst->hw;

	while (tcc_module->SYNCBUSY.reg & TCC_SYNCBUSY_ENABLE) {
   2286c:	2302      	movs	r3, #2
   2286e:	6942      	ldr	r2, [r0, #20]
   22870:	6891      	ldr	r1, [r2, #8]
   22872:	4219      	tst	r1, r3
   22874:	d1fc      	bne.n	22870 <sw_timer_enable+0x4>
		/* Wait for sync */
	}

	/* Enable the TCC module */
	tcc_module->CTRLA.reg |= TCC_CTRLA_ENABLE;
   22876:	6811      	ldr	r1, [r2, #0]
   22878:	430b      	orrs	r3, r1
   2287a:	6013      	str	r3, [r2, #0]
	NVIC_ClearPendingIRQ(RTT_IRQn);
	NVIC_SetPriority(RTT_IRQn, 0);
	NVIC_EnableIRQ(RTT_IRQn);
	rtt_enable_interrupt(RTT, RTT_MR_RTTINCIEN);
#endif
}
   2287c:	4770      	bx	lr
	...

00022880 <sw_timer_register_callback>:
#endif
}

int sw_timer_register_callback(struct sw_timer_module *const module_inst,
		sw_timer_callback_t callback, void *context, uint32_t period)
{
   22880:	b570      	push	{r4, r5, r6, lr}
   22882:	0004      	movs	r4, r0
	struct sw_timer_handle *handler;

	Assert(module_inst);

	for (index = 0; index < CONF_SW_TIMER_COUNT; index++) {
		if (module_inst->handler[index].used == 0) {
   22884:	7806      	ldrb	r6, [r0, #0]
			handler->period = period / module_inst->accuracy;
			handler->used = 1;
			return index;
		}
	}
	return -1;
   22886:	2001      	movs	r0, #1
		if (module_inst->handler[index].used == 0) {
   22888:	07f5      	lsls	r5, r6, #31
   2288a:	0fed      	lsrs	r5, r5, #31
	return -1;
   2288c:	4240      	negs	r0, r0
		if (module_inst->handler[index].used == 0) {
   2288e:	2d00      	cmp	r5, #0
   22890:	d10e      	bne.n	228b0 <sw_timer_register_callback+0x30>
			handler->callback = callback;
   22892:	6061      	str	r1, [r4, #4]
			handler->callback_enable = 0;
   22894:	2102      	movs	r1, #2
   22896:	438e      	bics	r6, r1
			handler->context = context;
   22898:	60a2      	str	r2, [r4, #8]
			handler->period = period / module_inst->accuracy;
   2289a:	0018      	movs	r0, r3
			handler->callback_enable = 0;
   2289c:	7026      	strb	r6, [r4, #0]
			handler->period = period / module_inst->accuracy;
   2289e:	4b05      	ldr	r3, [pc, #20]	; (228b4 <sw_timer_register_callback+0x34>)
   228a0:	6d61      	ldr	r1, [r4, #84]	; 0x54
   228a2:	4798      	blx	r3
			handler->used = 1;
   228a4:	2301      	movs	r3, #1
			handler->period = period / module_inst->accuracy;
   228a6:	60e0      	str	r0, [r4, #12]
			return index;
   228a8:	0028      	movs	r0, r5
			handler->used = 1;
   228aa:	b2f2      	uxtb	r2, r6
   228ac:	4313      	orrs	r3, r2
   228ae:	7023      	strb	r3, [r4, #0]
}
   228b0:	bd70      	pop	{r4, r5, r6, pc}
   228b2:	46c0      	nop			; (mov r8, r8)
   228b4:	000258bd 	.word	0x000258bd

000228b8 <sw_timer_enable_callback>:
	Assert(module_inst);
	Assert((timer_id >= 0 && timer_id < CONF_SW_TIMER_COUNT));

	handler = &module_inst->handler[timer_id];

	handler->callback_enable = 1;
   228b8:	2314      	movs	r3, #20
{
   228ba:	b510      	push	{r4, lr}
	handler->callback_enable = 1;
   228bc:	4359      	muls	r1, r3
   228be:	5c0c      	ldrb	r4, [r1, r0]
   228c0:	3b12      	subs	r3, #18
   228c2:	4323      	orrs	r3, r4
   228c4:	540b      	strb	r3, [r1, r0]
	handler->expire_time = sw_timer_tick + (delay / module_inst->accuracy);
   228c6:	1844      	adds	r4, r0, r1
   228c8:	4b04      	ldr	r3, [pc, #16]	; (228dc <sw_timer_enable_callback+0x24>)
   228ca:	6d41      	ldr	r1, [r0, #84]	; 0x54
   228cc:	0010      	movs	r0, r2
   228ce:	4798      	blx	r3
   228d0:	4b03      	ldr	r3, [pc, #12]	; (228e0 <sw_timer_enable_callback+0x28>)
   228d2:	681b      	ldr	r3, [r3, #0]
   228d4:	18c0      	adds	r0, r0, r3
   228d6:	6120      	str	r0, [r4, #16]
}
   228d8:	bd10      	pop	{r4, pc}
   228da:	46c0      	nop			; (mov r8, r8)
   228dc:	000258bd 	.word	0x000258bd
   228e0:	200041e4 	.word	0x200041e4

000228e4 <sw_timer_disable_callback>:
	Assert(module_inst);
	Assert((timer_id >= 0 && timer_id < CONF_SW_TIMER_COUNT));

	handler = &module_inst->handler[timer_id];

	handler->callback_enable = 0;
   228e4:	2314      	movs	r3, #20
   228e6:	2202      	movs	r2, #2
   228e8:	4359      	muls	r1, r3
   228ea:	5c0b      	ldrb	r3, [r1, r0]
   228ec:	4393      	bics	r3, r2
   228ee:	540b      	strb	r3, [r1, r0]
}
   228f0:	4770      	bx	lr
	...

000228f4 <sw_timer_task>:

void sw_timer_task(struct sw_timer_module *const module_inst)
{
   228f4:	b570      	push	{r4, r5, r6, lr}
	struct sw_timer_handle *handler;

	Assert(module_inst);

	for (index = 0; index < CONF_SW_TIMER_COUNT; index++) {
		if (module_inst->handler[index].used && module_inst->handler[index].callback_enable) {
   228f6:	7801      	ldrb	r1, [r0, #0]
{
   228f8:	0004      	movs	r4, r0
		if (module_inst->handler[index].used && module_inst->handler[index].callback_enable) {
   228fa:	07cb      	lsls	r3, r1, #31
   228fc:	d51b      	bpl.n	22936 <sw_timer_task+0x42>
   228fe:	078b      	lsls	r3, r1, #30
   22900:	d519      	bpl.n	22936 <sw_timer_task+0x42>
			handler = &module_inst->handler[index];
			if ((int)(handler->expire_time - sw_timer_tick) < 0 && handler->busy == 0) {
   22902:	4b0f      	ldr	r3, [pc, #60]	; (22940 <sw_timer_task+0x4c>)
   22904:	681a      	ldr	r2, [r3, #0]
   22906:	6903      	ldr	r3, [r0, #16]
   22908:	1a9b      	subs	r3, r3, r2
   2290a:	d514      	bpl.n	22936 <sw_timer_task+0x42>
   2290c:	2304      	movs	r3, #4
   2290e:	4219      	tst	r1, r3
   22910:	d111      	bne.n	22936 <sw_timer_task+0x42>
				/* Enter critical section. */
				handler->busy = 1;
   22912:	430b      	orrs	r3, r1
   22914:	7003      	strb	r3, [r0, #0]
				/* Timer was expired. */
				if (handler->period > 0) {
   22916:	68c3      	ldr	r3, [r0, #12]
   22918:	2b00      	cmp	r3, #0
   2291a:	d10d      	bne.n	22938 <sw_timer_task+0x44>
					handler->expire_time = sw_timer_tick + handler->period;
				} else {
					/* One shot. */
					handler->callback_enable = 0;
   2291c:	2102      	movs	r1, #2
   2291e:	7802      	ldrb	r2, [r0, #0]
   22920:	438a      	bics	r2, r1
   22922:	7002      	strb	r2, [r0, #0]
				}
				/* Call callback function. */
				handler->callback(module_inst, index, handler->context, handler->period);
   22924:	68a2      	ldr	r2, [r4, #8]
   22926:	2100      	movs	r1, #0
   22928:	0020      	movs	r0, r4
   2292a:	6865      	ldr	r5, [r4, #4]
   2292c:	47a8      	blx	r5
				/* Leave critical section. */
				handler->busy = 0;
   2292e:	2204      	movs	r2, #4
   22930:	7823      	ldrb	r3, [r4, #0]
   22932:	4393      	bics	r3, r2
   22934:	7023      	strb	r3, [r4, #0]
			}
		}
	}
}
   22936:	bd70      	pop	{r4, r5, r6, pc}
					handler->expire_time = sw_timer_tick + handler->period;
   22938:	18d2      	adds	r2, r2, r3
   2293a:	6102      	str	r2, [r0, #16]
   2293c:	e7f2      	b.n	22924 <sw_timer_task+0x30>
   2293e:	46c0      	nop			; (mov r8, r8)
   22940:	200041e4 	.word	0x200041e4

00022944 <app_gpio_config>:

/* LSM6DSO SPI device descriptor */
stmdev_ctx_t *dev_ctx;

void app_gpio_config(void) 
{
   22944:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	config->input_pull = PORT_PIN_PULL_UP;
   22946:	2401      	movs	r4, #1
	config->powersave  = false;
   22948:	2600      	movs	r6, #0
	config->input_pull = PORT_PIN_PULL_UP;
   2294a:	a901      	add	r1, sp, #4
	/* Get default config for led */
	struct port_config led_port_pin;
	port_get_config_defaults(&led_port_pin);
	
	led_port_pin.direction = PORT_PIN_DIR_OUTPUT;
	port_pin_set_config(LED_0_PIN, &led_port_pin);
   2294c:	4d09      	ldr	r5, [pc, #36]	; (22974 <app_gpio_config+0x30>)
   2294e:	2017      	movs	r0, #23
	config->powersave  = false;
   22950:	708e      	strb	r6, [r1, #2]
	config->input_pull = PORT_PIN_PULL_UP;
   22952:	704c      	strb	r4, [r1, #1]
	led_port_pin.direction = PORT_PIN_DIR_OUTPUT;
   22954:	700c      	strb	r4, [r1, #0]
	port_pin_set_config(LED_0_PIN, &led_port_pin);
   22956:	47a8      	blx	r5
   22958:	a902      	add	r1, sp, #8
	
	struct port_config dir_port_pin;
	port_get_config_defaults(&dir_port_pin);
	
	dir_port_pin.direction = PORT_PIN_DIR_OUTPUT;
	port_pin_set_config(DIRECTION, &dir_port_pin);
   2295a:	2003      	movs	r0, #3
	config->powersave  = false;
   2295c:	708e      	strb	r6, [r1, #2]
	config->input_pull = PORT_PIN_PULL_UP;
   2295e:	704c      	strb	r4, [r1, #1]
	dir_port_pin.direction = PORT_PIN_DIR_OUTPUT;
   22960:	700c      	strb	r4, [r1, #0]
	port_pin_set_config(DIRECTION, &dir_port_pin);
   22962:	47a8      	blx	r5
   22964:	a903      	add	r1, sp, #12
	
	struct port_config step_port_pin;
	port_get_config_defaults(&step_port_pin);
	
	step_port_pin.direction = PORT_PIN_DIR_OUTPUT;
	port_pin_set_config(STEP, &step_port_pin);
   22966:	2002      	movs	r0, #2
	config->powersave  = false;
   22968:	708e      	strb	r6, [r1, #2]
	config->input_pull = PORT_PIN_PULL_UP;
   2296a:	704c      	strb	r4, [r1, #1]
	step_port_pin.direction = PORT_PIN_DIR_OUTPUT;
   2296c:	700c      	strb	r4, [r1, #0]
	port_pin_set_config(STEP, &step_port_pin);
   2296e:	47a8      	blx	r5
}
   22970:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}
   22972:	46c0      	nop			; (mov r8, r8)
   22974:	0001d0dd 	.word	0x0001d0dd

00022978 <main>:
 * @brief Main application function.
 * Application entry point.
 * @return int
 */
int main(void)
{
   22978:	b510      	push	{r4, lr}
    /* Initialize the board. */
    system_init();
   2297a:	4b06      	ldr	r3, [pc, #24]	; (22994 <main+0x1c>)
   2297c:	4798      	blx	r3

    /* Initialize the UART console. */
    InitializeSerialConsole();
   2297e:	4b06      	ldr	r3, [pc, #24]	; (22998 <main+0x20>)
   22980:	4798      	blx	r3
	
	app_gpio_config();
   22982:	4b06      	ldr	r3, [pc, #24]	; (2299c <main+0x24>)
   22984:	4798      	blx	r3

    // Initialize trace capabilities
    vTraceEnable(TRC_START);
   22986:	2001      	movs	r0, #1
   22988:	4b05      	ldr	r3, [pc, #20]	; (229a0 <main+0x28>)
   2298a:	4798      	blx	r3
	
    // Start FreeRTOS scheduler
    vTaskStartScheduler();
   2298c:	4b05      	ldr	r3, [pc, #20]	; (229a4 <main+0x2c>)
   2298e:	4798      	blx	r3

    return 0;  // Will not get here
}
   22990:	2000      	movs	r0, #0
   22992:	bd10      	pop	{r4, pc}
   22994:	0001e96d 	.word	0x0001e96d
   22998:	0001920d 	.word	0x0001920d
   2299c:	00022945 	.word	0x00022945
   229a0:	00015da9 	.word	0x00015da9
   229a4:	000182a9 	.word	0x000182a9

000229a8 <vApplicationDaemonTaskStartupHook>:
 *					here will be called before other tasks are initialized.
 * @param[in]        None
 * @return           None
 */
void vApplicationDaemonTaskStartupHook(void)
{
   229a8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	int result;
	
    SerialConsoleWriteString("\r\n\r\n----- Wind Cheaters: V1 -----\r\n");
   229aa:	4844      	ldr	r0, [pc, #272]	; (22abc <vApplicationDaemonTaskStartupHook+0x114>)
   229ac:	4c44      	ldr	r4, [pc, #272]	; (22ac0 <vApplicationDaemonTaskStartupHook+0x118>)
   229ae:	47a0      	blx	r4

    // Initialize HW that needs FreeRTOS Initialization
    SerialConsoleWriteString("\r\n\r\nInitialize HW...\r\n");
   229b0:	4844      	ldr	r0, [pc, #272]	; (22ac4 <vApplicationDaemonTaskStartupHook+0x11c>)
   229b2:	47a0      	blx	r4
    if (I2cInitializeDriver() != STATUS_OK) {
   229b4:	4b44      	ldr	r3, [pc, #272]	; (22ac8 <vApplicationDaemonTaskStartupHook+0x120>)
   229b6:	4798      	blx	r3
   229b8:	2800      	cmp	r0, #0
   229ba:	d100      	bne.n	229be <vApplicationDaemonTaskStartupHook+0x16>
   229bc:	e078      	b.n	22ab0 <vApplicationDaemonTaskStartupHook+0x108>
        SerialConsoleWriteString("Error initializing I2C Driver!\r\n");
   229be:	4843      	ldr	r0, [pc, #268]	; (22acc <vApplicationDaemonTaskStartupHook+0x124>)
    } else {
        SerialConsoleWriteString("Initialized I2C Driver!\r\n");
   229c0:	47a0      	blx	r4
    }
	
	/* To let the sensor power-on properly before communicating */
	vTaskDelay(2000);
   229c2:	20fa      	movs	r0, #250	; 0xfa
   229c4:	4b42      	ldr	r3, [pc, #264]	; (22ad0 <vApplicationDaemonTaskStartupHook+0x128>)
   229c6:	00c0      	lsls	r0, r0, #3
   229c8:	4798      	blx	r3
	
	/* Initialize the BME680 Sensor
     * Interface preference is updated as a parameter
     * For I2C : BME68X_I2C_INTF
     */
    result = bme68x_interface_init(&bme, BME68X_I2C_INTF);
   229ca:	4e42      	ldr	r6, [pc, #264]	; (22ad4 <vApplicationDaemonTaskStartupHook+0x12c>)
   229cc:	2101      	movs	r1, #1
   229ce:	4b42      	ldr	r3, [pc, #264]	; (22ad8 <vApplicationDaemonTaskStartupHook+0x130>)
   229d0:	0030      	movs	r0, r6
   229d2:	4798      	blx	r3
    result |= bme68x_init(&bme);
   229d4:	4b41      	ldr	r3, [pc, #260]	; (22adc <vApplicationDaemonTaskStartupHook+0x134>)
    result = bme68x_interface_init(&bme, BME68X_I2C_INTF);
   229d6:	0005      	movs	r5, r0
    result |= bme68x_init(&bme);
   229d8:	0030      	movs	r0, r6
   229da:	4798      	blx	r3
    result |= bme68x_default_config(&bme);
   229dc:	4b40      	ldr	r3, [pc, #256]	; (22ae0 <vApplicationDaemonTaskStartupHook+0x138>)
   229de:	4305      	orrs	r5, r0
   229e0:	0030      	movs	r0, r6
   229e2:	4798      	blx	r3
   229e4:	b26d      	sxtb	r5, r5

    if (result != BME68X_OK) {
   229e6:	4328      	orrs	r0, r5
   229e8:	b240      	sxtb	r0, r0
   229ea:	2800      	cmp	r0, #0
   229ec:	d062      	beq.n	22ab4 <vApplicationDaemonTaskStartupHook+0x10c>
	    SerialConsoleWriteString("BME680 Initial failed!\r\n");
   229ee:	483d      	ldr	r0, [pc, #244]	; (22ae4 <vApplicationDaemonTaskStartupHook+0x13c>)
	} else{
	    SerialConsoleWriteString("BME680 Initialed Success!\r\n");
   229f0:	47a0      	blx	r4
    }
	
	/* Configure SPI for LSM6DSO */
	configure_spi_master();
   229f2:	4b3d      	ldr	r3, [pc, #244]	; (22ae8 <vApplicationDaemonTaskStartupHook+0x140>)
   229f4:	4798      	blx	r3
	dev_ctx = GetImuStruct();
   229f6:	4b3d      	ldr	r3, [pc, #244]	; (22aec <vApplicationDaemonTaskStartupHook+0x144>)
   229f8:	4798      	blx	r3
   229fa:	4b3d      	ldr	r3, [pc, #244]	; (22af0 <vApplicationDaemonTaskStartupHook+0x148>)
   229fc:	6018      	str	r0, [r3, #0]
	
	/* Passing device specific handle. */
	dev_ctx->handle = &spi_master_instance;
   229fe:	4b3d      	ldr	r3, [pc, #244]	; (22af4 <vApplicationDaemonTaskStartupHook+0x14c>)
   22a00:	6083      	str	r3, [r0, #8]

    if (InitImu() == 0) {
   22a02:	4b3d      	ldr	r3, [pc, #244]	; (22af8 <vApplicationDaemonTaskStartupHook+0x150>)
   22a04:	4798      	blx	r3
   22a06:	2800      	cmp	r0, #0
   22a08:	d156      	bne.n	22ab8 <vApplicationDaemonTaskStartupHook+0x110>
	    SerialConsoleWriteString("IMU initialized!\r\n");
   22a0a:	483c      	ldr	r0, [pc, #240]	; (22afc <vApplicationDaemonTaskStartupHook+0x154>)
	} else {
	    SerialConsoleWriteString("Could not initialize IMU\r\n");
   22a0c:	47a0      	blx	r4
    }
	
	FS3000_begin();
   22a0e:	4b3c      	ldr	r3, [pc, #240]	; (22b00 <vApplicationDaemonTaskStartupHook+0x158>)
   22a10:	4798      	blx	r3
 * @param[in]        None
 * @return           None
 */
static void StartTasks(void)
{
    snprintf(bufferPrint, 64, "Heap before starting tasks: %d\r\n", xPortGetFreeHeapSize());
   22a12:	4f3c      	ldr	r7, [pc, #240]	; (22b04 <vApplicationDaemonTaskStartupHook+0x15c>)
   22a14:	47b8      	blx	r7
   22a16:	4d3c      	ldr	r5, [pc, #240]	; (22b08 <vApplicationDaemonTaskStartupHook+0x160>)
   22a18:	0003      	movs	r3, r0
   22a1a:	4a3c      	ldr	r2, [pc, #240]	; (22b0c <vApplicationDaemonTaskStartupHook+0x164>)
   22a1c:	2140      	movs	r1, #64	; 0x40
   22a1e:	4e3c      	ldr	r6, [pc, #240]	; (22b10 <vApplicationDaemonTaskStartupHook+0x168>)
   22a20:	0028      	movs	r0, r5
   22a22:	47b0      	blx	r6
    SerialConsoleWriteString(bufferPrint);
   22a24:	0028      	movs	r0, r5
   22a26:	47a0      	blx	r4

    // Initialize Tasks here
    if (xTaskCreate(vCommandConsoleTask, "CLI_TASK", CLI_TASK_SIZE, NULL, CLI_PRIORITY, &cliTaskHandle) != pdPASS) {
   22a28:	4b3a      	ldr	r3, [pc, #232]	; (22b14 <vApplicationDaemonTaskStartupHook+0x16c>)
   22a2a:	22fa      	movs	r2, #250	; 0xfa
   22a2c:	9301      	str	r3, [sp, #4]
   22a2e:	2303      	movs	r3, #3
   22a30:	0052      	lsls	r2, r2, #1
   22a32:	9300      	str	r3, [sp, #0]
   22a34:	4938      	ldr	r1, [pc, #224]	; (22b18 <vApplicationDaemonTaskStartupHook+0x170>)
   22a36:	2300      	movs	r3, #0
   22a38:	4838      	ldr	r0, [pc, #224]	; (22b1c <vApplicationDaemonTaskStartupHook+0x174>)
   22a3a:	4e39      	ldr	r6, [pc, #228]	; (22b20 <vApplicationDaemonTaskStartupHook+0x178>)
   22a3c:	47b0      	blx	r6
   22a3e:	2801      	cmp	r0, #1
   22a40:	d001      	beq.n	22a46 <vApplicationDaemonTaskStartupHook+0x9e>
        SerialConsoleWriteString("ERR: CLI task could not be initialized!\r\n");
   22a42:	4838      	ldr	r0, [pc, #224]	; (22b24 <vApplicationDaemonTaskStartupHook+0x17c>)
   22a44:	47a0      	blx	r4
    }

    if (xTaskCreate(vWifiTask, "WIFI_TASK", WIFI_TASK_SIZE, NULL, WIFI_PRIORITY, &wifiTaskHandle) != pdPASS) {
   22a46:	4b38      	ldr	r3, [pc, #224]	; (22b28 <vApplicationDaemonTaskStartupHook+0x180>)
   22a48:	22c8      	movs	r2, #200	; 0xc8
   22a4a:	9301      	str	r3, [sp, #4]
   22a4c:	2302      	movs	r3, #2
   22a4e:	0092      	lsls	r2, r2, #2
   22a50:	9300      	str	r3, [sp, #0]
   22a52:	4936      	ldr	r1, [pc, #216]	; (22b2c <vApplicationDaemonTaskStartupHook+0x184>)
   22a54:	2300      	movs	r3, #0
   22a56:	4836      	ldr	r0, [pc, #216]	; (22b30 <vApplicationDaemonTaskStartupHook+0x188>)
   22a58:	47b0      	blx	r6
   22a5a:	2801      	cmp	r0, #1
   22a5c:	d001      	beq.n	22a62 <vApplicationDaemonTaskStartupHook+0xba>
        SerialConsoleWriteString("ERR: WIFI task could not be initialized!\r\n");
   22a5e:	4835      	ldr	r0, [pc, #212]	; (22b34 <vApplicationDaemonTaskStartupHook+0x18c>)
   22a60:	47a0      	blx	r4
    }
	
	if (xTaskCreate(vImuTask, "ACCEL_TASK", IMU_TASK_SIZE, NULL, AIR_TASK_PRIORITY, &accelTaskHandle) != pdPASS) {
   22a62:	4b35      	ldr	r3, [pc, #212]	; (22b38 <vApplicationDaemonTaskStartupHook+0x190>)
   22a64:	2264      	movs	r2, #100	; 0x64
   22a66:	9301      	str	r3, [sp, #4]
   22a68:	2304      	movs	r3, #4
   22a6a:	4934      	ldr	r1, [pc, #208]	; (22b3c <vApplicationDaemonTaskStartupHook+0x194>)
   22a6c:	9300      	str	r3, [sp, #0]
   22a6e:	4834      	ldr	r0, [pc, #208]	; (22b40 <vApplicationDaemonTaskStartupHook+0x198>)
   22a70:	2300      	movs	r3, #0
   22a72:	47b0      	blx	r6
   22a74:	2801      	cmp	r0, #1
   22a76:	d001      	beq.n	22a7c <vApplicationDaemonTaskStartupHook+0xd4>
		SerialConsoleWriteString("ERR: IMU task could not be initialized!\r\n");
   22a78:	4832      	ldr	r0, [pc, #200]	; (22b44 <vApplicationDaemonTaskStartupHook+0x19c>)
   22a7a:	47a0      	blx	r4
	}

	
	if (xTaskCreate(vBmeTask, "BME_TASK", BME_TASK_SIZE, NULL, BME_TASK_PRIORITY, &bmeTaskHandle) != pdPASS) {
   22a7c:	4b32      	ldr	r3, [pc, #200]	; (22b48 <vApplicationDaemonTaskStartupHook+0x1a0>)
   22a7e:	22c8      	movs	r2, #200	; 0xc8
   22a80:	9301      	str	r3, [sp, #4]
   22a82:	2304      	movs	r3, #4
   22a84:	4931      	ldr	r1, [pc, #196]	; (22b4c <vApplicationDaemonTaskStartupHook+0x1a4>)
   22a86:	9300      	str	r3, [sp, #0]
   22a88:	4831      	ldr	r0, [pc, #196]	; (22b50 <vApplicationDaemonTaskStartupHook+0x1a8>)
   22a8a:	2300      	movs	r3, #0
   22a8c:	47b0      	blx	r6
   22a8e:	2801      	cmp	r0, #1
   22a90:	d001      	beq.n	22a96 <vApplicationDaemonTaskStartupHook+0xee>
		 SerialConsoleWriteString("ERR: BME task could not be initialized!\r\n");
   22a92:	4830      	ldr	r0, [pc, #192]	; (22b54 <vApplicationDaemonTaskStartupHook+0x1ac>)
   22a94:	47a0      	blx	r4
	}
	

	snprintf(bufferPrint, 64, "Heap after all tasks %d\r\n", xPortGetFreeHeapSize());
   22a96:	47b8      	blx	r7
   22a98:	4a2f      	ldr	r2, [pc, #188]	; (22b58 <vApplicationDaemonTaskStartupHook+0x1b0>)
   22a9a:	0003      	movs	r3, r0
   22a9c:	2140      	movs	r1, #64	; 0x40
   22a9e:	0028      	movs	r0, r5
   22aa0:	4e1b      	ldr	r6, [pc, #108]	; (22b10 <vApplicationDaemonTaskStartupHook+0x168>)
   22aa2:	47b0      	blx	r6
	SerialConsoleWriteString(bufferPrint);
   22aa4:	0028      	movs	r0, r5
   22aa6:	47a0      	blx	r4
    vTaskSuspend(daemonTaskHandle);
   22aa8:	2000      	movs	r0, #0
   22aaa:	4b2c      	ldr	r3, [pc, #176]	; (22b5c <vApplicationDaemonTaskStartupHook+0x1b4>)
   22aac:	4798      	blx	r3
}
   22aae:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
        SerialConsoleWriteString("Initialized I2C Driver!\r\n");
   22ab0:	482b      	ldr	r0, [pc, #172]	; (22b60 <vApplicationDaemonTaskStartupHook+0x1b8>)
   22ab2:	e785      	b.n	229c0 <vApplicationDaemonTaskStartupHook+0x18>
	    SerialConsoleWriteString("BME680 Initialed Success!\r\n");
   22ab4:	482b      	ldr	r0, [pc, #172]	; (22b64 <vApplicationDaemonTaskStartupHook+0x1bc>)
   22ab6:	e79b      	b.n	229f0 <vApplicationDaemonTaskStartupHook+0x48>
	    SerialConsoleWriteString("Could not initialize IMU\r\n");
   22ab8:	482b      	ldr	r0, [pc, #172]	; (22b68 <vApplicationDaemonTaskStartupHook+0x1c0>)
   22aba:	e7a7      	b.n	22a0c <vApplicationDaemonTaskStartupHook+0x64>
   22abc:	0002b434 	.word	0x0002b434
   22ac0:	00019335 	.word	0x00019335
   22ac4:	0002b458 	.word	0x0002b458
   22ac8:	00013ef1 	.word	0x00013ef1
   22acc:	0002b46f 	.word	0x0002b46f
   22ad0:	000185ad 	.word	0x000185ad
   22ad4:	200056d0 	.word	0x200056d0
   22ad8:	000139c5 	.word	0x000139c5
   22adc:	00012fe9 	.word	0x00012fe9
   22ae0:	00013985 	.word	0x00013985
   22ae4:	0002b4aa 	.word	0x0002b4aa
   22ae8:	00014825 	.word	0x00014825
   22aec:	0001478d 	.word	0x0001478d
   22af0:	200056c8 	.word	0x200056c8
   22af4:	200042f0 	.word	0x200042f0
   22af8:	00014795 	.word	0x00014795
   22afc:	0002b4df 	.word	0x0002b4df
   22b00:	00012131 	.word	0x00012131
   22b04:	00016f45 	.word	0x00016f45
   22b08:	20005720 	.word	0x20005720
   22b0c:	0002b50d 	.word	0x0002b50d
   22b10:	00023781 	.word	0x00023781
   22b14:	200041f0 	.word	0x200041f0
   22b18:	0002b52e 	.word	0x0002b52e
   22b1c:	00013bb1 	.word	0x00013bb1
   22b20:	00018031 	.word	0x00018031
   22b24:	0002b537 	.word	0x0002b537
   22b28:	200041f4 	.word	0x200041f4
   22b2c:	0002b561 	.word	0x0002b561
   22b30:	00015179 	.word	0x00015179
   22b34:	0002b56b 	.word	0x0002b56b
   22b38:	200041e8 	.word	0x200041e8
   22b3c:	0002b596 	.word	0x0002b596
   22b40:	000141ed 	.word	0x000141ed
   22b44:	0002b5a1 	.word	0x0002b5a1
   22b48:	200041ec 	.word	0x200041ec
   22b4c:	0002b5cb 	.word	0x0002b5cb
   22b50:	00012701 	.word	0x00012701
   22b54:	0002b5d4 	.word	0x0002b5d4
   22b58:	0002b5fe 	.word	0x0002b5fe
   22b5c:	0001870d 	.word	0x0001870d
   22b60:	0002b490 	.word	0x0002b490
   22b64:	0002b4c3 	.word	0x0002b4c3
   22b68:	0002b4f2 	.word	0x0002b4f2

00022b6c <vApplicationMallocFailedHook>:
}

void vApplicationMallocFailedHook(void)
{
   22b6c:	b510      	push	{r4, lr}
    SerialConsoleWriteString("Error on memory allocation on FREERTOS!\r\n");
   22b6e:	4802      	ldr	r0, [pc, #8]	; (22b78 <vApplicationMallocFailedHook+0xc>)
   22b70:	4b02      	ldr	r3, [pc, #8]	; (22b7c <vApplicationMallocFailedHook+0x10>)
   22b72:	4798      	blx	r3
   22b74:	e7fe      	b.n	22b74 <vApplicationMallocFailedHook+0x8>
   22b76:	46c0      	nop			; (mov r8, r8)
   22b78:	0002b618 	.word	0x0002b618
   22b7c:	00019335 	.word	0x00019335

00022b80 <vApplicationStackOverflowHook>:
    while (1);
}

void vApplicationStackOverflowHook(void)
{
   22b80:	b510      	push	{r4, lr}
    SerialConsoleWriteString("Error on stack overflow on FREERTOS!\r\n");
   22b82:	4802      	ldr	r0, [pc, #8]	; (22b8c <vApplicationStackOverflowHook+0xc>)
   22b84:	4b02      	ldr	r3, [pc, #8]	; (22b90 <vApplicationStackOverflowHook+0x10>)
   22b86:	4798      	blx	r3
   22b88:	e7fe      	b.n	22b88 <vApplicationStackOverflowHook+0x8>
   22b8a:	46c0      	nop			; (mov r8, r8)
   22b8c:	0002b642 	.word	0x0002b642
   22b90:	00019335 	.word	0x00019335

00022b94 <atoi>:
   22b94:	b510      	push	{r4, lr}
   22b96:	220a      	movs	r2, #10
   22b98:	2100      	movs	r1, #0
   22b9a:	f000 ff6f 	bl	23a7c <strtol>
   22b9e:	bd10      	pop	{r4, pc}

00022ba0 <__libc_init_array>:
   22ba0:	b570      	push	{r4, r5, r6, lr}
   22ba2:	2600      	movs	r6, #0
   22ba4:	4d0c      	ldr	r5, [pc, #48]	; (22bd8 <__libc_init_array+0x38>)
   22ba6:	4c0d      	ldr	r4, [pc, #52]	; (22bdc <__libc_init_array+0x3c>)
   22ba8:	1b64      	subs	r4, r4, r5
   22baa:	10a4      	asrs	r4, r4, #2
   22bac:	42a6      	cmp	r6, r4
   22bae:	d109      	bne.n	22bc4 <__libc_init_array+0x24>
   22bb0:	2600      	movs	r6, #0
   22bb2:	f008 ff59 	bl	2ba68 <_init>
   22bb6:	4d0a      	ldr	r5, [pc, #40]	; (22be0 <__libc_init_array+0x40>)
   22bb8:	4c0a      	ldr	r4, [pc, #40]	; (22be4 <__libc_init_array+0x44>)
   22bba:	1b64      	subs	r4, r4, r5
   22bbc:	10a4      	asrs	r4, r4, #2
   22bbe:	42a6      	cmp	r6, r4
   22bc0:	d105      	bne.n	22bce <__libc_init_array+0x2e>
   22bc2:	bd70      	pop	{r4, r5, r6, pc}
   22bc4:	00b3      	lsls	r3, r6, #2
   22bc6:	58eb      	ldr	r3, [r5, r3]
   22bc8:	4798      	blx	r3
   22bca:	3601      	adds	r6, #1
   22bcc:	e7ee      	b.n	22bac <__libc_init_array+0xc>
   22bce:	00b3      	lsls	r3, r6, #2
   22bd0:	58eb      	ldr	r3, [r5, r3]
   22bd2:	4798      	blx	r3
   22bd4:	3601      	adds	r6, #1
   22bd6:	e7f2      	b.n	22bbe <__libc_init_array+0x1e>
   22bd8:	0002ba74 	.word	0x0002ba74
   22bdc:	0002ba74 	.word	0x0002ba74
   22be0:	0002ba74 	.word	0x0002ba74
   22be4:	0002ba78 	.word	0x0002ba78

00022be8 <malloc>:
   22be8:	b510      	push	{r4, lr}
   22bea:	4b03      	ldr	r3, [pc, #12]	; (22bf8 <malloc+0x10>)
   22bec:	0001      	movs	r1, r0
   22bee:	6818      	ldr	r0, [r3, #0]
   22bf0:	f000 f87c 	bl	22cec <_malloc_r>
   22bf4:	bd10      	pop	{r4, pc}
   22bf6:	46c0      	nop			; (mov r8, r8)
   22bf8:	2000020c 	.word	0x2000020c

00022bfc <free>:
   22bfc:	b510      	push	{r4, lr}
   22bfe:	4b03      	ldr	r3, [pc, #12]	; (22c0c <free+0x10>)
   22c00:	0001      	movs	r1, r0
   22c02:	6818      	ldr	r0, [r3, #0]
   22c04:	f000 f828 	bl	22c58 <_free_r>
   22c08:	bd10      	pop	{r4, pc}
   22c0a:	46c0      	nop			; (mov r8, r8)
   22c0c:	2000020c 	.word	0x2000020c

00022c10 <memcpy>:
   22c10:	2300      	movs	r3, #0
   22c12:	b510      	push	{r4, lr}
   22c14:	429a      	cmp	r2, r3
   22c16:	d100      	bne.n	22c1a <memcpy+0xa>
   22c18:	bd10      	pop	{r4, pc}
   22c1a:	5ccc      	ldrb	r4, [r1, r3]
   22c1c:	54c4      	strb	r4, [r0, r3]
   22c1e:	3301      	adds	r3, #1
   22c20:	e7f8      	b.n	22c14 <memcpy+0x4>

00022c22 <memmove>:
   22c22:	b510      	push	{r4, lr}
   22c24:	4288      	cmp	r0, r1
   22c26:	d902      	bls.n	22c2e <memmove+0xc>
   22c28:	188b      	adds	r3, r1, r2
   22c2a:	4298      	cmp	r0, r3
   22c2c:	d308      	bcc.n	22c40 <memmove+0x1e>
   22c2e:	2300      	movs	r3, #0
   22c30:	429a      	cmp	r2, r3
   22c32:	d007      	beq.n	22c44 <memmove+0x22>
   22c34:	5ccc      	ldrb	r4, [r1, r3]
   22c36:	54c4      	strb	r4, [r0, r3]
   22c38:	3301      	adds	r3, #1
   22c3a:	e7f9      	b.n	22c30 <memmove+0xe>
   22c3c:	5c8b      	ldrb	r3, [r1, r2]
   22c3e:	5483      	strb	r3, [r0, r2]
   22c40:	3a01      	subs	r2, #1
   22c42:	d2fb      	bcs.n	22c3c <memmove+0x1a>
   22c44:	bd10      	pop	{r4, pc}

00022c46 <memset>:
   22c46:	0003      	movs	r3, r0
   22c48:	1882      	adds	r2, r0, r2
   22c4a:	4293      	cmp	r3, r2
   22c4c:	d100      	bne.n	22c50 <memset+0xa>
   22c4e:	4770      	bx	lr
   22c50:	7019      	strb	r1, [r3, #0]
   22c52:	3301      	adds	r3, #1
   22c54:	e7f9      	b.n	22c4a <memset+0x4>
	...

00022c58 <_free_r>:
   22c58:	b570      	push	{r4, r5, r6, lr}
   22c5a:	0005      	movs	r5, r0
   22c5c:	2900      	cmp	r1, #0
   22c5e:	d010      	beq.n	22c82 <_free_r+0x2a>
   22c60:	1f0c      	subs	r4, r1, #4
   22c62:	6823      	ldr	r3, [r4, #0]
   22c64:	2b00      	cmp	r3, #0
   22c66:	da00      	bge.n	22c6a <_free_r+0x12>
   22c68:	18e4      	adds	r4, r4, r3
   22c6a:	0028      	movs	r0, r5
   22c6c:	f002 f8bd 	bl	24dea <__malloc_lock>
   22c70:	4a1d      	ldr	r2, [pc, #116]	; (22ce8 <_free_r+0x90>)
   22c72:	6813      	ldr	r3, [r2, #0]
   22c74:	2b00      	cmp	r3, #0
   22c76:	d105      	bne.n	22c84 <_free_r+0x2c>
   22c78:	6063      	str	r3, [r4, #4]
   22c7a:	6014      	str	r4, [r2, #0]
   22c7c:	0028      	movs	r0, r5
   22c7e:	f002 f8b5 	bl	24dec <__malloc_unlock>
   22c82:	bd70      	pop	{r4, r5, r6, pc}
   22c84:	42a3      	cmp	r3, r4
   22c86:	d909      	bls.n	22c9c <_free_r+0x44>
   22c88:	6821      	ldr	r1, [r4, #0]
   22c8a:	1860      	adds	r0, r4, r1
   22c8c:	4283      	cmp	r3, r0
   22c8e:	d1f3      	bne.n	22c78 <_free_r+0x20>
   22c90:	6818      	ldr	r0, [r3, #0]
   22c92:	685b      	ldr	r3, [r3, #4]
   22c94:	1841      	adds	r1, r0, r1
   22c96:	6021      	str	r1, [r4, #0]
   22c98:	e7ee      	b.n	22c78 <_free_r+0x20>
   22c9a:	0013      	movs	r3, r2
   22c9c:	685a      	ldr	r2, [r3, #4]
   22c9e:	2a00      	cmp	r2, #0
   22ca0:	d001      	beq.n	22ca6 <_free_r+0x4e>
   22ca2:	42a2      	cmp	r2, r4
   22ca4:	d9f9      	bls.n	22c9a <_free_r+0x42>
   22ca6:	6819      	ldr	r1, [r3, #0]
   22ca8:	1858      	adds	r0, r3, r1
   22caa:	42a0      	cmp	r0, r4
   22cac:	d10b      	bne.n	22cc6 <_free_r+0x6e>
   22cae:	6820      	ldr	r0, [r4, #0]
   22cb0:	1809      	adds	r1, r1, r0
   22cb2:	1858      	adds	r0, r3, r1
   22cb4:	6019      	str	r1, [r3, #0]
   22cb6:	4282      	cmp	r2, r0
   22cb8:	d1e0      	bne.n	22c7c <_free_r+0x24>
   22cba:	6810      	ldr	r0, [r2, #0]
   22cbc:	6852      	ldr	r2, [r2, #4]
   22cbe:	1841      	adds	r1, r0, r1
   22cc0:	6019      	str	r1, [r3, #0]
   22cc2:	605a      	str	r2, [r3, #4]
   22cc4:	e7da      	b.n	22c7c <_free_r+0x24>
   22cc6:	42a0      	cmp	r0, r4
   22cc8:	d902      	bls.n	22cd0 <_free_r+0x78>
   22cca:	230c      	movs	r3, #12
   22ccc:	602b      	str	r3, [r5, #0]
   22cce:	e7d5      	b.n	22c7c <_free_r+0x24>
   22cd0:	6821      	ldr	r1, [r4, #0]
   22cd2:	1860      	adds	r0, r4, r1
   22cd4:	4282      	cmp	r2, r0
   22cd6:	d103      	bne.n	22ce0 <_free_r+0x88>
   22cd8:	6810      	ldr	r0, [r2, #0]
   22cda:	6852      	ldr	r2, [r2, #4]
   22cdc:	1841      	adds	r1, r0, r1
   22cde:	6021      	str	r1, [r4, #0]
   22ce0:	6062      	str	r2, [r4, #4]
   22ce2:	605c      	str	r4, [r3, #4]
   22ce4:	e7ca      	b.n	22c7c <_free_r+0x24>
   22ce6:	46c0      	nop			; (mov r8, r8)
   22ce8:	200041f8 	.word	0x200041f8

00022cec <_malloc_r>:
   22cec:	2303      	movs	r3, #3
   22cee:	b570      	push	{r4, r5, r6, lr}
   22cf0:	1ccd      	adds	r5, r1, #3
   22cf2:	439d      	bics	r5, r3
   22cf4:	3508      	adds	r5, #8
   22cf6:	0006      	movs	r6, r0
   22cf8:	2d0c      	cmp	r5, #12
   22cfa:	d21e      	bcs.n	22d3a <_malloc_r+0x4e>
   22cfc:	250c      	movs	r5, #12
   22cfe:	42a9      	cmp	r1, r5
   22d00:	d81d      	bhi.n	22d3e <_malloc_r+0x52>
   22d02:	0030      	movs	r0, r6
   22d04:	f002 f871 	bl	24dea <__malloc_lock>
   22d08:	4a25      	ldr	r2, [pc, #148]	; (22da0 <_malloc_r+0xb4>)
   22d0a:	6814      	ldr	r4, [r2, #0]
   22d0c:	0021      	movs	r1, r4
   22d0e:	2900      	cmp	r1, #0
   22d10:	d119      	bne.n	22d46 <_malloc_r+0x5a>
   22d12:	4c24      	ldr	r4, [pc, #144]	; (22da4 <_malloc_r+0xb8>)
   22d14:	6823      	ldr	r3, [r4, #0]
   22d16:	2b00      	cmp	r3, #0
   22d18:	d103      	bne.n	22d22 <_malloc_r+0x36>
   22d1a:	0030      	movs	r0, r6
   22d1c:	f000 fd1e 	bl	2375c <_sbrk_r>
   22d20:	6020      	str	r0, [r4, #0]
   22d22:	0029      	movs	r1, r5
   22d24:	0030      	movs	r0, r6
   22d26:	f000 fd19 	bl	2375c <_sbrk_r>
   22d2a:	1c43      	adds	r3, r0, #1
   22d2c:	d12c      	bne.n	22d88 <_malloc_r+0x9c>
   22d2e:	230c      	movs	r3, #12
   22d30:	0030      	movs	r0, r6
   22d32:	6033      	str	r3, [r6, #0]
   22d34:	f002 f85a 	bl	24dec <__malloc_unlock>
   22d38:	e003      	b.n	22d42 <_malloc_r+0x56>
   22d3a:	2d00      	cmp	r5, #0
   22d3c:	dadf      	bge.n	22cfe <_malloc_r+0x12>
   22d3e:	230c      	movs	r3, #12
   22d40:	6033      	str	r3, [r6, #0]
   22d42:	2000      	movs	r0, #0
   22d44:	bd70      	pop	{r4, r5, r6, pc}
   22d46:	680b      	ldr	r3, [r1, #0]
   22d48:	1b5b      	subs	r3, r3, r5
   22d4a:	d41a      	bmi.n	22d82 <_malloc_r+0x96>
   22d4c:	2b0b      	cmp	r3, #11
   22d4e:	d903      	bls.n	22d58 <_malloc_r+0x6c>
   22d50:	600b      	str	r3, [r1, #0]
   22d52:	18cc      	adds	r4, r1, r3
   22d54:	6025      	str	r5, [r4, #0]
   22d56:	e003      	b.n	22d60 <_malloc_r+0x74>
   22d58:	428c      	cmp	r4, r1
   22d5a:	d10e      	bne.n	22d7a <_malloc_r+0x8e>
   22d5c:	6863      	ldr	r3, [r4, #4]
   22d5e:	6013      	str	r3, [r2, #0]
   22d60:	0030      	movs	r0, r6
   22d62:	f002 f843 	bl	24dec <__malloc_unlock>
   22d66:	0020      	movs	r0, r4
   22d68:	2207      	movs	r2, #7
   22d6a:	300b      	adds	r0, #11
   22d6c:	1d23      	adds	r3, r4, #4
   22d6e:	4390      	bics	r0, r2
   22d70:	1ac3      	subs	r3, r0, r3
   22d72:	d0e7      	beq.n	22d44 <_malloc_r+0x58>
   22d74:	425a      	negs	r2, r3
   22d76:	50e2      	str	r2, [r4, r3]
   22d78:	e7e4      	b.n	22d44 <_malloc_r+0x58>
   22d7a:	684b      	ldr	r3, [r1, #4]
   22d7c:	6063      	str	r3, [r4, #4]
   22d7e:	000c      	movs	r4, r1
   22d80:	e7ee      	b.n	22d60 <_malloc_r+0x74>
   22d82:	000c      	movs	r4, r1
   22d84:	6849      	ldr	r1, [r1, #4]
   22d86:	e7c2      	b.n	22d0e <_malloc_r+0x22>
   22d88:	2303      	movs	r3, #3
   22d8a:	1cc4      	adds	r4, r0, #3
   22d8c:	439c      	bics	r4, r3
   22d8e:	42a0      	cmp	r0, r4
   22d90:	d0e0      	beq.n	22d54 <_malloc_r+0x68>
   22d92:	1a21      	subs	r1, r4, r0
   22d94:	0030      	movs	r0, r6
   22d96:	f000 fce1 	bl	2375c <_sbrk_r>
   22d9a:	1c43      	adds	r3, r0, #1
   22d9c:	d1da      	bne.n	22d54 <_malloc_r+0x68>
   22d9e:	e7c6      	b.n	22d2e <_malloc_r+0x42>
   22da0:	200041f8 	.word	0x200041f8
   22da4:	200041fc 	.word	0x200041fc

00022da8 <__cvt>:
   22da8:	b5f0      	push	{r4, r5, r6, r7, lr}
   22daa:	b08b      	sub	sp, #44	; 0x2c
   22dac:	0014      	movs	r4, r2
   22dae:	1e1d      	subs	r5, r3, #0
   22db0:	9912      	ldr	r1, [sp, #72]	; 0x48
   22db2:	da53      	bge.n	22e5c <__cvt+0xb4>
   22db4:	2480      	movs	r4, #128	; 0x80
   22db6:	0624      	lsls	r4, r4, #24
   22db8:	191b      	adds	r3, r3, r4
   22dba:	001d      	movs	r5, r3
   22dbc:	0014      	movs	r4, r2
   22dbe:	232d      	movs	r3, #45	; 0x2d
   22dc0:	700b      	strb	r3, [r1, #0]
   22dc2:	2320      	movs	r3, #32
   22dc4:	9e14      	ldr	r6, [sp, #80]	; 0x50
   22dc6:	2203      	movs	r2, #3
   22dc8:	439e      	bics	r6, r3
   22dca:	2e46      	cmp	r6, #70	; 0x46
   22dcc:	d007      	beq.n	22dde <__cvt+0x36>
   22dce:	0033      	movs	r3, r6
   22dd0:	3b45      	subs	r3, #69	; 0x45
   22dd2:	4259      	negs	r1, r3
   22dd4:	414b      	adcs	r3, r1
   22dd6:	9910      	ldr	r1, [sp, #64]	; 0x40
   22dd8:	3a01      	subs	r2, #1
   22dda:	18cb      	adds	r3, r1, r3
   22ddc:	9310      	str	r3, [sp, #64]	; 0x40
   22dde:	ab09      	add	r3, sp, #36	; 0x24
   22de0:	9304      	str	r3, [sp, #16]
   22de2:	ab08      	add	r3, sp, #32
   22de4:	9303      	str	r3, [sp, #12]
   22de6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   22de8:	9200      	str	r2, [sp, #0]
   22dea:	9302      	str	r3, [sp, #8]
   22dec:	9b10      	ldr	r3, [sp, #64]	; 0x40
   22dee:	0022      	movs	r2, r4
   22df0:	9301      	str	r3, [sp, #4]
   22df2:	002b      	movs	r3, r5
   22df4:	f000 ffde 	bl	23db4 <_dtoa_r>
   22df8:	0007      	movs	r7, r0
   22dfa:	2e47      	cmp	r6, #71	; 0x47
   22dfc:	d102      	bne.n	22e04 <__cvt+0x5c>
   22dfe:	9b11      	ldr	r3, [sp, #68]	; 0x44
   22e00:	07db      	lsls	r3, r3, #31
   22e02:	d524      	bpl.n	22e4e <__cvt+0xa6>
   22e04:	9b10      	ldr	r3, [sp, #64]	; 0x40
   22e06:	18fb      	adds	r3, r7, r3
   22e08:	9307      	str	r3, [sp, #28]
   22e0a:	2e46      	cmp	r6, #70	; 0x46
   22e0c:	d114      	bne.n	22e38 <__cvt+0x90>
   22e0e:	783b      	ldrb	r3, [r7, #0]
   22e10:	2b30      	cmp	r3, #48	; 0x30
   22e12:	d10c      	bne.n	22e2e <__cvt+0x86>
   22e14:	2200      	movs	r2, #0
   22e16:	2300      	movs	r3, #0
   22e18:	0020      	movs	r0, r4
   22e1a:	0029      	movs	r1, r5
   22e1c:	f002 fee0 	bl	25be0 <__aeabi_dcmpeq>
   22e20:	2800      	cmp	r0, #0
   22e22:	d104      	bne.n	22e2e <__cvt+0x86>
   22e24:	2301      	movs	r3, #1
   22e26:	9a10      	ldr	r2, [sp, #64]	; 0x40
   22e28:	1a9b      	subs	r3, r3, r2
   22e2a:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   22e2c:	6013      	str	r3, [r2, #0]
   22e2e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   22e30:	9a07      	ldr	r2, [sp, #28]
   22e32:	681b      	ldr	r3, [r3, #0]
   22e34:	18d3      	adds	r3, r2, r3
   22e36:	9307      	str	r3, [sp, #28]
   22e38:	2200      	movs	r2, #0
   22e3a:	2300      	movs	r3, #0
   22e3c:	0020      	movs	r0, r4
   22e3e:	0029      	movs	r1, r5
   22e40:	f002 fece 	bl	25be0 <__aeabi_dcmpeq>
   22e44:	2230      	movs	r2, #48	; 0x30
   22e46:	2800      	cmp	r0, #0
   22e48:	d00d      	beq.n	22e66 <__cvt+0xbe>
   22e4a:	9b07      	ldr	r3, [sp, #28]
   22e4c:	9309      	str	r3, [sp, #36]	; 0x24
   22e4e:	0038      	movs	r0, r7
   22e50:	9b09      	ldr	r3, [sp, #36]	; 0x24
   22e52:	9a15      	ldr	r2, [sp, #84]	; 0x54
   22e54:	1bdb      	subs	r3, r3, r7
   22e56:	6013      	str	r3, [r2, #0]
   22e58:	b00b      	add	sp, #44	; 0x2c
   22e5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   22e5c:	2300      	movs	r3, #0
   22e5e:	e7af      	b.n	22dc0 <__cvt+0x18>
   22e60:	1c59      	adds	r1, r3, #1
   22e62:	9109      	str	r1, [sp, #36]	; 0x24
   22e64:	701a      	strb	r2, [r3, #0]
   22e66:	9b09      	ldr	r3, [sp, #36]	; 0x24
   22e68:	9907      	ldr	r1, [sp, #28]
   22e6a:	4299      	cmp	r1, r3
   22e6c:	d8f8      	bhi.n	22e60 <__cvt+0xb8>
   22e6e:	e7ee      	b.n	22e4e <__cvt+0xa6>

00022e70 <__exponent>:
   22e70:	b5f0      	push	{r4, r5, r6, r7, lr}
   22e72:	232b      	movs	r3, #43	; 0x2b
   22e74:	b085      	sub	sp, #20
   22e76:	0007      	movs	r7, r0
   22e78:	000c      	movs	r4, r1
   22e7a:	7002      	strb	r2, [r0, #0]
   22e7c:	1c86      	adds	r6, r0, #2
   22e7e:	2900      	cmp	r1, #0
   22e80:	da01      	bge.n	22e86 <__exponent+0x16>
   22e82:	232d      	movs	r3, #45	; 0x2d
   22e84:	424c      	negs	r4, r1
   22e86:	707b      	strb	r3, [r7, #1]
   22e88:	2c09      	cmp	r4, #9
   22e8a:	dd23      	ble.n	22ed4 <__exponent+0x64>
   22e8c:	ab02      	add	r3, sp, #8
   22e8e:	1ddd      	adds	r5, r3, #7
   22e90:	1e6b      	subs	r3, r5, #1
   22e92:	0020      	movs	r0, r4
   22e94:	210a      	movs	r1, #10
   22e96:	9301      	str	r3, [sp, #4]
   22e98:	f002 fe80 	bl	25b9c <__aeabi_idivmod>
   22e9c:	1e6b      	subs	r3, r5, #1
   22e9e:	3130      	adds	r1, #48	; 0x30
   22ea0:	7019      	strb	r1, [r3, #0]
   22ea2:	0020      	movs	r0, r4
   22ea4:	210a      	movs	r1, #10
   22ea6:	f002 fd93 	bl	259d0 <__divsi3>
   22eaa:	0004      	movs	r4, r0
   22eac:	2809      	cmp	r0, #9
   22eae:	dc0a      	bgt.n	22ec6 <__exponent+0x56>
   22eb0:	3d02      	subs	r5, #2
   22eb2:	3430      	adds	r4, #48	; 0x30
   22eb4:	702c      	strb	r4, [r5, #0]
   22eb6:	ab02      	add	r3, sp, #8
   22eb8:	3307      	adds	r3, #7
   22eba:	0030      	movs	r0, r6
   22ebc:	42ab      	cmp	r3, r5
   22ebe:	d804      	bhi.n	22eca <__exponent+0x5a>
   22ec0:	1bc0      	subs	r0, r0, r7
   22ec2:	b005      	add	sp, #20
   22ec4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   22ec6:	9d01      	ldr	r5, [sp, #4]
   22ec8:	e7e2      	b.n	22e90 <__exponent+0x20>
   22eca:	782b      	ldrb	r3, [r5, #0]
   22ecc:	3501      	adds	r5, #1
   22ece:	7033      	strb	r3, [r6, #0]
   22ed0:	3601      	adds	r6, #1
   22ed2:	e7f0      	b.n	22eb6 <__exponent+0x46>
   22ed4:	2330      	movs	r3, #48	; 0x30
   22ed6:	18e4      	adds	r4, r4, r3
   22ed8:	7033      	strb	r3, [r6, #0]
   22eda:	1cb0      	adds	r0, r6, #2
   22edc:	7074      	strb	r4, [r6, #1]
   22ede:	e7ef      	b.n	22ec0 <__exponent+0x50>

00022ee0 <_printf_float>:
   22ee0:	b5f0      	push	{r4, r5, r6, r7, lr}
   22ee2:	b095      	sub	sp, #84	; 0x54
   22ee4:	000c      	movs	r4, r1
   22ee6:	920a      	str	r2, [sp, #40]	; 0x28
   22ee8:	930b      	str	r3, [sp, #44]	; 0x2c
   22eea:	9d1a      	ldr	r5, [sp, #104]	; 0x68
   22eec:	9009      	str	r0, [sp, #36]	; 0x24
   22eee:	f001 fee7 	bl	24cc0 <_localeconv_r>
   22ef2:	6803      	ldr	r3, [r0, #0]
   22ef4:	0018      	movs	r0, r3
   22ef6:	930d      	str	r3, [sp, #52]	; 0x34
   22ef8:	f000 fce3 	bl	238c2 <strlen>
   22efc:	2300      	movs	r3, #0
   22efe:	9312      	str	r3, [sp, #72]	; 0x48
   22f00:	6823      	ldr	r3, [r4, #0]
   22f02:	900e      	str	r0, [sp, #56]	; 0x38
   22f04:	930c      	str	r3, [sp, #48]	; 0x30
   22f06:	990c      	ldr	r1, [sp, #48]	; 0x30
   22f08:	7e27      	ldrb	r7, [r4, #24]
   22f0a:	682b      	ldr	r3, [r5, #0]
   22f0c:	2207      	movs	r2, #7
   22f0e:	05c9      	lsls	r1, r1, #23
   22f10:	d547      	bpl.n	22fa2 <_printf_float+0xc2>
   22f12:	189b      	adds	r3, r3, r2
   22f14:	4393      	bics	r3, r2
   22f16:	001a      	movs	r2, r3
   22f18:	3208      	adds	r2, #8
   22f1a:	602a      	str	r2, [r5, #0]
   22f1c:	681a      	ldr	r2, [r3, #0]
   22f1e:	685b      	ldr	r3, [r3, #4]
   22f20:	64a2      	str	r2, [r4, #72]	; 0x48
   22f22:	64e3      	str	r3, [r4, #76]	; 0x4c
   22f24:	2201      	movs	r2, #1
   22f26:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
   22f28:	6ca6      	ldr	r6, [r4, #72]	; 0x48
   22f2a:	006b      	lsls	r3, r5, #1
   22f2c:	085b      	lsrs	r3, r3, #1
   22f2e:	930f      	str	r3, [sp, #60]	; 0x3c
   22f30:	4252      	negs	r2, r2
   22f32:	4ba7      	ldr	r3, [pc, #668]	; (231d0 <_printf_float+0x2f0>)
   22f34:	0030      	movs	r0, r6
   22f36:	990f      	ldr	r1, [sp, #60]	; 0x3c
   22f38:	f005 faca 	bl	284d0 <__aeabi_dcmpun>
   22f3c:	2800      	cmp	r0, #0
   22f3e:	d000      	beq.n	22f42 <_printf_float+0x62>
   22f40:	e206      	b.n	23350 <_printf_float+0x470>
   22f42:	2201      	movs	r2, #1
   22f44:	4ba2      	ldr	r3, [pc, #648]	; (231d0 <_printf_float+0x2f0>)
   22f46:	4252      	negs	r2, r2
   22f48:	0030      	movs	r0, r6
   22f4a:	990f      	ldr	r1, [sp, #60]	; 0x3c
   22f4c:	f002 fe58 	bl	25c00 <__aeabi_dcmple>
   22f50:	2800      	cmp	r0, #0
   22f52:	d000      	beq.n	22f56 <_printf_float+0x76>
   22f54:	e1fc      	b.n	23350 <_printf_float+0x470>
   22f56:	2200      	movs	r2, #0
   22f58:	2300      	movs	r3, #0
   22f5a:	0030      	movs	r0, r6
   22f5c:	0029      	movs	r1, r5
   22f5e:	f002 fe45 	bl	25bec <__aeabi_dcmplt>
   22f62:	2800      	cmp	r0, #0
   22f64:	d003      	beq.n	22f6e <_printf_float+0x8e>
   22f66:	0023      	movs	r3, r4
   22f68:	222d      	movs	r2, #45	; 0x2d
   22f6a:	3343      	adds	r3, #67	; 0x43
   22f6c:	701a      	strb	r2, [r3, #0]
   22f6e:	4d99      	ldr	r5, [pc, #612]	; (231d4 <_printf_float+0x2f4>)
   22f70:	2f47      	cmp	r7, #71	; 0x47
   22f72:	d800      	bhi.n	22f76 <_printf_float+0x96>
   22f74:	4d98      	ldr	r5, [pc, #608]	; (231d8 <_printf_float+0x2f8>)
   22f76:	2303      	movs	r3, #3
   22f78:	2600      	movs	r6, #0
   22f7a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   22f7c:	6123      	str	r3, [r4, #16]
   22f7e:	3301      	adds	r3, #1
   22f80:	439a      	bics	r2, r3
   22f82:	6022      	str	r2, [r4, #0]
   22f84:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   22f86:	aa13      	add	r2, sp, #76	; 0x4c
   22f88:	9300      	str	r3, [sp, #0]
   22f8a:	0021      	movs	r1, r4
   22f8c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   22f8e:	9809      	ldr	r0, [sp, #36]	; 0x24
   22f90:	f000 f9f2 	bl	23378 <_printf_common>
   22f94:	1c43      	adds	r3, r0, #1
   22f96:	d000      	beq.n	22f9a <_printf_float+0xba>
   22f98:	e09c      	b.n	230d4 <_printf_float+0x1f4>
   22f9a:	2001      	movs	r0, #1
   22f9c:	4240      	negs	r0, r0
   22f9e:	b015      	add	sp, #84	; 0x54
   22fa0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   22fa2:	3307      	adds	r3, #7
   22fa4:	e7b6      	b.n	22f14 <_printf_float+0x34>
   22fa6:	2380      	movs	r3, #128	; 0x80
   22fa8:	6862      	ldr	r2, [r4, #4]
   22faa:	00db      	lsls	r3, r3, #3
   22fac:	1c51      	adds	r1, r2, #1
   22fae:	d145      	bne.n	2303c <_printf_float+0x15c>
   22fb0:	3207      	adds	r2, #7
   22fb2:	6062      	str	r2, [r4, #4]
   22fb4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   22fb6:	2100      	movs	r1, #0
   22fb8:	4313      	orrs	r3, r2
   22fba:	aa12      	add	r2, sp, #72	; 0x48
   22fbc:	9205      	str	r2, [sp, #20]
   22fbe:	aa11      	add	r2, sp, #68	; 0x44
   22fc0:	9203      	str	r2, [sp, #12]
   22fc2:	2223      	movs	r2, #35	; 0x23
   22fc4:	6023      	str	r3, [r4, #0]
   22fc6:	9106      	str	r1, [sp, #24]
   22fc8:	9301      	str	r3, [sp, #4]
   22fca:	a908      	add	r1, sp, #32
   22fcc:	6863      	ldr	r3, [r4, #4]
   22fce:	1852      	adds	r2, r2, r1
   22fd0:	9202      	str	r2, [sp, #8]
   22fd2:	9300      	str	r3, [sp, #0]
   22fd4:	0032      	movs	r2, r6
   22fd6:	002b      	movs	r3, r5
   22fd8:	9704      	str	r7, [sp, #16]
   22fda:	9809      	ldr	r0, [sp, #36]	; 0x24
   22fdc:	f7ff fee4 	bl	22da8 <__cvt>
   22fe0:	2320      	movs	r3, #32
   22fe2:	003a      	movs	r2, r7
   22fe4:	0005      	movs	r5, r0
   22fe6:	439a      	bics	r2, r3
   22fe8:	2a47      	cmp	r2, #71	; 0x47
   22fea:	d107      	bne.n	22ffc <_printf_float+0x11c>
   22fec:	9b11      	ldr	r3, [sp, #68]	; 0x44
   22fee:	1cda      	adds	r2, r3, #3
   22ff0:	db02      	blt.n	22ff8 <_printf_float+0x118>
   22ff2:	6862      	ldr	r2, [r4, #4]
   22ff4:	4293      	cmp	r3, r2
   22ff6:	dd5b      	ble.n	230b0 <_printf_float+0x1d0>
   22ff8:	3f02      	subs	r7, #2
   22ffa:	b2ff      	uxtb	r7, r7
   22ffc:	9911      	ldr	r1, [sp, #68]	; 0x44
   22ffe:	2f65      	cmp	r7, #101	; 0x65
   23000:	d83b      	bhi.n	2307a <_printf_float+0x19a>
   23002:	0020      	movs	r0, r4
   23004:	3901      	subs	r1, #1
   23006:	003a      	movs	r2, r7
   23008:	3050      	adds	r0, #80	; 0x50
   2300a:	9111      	str	r1, [sp, #68]	; 0x44
   2300c:	f7ff ff30 	bl	22e70 <__exponent>
   23010:	9a12      	ldr	r2, [sp, #72]	; 0x48
   23012:	0006      	movs	r6, r0
   23014:	1883      	adds	r3, r0, r2
   23016:	6123      	str	r3, [r4, #16]
   23018:	2a01      	cmp	r2, #1
   2301a:	dc02      	bgt.n	23022 <_printf_float+0x142>
   2301c:	6822      	ldr	r2, [r4, #0]
   2301e:	07d2      	lsls	r2, r2, #31
   23020:	d501      	bpl.n	23026 <_printf_float+0x146>
   23022:	3301      	adds	r3, #1
   23024:	6123      	str	r3, [r4, #16]
   23026:	2323      	movs	r3, #35	; 0x23
   23028:	aa08      	add	r2, sp, #32
   2302a:	189b      	adds	r3, r3, r2
   2302c:	781b      	ldrb	r3, [r3, #0]
   2302e:	2b00      	cmp	r3, #0
   23030:	d0a8      	beq.n	22f84 <_printf_float+0xa4>
   23032:	0023      	movs	r3, r4
   23034:	222d      	movs	r2, #45	; 0x2d
   23036:	3343      	adds	r3, #67	; 0x43
   23038:	701a      	strb	r2, [r3, #0]
   2303a:	e7a3      	b.n	22f84 <_printf_float+0xa4>
   2303c:	2f67      	cmp	r7, #103	; 0x67
   2303e:	d001      	beq.n	23044 <_printf_float+0x164>
   23040:	2f47      	cmp	r7, #71	; 0x47
   23042:	d1b7      	bne.n	22fb4 <_printf_float+0xd4>
   23044:	2a00      	cmp	r2, #0
   23046:	d016      	beq.n	23076 <_printf_float+0x196>
   23048:	990c      	ldr	r1, [sp, #48]	; 0x30
   2304a:	a808      	add	r0, sp, #32
   2304c:	430b      	orrs	r3, r1
   2304e:	2100      	movs	r1, #0
   23050:	9106      	str	r1, [sp, #24]
   23052:	a912      	add	r1, sp, #72	; 0x48
   23054:	9105      	str	r1, [sp, #20]
   23056:	a911      	add	r1, sp, #68	; 0x44
   23058:	9103      	str	r1, [sp, #12]
   2305a:	2123      	movs	r1, #35	; 0x23
   2305c:	1809      	adds	r1, r1, r0
   2305e:	6023      	str	r3, [r4, #0]
   23060:	9301      	str	r3, [sp, #4]
   23062:	9200      	str	r2, [sp, #0]
   23064:	002b      	movs	r3, r5
   23066:	9704      	str	r7, [sp, #16]
   23068:	9102      	str	r1, [sp, #8]
   2306a:	0032      	movs	r2, r6
   2306c:	9809      	ldr	r0, [sp, #36]	; 0x24
   2306e:	f7ff fe9b 	bl	22da8 <__cvt>
   23072:	0005      	movs	r5, r0
   23074:	e7ba      	b.n	22fec <_printf_float+0x10c>
   23076:	2201      	movs	r2, #1
   23078:	e79b      	b.n	22fb2 <_printf_float+0xd2>
   2307a:	2f66      	cmp	r7, #102	; 0x66
   2307c:	d119      	bne.n	230b2 <_printf_float+0x1d2>
   2307e:	6863      	ldr	r3, [r4, #4]
   23080:	2900      	cmp	r1, #0
   23082:	dd0c      	ble.n	2309e <_printf_float+0x1be>
   23084:	6121      	str	r1, [r4, #16]
   23086:	2b00      	cmp	r3, #0
   23088:	d102      	bne.n	23090 <_printf_float+0x1b0>
   2308a:	6822      	ldr	r2, [r4, #0]
   2308c:	07d2      	lsls	r2, r2, #31
   2308e:	d502      	bpl.n	23096 <_printf_float+0x1b6>
   23090:	3301      	adds	r3, #1
   23092:	185b      	adds	r3, r3, r1
   23094:	6123      	str	r3, [r4, #16]
   23096:	9b11      	ldr	r3, [sp, #68]	; 0x44
   23098:	2600      	movs	r6, #0
   2309a:	65a3      	str	r3, [r4, #88]	; 0x58
   2309c:	e7c3      	b.n	23026 <_printf_float+0x146>
   2309e:	2b00      	cmp	r3, #0
   230a0:	d103      	bne.n	230aa <_printf_float+0x1ca>
   230a2:	2201      	movs	r2, #1
   230a4:	6821      	ldr	r1, [r4, #0]
   230a6:	4211      	tst	r1, r2
   230a8:	d000      	beq.n	230ac <_printf_float+0x1cc>
   230aa:	1c9a      	adds	r2, r3, #2
   230ac:	6122      	str	r2, [r4, #16]
   230ae:	e7f2      	b.n	23096 <_printf_float+0x1b6>
   230b0:	2767      	movs	r7, #103	; 0x67
   230b2:	9b11      	ldr	r3, [sp, #68]	; 0x44
   230b4:	9812      	ldr	r0, [sp, #72]	; 0x48
   230b6:	4283      	cmp	r3, r0
   230b8:	db05      	blt.n	230c6 <_printf_float+0x1e6>
   230ba:	6822      	ldr	r2, [r4, #0]
   230bc:	6123      	str	r3, [r4, #16]
   230be:	07d2      	lsls	r2, r2, #31
   230c0:	d5e9      	bpl.n	23096 <_printf_float+0x1b6>
   230c2:	3301      	adds	r3, #1
   230c4:	e7e6      	b.n	23094 <_printf_float+0x1b4>
   230c6:	2201      	movs	r2, #1
   230c8:	2b00      	cmp	r3, #0
   230ca:	dc01      	bgt.n	230d0 <_printf_float+0x1f0>
   230cc:	1892      	adds	r2, r2, r2
   230ce:	1ad2      	subs	r2, r2, r3
   230d0:	1812      	adds	r2, r2, r0
   230d2:	e7eb      	b.n	230ac <_printf_float+0x1cc>
   230d4:	6822      	ldr	r2, [r4, #0]
   230d6:	0553      	lsls	r3, r2, #21
   230d8:	d408      	bmi.n	230ec <_printf_float+0x20c>
   230da:	6923      	ldr	r3, [r4, #16]
   230dc:	002a      	movs	r2, r5
   230de:	990a      	ldr	r1, [sp, #40]	; 0x28
   230e0:	9809      	ldr	r0, [sp, #36]	; 0x24
   230e2:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   230e4:	47a8      	blx	r5
   230e6:	1c43      	adds	r3, r0, #1
   230e8:	d129      	bne.n	2313e <_printf_float+0x25e>
   230ea:	e756      	b.n	22f9a <_printf_float+0xba>
   230ec:	2f65      	cmp	r7, #101	; 0x65
   230ee:	d800      	bhi.n	230f2 <_printf_float+0x212>
   230f0:	e0dc      	b.n	232ac <_printf_float+0x3cc>
   230f2:	6ca0      	ldr	r0, [r4, #72]	; 0x48
   230f4:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
   230f6:	2200      	movs	r2, #0
   230f8:	2300      	movs	r3, #0
   230fa:	f002 fd71 	bl	25be0 <__aeabi_dcmpeq>
   230fe:	2800      	cmp	r0, #0
   23100:	d035      	beq.n	2316e <_printf_float+0x28e>
   23102:	2301      	movs	r3, #1
   23104:	4a35      	ldr	r2, [pc, #212]	; (231dc <_printf_float+0x2fc>)
   23106:	990a      	ldr	r1, [sp, #40]	; 0x28
   23108:	9809      	ldr	r0, [sp, #36]	; 0x24
   2310a:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   2310c:	47a8      	blx	r5
   2310e:	1c43      	adds	r3, r0, #1
   23110:	d100      	bne.n	23114 <_printf_float+0x234>
   23112:	e742      	b.n	22f9a <_printf_float+0xba>
   23114:	9b11      	ldr	r3, [sp, #68]	; 0x44
   23116:	9a12      	ldr	r2, [sp, #72]	; 0x48
   23118:	4293      	cmp	r3, r2
   2311a:	db02      	blt.n	23122 <_printf_float+0x242>
   2311c:	6823      	ldr	r3, [r4, #0]
   2311e:	07db      	lsls	r3, r3, #31
   23120:	d50d      	bpl.n	2313e <_printf_float+0x25e>
   23122:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   23124:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   23126:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   23128:	990a      	ldr	r1, [sp, #40]	; 0x28
   2312a:	9809      	ldr	r0, [sp, #36]	; 0x24
   2312c:	47a8      	blx	r5
   2312e:	2500      	movs	r5, #0
   23130:	1c43      	adds	r3, r0, #1
   23132:	d100      	bne.n	23136 <_printf_float+0x256>
   23134:	e731      	b.n	22f9a <_printf_float+0xba>
   23136:	9b12      	ldr	r3, [sp, #72]	; 0x48
   23138:	3b01      	subs	r3, #1
   2313a:	429d      	cmp	r5, r3
   2313c:	db0b      	blt.n	23156 <_printf_float+0x276>
   2313e:	6823      	ldr	r3, [r4, #0]
   23140:	2500      	movs	r5, #0
   23142:	079b      	lsls	r3, r3, #30
   23144:	d500      	bpl.n	23148 <_printf_float+0x268>
   23146:	e0fd      	b.n	23344 <_printf_float+0x464>
   23148:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   2314a:	68e0      	ldr	r0, [r4, #12]
   2314c:	4298      	cmp	r0, r3
   2314e:	db00      	blt.n	23152 <_printf_float+0x272>
   23150:	e725      	b.n	22f9e <_printf_float+0xbe>
   23152:	0018      	movs	r0, r3
   23154:	e723      	b.n	22f9e <_printf_float+0xbe>
   23156:	0022      	movs	r2, r4
   23158:	2301      	movs	r3, #1
   2315a:	321a      	adds	r2, #26
   2315c:	990a      	ldr	r1, [sp, #40]	; 0x28
   2315e:	9809      	ldr	r0, [sp, #36]	; 0x24
   23160:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
   23162:	47b0      	blx	r6
   23164:	1c43      	adds	r3, r0, #1
   23166:	d100      	bne.n	2316a <_printf_float+0x28a>
   23168:	e717      	b.n	22f9a <_printf_float+0xba>
   2316a:	3501      	adds	r5, #1
   2316c:	e7e3      	b.n	23136 <_printf_float+0x256>
   2316e:	9b11      	ldr	r3, [sp, #68]	; 0x44
   23170:	2b00      	cmp	r3, #0
   23172:	dc35      	bgt.n	231e0 <_printf_float+0x300>
   23174:	2301      	movs	r3, #1
   23176:	4a19      	ldr	r2, [pc, #100]	; (231dc <_printf_float+0x2fc>)
   23178:	990a      	ldr	r1, [sp, #40]	; 0x28
   2317a:	9809      	ldr	r0, [sp, #36]	; 0x24
   2317c:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
   2317e:	47b0      	blx	r6
   23180:	1c43      	adds	r3, r0, #1
   23182:	d100      	bne.n	23186 <_printf_float+0x2a6>
   23184:	e709      	b.n	22f9a <_printf_float+0xba>
   23186:	9b11      	ldr	r3, [sp, #68]	; 0x44
   23188:	2b00      	cmp	r3, #0
   2318a:	d105      	bne.n	23198 <_printf_float+0x2b8>
   2318c:	9b12      	ldr	r3, [sp, #72]	; 0x48
   2318e:	2b00      	cmp	r3, #0
   23190:	d102      	bne.n	23198 <_printf_float+0x2b8>
   23192:	6823      	ldr	r3, [r4, #0]
   23194:	07db      	lsls	r3, r3, #31
   23196:	d5d2      	bpl.n	2313e <_printf_float+0x25e>
   23198:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
   2319a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   2319c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   2319e:	990a      	ldr	r1, [sp, #40]	; 0x28
   231a0:	9809      	ldr	r0, [sp, #36]	; 0x24
   231a2:	47b0      	blx	r6
   231a4:	2600      	movs	r6, #0
   231a6:	1c43      	adds	r3, r0, #1
   231a8:	d100      	bne.n	231ac <_printf_float+0x2cc>
   231aa:	e6f6      	b.n	22f9a <_printf_float+0xba>
   231ac:	9b11      	ldr	r3, [sp, #68]	; 0x44
   231ae:	425b      	negs	r3, r3
   231b0:	429e      	cmp	r6, r3
   231b2:	db01      	blt.n	231b8 <_printf_float+0x2d8>
   231b4:	9b12      	ldr	r3, [sp, #72]	; 0x48
   231b6:	e791      	b.n	230dc <_printf_float+0x1fc>
   231b8:	0022      	movs	r2, r4
   231ba:	2301      	movs	r3, #1
   231bc:	321a      	adds	r2, #26
   231be:	990a      	ldr	r1, [sp, #40]	; 0x28
   231c0:	9809      	ldr	r0, [sp, #36]	; 0x24
   231c2:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
   231c4:	47b8      	blx	r7
   231c6:	1c43      	adds	r3, r0, #1
   231c8:	d100      	bne.n	231cc <_printf_float+0x2ec>
   231ca:	e6e6      	b.n	22f9a <_printf_float+0xba>
   231cc:	3601      	adds	r6, #1
   231ce:	e7ed      	b.n	231ac <_printf_float+0x2cc>
   231d0:	7fefffff 	.word	0x7fefffff
   231d4:	0002b674 	.word	0x0002b674
   231d8:	0002b670 	.word	0x0002b670
   231dc:	000296f8 	.word	0x000296f8
   231e0:	6da3      	ldr	r3, [r4, #88]	; 0x58
   231e2:	9e12      	ldr	r6, [sp, #72]	; 0x48
   231e4:	429e      	cmp	r6, r3
   231e6:	dd00      	ble.n	231ea <_printf_float+0x30a>
   231e8:	001e      	movs	r6, r3
   231ea:	2e00      	cmp	r6, #0
   231ec:	dc35      	bgt.n	2325a <_printf_float+0x37a>
   231ee:	2300      	movs	r3, #0
   231f0:	930c      	str	r3, [sp, #48]	; 0x30
   231f2:	43f3      	mvns	r3, r6
   231f4:	17db      	asrs	r3, r3, #31
   231f6:	930f      	str	r3, [sp, #60]	; 0x3c
   231f8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   231fa:	6da7      	ldr	r7, [r4, #88]	; 0x58
   231fc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   231fe:	4033      	ands	r3, r6
   23200:	1afb      	subs	r3, r7, r3
   23202:	429a      	cmp	r2, r3
   23204:	db32      	blt.n	2326c <_printf_float+0x38c>
   23206:	9b11      	ldr	r3, [sp, #68]	; 0x44
   23208:	9a12      	ldr	r2, [sp, #72]	; 0x48
   2320a:	4293      	cmp	r3, r2
   2320c:	db3c      	blt.n	23288 <_printf_float+0x3a8>
   2320e:	6823      	ldr	r3, [r4, #0]
   23210:	07db      	lsls	r3, r3, #31
   23212:	d439      	bmi.n	23288 <_printf_float+0x3a8>
   23214:	9e12      	ldr	r6, [sp, #72]	; 0x48
   23216:	9a11      	ldr	r2, [sp, #68]	; 0x44
   23218:	1bf3      	subs	r3, r6, r7
   2321a:	1ab6      	subs	r6, r6, r2
   2321c:	429e      	cmp	r6, r3
   2321e:	dd00      	ble.n	23222 <_printf_float+0x342>
   23220:	001e      	movs	r6, r3
   23222:	2e00      	cmp	r6, #0
   23224:	dc39      	bgt.n	2329a <_printf_float+0x3ba>
   23226:	43f7      	mvns	r7, r6
   23228:	2500      	movs	r5, #0
   2322a:	17fb      	asrs	r3, r7, #31
   2322c:	930c      	str	r3, [sp, #48]	; 0x30
   2322e:	9a11      	ldr	r2, [sp, #68]	; 0x44
   23230:	9b12      	ldr	r3, [sp, #72]	; 0x48
   23232:	990c      	ldr	r1, [sp, #48]	; 0x30
   23234:	1a9b      	subs	r3, r3, r2
   23236:	0032      	movs	r2, r6
   23238:	400a      	ands	r2, r1
   2323a:	1a9b      	subs	r3, r3, r2
   2323c:	429d      	cmp	r5, r3
   2323e:	db00      	blt.n	23242 <_printf_float+0x362>
   23240:	e77d      	b.n	2313e <_printf_float+0x25e>
   23242:	0022      	movs	r2, r4
   23244:	2301      	movs	r3, #1
   23246:	321a      	adds	r2, #26
   23248:	990a      	ldr	r1, [sp, #40]	; 0x28
   2324a:	9809      	ldr	r0, [sp, #36]	; 0x24
   2324c:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
   2324e:	47b8      	blx	r7
   23250:	1c43      	adds	r3, r0, #1
   23252:	d100      	bne.n	23256 <_printf_float+0x376>
   23254:	e6a1      	b.n	22f9a <_printf_float+0xba>
   23256:	3501      	adds	r5, #1
   23258:	e7e9      	b.n	2322e <_printf_float+0x34e>
   2325a:	0033      	movs	r3, r6
   2325c:	002a      	movs	r2, r5
   2325e:	990a      	ldr	r1, [sp, #40]	; 0x28
   23260:	9809      	ldr	r0, [sp, #36]	; 0x24
   23262:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
   23264:	47b8      	blx	r7
   23266:	1c43      	adds	r3, r0, #1
   23268:	d1c1      	bne.n	231ee <_printf_float+0x30e>
   2326a:	e696      	b.n	22f9a <_printf_float+0xba>
   2326c:	0022      	movs	r2, r4
   2326e:	2301      	movs	r3, #1
   23270:	321a      	adds	r2, #26
   23272:	990a      	ldr	r1, [sp, #40]	; 0x28
   23274:	9809      	ldr	r0, [sp, #36]	; 0x24
   23276:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
   23278:	47b8      	blx	r7
   2327a:	1c43      	adds	r3, r0, #1
   2327c:	d100      	bne.n	23280 <_printf_float+0x3a0>
   2327e:	e68c      	b.n	22f9a <_printf_float+0xba>
   23280:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   23282:	3301      	adds	r3, #1
   23284:	930c      	str	r3, [sp, #48]	; 0x30
   23286:	e7b7      	b.n	231f8 <_printf_float+0x318>
   23288:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   2328a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   2328c:	990a      	ldr	r1, [sp, #40]	; 0x28
   2328e:	9809      	ldr	r0, [sp, #36]	; 0x24
   23290:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
   23292:	47b0      	blx	r6
   23294:	1c43      	adds	r3, r0, #1
   23296:	d1bd      	bne.n	23214 <_printf_float+0x334>
   23298:	e67f      	b.n	22f9a <_printf_float+0xba>
   2329a:	19ea      	adds	r2, r5, r7
   2329c:	0033      	movs	r3, r6
   2329e:	990a      	ldr	r1, [sp, #40]	; 0x28
   232a0:	9809      	ldr	r0, [sp, #36]	; 0x24
   232a2:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   232a4:	47a8      	blx	r5
   232a6:	1c43      	adds	r3, r0, #1
   232a8:	d1bd      	bne.n	23226 <_printf_float+0x346>
   232aa:	e676      	b.n	22f9a <_printf_float+0xba>
   232ac:	9b12      	ldr	r3, [sp, #72]	; 0x48
   232ae:	2b01      	cmp	r3, #1
   232b0:	dc02      	bgt.n	232b8 <_printf_float+0x3d8>
   232b2:	2301      	movs	r3, #1
   232b4:	421a      	tst	r2, r3
   232b6:	d038      	beq.n	2332a <_printf_float+0x44a>
   232b8:	2301      	movs	r3, #1
   232ba:	002a      	movs	r2, r5
   232bc:	990a      	ldr	r1, [sp, #40]	; 0x28
   232be:	9809      	ldr	r0, [sp, #36]	; 0x24
   232c0:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
   232c2:	47b8      	blx	r7
   232c4:	1c43      	adds	r3, r0, #1
   232c6:	d100      	bne.n	232ca <_printf_float+0x3ea>
   232c8:	e667      	b.n	22f9a <_printf_float+0xba>
   232ca:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   232cc:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   232ce:	990a      	ldr	r1, [sp, #40]	; 0x28
   232d0:	9809      	ldr	r0, [sp, #36]	; 0x24
   232d2:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
   232d4:	47b8      	blx	r7
   232d6:	1c43      	adds	r3, r0, #1
   232d8:	d100      	bne.n	232dc <_printf_float+0x3fc>
   232da:	e65e      	b.n	22f9a <_printf_float+0xba>
   232dc:	6ca0      	ldr	r0, [r4, #72]	; 0x48
   232de:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
   232e0:	2200      	movs	r2, #0
   232e2:	2300      	movs	r3, #0
   232e4:	f002 fc7c 	bl	25be0 <__aeabi_dcmpeq>
   232e8:	2800      	cmp	r0, #0
   232ea:	d008      	beq.n	232fe <_printf_float+0x41e>
   232ec:	2500      	movs	r5, #0
   232ee:	9b12      	ldr	r3, [sp, #72]	; 0x48
   232f0:	3b01      	subs	r3, #1
   232f2:	429d      	cmp	r5, r3
   232f4:	db0d      	blt.n	23312 <_printf_float+0x432>
   232f6:	0022      	movs	r2, r4
   232f8:	0033      	movs	r3, r6
   232fa:	3250      	adds	r2, #80	; 0x50
   232fc:	e6ef      	b.n	230de <_printf_float+0x1fe>
   232fe:	9b12      	ldr	r3, [sp, #72]	; 0x48
   23300:	1c6a      	adds	r2, r5, #1
   23302:	3b01      	subs	r3, #1
   23304:	990a      	ldr	r1, [sp, #40]	; 0x28
   23306:	9809      	ldr	r0, [sp, #36]	; 0x24
   23308:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   2330a:	47a8      	blx	r5
   2330c:	1c43      	adds	r3, r0, #1
   2330e:	d1f2      	bne.n	232f6 <_printf_float+0x416>
   23310:	e643      	b.n	22f9a <_printf_float+0xba>
   23312:	0022      	movs	r2, r4
   23314:	2301      	movs	r3, #1
   23316:	321a      	adds	r2, #26
   23318:	990a      	ldr	r1, [sp, #40]	; 0x28
   2331a:	9809      	ldr	r0, [sp, #36]	; 0x24
   2331c:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
   2331e:	47b8      	blx	r7
   23320:	1c43      	adds	r3, r0, #1
   23322:	d100      	bne.n	23326 <_printf_float+0x446>
   23324:	e639      	b.n	22f9a <_printf_float+0xba>
   23326:	3501      	adds	r5, #1
   23328:	e7e1      	b.n	232ee <_printf_float+0x40e>
   2332a:	002a      	movs	r2, r5
   2332c:	e7ea      	b.n	23304 <_printf_float+0x424>
   2332e:	0022      	movs	r2, r4
   23330:	2301      	movs	r3, #1
   23332:	3219      	adds	r2, #25
   23334:	990a      	ldr	r1, [sp, #40]	; 0x28
   23336:	9809      	ldr	r0, [sp, #36]	; 0x24
   23338:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
   2333a:	47b0      	blx	r6
   2333c:	1c43      	adds	r3, r0, #1
   2333e:	d100      	bne.n	23342 <_printf_float+0x462>
   23340:	e62b      	b.n	22f9a <_printf_float+0xba>
   23342:	3501      	adds	r5, #1
   23344:	68e3      	ldr	r3, [r4, #12]
   23346:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   23348:	1a9b      	subs	r3, r3, r2
   2334a:	429d      	cmp	r5, r3
   2334c:	dbef      	blt.n	2332e <_printf_float+0x44e>
   2334e:	e6fb      	b.n	23148 <_printf_float+0x268>
   23350:	0032      	movs	r2, r6
   23352:	002b      	movs	r3, r5
   23354:	0030      	movs	r0, r6
   23356:	0029      	movs	r1, r5
   23358:	f005 f8ba 	bl	284d0 <__aeabi_dcmpun>
   2335c:	2800      	cmp	r0, #0
   2335e:	d100      	bne.n	23362 <_printf_float+0x482>
   23360:	e621      	b.n	22fa6 <_printf_float+0xc6>
   23362:	4d03      	ldr	r5, [pc, #12]	; (23370 <_printf_float+0x490>)
   23364:	2f47      	cmp	r7, #71	; 0x47
   23366:	d900      	bls.n	2336a <_printf_float+0x48a>
   23368:	e605      	b.n	22f76 <_printf_float+0x96>
   2336a:	4d02      	ldr	r5, [pc, #8]	; (23374 <_printf_float+0x494>)
   2336c:	e603      	b.n	22f76 <_printf_float+0x96>
   2336e:	46c0      	nop			; (mov r8, r8)
   23370:	0002b67c 	.word	0x0002b67c
   23374:	0002b678 	.word	0x0002b678

00023378 <_printf_common>:
   23378:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   2337a:	0015      	movs	r5, r2
   2337c:	9301      	str	r3, [sp, #4]
   2337e:	688a      	ldr	r2, [r1, #8]
   23380:	690b      	ldr	r3, [r1, #16]
   23382:	9000      	str	r0, [sp, #0]
   23384:	000c      	movs	r4, r1
   23386:	4293      	cmp	r3, r2
   23388:	da00      	bge.n	2338c <_printf_common+0x14>
   2338a:	0013      	movs	r3, r2
   2338c:	0022      	movs	r2, r4
   2338e:	602b      	str	r3, [r5, #0]
   23390:	3243      	adds	r2, #67	; 0x43
   23392:	7812      	ldrb	r2, [r2, #0]
   23394:	2a00      	cmp	r2, #0
   23396:	d001      	beq.n	2339c <_printf_common+0x24>
   23398:	3301      	adds	r3, #1
   2339a:	602b      	str	r3, [r5, #0]
   2339c:	6823      	ldr	r3, [r4, #0]
   2339e:	069b      	lsls	r3, r3, #26
   233a0:	d502      	bpl.n	233a8 <_printf_common+0x30>
   233a2:	682b      	ldr	r3, [r5, #0]
   233a4:	3302      	adds	r3, #2
   233a6:	602b      	str	r3, [r5, #0]
   233a8:	2706      	movs	r7, #6
   233aa:	6823      	ldr	r3, [r4, #0]
   233ac:	401f      	ands	r7, r3
   233ae:	d027      	beq.n	23400 <_printf_common+0x88>
   233b0:	0023      	movs	r3, r4
   233b2:	3343      	adds	r3, #67	; 0x43
   233b4:	781b      	ldrb	r3, [r3, #0]
   233b6:	1e5a      	subs	r2, r3, #1
   233b8:	4193      	sbcs	r3, r2
   233ba:	6822      	ldr	r2, [r4, #0]
   233bc:	0692      	lsls	r2, r2, #26
   233be:	d430      	bmi.n	23422 <_printf_common+0xaa>
   233c0:	0022      	movs	r2, r4
   233c2:	9901      	ldr	r1, [sp, #4]
   233c4:	3243      	adds	r2, #67	; 0x43
   233c6:	9800      	ldr	r0, [sp, #0]
   233c8:	9e08      	ldr	r6, [sp, #32]
   233ca:	47b0      	blx	r6
   233cc:	1c43      	adds	r3, r0, #1
   233ce:	d025      	beq.n	2341c <_printf_common+0xa4>
   233d0:	2306      	movs	r3, #6
   233d2:	6820      	ldr	r0, [r4, #0]
   233d4:	682a      	ldr	r2, [r5, #0]
   233d6:	68e1      	ldr	r1, [r4, #12]
   233d8:	4003      	ands	r3, r0
   233da:	2500      	movs	r5, #0
   233dc:	2b04      	cmp	r3, #4
   233de:	d103      	bne.n	233e8 <_printf_common+0x70>
   233e0:	1a8d      	subs	r5, r1, r2
   233e2:	43eb      	mvns	r3, r5
   233e4:	17db      	asrs	r3, r3, #31
   233e6:	401d      	ands	r5, r3
   233e8:	68a3      	ldr	r3, [r4, #8]
   233ea:	6922      	ldr	r2, [r4, #16]
   233ec:	4293      	cmp	r3, r2
   233ee:	dd01      	ble.n	233f4 <_printf_common+0x7c>
   233f0:	1a9b      	subs	r3, r3, r2
   233f2:	18ed      	adds	r5, r5, r3
   233f4:	2700      	movs	r7, #0
   233f6:	42bd      	cmp	r5, r7
   233f8:	d120      	bne.n	2343c <_printf_common+0xc4>
   233fa:	2000      	movs	r0, #0
   233fc:	e010      	b.n	23420 <_printf_common+0xa8>
   233fe:	3701      	adds	r7, #1
   23400:	68e3      	ldr	r3, [r4, #12]
   23402:	682a      	ldr	r2, [r5, #0]
   23404:	1a9b      	subs	r3, r3, r2
   23406:	429f      	cmp	r7, r3
   23408:	dad2      	bge.n	233b0 <_printf_common+0x38>
   2340a:	0022      	movs	r2, r4
   2340c:	2301      	movs	r3, #1
   2340e:	3219      	adds	r2, #25
   23410:	9901      	ldr	r1, [sp, #4]
   23412:	9800      	ldr	r0, [sp, #0]
   23414:	9e08      	ldr	r6, [sp, #32]
   23416:	47b0      	blx	r6
   23418:	1c43      	adds	r3, r0, #1
   2341a:	d1f0      	bne.n	233fe <_printf_common+0x86>
   2341c:	2001      	movs	r0, #1
   2341e:	4240      	negs	r0, r0
   23420:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   23422:	2030      	movs	r0, #48	; 0x30
   23424:	18e1      	adds	r1, r4, r3
   23426:	3143      	adds	r1, #67	; 0x43
   23428:	7008      	strb	r0, [r1, #0]
   2342a:	0021      	movs	r1, r4
   2342c:	1c5a      	adds	r2, r3, #1
   2342e:	3145      	adds	r1, #69	; 0x45
   23430:	7809      	ldrb	r1, [r1, #0]
   23432:	18a2      	adds	r2, r4, r2
   23434:	3243      	adds	r2, #67	; 0x43
   23436:	3302      	adds	r3, #2
   23438:	7011      	strb	r1, [r2, #0]
   2343a:	e7c1      	b.n	233c0 <_printf_common+0x48>
   2343c:	0022      	movs	r2, r4
   2343e:	2301      	movs	r3, #1
   23440:	321a      	adds	r2, #26
   23442:	9901      	ldr	r1, [sp, #4]
   23444:	9800      	ldr	r0, [sp, #0]
   23446:	9e08      	ldr	r6, [sp, #32]
   23448:	47b0      	blx	r6
   2344a:	1c43      	adds	r3, r0, #1
   2344c:	d0e6      	beq.n	2341c <_printf_common+0xa4>
   2344e:	3701      	adds	r7, #1
   23450:	e7d1      	b.n	233f6 <_printf_common+0x7e>
	...

00023454 <_printf_i>:
   23454:	b5f0      	push	{r4, r5, r6, r7, lr}
   23456:	b08b      	sub	sp, #44	; 0x2c
   23458:	9206      	str	r2, [sp, #24]
   2345a:	000a      	movs	r2, r1
   2345c:	3243      	adds	r2, #67	; 0x43
   2345e:	9307      	str	r3, [sp, #28]
   23460:	9005      	str	r0, [sp, #20]
   23462:	9204      	str	r2, [sp, #16]
   23464:	7e0a      	ldrb	r2, [r1, #24]
   23466:	000c      	movs	r4, r1
   23468:	9b10      	ldr	r3, [sp, #64]	; 0x40
   2346a:	2a6e      	cmp	r2, #110	; 0x6e
   2346c:	d100      	bne.n	23470 <_printf_i+0x1c>
   2346e:	e08f      	b.n	23590 <_printf_i+0x13c>
   23470:	d817      	bhi.n	234a2 <_printf_i+0x4e>
   23472:	2a63      	cmp	r2, #99	; 0x63
   23474:	d02c      	beq.n	234d0 <_printf_i+0x7c>
   23476:	d808      	bhi.n	2348a <_printf_i+0x36>
   23478:	2a00      	cmp	r2, #0
   2347a:	d100      	bne.n	2347e <_printf_i+0x2a>
   2347c:	e099      	b.n	235b2 <_printf_i+0x15e>
   2347e:	2a58      	cmp	r2, #88	; 0x58
   23480:	d054      	beq.n	2352c <_printf_i+0xd8>
   23482:	0026      	movs	r6, r4
   23484:	3642      	adds	r6, #66	; 0x42
   23486:	7032      	strb	r2, [r6, #0]
   23488:	e029      	b.n	234de <_printf_i+0x8a>
   2348a:	2a64      	cmp	r2, #100	; 0x64
   2348c:	d001      	beq.n	23492 <_printf_i+0x3e>
   2348e:	2a69      	cmp	r2, #105	; 0x69
   23490:	d1f7      	bne.n	23482 <_printf_i+0x2e>
   23492:	6821      	ldr	r1, [r4, #0]
   23494:	681a      	ldr	r2, [r3, #0]
   23496:	0608      	lsls	r0, r1, #24
   23498:	d523      	bpl.n	234e2 <_printf_i+0x8e>
   2349a:	1d11      	adds	r1, r2, #4
   2349c:	6019      	str	r1, [r3, #0]
   2349e:	6815      	ldr	r5, [r2, #0]
   234a0:	e025      	b.n	234ee <_printf_i+0x9a>
   234a2:	2a73      	cmp	r2, #115	; 0x73
   234a4:	d100      	bne.n	234a8 <_printf_i+0x54>
   234a6:	e088      	b.n	235ba <_printf_i+0x166>
   234a8:	d808      	bhi.n	234bc <_printf_i+0x68>
   234aa:	2a6f      	cmp	r2, #111	; 0x6f
   234ac:	d029      	beq.n	23502 <_printf_i+0xae>
   234ae:	2a70      	cmp	r2, #112	; 0x70
   234b0:	d1e7      	bne.n	23482 <_printf_i+0x2e>
   234b2:	2220      	movs	r2, #32
   234b4:	6809      	ldr	r1, [r1, #0]
   234b6:	430a      	orrs	r2, r1
   234b8:	6022      	str	r2, [r4, #0]
   234ba:	e003      	b.n	234c4 <_printf_i+0x70>
   234bc:	2a75      	cmp	r2, #117	; 0x75
   234be:	d020      	beq.n	23502 <_printf_i+0xae>
   234c0:	2a78      	cmp	r2, #120	; 0x78
   234c2:	d1de      	bne.n	23482 <_printf_i+0x2e>
   234c4:	0022      	movs	r2, r4
   234c6:	2178      	movs	r1, #120	; 0x78
   234c8:	3245      	adds	r2, #69	; 0x45
   234ca:	7011      	strb	r1, [r2, #0]
   234cc:	4a6c      	ldr	r2, [pc, #432]	; (23680 <_printf_i+0x22c>)
   234ce:	e030      	b.n	23532 <_printf_i+0xde>
   234d0:	000e      	movs	r6, r1
   234d2:	681a      	ldr	r2, [r3, #0]
   234d4:	3642      	adds	r6, #66	; 0x42
   234d6:	1d11      	adds	r1, r2, #4
   234d8:	6019      	str	r1, [r3, #0]
   234da:	6813      	ldr	r3, [r2, #0]
   234dc:	7033      	strb	r3, [r6, #0]
   234de:	2301      	movs	r3, #1
   234e0:	e079      	b.n	235d6 <_printf_i+0x182>
   234e2:	0649      	lsls	r1, r1, #25
   234e4:	d5d9      	bpl.n	2349a <_printf_i+0x46>
   234e6:	1d11      	adds	r1, r2, #4
   234e8:	6019      	str	r1, [r3, #0]
   234ea:	2300      	movs	r3, #0
   234ec:	5ed5      	ldrsh	r5, [r2, r3]
   234ee:	2d00      	cmp	r5, #0
   234f0:	da03      	bge.n	234fa <_printf_i+0xa6>
   234f2:	232d      	movs	r3, #45	; 0x2d
   234f4:	9a04      	ldr	r2, [sp, #16]
   234f6:	426d      	negs	r5, r5
   234f8:	7013      	strb	r3, [r2, #0]
   234fa:	4b62      	ldr	r3, [pc, #392]	; (23684 <_printf_i+0x230>)
   234fc:	270a      	movs	r7, #10
   234fe:	9303      	str	r3, [sp, #12]
   23500:	e02f      	b.n	23562 <_printf_i+0x10e>
   23502:	6820      	ldr	r0, [r4, #0]
   23504:	6819      	ldr	r1, [r3, #0]
   23506:	0605      	lsls	r5, r0, #24
   23508:	d503      	bpl.n	23512 <_printf_i+0xbe>
   2350a:	1d08      	adds	r0, r1, #4
   2350c:	6018      	str	r0, [r3, #0]
   2350e:	680d      	ldr	r5, [r1, #0]
   23510:	e005      	b.n	2351e <_printf_i+0xca>
   23512:	0640      	lsls	r0, r0, #25
   23514:	d5f9      	bpl.n	2350a <_printf_i+0xb6>
   23516:	680d      	ldr	r5, [r1, #0]
   23518:	1d08      	adds	r0, r1, #4
   2351a:	6018      	str	r0, [r3, #0]
   2351c:	b2ad      	uxth	r5, r5
   2351e:	4b59      	ldr	r3, [pc, #356]	; (23684 <_printf_i+0x230>)
   23520:	2708      	movs	r7, #8
   23522:	9303      	str	r3, [sp, #12]
   23524:	2a6f      	cmp	r2, #111	; 0x6f
   23526:	d018      	beq.n	2355a <_printf_i+0x106>
   23528:	270a      	movs	r7, #10
   2352a:	e016      	b.n	2355a <_printf_i+0x106>
   2352c:	3145      	adds	r1, #69	; 0x45
   2352e:	700a      	strb	r2, [r1, #0]
   23530:	4a54      	ldr	r2, [pc, #336]	; (23684 <_printf_i+0x230>)
   23532:	9203      	str	r2, [sp, #12]
   23534:	681a      	ldr	r2, [r3, #0]
   23536:	6821      	ldr	r1, [r4, #0]
   23538:	1d10      	adds	r0, r2, #4
   2353a:	6018      	str	r0, [r3, #0]
   2353c:	6815      	ldr	r5, [r2, #0]
   2353e:	0608      	lsls	r0, r1, #24
   23540:	d522      	bpl.n	23588 <_printf_i+0x134>
   23542:	07cb      	lsls	r3, r1, #31
   23544:	d502      	bpl.n	2354c <_printf_i+0xf8>
   23546:	2320      	movs	r3, #32
   23548:	4319      	orrs	r1, r3
   2354a:	6021      	str	r1, [r4, #0]
   2354c:	2710      	movs	r7, #16
   2354e:	2d00      	cmp	r5, #0
   23550:	d103      	bne.n	2355a <_printf_i+0x106>
   23552:	2320      	movs	r3, #32
   23554:	6822      	ldr	r2, [r4, #0]
   23556:	439a      	bics	r2, r3
   23558:	6022      	str	r2, [r4, #0]
   2355a:	0023      	movs	r3, r4
   2355c:	2200      	movs	r2, #0
   2355e:	3343      	adds	r3, #67	; 0x43
   23560:	701a      	strb	r2, [r3, #0]
   23562:	6863      	ldr	r3, [r4, #4]
   23564:	60a3      	str	r3, [r4, #8]
   23566:	2b00      	cmp	r3, #0
   23568:	db5c      	blt.n	23624 <_printf_i+0x1d0>
   2356a:	2204      	movs	r2, #4
   2356c:	6821      	ldr	r1, [r4, #0]
   2356e:	4391      	bics	r1, r2
   23570:	6021      	str	r1, [r4, #0]
   23572:	2d00      	cmp	r5, #0
   23574:	d158      	bne.n	23628 <_printf_i+0x1d4>
   23576:	9e04      	ldr	r6, [sp, #16]
   23578:	2b00      	cmp	r3, #0
   2357a:	d064      	beq.n	23646 <_printf_i+0x1f2>
   2357c:	0026      	movs	r6, r4
   2357e:	9b03      	ldr	r3, [sp, #12]
   23580:	3642      	adds	r6, #66	; 0x42
   23582:	781b      	ldrb	r3, [r3, #0]
   23584:	7033      	strb	r3, [r6, #0]
   23586:	e05e      	b.n	23646 <_printf_i+0x1f2>
   23588:	0648      	lsls	r0, r1, #25
   2358a:	d5da      	bpl.n	23542 <_printf_i+0xee>
   2358c:	b2ad      	uxth	r5, r5
   2358e:	e7d8      	b.n	23542 <_printf_i+0xee>
   23590:	6809      	ldr	r1, [r1, #0]
   23592:	681a      	ldr	r2, [r3, #0]
   23594:	0608      	lsls	r0, r1, #24
   23596:	d505      	bpl.n	235a4 <_printf_i+0x150>
   23598:	1d11      	adds	r1, r2, #4
   2359a:	6019      	str	r1, [r3, #0]
   2359c:	6813      	ldr	r3, [r2, #0]
   2359e:	6962      	ldr	r2, [r4, #20]
   235a0:	601a      	str	r2, [r3, #0]
   235a2:	e006      	b.n	235b2 <_printf_i+0x15e>
   235a4:	0649      	lsls	r1, r1, #25
   235a6:	d5f7      	bpl.n	23598 <_printf_i+0x144>
   235a8:	1d11      	adds	r1, r2, #4
   235aa:	6019      	str	r1, [r3, #0]
   235ac:	6813      	ldr	r3, [r2, #0]
   235ae:	8aa2      	ldrh	r2, [r4, #20]
   235b0:	801a      	strh	r2, [r3, #0]
   235b2:	2300      	movs	r3, #0
   235b4:	9e04      	ldr	r6, [sp, #16]
   235b6:	6123      	str	r3, [r4, #16]
   235b8:	e054      	b.n	23664 <_printf_i+0x210>
   235ba:	681a      	ldr	r2, [r3, #0]
   235bc:	1d11      	adds	r1, r2, #4
   235be:	6019      	str	r1, [r3, #0]
   235c0:	6816      	ldr	r6, [r2, #0]
   235c2:	2100      	movs	r1, #0
   235c4:	6862      	ldr	r2, [r4, #4]
   235c6:	0030      	movs	r0, r6
   235c8:	f001 fc04 	bl	24dd4 <memchr>
   235cc:	2800      	cmp	r0, #0
   235ce:	d001      	beq.n	235d4 <_printf_i+0x180>
   235d0:	1b80      	subs	r0, r0, r6
   235d2:	6060      	str	r0, [r4, #4]
   235d4:	6863      	ldr	r3, [r4, #4]
   235d6:	6123      	str	r3, [r4, #16]
   235d8:	2300      	movs	r3, #0
   235da:	9a04      	ldr	r2, [sp, #16]
   235dc:	7013      	strb	r3, [r2, #0]
   235de:	e041      	b.n	23664 <_printf_i+0x210>
   235e0:	6923      	ldr	r3, [r4, #16]
   235e2:	0032      	movs	r2, r6
   235e4:	9906      	ldr	r1, [sp, #24]
   235e6:	9805      	ldr	r0, [sp, #20]
   235e8:	9d07      	ldr	r5, [sp, #28]
   235ea:	47a8      	blx	r5
   235ec:	1c43      	adds	r3, r0, #1
   235ee:	d043      	beq.n	23678 <_printf_i+0x224>
   235f0:	6823      	ldr	r3, [r4, #0]
   235f2:	2500      	movs	r5, #0
   235f4:	079b      	lsls	r3, r3, #30
   235f6:	d40f      	bmi.n	23618 <_printf_i+0x1c4>
   235f8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   235fa:	68e0      	ldr	r0, [r4, #12]
   235fc:	4298      	cmp	r0, r3
   235fe:	da3d      	bge.n	2367c <_printf_i+0x228>
   23600:	0018      	movs	r0, r3
   23602:	e03b      	b.n	2367c <_printf_i+0x228>
   23604:	0022      	movs	r2, r4
   23606:	2301      	movs	r3, #1
   23608:	3219      	adds	r2, #25
   2360a:	9906      	ldr	r1, [sp, #24]
   2360c:	9805      	ldr	r0, [sp, #20]
   2360e:	9e07      	ldr	r6, [sp, #28]
   23610:	47b0      	blx	r6
   23612:	1c43      	adds	r3, r0, #1
   23614:	d030      	beq.n	23678 <_printf_i+0x224>
   23616:	3501      	adds	r5, #1
   23618:	68e3      	ldr	r3, [r4, #12]
   2361a:	9a09      	ldr	r2, [sp, #36]	; 0x24
   2361c:	1a9b      	subs	r3, r3, r2
   2361e:	429d      	cmp	r5, r3
   23620:	dbf0      	blt.n	23604 <_printf_i+0x1b0>
   23622:	e7e9      	b.n	235f8 <_printf_i+0x1a4>
   23624:	2d00      	cmp	r5, #0
   23626:	d0a9      	beq.n	2357c <_printf_i+0x128>
   23628:	9e04      	ldr	r6, [sp, #16]
   2362a:	0028      	movs	r0, r5
   2362c:	0039      	movs	r1, r7
   2362e:	f002 f9cb 	bl	259c8 <__aeabi_uidivmod>
   23632:	9b03      	ldr	r3, [sp, #12]
   23634:	3e01      	subs	r6, #1
   23636:	5c5b      	ldrb	r3, [r3, r1]
   23638:	0028      	movs	r0, r5
   2363a:	7033      	strb	r3, [r6, #0]
   2363c:	0039      	movs	r1, r7
   2363e:	f002 f93d 	bl	258bc <__udivsi3>
   23642:	1e05      	subs	r5, r0, #0
   23644:	d1f1      	bne.n	2362a <_printf_i+0x1d6>
   23646:	2f08      	cmp	r7, #8
   23648:	d109      	bne.n	2365e <_printf_i+0x20a>
   2364a:	6823      	ldr	r3, [r4, #0]
   2364c:	07db      	lsls	r3, r3, #31
   2364e:	d506      	bpl.n	2365e <_printf_i+0x20a>
   23650:	6863      	ldr	r3, [r4, #4]
   23652:	6922      	ldr	r2, [r4, #16]
   23654:	4293      	cmp	r3, r2
   23656:	dc02      	bgt.n	2365e <_printf_i+0x20a>
   23658:	2330      	movs	r3, #48	; 0x30
   2365a:	3e01      	subs	r6, #1
   2365c:	7033      	strb	r3, [r6, #0]
   2365e:	9b04      	ldr	r3, [sp, #16]
   23660:	1b9b      	subs	r3, r3, r6
   23662:	6123      	str	r3, [r4, #16]
   23664:	9b07      	ldr	r3, [sp, #28]
   23666:	aa09      	add	r2, sp, #36	; 0x24
   23668:	9300      	str	r3, [sp, #0]
   2366a:	0021      	movs	r1, r4
   2366c:	9b06      	ldr	r3, [sp, #24]
   2366e:	9805      	ldr	r0, [sp, #20]
   23670:	f7ff fe82 	bl	23378 <_printf_common>
   23674:	1c43      	adds	r3, r0, #1
   23676:	d1b3      	bne.n	235e0 <_printf_i+0x18c>
   23678:	2001      	movs	r0, #1
   2367a:	4240      	negs	r0, r0
   2367c:	b00b      	add	sp, #44	; 0x2c
   2367e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   23680:	0002b691 	.word	0x0002b691
   23684:	0002b680 	.word	0x0002b680

00023688 <_puts_r>:
   23688:	b570      	push	{r4, r5, r6, lr}
   2368a:	0005      	movs	r5, r0
   2368c:	000e      	movs	r6, r1
   2368e:	2800      	cmp	r0, #0
   23690:	d004      	beq.n	2369c <_puts_r+0x14>
   23692:	6983      	ldr	r3, [r0, #24]
   23694:	2b00      	cmp	r3, #0
   23696:	d101      	bne.n	2369c <_puts_r+0x14>
   23698:	f001 fa6c 	bl	24b74 <__sinit>
   2369c:	69ab      	ldr	r3, [r5, #24]
   2369e:	68ac      	ldr	r4, [r5, #8]
   236a0:	2b00      	cmp	r3, #0
   236a2:	d102      	bne.n	236aa <_puts_r+0x22>
   236a4:	0028      	movs	r0, r5
   236a6:	f001 fa65 	bl	24b74 <__sinit>
   236aa:	4b24      	ldr	r3, [pc, #144]	; (2373c <_puts_r+0xb4>)
   236ac:	429c      	cmp	r4, r3
   236ae:	d10f      	bne.n	236d0 <_puts_r+0x48>
   236b0:	686c      	ldr	r4, [r5, #4]
   236b2:	89a3      	ldrh	r3, [r4, #12]
   236b4:	071b      	lsls	r3, r3, #28
   236b6:	d502      	bpl.n	236be <_puts_r+0x36>
   236b8:	6923      	ldr	r3, [r4, #16]
   236ba:	2b00      	cmp	r3, #0
   236bc:	d120      	bne.n	23700 <_puts_r+0x78>
   236be:	0021      	movs	r1, r4
   236c0:	0028      	movs	r0, r5
   236c2:	f000 fa7d 	bl	23bc0 <__swsetup_r>
   236c6:	2800      	cmp	r0, #0
   236c8:	d01a      	beq.n	23700 <_puts_r+0x78>
   236ca:	2001      	movs	r0, #1
   236cc:	4240      	negs	r0, r0
   236ce:	bd70      	pop	{r4, r5, r6, pc}
   236d0:	4b1b      	ldr	r3, [pc, #108]	; (23740 <_puts_r+0xb8>)
   236d2:	429c      	cmp	r4, r3
   236d4:	d101      	bne.n	236da <_puts_r+0x52>
   236d6:	68ac      	ldr	r4, [r5, #8]
   236d8:	e7eb      	b.n	236b2 <_puts_r+0x2a>
   236da:	4b1a      	ldr	r3, [pc, #104]	; (23744 <_puts_r+0xbc>)
   236dc:	429c      	cmp	r4, r3
   236de:	d1e8      	bne.n	236b2 <_puts_r+0x2a>
   236e0:	68ec      	ldr	r4, [r5, #12]
   236e2:	e7e6      	b.n	236b2 <_puts_r+0x2a>
   236e4:	3b01      	subs	r3, #1
   236e6:	3601      	adds	r6, #1
   236e8:	60a3      	str	r3, [r4, #8]
   236ea:	2b00      	cmp	r3, #0
   236ec:	da04      	bge.n	236f8 <_puts_r+0x70>
   236ee:	69a2      	ldr	r2, [r4, #24]
   236f0:	4293      	cmp	r3, r2
   236f2:	db16      	blt.n	23722 <_puts_r+0x9a>
   236f4:	290a      	cmp	r1, #10
   236f6:	d014      	beq.n	23722 <_puts_r+0x9a>
   236f8:	6823      	ldr	r3, [r4, #0]
   236fa:	1c5a      	adds	r2, r3, #1
   236fc:	6022      	str	r2, [r4, #0]
   236fe:	7019      	strb	r1, [r3, #0]
   23700:	7831      	ldrb	r1, [r6, #0]
   23702:	68a3      	ldr	r3, [r4, #8]
   23704:	2900      	cmp	r1, #0
   23706:	d1ed      	bne.n	236e4 <_puts_r+0x5c>
   23708:	3b01      	subs	r3, #1
   2370a:	60a3      	str	r3, [r4, #8]
   2370c:	2b00      	cmp	r3, #0
   2370e:	da0f      	bge.n	23730 <_puts_r+0xa8>
   23710:	0022      	movs	r2, r4
   23712:	310a      	adds	r1, #10
   23714:	0028      	movs	r0, r5
   23716:	f000 f9fd 	bl	23b14 <__swbuf_r>
   2371a:	1c43      	adds	r3, r0, #1
   2371c:	d0d5      	beq.n	236ca <_puts_r+0x42>
   2371e:	200a      	movs	r0, #10
   23720:	e7d5      	b.n	236ce <_puts_r+0x46>
   23722:	0022      	movs	r2, r4
   23724:	0028      	movs	r0, r5
   23726:	f000 f9f5 	bl	23b14 <__swbuf_r>
   2372a:	1c43      	adds	r3, r0, #1
   2372c:	d1e8      	bne.n	23700 <_puts_r+0x78>
   2372e:	e7cc      	b.n	236ca <_puts_r+0x42>
   23730:	200a      	movs	r0, #10
   23732:	6823      	ldr	r3, [r4, #0]
   23734:	1c5a      	adds	r2, r3, #1
   23736:	6022      	str	r2, [r4, #0]
   23738:	7018      	strb	r0, [r3, #0]
   2373a:	e7c8      	b.n	236ce <_puts_r+0x46>
   2373c:	0002b6d0 	.word	0x0002b6d0
   23740:	0002b6f0 	.word	0x0002b6f0
   23744:	0002b6b0 	.word	0x0002b6b0

00023748 <puts>:
   23748:	b510      	push	{r4, lr}
   2374a:	4b03      	ldr	r3, [pc, #12]	; (23758 <puts+0x10>)
   2374c:	0001      	movs	r1, r0
   2374e:	6818      	ldr	r0, [r3, #0]
   23750:	f7ff ff9a 	bl	23688 <_puts_r>
   23754:	bd10      	pop	{r4, pc}
   23756:	46c0      	nop			; (mov r8, r8)
   23758:	2000020c 	.word	0x2000020c

0002375c <_sbrk_r>:
   2375c:	2300      	movs	r3, #0
   2375e:	b570      	push	{r4, r5, r6, lr}
   23760:	4c06      	ldr	r4, [pc, #24]	; (2377c <_sbrk_r+0x20>)
   23762:	0005      	movs	r5, r0
   23764:	0008      	movs	r0, r1
   23766:	6023      	str	r3, [r4, #0]
   23768:	f7fb fc7c 	bl	1f064 <_sbrk>
   2376c:	1c43      	adds	r3, r0, #1
   2376e:	d103      	bne.n	23778 <_sbrk_r+0x1c>
   23770:	6823      	ldr	r3, [r4, #0]
   23772:	2b00      	cmp	r3, #0
   23774:	d000      	beq.n	23778 <_sbrk_r+0x1c>
   23776:	602b      	str	r3, [r5, #0]
   23778:	bd70      	pop	{r4, r5, r6, pc}
   2377a:	46c0      	nop			; (mov r8, r8)
   2377c:	20005760 	.word	0x20005760

00023780 <sniprintf>:
   23780:	b40c      	push	{r2, r3}
   23782:	b530      	push	{r4, r5, lr}
   23784:	4b16      	ldr	r3, [pc, #88]	; (237e0 <sniprintf+0x60>)
   23786:	b09d      	sub	sp, #116	; 0x74
   23788:	1e0c      	subs	r4, r1, #0
   2378a:	681d      	ldr	r5, [r3, #0]
   2378c:	da08      	bge.n	237a0 <sniprintf+0x20>
   2378e:	238b      	movs	r3, #139	; 0x8b
   23790:	2001      	movs	r0, #1
   23792:	602b      	str	r3, [r5, #0]
   23794:	4240      	negs	r0, r0
   23796:	b01d      	add	sp, #116	; 0x74
   23798:	bc30      	pop	{r4, r5}
   2379a:	bc08      	pop	{r3}
   2379c:	b002      	add	sp, #8
   2379e:	4718      	bx	r3
   237a0:	2382      	movs	r3, #130	; 0x82
   237a2:	a902      	add	r1, sp, #8
   237a4:	009b      	lsls	r3, r3, #2
   237a6:	818b      	strh	r3, [r1, #12]
   237a8:	2300      	movs	r3, #0
   237aa:	9002      	str	r0, [sp, #8]
   237ac:	6108      	str	r0, [r1, #16]
   237ae:	429c      	cmp	r4, r3
   237b0:	d000      	beq.n	237b4 <sniprintf+0x34>
   237b2:	1e63      	subs	r3, r4, #1
   237b4:	608b      	str	r3, [r1, #8]
   237b6:	614b      	str	r3, [r1, #20]
   237b8:	2301      	movs	r3, #1
   237ba:	425b      	negs	r3, r3
   237bc:	81cb      	strh	r3, [r1, #14]
   237be:	9a20      	ldr	r2, [sp, #128]	; 0x80
   237c0:	ab21      	add	r3, sp, #132	; 0x84
   237c2:	0028      	movs	r0, r5
   237c4:	9301      	str	r3, [sp, #4]
   237c6:	f001 fe65 	bl	25494 <_svfiprintf_r>
   237ca:	1c43      	adds	r3, r0, #1
   237cc:	da01      	bge.n	237d2 <sniprintf+0x52>
   237ce:	238b      	movs	r3, #139	; 0x8b
   237d0:	602b      	str	r3, [r5, #0]
   237d2:	2c00      	cmp	r4, #0
   237d4:	d0df      	beq.n	23796 <sniprintf+0x16>
   237d6:	2300      	movs	r3, #0
   237d8:	9a02      	ldr	r2, [sp, #8]
   237da:	7013      	strb	r3, [r2, #0]
   237dc:	e7db      	b.n	23796 <sniprintf+0x16>
   237de:	46c0      	nop			; (mov r8, r8)
   237e0:	2000020c 	.word	0x2000020c

000237e4 <siprintf>:
   237e4:	b40e      	push	{r1, r2, r3}
   237e6:	b510      	push	{r4, lr}
   237e8:	b09d      	sub	sp, #116	; 0x74
   237ea:	a902      	add	r1, sp, #8
   237ec:	9002      	str	r0, [sp, #8]
   237ee:	6108      	str	r0, [r1, #16]
   237f0:	480b      	ldr	r0, [pc, #44]	; (23820 <siprintf+0x3c>)
   237f2:	2482      	movs	r4, #130	; 0x82
   237f4:	6088      	str	r0, [r1, #8]
   237f6:	6148      	str	r0, [r1, #20]
   237f8:	2001      	movs	r0, #1
   237fa:	4240      	negs	r0, r0
   237fc:	ab1f      	add	r3, sp, #124	; 0x7c
   237fe:	81c8      	strh	r0, [r1, #14]
   23800:	4808      	ldr	r0, [pc, #32]	; (23824 <siprintf+0x40>)
   23802:	cb04      	ldmia	r3!, {r2}
   23804:	00a4      	lsls	r4, r4, #2
   23806:	6800      	ldr	r0, [r0, #0]
   23808:	9301      	str	r3, [sp, #4]
   2380a:	818c      	strh	r4, [r1, #12]
   2380c:	f001 fe42 	bl	25494 <_svfiprintf_r>
   23810:	2300      	movs	r3, #0
   23812:	9a02      	ldr	r2, [sp, #8]
   23814:	7013      	strb	r3, [r2, #0]
   23816:	b01d      	add	sp, #116	; 0x74
   23818:	bc10      	pop	{r4}
   2381a:	bc08      	pop	{r3}
   2381c:	b003      	add	sp, #12
   2381e:	4718      	bx	r3
   23820:	7fffffff 	.word	0x7fffffff
   23824:	2000020c 	.word	0x2000020c

00023828 <strcasecmp>:
   23828:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2382a:	0007      	movs	r7, r0
   2382c:	000e      	movs	r6, r1
   2382e:	783c      	ldrb	r4, [r7, #0]
   23830:	f001 fa38 	bl	24ca4 <__locale_ctype_ptr>
   23834:	2203      	movs	r2, #3
   23836:	1900      	adds	r0, r0, r4
   23838:	7843      	ldrb	r3, [r0, #1]
   2383a:	4013      	ands	r3, r2
   2383c:	2b01      	cmp	r3, #1
   2383e:	d100      	bne.n	23842 <strcasecmp+0x1a>
   23840:	3420      	adds	r4, #32
   23842:	7835      	ldrb	r5, [r6, #0]
   23844:	f001 fa2e 	bl	24ca4 <__locale_ctype_ptr>
   23848:	2203      	movs	r2, #3
   2384a:	1940      	adds	r0, r0, r5
   2384c:	7843      	ldrb	r3, [r0, #1]
   2384e:	4013      	ands	r3, r2
   23850:	2b01      	cmp	r3, #1
   23852:	d100      	bne.n	23856 <strcasecmp+0x2e>
   23854:	3520      	adds	r5, #32
   23856:	1b60      	subs	r0, r4, r5
   23858:	d103      	bne.n	23862 <strcasecmp+0x3a>
   2385a:	3701      	adds	r7, #1
   2385c:	3601      	adds	r6, #1
   2385e:	2d00      	cmp	r5, #0
   23860:	d1e5      	bne.n	2382e <strcasecmp+0x6>
   23862:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00023864 <strcmp>:
   23864:	7802      	ldrb	r2, [r0, #0]
   23866:	780b      	ldrb	r3, [r1, #0]
   23868:	2a00      	cmp	r2, #0
   2386a:	d003      	beq.n	23874 <strcmp+0x10>
   2386c:	3001      	adds	r0, #1
   2386e:	3101      	adds	r1, #1
   23870:	429a      	cmp	r2, r3
   23872:	d0f7      	beq.n	23864 <strcmp>
   23874:	1ad0      	subs	r0, r2, r3
   23876:	4770      	bx	lr

00023878 <strcpy>:
   23878:	1c03      	adds	r3, r0, #0
   2387a:	780a      	ldrb	r2, [r1, #0]
   2387c:	3101      	adds	r1, #1
   2387e:	701a      	strb	r2, [r3, #0]
   23880:	3301      	adds	r3, #1
   23882:	2a00      	cmp	r2, #0
   23884:	d1f9      	bne.n	2387a <strcpy+0x2>
   23886:	4770      	bx	lr

00023888 <strdup>:
   23888:	b510      	push	{r4, lr}
   2388a:	4b03      	ldr	r3, [pc, #12]	; (23898 <strdup+0x10>)
   2388c:	0001      	movs	r1, r0
   2388e:	6818      	ldr	r0, [r3, #0]
   23890:	f000 f804 	bl	2389c <_strdup_r>
   23894:	bd10      	pop	{r4, pc}
   23896:	46c0      	nop			; (mov r8, r8)
   23898:	2000020c 	.word	0x2000020c

0002389c <_strdup_r>:
   2389c:	b570      	push	{r4, r5, r6, lr}
   2389e:	0005      	movs	r5, r0
   238a0:	0008      	movs	r0, r1
   238a2:	000e      	movs	r6, r1
   238a4:	f000 f80d 	bl	238c2 <strlen>
   238a8:	1c44      	adds	r4, r0, #1
   238aa:	0021      	movs	r1, r4
   238ac:	0028      	movs	r0, r5
   238ae:	f7ff fa1d 	bl	22cec <_malloc_r>
   238b2:	1e05      	subs	r5, r0, #0
   238b4:	d003      	beq.n	238be <_strdup_r+0x22>
   238b6:	0022      	movs	r2, r4
   238b8:	0031      	movs	r1, r6
   238ba:	f7ff f9a9 	bl	22c10 <memcpy>
   238be:	0028      	movs	r0, r5
   238c0:	bd70      	pop	{r4, r5, r6, pc}

000238c2 <strlen>:
   238c2:	2300      	movs	r3, #0
   238c4:	5cc2      	ldrb	r2, [r0, r3]
   238c6:	3301      	adds	r3, #1
   238c8:	2a00      	cmp	r2, #0
   238ca:	d1fb      	bne.n	238c4 <strlen+0x2>
   238cc:	1e58      	subs	r0, r3, #1
   238ce:	4770      	bx	lr

000238d0 <strncmp>:
   238d0:	2300      	movs	r3, #0
   238d2:	b530      	push	{r4, r5, lr}
   238d4:	429a      	cmp	r2, r3
   238d6:	d00a      	beq.n	238ee <strncmp+0x1e>
   238d8:	3a01      	subs	r2, #1
   238da:	5cc4      	ldrb	r4, [r0, r3]
   238dc:	5ccd      	ldrb	r5, [r1, r3]
   238de:	42ac      	cmp	r4, r5
   238e0:	d104      	bne.n	238ec <strncmp+0x1c>
   238e2:	429a      	cmp	r2, r3
   238e4:	d002      	beq.n	238ec <strncmp+0x1c>
   238e6:	3301      	adds	r3, #1
   238e8:	2c00      	cmp	r4, #0
   238ea:	d1f6      	bne.n	238da <strncmp+0xa>
   238ec:	1b63      	subs	r3, r4, r5
   238ee:	0018      	movs	r0, r3
   238f0:	bd30      	pop	{r4, r5, pc}

000238f2 <strncpy>:
   238f2:	b570      	push	{r4, r5, r6, lr}
   238f4:	0004      	movs	r4, r0
   238f6:	2a00      	cmp	r2, #0
   238f8:	d100      	bne.n	238fc <strncpy+0xa>
   238fa:	bd70      	pop	{r4, r5, r6, pc}
   238fc:	780d      	ldrb	r5, [r1, #0]
   238fe:	1e56      	subs	r6, r2, #1
   23900:	1c63      	adds	r3, r4, #1
   23902:	7025      	strb	r5, [r4, #0]
   23904:	3101      	adds	r1, #1
   23906:	2d00      	cmp	r5, #0
   23908:	d105      	bne.n	23916 <strncpy+0x24>
   2390a:	18a4      	adds	r4, r4, r2
   2390c:	429c      	cmp	r4, r3
   2390e:	d0f4      	beq.n	238fa <strncpy+0x8>
   23910:	701d      	strb	r5, [r3, #0]
   23912:	3301      	adds	r3, #1
   23914:	e7fa      	b.n	2390c <strncpy+0x1a>
   23916:	001c      	movs	r4, r3
   23918:	0032      	movs	r2, r6
   2391a:	e7ec      	b.n	238f6 <strncpy+0x4>

0002391c <strrchr>:
   2391c:	b570      	push	{r4, r5, r6, lr}
   2391e:	000d      	movs	r5, r1
   23920:	2400      	movs	r4, #0
   23922:	2900      	cmp	r1, #0
   23924:	d105      	bne.n	23932 <strrchr+0x16>
   23926:	f001 ff05 	bl	25734 <strchr>
   2392a:	0004      	movs	r4, r0
   2392c:	e006      	b.n	2393c <strrchr+0x20>
   2392e:	001c      	movs	r4, r3
   23930:	1c58      	adds	r0, r3, #1
   23932:	0029      	movs	r1, r5
   23934:	f001 fefe 	bl	25734 <strchr>
   23938:	1e03      	subs	r3, r0, #0
   2393a:	d1f8      	bne.n	2392e <strrchr+0x12>
   2393c:	0020      	movs	r0, r4
   2393e:	bd70      	pop	{r4, r5, r6, pc}

00023940 <strstr>:
   23940:	b510      	push	{r4, lr}
   23942:	0002      	movs	r2, r0
   23944:	7800      	ldrb	r0, [r0, #0]
   23946:	2800      	cmp	r0, #0
   23948:	d104      	bne.n	23954 <strstr+0x14>
   2394a:	7809      	ldrb	r1, [r1, #0]
   2394c:	2900      	cmp	r1, #0
   2394e:	d00d      	beq.n	2396c <strstr+0x2c>
   23950:	bd10      	pop	{r4, pc}
   23952:	3201      	adds	r2, #1
   23954:	7810      	ldrb	r0, [r2, #0]
   23956:	2800      	cmp	r0, #0
   23958:	d0fa      	beq.n	23950 <strstr+0x10>
   2395a:	2300      	movs	r3, #0
   2395c:	5cc8      	ldrb	r0, [r1, r3]
   2395e:	2800      	cmp	r0, #0
   23960:	d004      	beq.n	2396c <strstr+0x2c>
   23962:	5cd4      	ldrb	r4, [r2, r3]
   23964:	4284      	cmp	r4, r0
   23966:	d1f4      	bne.n	23952 <strstr+0x12>
   23968:	3301      	adds	r3, #1
   2396a:	e7f7      	b.n	2395c <strstr+0x1c>
   2396c:	0010      	movs	r0, r2
   2396e:	e7ef      	b.n	23950 <strstr+0x10>

00023970 <_strtol_l.isra.0>:
   23970:	b5f0      	push	{r4, r5, r6, r7, lr}
   23972:	001f      	movs	r7, r3
   23974:	000e      	movs	r6, r1
   23976:	b087      	sub	sp, #28
   23978:	9005      	str	r0, [sp, #20]
   2397a:	9103      	str	r1, [sp, #12]
   2397c:	9202      	str	r2, [sp, #8]
   2397e:	980c      	ldr	r0, [sp, #48]	; 0x30
   23980:	7834      	ldrb	r4, [r6, #0]
   23982:	f001 f98c 	bl	24c9e <__locale_ctype_ptr_l>
   23986:	2208      	movs	r2, #8
   23988:	1900      	adds	r0, r0, r4
   2398a:	7843      	ldrb	r3, [r0, #1]
   2398c:	1c75      	adds	r5, r6, #1
   2398e:	4013      	ands	r3, r2
   23990:	d10c      	bne.n	239ac <_strtol_l.isra.0+0x3c>
   23992:	2c2d      	cmp	r4, #45	; 0x2d
   23994:	d10c      	bne.n	239b0 <_strtol_l.isra.0+0x40>
   23996:	3301      	adds	r3, #1
   23998:	782c      	ldrb	r4, [r5, #0]
   2399a:	9301      	str	r3, [sp, #4]
   2399c:	1cb5      	adds	r5, r6, #2
   2399e:	2f00      	cmp	r7, #0
   239a0:	d00c      	beq.n	239bc <_strtol_l.isra.0+0x4c>
   239a2:	2f10      	cmp	r7, #16
   239a4:	d114      	bne.n	239d0 <_strtol_l.isra.0+0x60>
   239a6:	2c30      	cmp	r4, #48	; 0x30
   239a8:	d00a      	beq.n	239c0 <_strtol_l.isra.0+0x50>
   239aa:	e011      	b.n	239d0 <_strtol_l.isra.0+0x60>
   239ac:	002e      	movs	r6, r5
   239ae:	e7e6      	b.n	2397e <_strtol_l.isra.0+0xe>
   239b0:	9301      	str	r3, [sp, #4]
   239b2:	2c2b      	cmp	r4, #43	; 0x2b
   239b4:	d1f3      	bne.n	2399e <_strtol_l.isra.0+0x2e>
   239b6:	782c      	ldrb	r4, [r5, #0]
   239b8:	1cb5      	adds	r5, r6, #2
   239ba:	e7f0      	b.n	2399e <_strtol_l.isra.0+0x2e>
   239bc:	2c30      	cmp	r4, #48	; 0x30
   239be:	d12f      	bne.n	23a20 <_strtol_l.isra.0+0xb0>
   239c0:	2220      	movs	r2, #32
   239c2:	782b      	ldrb	r3, [r5, #0]
   239c4:	4393      	bics	r3, r2
   239c6:	2b58      	cmp	r3, #88	; 0x58
   239c8:	d151      	bne.n	23a6e <_strtol_l.isra.0+0xfe>
   239ca:	2710      	movs	r7, #16
   239cc:	786c      	ldrb	r4, [r5, #1]
   239ce:	3502      	adds	r5, #2
   239d0:	9b01      	ldr	r3, [sp, #4]
   239d2:	4a29      	ldr	r2, [pc, #164]	; (23a78 <_strtol_l.isra.0+0x108>)
   239d4:	0039      	movs	r1, r7
   239d6:	189e      	adds	r6, r3, r2
   239d8:	0030      	movs	r0, r6
   239da:	f001 fff5 	bl	259c8 <__aeabi_uidivmod>
   239de:	0030      	movs	r0, r6
   239e0:	9104      	str	r1, [sp, #16]
   239e2:	0039      	movs	r1, r7
   239e4:	f001 ff6a 	bl	258bc <__udivsi3>
   239e8:	2101      	movs	r1, #1
   239ea:	2300      	movs	r3, #0
   239ec:	4249      	negs	r1, r1
   239ee:	0002      	movs	r2, r0
   239f0:	468c      	mov	ip, r1
   239f2:	0018      	movs	r0, r3
   239f4:	0021      	movs	r1, r4
   239f6:	3930      	subs	r1, #48	; 0x30
   239f8:	2909      	cmp	r1, #9
   239fa:	d813      	bhi.n	23a24 <_strtol_l.isra.0+0xb4>
   239fc:	000c      	movs	r4, r1
   239fe:	42a7      	cmp	r7, r4
   23a00:	dd1c      	ble.n	23a3c <_strtol_l.isra.0+0xcc>
   23a02:	1c59      	adds	r1, r3, #1
   23a04:	d009      	beq.n	23a1a <_strtol_l.isra.0+0xaa>
   23a06:	4663      	mov	r3, ip
   23a08:	4282      	cmp	r2, r0
   23a0a:	d306      	bcc.n	23a1a <_strtol_l.isra.0+0xaa>
   23a0c:	d102      	bne.n	23a14 <_strtol_l.isra.0+0xa4>
   23a0e:	9904      	ldr	r1, [sp, #16]
   23a10:	42a1      	cmp	r1, r4
   23a12:	db02      	blt.n	23a1a <_strtol_l.isra.0+0xaa>
   23a14:	2301      	movs	r3, #1
   23a16:	4378      	muls	r0, r7
   23a18:	1820      	adds	r0, r4, r0
   23a1a:	782c      	ldrb	r4, [r5, #0]
   23a1c:	3501      	adds	r5, #1
   23a1e:	e7e9      	b.n	239f4 <_strtol_l.isra.0+0x84>
   23a20:	270a      	movs	r7, #10
   23a22:	e7d5      	b.n	239d0 <_strtol_l.isra.0+0x60>
   23a24:	0021      	movs	r1, r4
   23a26:	3941      	subs	r1, #65	; 0x41
   23a28:	2919      	cmp	r1, #25
   23a2a:	d801      	bhi.n	23a30 <_strtol_l.isra.0+0xc0>
   23a2c:	3c37      	subs	r4, #55	; 0x37
   23a2e:	e7e6      	b.n	239fe <_strtol_l.isra.0+0x8e>
   23a30:	0021      	movs	r1, r4
   23a32:	3961      	subs	r1, #97	; 0x61
   23a34:	2919      	cmp	r1, #25
   23a36:	d801      	bhi.n	23a3c <_strtol_l.isra.0+0xcc>
   23a38:	3c57      	subs	r4, #87	; 0x57
   23a3a:	e7e0      	b.n	239fe <_strtol_l.isra.0+0x8e>
   23a3c:	1c5a      	adds	r2, r3, #1
   23a3e:	d108      	bne.n	23a52 <_strtol_l.isra.0+0xe2>
   23a40:	9a05      	ldr	r2, [sp, #20]
   23a42:	3323      	adds	r3, #35	; 0x23
   23a44:	6013      	str	r3, [r2, #0]
   23a46:	9b02      	ldr	r3, [sp, #8]
   23a48:	0030      	movs	r0, r6
   23a4a:	2b00      	cmp	r3, #0
   23a4c:	d10b      	bne.n	23a66 <_strtol_l.isra.0+0xf6>
   23a4e:	b007      	add	sp, #28
   23a50:	bdf0      	pop	{r4, r5, r6, r7, pc}
   23a52:	9a01      	ldr	r2, [sp, #4]
   23a54:	2a00      	cmp	r2, #0
   23a56:	d000      	beq.n	23a5a <_strtol_l.isra.0+0xea>
   23a58:	4240      	negs	r0, r0
   23a5a:	9a02      	ldr	r2, [sp, #8]
   23a5c:	2a00      	cmp	r2, #0
   23a5e:	d0f6      	beq.n	23a4e <_strtol_l.isra.0+0xde>
   23a60:	9a03      	ldr	r2, [sp, #12]
   23a62:	2b00      	cmp	r3, #0
   23a64:	d000      	beq.n	23a68 <_strtol_l.isra.0+0xf8>
   23a66:	1e6a      	subs	r2, r5, #1
   23a68:	9b02      	ldr	r3, [sp, #8]
   23a6a:	601a      	str	r2, [r3, #0]
   23a6c:	e7ef      	b.n	23a4e <_strtol_l.isra.0+0xde>
   23a6e:	2430      	movs	r4, #48	; 0x30
   23a70:	2f00      	cmp	r7, #0
   23a72:	d1ad      	bne.n	239d0 <_strtol_l.isra.0+0x60>
   23a74:	3708      	adds	r7, #8
   23a76:	e7ab      	b.n	239d0 <_strtol_l.isra.0+0x60>
   23a78:	7fffffff 	.word	0x7fffffff

00023a7c <strtol>:
   23a7c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   23a7e:	0013      	movs	r3, r2
   23a80:	4a06      	ldr	r2, [pc, #24]	; (23a9c <strtol+0x20>)
   23a82:	0005      	movs	r5, r0
   23a84:	6810      	ldr	r0, [r2, #0]
   23a86:	6a04      	ldr	r4, [r0, #32]
   23a88:	2c00      	cmp	r4, #0
   23a8a:	d100      	bne.n	23a8e <strtol+0x12>
   23a8c:	4c04      	ldr	r4, [pc, #16]	; (23aa0 <strtol+0x24>)
   23a8e:	000a      	movs	r2, r1
   23a90:	9400      	str	r4, [sp, #0]
   23a92:	0029      	movs	r1, r5
   23a94:	f7ff ff6c 	bl	23970 <_strtol_l.isra.0>
   23a98:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
   23a9a:	46c0      	nop			; (mov r8, r8)
   23a9c:	2000020c 	.word	0x2000020c
   23aa0:	20000270 	.word	0x20000270

00023aa4 <_vsniprintf_r>:
   23aa4:	b530      	push	{r4, r5, lr}
   23aa6:	0014      	movs	r4, r2
   23aa8:	b09b      	sub	sp, #108	; 0x6c
   23aaa:	0005      	movs	r5, r0
   23aac:	001a      	movs	r2, r3
   23aae:	2c00      	cmp	r4, #0
   23ab0:	da05      	bge.n	23abe <_vsniprintf_r+0x1a>
   23ab2:	238b      	movs	r3, #139	; 0x8b
   23ab4:	6003      	str	r3, [r0, #0]
   23ab6:	2001      	movs	r0, #1
   23ab8:	4240      	negs	r0, r0
   23aba:	b01b      	add	sp, #108	; 0x6c
   23abc:	bd30      	pop	{r4, r5, pc}
   23abe:	2382      	movs	r3, #130	; 0x82
   23ac0:	4668      	mov	r0, sp
   23ac2:	009b      	lsls	r3, r3, #2
   23ac4:	8183      	strh	r3, [r0, #12]
   23ac6:	2300      	movs	r3, #0
   23ac8:	9100      	str	r1, [sp, #0]
   23aca:	9104      	str	r1, [sp, #16]
   23acc:	429c      	cmp	r4, r3
   23ace:	d000      	beq.n	23ad2 <_vsniprintf_r+0x2e>
   23ad0:	1e63      	subs	r3, r4, #1
   23ad2:	9302      	str	r3, [sp, #8]
   23ad4:	9305      	str	r3, [sp, #20]
   23ad6:	2301      	movs	r3, #1
   23ad8:	4669      	mov	r1, sp
   23ada:	425b      	negs	r3, r3
   23adc:	81cb      	strh	r3, [r1, #14]
   23ade:	0028      	movs	r0, r5
   23ae0:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   23ae2:	f001 fcd7 	bl	25494 <_svfiprintf_r>
   23ae6:	1c43      	adds	r3, r0, #1
   23ae8:	da01      	bge.n	23aee <_vsniprintf_r+0x4a>
   23aea:	238b      	movs	r3, #139	; 0x8b
   23aec:	602b      	str	r3, [r5, #0]
   23aee:	2c00      	cmp	r4, #0
   23af0:	d0e3      	beq.n	23aba <_vsniprintf_r+0x16>
   23af2:	2300      	movs	r3, #0
   23af4:	9a00      	ldr	r2, [sp, #0]
   23af6:	7013      	strb	r3, [r2, #0]
   23af8:	e7df      	b.n	23aba <_vsniprintf_r+0x16>
	...

00023afc <vsniprintf>:
   23afc:	b507      	push	{r0, r1, r2, lr}
   23afe:	9300      	str	r3, [sp, #0]
   23b00:	0013      	movs	r3, r2
   23b02:	000a      	movs	r2, r1
   23b04:	0001      	movs	r1, r0
   23b06:	4802      	ldr	r0, [pc, #8]	; (23b10 <vsniprintf+0x14>)
   23b08:	6800      	ldr	r0, [r0, #0]
   23b0a:	f7ff ffcb 	bl	23aa4 <_vsniprintf_r>
   23b0e:	bd0e      	pop	{r1, r2, r3, pc}
   23b10:	2000020c 	.word	0x2000020c

00023b14 <__swbuf_r>:
   23b14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   23b16:	0005      	movs	r5, r0
   23b18:	000e      	movs	r6, r1
   23b1a:	0014      	movs	r4, r2
   23b1c:	2800      	cmp	r0, #0
   23b1e:	d004      	beq.n	23b2a <__swbuf_r+0x16>
   23b20:	6983      	ldr	r3, [r0, #24]
   23b22:	2b00      	cmp	r3, #0
   23b24:	d101      	bne.n	23b2a <__swbuf_r+0x16>
   23b26:	f001 f825 	bl	24b74 <__sinit>
   23b2a:	4b22      	ldr	r3, [pc, #136]	; (23bb4 <__swbuf_r+0xa0>)
   23b2c:	429c      	cmp	r4, r3
   23b2e:	d12d      	bne.n	23b8c <__swbuf_r+0x78>
   23b30:	686c      	ldr	r4, [r5, #4]
   23b32:	69a3      	ldr	r3, [r4, #24]
   23b34:	60a3      	str	r3, [r4, #8]
   23b36:	89a3      	ldrh	r3, [r4, #12]
   23b38:	071b      	lsls	r3, r3, #28
   23b3a:	d531      	bpl.n	23ba0 <__swbuf_r+0x8c>
   23b3c:	6923      	ldr	r3, [r4, #16]
   23b3e:	2b00      	cmp	r3, #0
   23b40:	d02e      	beq.n	23ba0 <__swbuf_r+0x8c>
   23b42:	6823      	ldr	r3, [r4, #0]
   23b44:	6922      	ldr	r2, [r4, #16]
   23b46:	b2f7      	uxtb	r7, r6
   23b48:	1a98      	subs	r0, r3, r2
   23b4a:	6963      	ldr	r3, [r4, #20]
   23b4c:	b2f6      	uxtb	r6, r6
   23b4e:	4298      	cmp	r0, r3
   23b50:	db05      	blt.n	23b5e <__swbuf_r+0x4a>
   23b52:	0021      	movs	r1, r4
   23b54:	0028      	movs	r0, r5
   23b56:	f000 ff9f 	bl	24a98 <_fflush_r>
   23b5a:	2800      	cmp	r0, #0
   23b5c:	d126      	bne.n	23bac <__swbuf_r+0x98>
   23b5e:	68a3      	ldr	r3, [r4, #8]
   23b60:	3001      	adds	r0, #1
   23b62:	3b01      	subs	r3, #1
   23b64:	60a3      	str	r3, [r4, #8]
   23b66:	6823      	ldr	r3, [r4, #0]
   23b68:	1c5a      	adds	r2, r3, #1
   23b6a:	6022      	str	r2, [r4, #0]
   23b6c:	701f      	strb	r7, [r3, #0]
   23b6e:	6963      	ldr	r3, [r4, #20]
   23b70:	4298      	cmp	r0, r3
   23b72:	d004      	beq.n	23b7e <__swbuf_r+0x6a>
   23b74:	89a3      	ldrh	r3, [r4, #12]
   23b76:	07db      	lsls	r3, r3, #31
   23b78:	d51a      	bpl.n	23bb0 <__swbuf_r+0x9c>
   23b7a:	2e0a      	cmp	r6, #10
   23b7c:	d118      	bne.n	23bb0 <__swbuf_r+0x9c>
   23b7e:	0021      	movs	r1, r4
   23b80:	0028      	movs	r0, r5
   23b82:	f000 ff89 	bl	24a98 <_fflush_r>
   23b86:	2800      	cmp	r0, #0
   23b88:	d012      	beq.n	23bb0 <__swbuf_r+0x9c>
   23b8a:	e00f      	b.n	23bac <__swbuf_r+0x98>
   23b8c:	4b0a      	ldr	r3, [pc, #40]	; (23bb8 <__swbuf_r+0xa4>)
   23b8e:	429c      	cmp	r4, r3
   23b90:	d101      	bne.n	23b96 <__swbuf_r+0x82>
   23b92:	68ac      	ldr	r4, [r5, #8]
   23b94:	e7cd      	b.n	23b32 <__swbuf_r+0x1e>
   23b96:	4b09      	ldr	r3, [pc, #36]	; (23bbc <__swbuf_r+0xa8>)
   23b98:	429c      	cmp	r4, r3
   23b9a:	d1ca      	bne.n	23b32 <__swbuf_r+0x1e>
   23b9c:	68ec      	ldr	r4, [r5, #12]
   23b9e:	e7c8      	b.n	23b32 <__swbuf_r+0x1e>
   23ba0:	0021      	movs	r1, r4
   23ba2:	0028      	movs	r0, r5
   23ba4:	f000 f80c 	bl	23bc0 <__swsetup_r>
   23ba8:	2800      	cmp	r0, #0
   23baa:	d0ca      	beq.n	23b42 <__swbuf_r+0x2e>
   23bac:	2601      	movs	r6, #1
   23bae:	4276      	negs	r6, r6
   23bb0:	0030      	movs	r0, r6
   23bb2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   23bb4:	0002b6d0 	.word	0x0002b6d0
   23bb8:	0002b6f0 	.word	0x0002b6f0
   23bbc:	0002b6b0 	.word	0x0002b6b0

00023bc0 <__swsetup_r>:
   23bc0:	4b36      	ldr	r3, [pc, #216]	; (23c9c <__swsetup_r+0xdc>)
   23bc2:	b570      	push	{r4, r5, r6, lr}
   23bc4:	681d      	ldr	r5, [r3, #0]
   23bc6:	0006      	movs	r6, r0
   23bc8:	000c      	movs	r4, r1
   23bca:	2d00      	cmp	r5, #0
   23bcc:	d005      	beq.n	23bda <__swsetup_r+0x1a>
   23bce:	69ab      	ldr	r3, [r5, #24]
   23bd0:	2b00      	cmp	r3, #0
   23bd2:	d102      	bne.n	23bda <__swsetup_r+0x1a>
   23bd4:	0028      	movs	r0, r5
   23bd6:	f000 ffcd 	bl	24b74 <__sinit>
   23bda:	4b31      	ldr	r3, [pc, #196]	; (23ca0 <__swsetup_r+0xe0>)
   23bdc:	429c      	cmp	r4, r3
   23bde:	d10f      	bne.n	23c00 <__swsetup_r+0x40>
   23be0:	686c      	ldr	r4, [r5, #4]
   23be2:	230c      	movs	r3, #12
   23be4:	5ee2      	ldrsh	r2, [r4, r3]
   23be6:	b293      	uxth	r3, r2
   23be8:	0719      	lsls	r1, r3, #28
   23bea:	d42d      	bmi.n	23c48 <__swsetup_r+0x88>
   23bec:	06d9      	lsls	r1, r3, #27
   23bee:	d411      	bmi.n	23c14 <__swsetup_r+0x54>
   23bf0:	2309      	movs	r3, #9
   23bf2:	2001      	movs	r0, #1
   23bf4:	6033      	str	r3, [r6, #0]
   23bf6:	3337      	adds	r3, #55	; 0x37
   23bf8:	4313      	orrs	r3, r2
   23bfa:	81a3      	strh	r3, [r4, #12]
   23bfc:	4240      	negs	r0, r0
   23bfe:	bd70      	pop	{r4, r5, r6, pc}
   23c00:	4b28      	ldr	r3, [pc, #160]	; (23ca4 <__swsetup_r+0xe4>)
   23c02:	429c      	cmp	r4, r3
   23c04:	d101      	bne.n	23c0a <__swsetup_r+0x4a>
   23c06:	68ac      	ldr	r4, [r5, #8]
   23c08:	e7eb      	b.n	23be2 <__swsetup_r+0x22>
   23c0a:	4b27      	ldr	r3, [pc, #156]	; (23ca8 <__swsetup_r+0xe8>)
   23c0c:	429c      	cmp	r4, r3
   23c0e:	d1e8      	bne.n	23be2 <__swsetup_r+0x22>
   23c10:	68ec      	ldr	r4, [r5, #12]
   23c12:	e7e6      	b.n	23be2 <__swsetup_r+0x22>
   23c14:	075b      	lsls	r3, r3, #29
   23c16:	d513      	bpl.n	23c40 <__swsetup_r+0x80>
   23c18:	6b61      	ldr	r1, [r4, #52]	; 0x34
   23c1a:	2900      	cmp	r1, #0
   23c1c:	d008      	beq.n	23c30 <__swsetup_r+0x70>
   23c1e:	0023      	movs	r3, r4
   23c20:	3344      	adds	r3, #68	; 0x44
   23c22:	4299      	cmp	r1, r3
   23c24:	d002      	beq.n	23c2c <__swsetup_r+0x6c>
   23c26:	0030      	movs	r0, r6
   23c28:	f7ff f816 	bl	22c58 <_free_r>
   23c2c:	2300      	movs	r3, #0
   23c2e:	6363      	str	r3, [r4, #52]	; 0x34
   23c30:	2224      	movs	r2, #36	; 0x24
   23c32:	89a3      	ldrh	r3, [r4, #12]
   23c34:	4393      	bics	r3, r2
   23c36:	81a3      	strh	r3, [r4, #12]
   23c38:	2300      	movs	r3, #0
   23c3a:	6063      	str	r3, [r4, #4]
   23c3c:	6923      	ldr	r3, [r4, #16]
   23c3e:	6023      	str	r3, [r4, #0]
   23c40:	2308      	movs	r3, #8
   23c42:	89a2      	ldrh	r2, [r4, #12]
   23c44:	4313      	orrs	r3, r2
   23c46:	81a3      	strh	r3, [r4, #12]
   23c48:	6923      	ldr	r3, [r4, #16]
   23c4a:	2b00      	cmp	r3, #0
   23c4c:	d10b      	bne.n	23c66 <__swsetup_r+0xa6>
   23c4e:	21a0      	movs	r1, #160	; 0xa0
   23c50:	2280      	movs	r2, #128	; 0x80
   23c52:	89a3      	ldrh	r3, [r4, #12]
   23c54:	0089      	lsls	r1, r1, #2
   23c56:	0092      	lsls	r2, r2, #2
   23c58:	400b      	ands	r3, r1
   23c5a:	4293      	cmp	r3, r2
   23c5c:	d003      	beq.n	23c66 <__swsetup_r+0xa6>
   23c5e:	0021      	movs	r1, r4
   23c60:	0030      	movs	r0, r6
   23c62:	f001 f861 	bl	24d28 <__smakebuf_r>
   23c66:	2301      	movs	r3, #1
   23c68:	89a2      	ldrh	r2, [r4, #12]
   23c6a:	4013      	ands	r3, r2
   23c6c:	d011      	beq.n	23c92 <__swsetup_r+0xd2>
   23c6e:	2300      	movs	r3, #0
   23c70:	60a3      	str	r3, [r4, #8]
   23c72:	6963      	ldr	r3, [r4, #20]
   23c74:	425b      	negs	r3, r3
   23c76:	61a3      	str	r3, [r4, #24]
   23c78:	2000      	movs	r0, #0
   23c7a:	6923      	ldr	r3, [r4, #16]
   23c7c:	4283      	cmp	r3, r0
   23c7e:	d1be      	bne.n	23bfe <__swsetup_r+0x3e>
   23c80:	230c      	movs	r3, #12
   23c82:	5ee2      	ldrsh	r2, [r4, r3]
   23c84:	0613      	lsls	r3, r2, #24
   23c86:	d5ba      	bpl.n	23bfe <__swsetup_r+0x3e>
   23c88:	2340      	movs	r3, #64	; 0x40
   23c8a:	4313      	orrs	r3, r2
   23c8c:	81a3      	strh	r3, [r4, #12]
   23c8e:	3801      	subs	r0, #1
   23c90:	e7b5      	b.n	23bfe <__swsetup_r+0x3e>
   23c92:	0792      	lsls	r2, r2, #30
   23c94:	d400      	bmi.n	23c98 <__swsetup_r+0xd8>
   23c96:	6963      	ldr	r3, [r4, #20]
   23c98:	60a3      	str	r3, [r4, #8]
   23c9a:	e7ed      	b.n	23c78 <__swsetup_r+0xb8>
   23c9c:	2000020c 	.word	0x2000020c
   23ca0:	0002b6d0 	.word	0x0002b6d0
   23ca4:	0002b6f0 	.word	0x0002b6f0
   23ca8:	0002b6b0 	.word	0x0002b6b0

00023cac <quorem>:
   23cac:	b5f0      	push	{r4, r5, r6, r7, lr}
   23cae:	6903      	ldr	r3, [r0, #16]
   23cb0:	690c      	ldr	r4, [r1, #16]
   23cb2:	b089      	sub	sp, #36	; 0x24
   23cb4:	0007      	movs	r7, r0
   23cb6:	9105      	str	r1, [sp, #20]
   23cb8:	2600      	movs	r6, #0
   23cba:	429c      	cmp	r4, r3
   23cbc:	dc6d      	bgt.n	23d9a <quorem+0xee>
   23cbe:	000b      	movs	r3, r1
   23cc0:	3c01      	subs	r4, #1
   23cc2:	3314      	adds	r3, #20
   23cc4:	00a5      	lsls	r5, r4, #2
   23cc6:	9303      	str	r3, [sp, #12]
   23cc8:	195b      	adds	r3, r3, r5
   23cca:	9304      	str	r3, [sp, #16]
   23ccc:	0003      	movs	r3, r0
   23cce:	3314      	adds	r3, #20
   23cd0:	9302      	str	r3, [sp, #8]
   23cd2:	195d      	adds	r5, r3, r5
   23cd4:	9b04      	ldr	r3, [sp, #16]
   23cd6:	6828      	ldr	r0, [r5, #0]
   23cd8:	681b      	ldr	r3, [r3, #0]
   23cda:	1c59      	adds	r1, r3, #1
   23cdc:	9301      	str	r3, [sp, #4]
   23cde:	f001 fded 	bl	258bc <__udivsi3>
   23ce2:	9001      	str	r0, [sp, #4]
   23ce4:	42b0      	cmp	r0, r6
   23ce6:	d02d      	beq.n	23d44 <quorem+0x98>
   23ce8:	9b03      	ldr	r3, [sp, #12]
   23cea:	9802      	ldr	r0, [sp, #8]
   23cec:	469c      	mov	ip, r3
   23cee:	9606      	str	r6, [sp, #24]
   23cf0:	4662      	mov	r2, ip
   23cf2:	ca08      	ldmia	r2!, {r3}
   23cf4:	4694      	mov	ip, r2
   23cf6:	9a01      	ldr	r2, [sp, #4]
   23cf8:	b299      	uxth	r1, r3
   23cfa:	4351      	muls	r1, r2
   23cfc:	0c1b      	lsrs	r3, r3, #16
   23cfe:	4353      	muls	r3, r2
   23d00:	1989      	adds	r1, r1, r6
   23d02:	0c0a      	lsrs	r2, r1, #16
   23d04:	189b      	adds	r3, r3, r2
   23d06:	9307      	str	r3, [sp, #28]
   23d08:	8802      	ldrh	r2, [r0, #0]
   23d0a:	0c1e      	lsrs	r6, r3, #16
   23d0c:	9b06      	ldr	r3, [sp, #24]
   23d0e:	b289      	uxth	r1, r1
   23d10:	18d2      	adds	r2, r2, r3
   23d12:	6803      	ldr	r3, [r0, #0]
   23d14:	1a52      	subs	r2, r2, r1
   23d16:	0c19      	lsrs	r1, r3, #16
   23d18:	466b      	mov	r3, sp
   23d1a:	8b9b      	ldrh	r3, [r3, #28]
   23d1c:	1acb      	subs	r3, r1, r3
   23d1e:	1411      	asrs	r1, r2, #16
   23d20:	185b      	adds	r3, r3, r1
   23d22:	1419      	asrs	r1, r3, #16
   23d24:	b292      	uxth	r2, r2
   23d26:	041b      	lsls	r3, r3, #16
   23d28:	431a      	orrs	r2, r3
   23d2a:	9b04      	ldr	r3, [sp, #16]
   23d2c:	9106      	str	r1, [sp, #24]
   23d2e:	c004      	stmia	r0!, {r2}
   23d30:	4563      	cmp	r3, ip
   23d32:	d2dd      	bcs.n	23cf0 <quorem+0x44>
   23d34:	682b      	ldr	r3, [r5, #0]
   23d36:	2b00      	cmp	r3, #0
   23d38:	d104      	bne.n	23d44 <quorem+0x98>
   23d3a:	9b02      	ldr	r3, [sp, #8]
   23d3c:	3d04      	subs	r5, #4
   23d3e:	42ab      	cmp	r3, r5
   23d40:	d32e      	bcc.n	23da0 <quorem+0xf4>
   23d42:	613c      	str	r4, [r7, #16]
   23d44:	9905      	ldr	r1, [sp, #20]
   23d46:	0038      	movs	r0, r7
   23d48:	f001 fa63 	bl	25212 <__mcmp>
   23d4c:	2800      	cmp	r0, #0
   23d4e:	db23      	blt.n	23d98 <quorem+0xec>
   23d50:	2500      	movs	r5, #0
   23d52:	9b01      	ldr	r3, [sp, #4]
   23d54:	9802      	ldr	r0, [sp, #8]
   23d56:	3301      	adds	r3, #1
   23d58:	9903      	ldr	r1, [sp, #12]
   23d5a:	9301      	str	r3, [sp, #4]
   23d5c:	c908      	ldmia	r1!, {r3}
   23d5e:	8802      	ldrh	r2, [r0, #0]
   23d60:	1955      	adds	r5, r2, r5
   23d62:	b29a      	uxth	r2, r3
   23d64:	1aaa      	subs	r2, r5, r2
   23d66:	6805      	ldr	r5, [r0, #0]
   23d68:	0c1b      	lsrs	r3, r3, #16
   23d6a:	0c2d      	lsrs	r5, r5, #16
   23d6c:	1aeb      	subs	r3, r5, r3
   23d6e:	1415      	asrs	r5, r2, #16
   23d70:	195b      	adds	r3, r3, r5
   23d72:	141d      	asrs	r5, r3, #16
   23d74:	b292      	uxth	r2, r2
   23d76:	041b      	lsls	r3, r3, #16
   23d78:	4313      	orrs	r3, r2
   23d7a:	c008      	stmia	r0!, {r3}
   23d7c:	9b04      	ldr	r3, [sp, #16]
   23d7e:	428b      	cmp	r3, r1
   23d80:	d2ec      	bcs.n	23d5c <quorem+0xb0>
   23d82:	9a02      	ldr	r2, [sp, #8]
   23d84:	00a3      	lsls	r3, r4, #2
   23d86:	18d3      	adds	r3, r2, r3
   23d88:	681a      	ldr	r2, [r3, #0]
   23d8a:	2a00      	cmp	r2, #0
   23d8c:	d104      	bne.n	23d98 <quorem+0xec>
   23d8e:	9a02      	ldr	r2, [sp, #8]
   23d90:	3b04      	subs	r3, #4
   23d92:	429a      	cmp	r2, r3
   23d94:	d309      	bcc.n	23daa <quorem+0xfe>
   23d96:	613c      	str	r4, [r7, #16]
   23d98:	9e01      	ldr	r6, [sp, #4]
   23d9a:	0030      	movs	r0, r6
   23d9c:	b009      	add	sp, #36	; 0x24
   23d9e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   23da0:	682b      	ldr	r3, [r5, #0]
   23da2:	2b00      	cmp	r3, #0
   23da4:	d1cd      	bne.n	23d42 <quorem+0x96>
   23da6:	3c01      	subs	r4, #1
   23da8:	e7c7      	b.n	23d3a <quorem+0x8e>
   23daa:	681a      	ldr	r2, [r3, #0]
   23dac:	2a00      	cmp	r2, #0
   23dae:	d1f2      	bne.n	23d96 <quorem+0xea>
   23db0:	3c01      	subs	r4, #1
   23db2:	e7ec      	b.n	23d8e <quorem+0xe2>

00023db4 <_dtoa_r>:
   23db4:	b5f0      	push	{r4, r5, r6, r7, lr}
   23db6:	0016      	movs	r6, r2
   23db8:	001f      	movs	r7, r3
   23dba:	6a44      	ldr	r4, [r0, #36]	; 0x24
   23dbc:	b09d      	sub	sp, #116	; 0x74
   23dbe:	9004      	str	r0, [sp, #16]
   23dc0:	9d25      	ldr	r5, [sp, #148]	; 0x94
   23dc2:	9606      	str	r6, [sp, #24]
   23dc4:	9707      	str	r7, [sp, #28]
   23dc6:	2c00      	cmp	r4, #0
   23dc8:	d108      	bne.n	23ddc <_dtoa_r+0x28>
   23dca:	2010      	movs	r0, #16
   23dcc:	f7fe ff0c 	bl	22be8 <malloc>
   23dd0:	9b04      	ldr	r3, [sp, #16]
   23dd2:	6258      	str	r0, [r3, #36]	; 0x24
   23dd4:	6044      	str	r4, [r0, #4]
   23dd6:	6084      	str	r4, [r0, #8]
   23dd8:	6004      	str	r4, [r0, #0]
   23dda:	60c4      	str	r4, [r0, #12]
   23ddc:	9b04      	ldr	r3, [sp, #16]
   23dde:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   23de0:	6819      	ldr	r1, [r3, #0]
   23de2:	2900      	cmp	r1, #0
   23de4:	d00b      	beq.n	23dfe <_dtoa_r+0x4a>
   23de6:	685a      	ldr	r2, [r3, #4]
   23de8:	2301      	movs	r3, #1
   23dea:	4093      	lsls	r3, r2
   23dec:	604a      	str	r2, [r1, #4]
   23dee:	608b      	str	r3, [r1, #8]
   23df0:	9804      	ldr	r0, [sp, #16]
   23df2:	f001 f834 	bl	24e5e <_Bfree>
   23df6:	2200      	movs	r2, #0
   23df8:	9b04      	ldr	r3, [sp, #16]
   23dfa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   23dfc:	601a      	str	r2, [r3, #0]
   23dfe:	9b07      	ldr	r3, [sp, #28]
   23e00:	2b00      	cmp	r3, #0
   23e02:	da1f      	bge.n	23e44 <_dtoa_r+0x90>
   23e04:	2301      	movs	r3, #1
   23e06:	602b      	str	r3, [r5, #0]
   23e08:	007b      	lsls	r3, r7, #1
   23e0a:	085b      	lsrs	r3, r3, #1
   23e0c:	9307      	str	r3, [sp, #28]
   23e0e:	9c07      	ldr	r4, [sp, #28]
   23e10:	4bb7      	ldr	r3, [pc, #732]	; (240f0 <_dtoa_r+0x33c>)
   23e12:	0022      	movs	r2, r4
   23e14:	9319      	str	r3, [sp, #100]	; 0x64
   23e16:	401a      	ands	r2, r3
   23e18:	429a      	cmp	r2, r3
   23e1a:	d116      	bne.n	23e4a <_dtoa_r+0x96>
   23e1c:	4bb5      	ldr	r3, [pc, #724]	; (240f4 <_dtoa_r+0x340>)
   23e1e:	9a24      	ldr	r2, [sp, #144]	; 0x90
   23e20:	6013      	str	r3, [r2, #0]
   23e22:	9b06      	ldr	r3, [sp, #24]
   23e24:	2b00      	cmp	r3, #0
   23e26:	d103      	bne.n	23e30 <_dtoa_r+0x7c>
   23e28:	0324      	lsls	r4, r4, #12
   23e2a:	d101      	bne.n	23e30 <_dtoa_r+0x7c>
   23e2c:	f000 fd91 	bl	24952 <_dtoa_r+0xb9e>
   23e30:	4bb1      	ldr	r3, [pc, #708]	; (240f8 <_dtoa_r+0x344>)
   23e32:	9a26      	ldr	r2, [sp, #152]	; 0x98
   23e34:	930a      	str	r3, [sp, #40]	; 0x28
   23e36:	4bb1      	ldr	r3, [pc, #708]	; (240fc <_dtoa_r+0x348>)
   23e38:	2a00      	cmp	r2, #0
   23e3a:	d001      	beq.n	23e40 <_dtoa_r+0x8c>
   23e3c:	f000 fd8f 	bl	2495e <_dtoa_r+0xbaa>
   23e40:	f000 fd8f 	bl	24962 <_dtoa_r+0xbae>
   23e44:	2300      	movs	r3, #0
   23e46:	602b      	str	r3, [r5, #0]
   23e48:	e7e1      	b.n	23e0e <_dtoa_r+0x5a>
   23e4a:	9e06      	ldr	r6, [sp, #24]
   23e4c:	9f07      	ldr	r7, [sp, #28]
   23e4e:	2200      	movs	r2, #0
   23e50:	2300      	movs	r3, #0
   23e52:	0030      	movs	r0, r6
   23e54:	0039      	movs	r1, r7
   23e56:	f001 fec3 	bl	25be0 <__aeabi_dcmpeq>
   23e5a:	1e05      	subs	r5, r0, #0
   23e5c:	d00e      	beq.n	23e7c <_dtoa_r+0xc8>
   23e5e:	2301      	movs	r3, #1
   23e60:	9a24      	ldr	r2, [sp, #144]	; 0x90
   23e62:	6013      	str	r3, [r2, #0]
   23e64:	4ba6      	ldr	r3, [pc, #664]	; (24100 <_dtoa_r+0x34c>)
   23e66:	9a26      	ldr	r2, [sp, #152]	; 0x98
   23e68:	930a      	str	r3, [sp, #40]	; 0x28
   23e6a:	2a00      	cmp	r2, #0
   23e6c:	d101      	bne.n	23e72 <_dtoa_r+0xbe>
   23e6e:	f000 fd78 	bl	24962 <_dtoa_r+0xbae>
   23e72:	4aa4      	ldr	r2, [pc, #656]	; (24104 <_dtoa_r+0x350>)
   23e74:	9926      	ldr	r1, [sp, #152]	; 0x98
   23e76:	600a      	str	r2, [r1, #0]
   23e78:	f000 fd73 	bl	24962 <_dtoa_r+0xbae>
   23e7c:	ab1a      	add	r3, sp, #104	; 0x68
   23e7e:	9301      	str	r3, [sp, #4]
   23e80:	ab1b      	add	r3, sp, #108	; 0x6c
   23e82:	9300      	str	r3, [sp, #0]
   23e84:	0032      	movs	r2, r6
   23e86:	003b      	movs	r3, r7
   23e88:	9804      	ldr	r0, [sp, #16]
   23e8a:	f001 fa3f 	bl	2530c <__d2b>
   23e8e:	0063      	lsls	r3, r4, #1
   23e90:	9005      	str	r0, [sp, #20]
   23e92:	0d5b      	lsrs	r3, r3, #21
   23e94:	d100      	bne.n	23e98 <_dtoa_r+0xe4>
   23e96:	e07f      	b.n	23f98 <_dtoa_r+0x1e4>
   23e98:	033a      	lsls	r2, r7, #12
   23e9a:	4c9b      	ldr	r4, [pc, #620]	; (24108 <_dtoa_r+0x354>)
   23e9c:	0b12      	lsrs	r2, r2, #12
   23e9e:	4314      	orrs	r4, r2
   23ea0:	0021      	movs	r1, r4
   23ea2:	4a9a      	ldr	r2, [pc, #616]	; (2410c <_dtoa_r+0x358>)
   23ea4:	0030      	movs	r0, r6
   23ea6:	9518      	str	r5, [sp, #96]	; 0x60
   23ea8:	189e      	adds	r6, r3, r2
   23eaa:	2200      	movs	r2, #0
   23eac:	4b98      	ldr	r3, [pc, #608]	; (24110 <_dtoa_r+0x35c>)
   23eae:	f003 fff9 	bl	27ea4 <__aeabi_dsub>
   23eb2:	4a98      	ldr	r2, [pc, #608]	; (24114 <_dtoa_r+0x360>)
   23eb4:	4b98      	ldr	r3, [pc, #608]	; (24118 <_dtoa_r+0x364>)
   23eb6:	f003 fd75 	bl	279a4 <__aeabi_dmul>
   23eba:	4a98      	ldr	r2, [pc, #608]	; (2411c <_dtoa_r+0x368>)
   23ebc:	4b98      	ldr	r3, [pc, #608]	; (24120 <_dtoa_r+0x36c>)
   23ebe:	f002 fe2d 	bl	26b1c <__aeabi_dadd>
   23ec2:	0004      	movs	r4, r0
   23ec4:	0030      	movs	r0, r6
   23ec6:	000d      	movs	r5, r1
   23ec8:	f004 fb56 	bl	28578 <__aeabi_i2d>
   23ecc:	4a95      	ldr	r2, [pc, #596]	; (24124 <_dtoa_r+0x370>)
   23ece:	4b96      	ldr	r3, [pc, #600]	; (24128 <_dtoa_r+0x374>)
   23ed0:	f003 fd68 	bl	279a4 <__aeabi_dmul>
   23ed4:	0002      	movs	r2, r0
   23ed6:	000b      	movs	r3, r1
   23ed8:	0020      	movs	r0, r4
   23eda:	0029      	movs	r1, r5
   23edc:	f002 fe1e 	bl	26b1c <__aeabi_dadd>
   23ee0:	0004      	movs	r4, r0
   23ee2:	000d      	movs	r5, r1
   23ee4:	f004 fb14 	bl	28510 <__aeabi_d2iz>
   23ee8:	2200      	movs	r2, #0
   23eea:	9003      	str	r0, [sp, #12]
   23eec:	2300      	movs	r3, #0
   23eee:	0020      	movs	r0, r4
   23ef0:	0029      	movs	r1, r5
   23ef2:	f001 fe7b 	bl	25bec <__aeabi_dcmplt>
   23ef6:	2800      	cmp	r0, #0
   23ef8:	d00e      	beq.n	23f18 <_dtoa_r+0x164>
   23efa:	9803      	ldr	r0, [sp, #12]
   23efc:	f004 fb3c 	bl	28578 <__aeabi_i2d>
   23f00:	000b      	movs	r3, r1
   23f02:	0002      	movs	r2, r0
   23f04:	0029      	movs	r1, r5
   23f06:	0020      	movs	r0, r4
   23f08:	f001 fe6a 	bl	25be0 <__aeabi_dcmpeq>
   23f0c:	0003      	movs	r3, r0
   23f0e:	4258      	negs	r0, r3
   23f10:	4158      	adcs	r0, r3
   23f12:	9b03      	ldr	r3, [sp, #12]
   23f14:	1a1b      	subs	r3, r3, r0
   23f16:	9303      	str	r3, [sp, #12]
   23f18:	2301      	movs	r3, #1
   23f1a:	9316      	str	r3, [sp, #88]	; 0x58
   23f1c:	9b03      	ldr	r3, [sp, #12]
   23f1e:	2b16      	cmp	r3, #22
   23f20:	d80f      	bhi.n	23f42 <_dtoa_r+0x18e>
   23f22:	4982      	ldr	r1, [pc, #520]	; (2412c <_dtoa_r+0x378>)
   23f24:	00db      	lsls	r3, r3, #3
   23f26:	18c9      	adds	r1, r1, r3
   23f28:	6808      	ldr	r0, [r1, #0]
   23f2a:	6849      	ldr	r1, [r1, #4]
   23f2c:	9a06      	ldr	r2, [sp, #24]
   23f2e:	9b07      	ldr	r3, [sp, #28]
   23f30:	f001 fe70 	bl	25c14 <__aeabi_dcmpgt>
   23f34:	2800      	cmp	r0, #0
   23f36:	d04b      	beq.n	23fd0 <_dtoa_r+0x21c>
   23f38:	9b03      	ldr	r3, [sp, #12]
   23f3a:	3b01      	subs	r3, #1
   23f3c:	9303      	str	r3, [sp, #12]
   23f3e:	2300      	movs	r3, #0
   23f40:	9316      	str	r3, [sp, #88]	; 0x58
   23f42:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   23f44:	1b9e      	subs	r6, r3, r6
   23f46:	2300      	movs	r3, #0
   23f48:	930b      	str	r3, [sp, #44]	; 0x2c
   23f4a:	0033      	movs	r3, r6
   23f4c:	3b01      	subs	r3, #1
   23f4e:	930c      	str	r3, [sp, #48]	; 0x30
   23f50:	d504      	bpl.n	23f5c <_dtoa_r+0x1a8>
   23f52:	2301      	movs	r3, #1
   23f54:	1b9b      	subs	r3, r3, r6
   23f56:	930b      	str	r3, [sp, #44]	; 0x2c
   23f58:	2300      	movs	r3, #0
   23f5a:	930c      	str	r3, [sp, #48]	; 0x30
   23f5c:	9b03      	ldr	r3, [sp, #12]
   23f5e:	2b00      	cmp	r3, #0
   23f60:	db38      	blt.n	23fd4 <_dtoa_r+0x220>
   23f62:	9a03      	ldr	r2, [sp, #12]
   23f64:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   23f66:	4694      	mov	ip, r2
   23f68:	4463      	add	r3, ip
   23f6a:	930c      	str	r3, [sp, #48]	; 0x30
   23f6c:	2300      	movs	r3, #0
   23f6e:	920f      	str	r2, [sp, #60]	; 0x3c
   23f70:	9308      	str	r3, [sp, #32]
   23f72:	9b22      	ldr	r3, [sp, #136]	; 0x88
   23f74:	2501      	movs	r5, #1
   23f76:	2b09      	cmp	r3, #9
   23f78:	d900      	bls.n	23f7c <_dtoa_r+0x1c8>
   23f7a:	e091      	b.n	240a0 <_dtoa_r+0x2ec>
   23f7c:	2b05      	cmp	r3, #5
   23f7e:	dd02      	ble.n	23f86 <_dtoa_r+0x1d2>
   23f80:	2500      	movs	r5, #0
   23f82:	3b04      	subs	r3, #4
   23f84:	9322      	str	r3, [sp, #136]	; 0x88
   23f86:	9b22      	ldr	r3, [sp, #136]	; 0x88
   23f88:	1e98      	subs	r0, r3, #2
   23f8a:	2803      	cmp	r0, #3
   23f8c:	d900      	bls.n	23f90 <_dtoa_r+0x1dc>
   23f8e:	e091      	b.n	240b4 <_dtoa_r+0x300>
   23f90:	f001 fc8a 	bl	258a8 <__gnu_thumb1_case_uqi>
   23f94:	76298482 	.word	0x76298482
   23f98:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   23f9a:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   23f9c:	189e      	adds	r6, r3, r2
   23f9e:	4b64      	ldr	r3, [pc, #400]	; (24130 <_dtoa_r+0x37c>)
   23fa0:	18f2      	adds	r2, r6, r3
   23fa2:	2a20      	cmp	r2, #32
   23fa4:	dd0f      	ble.n	23fc6 <_dtoa_r+0x212>
   23fa6:	4b63      	ldr	r3, [pc, #396]	; (24134 <_dtoa_r+0x380>)
   23fa8:	9806      	ldr	r0, [sp, #24]
   23faa:	18f3      	adds	r3, r6, r3
   23fac:	40d8      	lsrs	r0, r3
   23fae:	2340      	movs	r3, #64	; 0x40
   23fb0:	1a9b      	subs	r3, r3, r2
   23fb2:	409c      	lsls	r4, r3
   23fb4:	4320      	orrs	r0, r4
   23fb6:	f004 fb21 	bl	285fc <__aeabi_ui2d>
   23fba:	2301      	movs	r3, #1
   23fbc:	4c5e      	ldr	r4, [pc, #376]	; (24138 <_dtoa_r+0x384>)
   23fbe:	3e01      	subs	r6, #1
   23fc0:	1909      	adds	r1, r1, r4
   23fc2:	9318      	str	r3, [sp, #96]	; 0x60
   23fc4:	e771      	b.n	23eaa <_dtoa_r+0xf6>
   23fc6:	2320      	movs	r3, #32
   23fc8:	9806      	ldr	r0, [sp, #24]
   23fca:	1a9b      	subs	r3, r3, r2
   23fcc:	4098      	lsls	r0, r3
   23fce:	e7f2      	b.n	23fb6 <_dtoa_r+0x202>
   23fd0:	9016      	str	r0, [sp, #88]	; 0x58
   23fd2:	e7b6      	b.n	23f42 <_dtoa_r+0x18e>
   23fd4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   23fd6:	9a03      	ldr	r2, [sp, #12]
   23fd8:	1a9b      	subs	r3, r3, r2
   23fda:	930b      	str	r3, [sp, #44]	; 0x2c
   23fdc:	4253      	negs	r3, r2
   23fde:	9308      	str	r3, [sp, #32]
   23fe0:	2300      	movs	r3, #0
   23fe2:	930f      	str	r3, [sp, #60]	; 0x3c
   23fe4:	e7c5      	b.n	23f72 <_dtoa_r+0x1be>
   23fe6:	2301      	movs	r3, #1
   23fe8:	930e      	str	r3, [sp, #56]	; 0x38
   23fea:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   23fec:	2b00      	cmp	r3, #0
   23fee:	dd65      	ble.n	240bc <_dtoa_r+0x308>
   23ff0:	001f      	movs	r7, r3
   23ff2:	930d      	str	r3, [sp, #52]	; 0x34
   23ff4:	9a04      	ldr	r2, [sp, #16]
   23ff6:	6a54      	ldr	r4, [r2, #36]	; 0x24
   23ff8:	2200      	movs	r2, #0
   23ffa:	6062      	str	r2, [r4, #4]
   23ffc:	3204      	adds	r2, #4
   23ffe:	0011      	movs	r1, r2
   24000:	3114      	adds	r1, #20
   24002:	4299      	cmp	r1, r3
   24004:	d95f      	bls.n	240c6 <_dtoa_r+0x312>
   24006:	6861      	ldr	r1, [r4, #4]
   24008:	9804      	ldr	r0, [sp, #16]
   2400a:	f000 fef0 	bl	24dee <_Balloc>
   2400e:	9b04      	ldr	r3, [sp, #16]
   24010:	6020      	str	r0, [r4, #0]
   24012:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   24014:	681b      	ldr	r3, [r3, #0]
   24016:	930a      	str	r3, [sp, #40]	; 0x28
   24018:	2f0e      	cmp	r7, #14
   2401a:	d900      	bls.n	2401e <_dtoa_r+0x26a>
   2401c:	e105      	b.n	2422a <_dtoa_r+0x476>
   2401e:	2d00      	cmp	r5, #0
   24020:	d100      	bne.n	24024 <_dtoa_r+0x270>
   24022:	e102      	b.n	2422a <_dtoa_r+0x476>
   24024:	9b06      	ldr	r3, [sp, #24]
   24026:	9c07      	ldr	r4, [sp, #28]
   24028:	9314      	str	r3, [sp, #80]	; 0x50
   2402a:	9415      	str	r4, [sp, #84]	; 0x54
   2402c:	9b03      	ldr	r3, [sp, #12]
   2402e:	2b00      	cmp	r3, #0
   24030:	dc00      	bgt.n	24034 <_dtoa_r+0x280>
   24032:	e085      	b.n	24140 <_dtoa_r+0x38c>
   24034:	001a      	movs	r2, r3
   24036:	210f      	movs	r1, #15
   24038:	4b3c      	ldr	r3, [pc, #240]	; (2412c <_dtoa_r+0x378>)
   2403a:	400a      	ands	r2, r1
   2403c:	00d2      	lsls	r2, r2, #3
   2403e:	189b      	adds	r3, r3, r2
   24040:	685c      	ldr	r4, [r3, #4]
   24042:	681b      	ldr	r3, [r3, #0]
   24044:	9310      	str	r3, [sp, #64]	; 0x40
   24046:	9411      	str	r4, [sp, #68]	; 0x44
   24048:	9b03      	ldr	r3, [sp, #12]
   2404a:	2402      	movs	r4, #2
   2404c:	111d      	asrs	r5, r3, #4
   2404e:	06eb      	lsls	r3, r5, #27
   24050:	d50a      	bpl.n	24068 <_dtoa_r+0x2b4>
   24052:	4b3a      	ldr	r3, [pc, #232]	; (2413c <_dtoa_r+0x388>)
   24054:	400d      	ands	r5, r1
   24056:	6a1a      	ldr	r2, [r3, #32]
   24058:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   2405a:	9814      	ldr	r0, [sp, #80]	; 0x50
   2405c:	9915      	ldr	r1, [sp, #84]	; 0x54
   2405e:	f003 f86d 	bl	2713c <__aeabi_ddiv>
   24062:	9006      	str	r0, [sp, #24]
   24064:	9107      	str	r1, [sp, #28]
   24066:	3401      	adds	r4, #1
   24068:	4e34      	ldr	r6, [pc, #208]	; (2413c <_dtoa_r+0x388>)
   2406a:	2d00      	cmp	r5, #0
   2406c:	d130      	bne.n	240d0 <_dtoa_r+0x31c>
   2406e:	9a10      	ldr	r2, [sp, #64]	; 0x40
   24070:	9b11      	ldr	r3, [sp, #68]	; 0x44
   24072:	9806      	ldr	r0, [sp, #24]
   24074:	9907      	ldr	r1, [sp, #28]
   24076:	f003 f861 	bl	2713c <__aeabi_ddiv>
   2407a:	9006      	str	r0, [sp, #24]
   2407c:	9107      	str	r1, [sp, #28]
   2407e:	e07a      	b.n	24176 <_dtoa_r+0x3c2>
   24080:	2301      	movs	r3, #1
   24082:	9a23      	ldr	r2, [sp, #140]	; 0x8c
   24084:	930e      	str	r3, [sp, #56]	; 0x38
   24086:	4694      	mov	ip, r2
   24088:	9b03      	ldr	r3, [sp, #12]
   2408a:	4463      	add	r3, ip
   2408c:	1c5f      	adds	r7, r3, #1
   2408e:	930d      	str	r3, [sp, #52]	; 0x34
   24090:	1e3b      	subs	r3, r7, #0
   24092:	dcaf      	bgt.n	23ff4 <_dtoa_r+0x240>
   24094:	2301      	movs	r3, #1
   24096:	e7ad      	b.n	23ff4 <_dtoa_r+0x240>
   24098:	2300      	movs	r3, #0
   2409a:	e7a5      	b.n	23fe8 <_dtoa_r+0x234>
   2409c:	2300      	movs	r3, #0
   2409e:	e7f0      	b.n	24082 <_dtoa_r+0x2ce>
   240a0:	2300      	movs	r3, #0
   240a2:	950e      	str	r5, [sp, #56]	; 0x38
   240a4:	9322      	str	r3, [sp, #136]	; 0x88
   240a6:	3b01      	subs	r3, #1
   240a8:	2200      	movs	r2, #0
   240aa:	930d      	str	r3, [sp, #52]	; 0x34
   240ac:	001f      	movs	r7, r3
   240ae:	3313      	adds	r3, #19
   240b0:	9223      	str	r2, [sp, #140]	; 0x8c
   240b2:	e79f      	b.n	23ff4 <_dtoa_r+0x240>
   240b4:	2301      	movs	r3, #1
   240b6:	930e      	str	r3, [sp, #56]	; 0x38
   240b8:	3b02      	subs	r3, #2
   240ba:	e7f5      	b.n	240a8 <_dtoa_r+0x2f4>
   240bc:	2301      	movs	r3, #1
   240be:	930d      	str	r3, [sp, #52]	; 0x34
   240c0:	001f      	movs	r7, r3
   240c2:	001a      	movs	r2, r3
   240c4:	e7f4      	b.n	240b0 <_dtoa_r+0x2fc>
   240c6:	6861      	ldr	r1, [r4, #4]
   240c8:	0052      	lsls	r2, r2, #1
   240ca:	3101      	adds	r1, #1
   240cc:	6061      	str	r1, [r4, #4]
   240ce:	e796      	b.n	23ffe <_dtoa_r+0x24a>
   240d0:	2301      	movs	r3, #1
   240d2:	421d      	tst	r5, r3
   240d4:	d008      	beq.n	240e8 <_dtoa_r+0x334>
   240d6:	9810      	ldr	r0, [sp, #64]	; 0x40
   240d8:	9911      	ldr	r1, [sp, #68]	; 0x44
   240da:	18e4      	adds	r4, r4, r3
   240dc:	6832      	ldr	r2, [r6, #0]
   240de:	6873      	ldr	r3, [r6, #4]
   240e0:	f003 fc60 	bl	279a4 <__aeabi_dmul>
   240e4:	9010      	str	r0, [sp, #64]	; 0x40
   240e6:	9111      	str	r1, [sp, #68]	; 0x44
   240e8:	106d      	asrs	r5, r5, #1
   240ea:	3608      	adds	r6, #8
   240ec:	e7bd      	b.n	2406a <_dtoa_r+0x2b6>
   240ee:	46c0      	nop			; (mov r8, r8)
   240f0:	7ff00000 	.word	0x7ff00000
   240f4:	0000270f 	.word	0x0000270f
   240f8:	0002b6ab 	.word	0x0002b6ab
   240fc:	0002b6ae 	.word	0x0002b6ae
   24100:	000296f8 	.word	0x000296f8
   24104:	000296f9 	.word	0x000296f9
   24108:	3ff00000 	.word	0x3ff00000
   2410c:	fffffc01 	.word	0xfffffc01
   24110:	3ff80000 	.word	0x3ff80000
   24114:	636f4361 	.word	0x636f4361
   24118:	3fd287a7 	.word	0x3fd287a7
   2411c:	8b60c8b3 	.word	0x8b60c8b3
   24120:	3fc68a28 	.word	0x3fc68a28
   24124:	509f79fb 	.word	0x509f79fb
   24128:	3fd34413 	.word	0x3fd34413
   2412c:	0002b740 	.word	0x0002b740
   24130:	00000432 	.word	0x00000432
   24134:	00000412 	.word	0x00000412
   24138:	fe100000 	.word	0xfe100000
   2413c:	0002b718 	.word	0x0002b718
   24140:	9b03      	ldr	r3, [sp, #12]
   24142:	2402      	movs	r4, #2
   24144:	2b00      	cmp	r3, #0
   24146:	d016      	beq.n	24176 <_dtoa_r+0x3c2>
   24148:	9814      	ldr	r0, [sp, #80]	; 0x50
   2414a:	9915      	ldr	r1, [sp, #84]	; 0x54
   2414c:	425d      	negs	r5, r3
   2414e:	230f      	movs	r3, #15
   24150:	4aca      	ldr	r2, [pc, #808]	; (2447c <_dtoa_r+0x6c8>)
   24152:	402b      	ands	r3, r5
   24154:	00db      	lsls	r3, r3, #3
   24156:	18d3      	adds	r3, r2, r3
   24158:	681a      	ldr	r2, [r3, #0]
   2415a:	685b      	ldr	r3, [r3, #4]
   2415c:	f003 fc22 	bl	279a4 <__aeabi_dmul>
   24160:	2300      	movs	r3, #0
   24162:	9006      	str	r0, [sp, #24]
   24164:	9107      	str	r1, [sp, #28]
   24166:	4ec6      	ldr	r6, [pc, #792]	; (24480 <_dtoa_r+0x6cc>)
   24168:	112d      	asrs	r5, r5, #4
   2416a:	2d00      	cmp	r5, #0
   2416c:	d000      	beq.n	24170 <_dtoa_r+0x3bc>
   2416e:	e08c      	b.n	2428a <_dtoa_r+0x4d6>
   24170:	2b00      	cmp	r3, #0
   24172:	d000      	beq.n	24176 <_dtoa_r+0x3c2>
   24174:	e781      	b.n	2407a <_dtoa_r+0x2c6>
   24176:	9b16      	ldr	r3, [sp, #88]	; 0x58
   24178:	2b00      	cmp	r3, #0
   2417a:	d100      	bne.n	2417e <_dtoa_r+0x3ca>
   2417c:	e091      	b.n	242a2 <_dtoa_r+0x4ee>
   2417e:	9a06      	ldr	r2, [sp, #24]
   24180:	9b07      	ldr	r3, [sp, #28]
   24182:	9210      	str	r2, [sp, #64]	; 0x40
   24184:	9311      	str	r3, [sp, #68]	; 0x44
   24186:	9810      	ldr	r0, [sp, #64]	; 0x40
   24188:	9911      	ldr	r1, [sp, #68]	; 0x44
   2418a:	2200      	movs	r2, #0
   2418c:	4bbd      	ldr	r3, [pc, #756]	; (24484 <_dtoa_r+0x6d0>)
   2418e:	f001 fd2d 	bl	25bec <__aeabi_dcmplt>
   24192:	2800      	cmp	r0, #0
   24194:	d100      	bne.n	24198 <_dtoa_r+0x3e4>
   24196:	e084      	b.n	242a2 <_dtoa_r+0x4ee>
   24198:	2f00      	cmp	r7, #0
   2419a:	d100      	bne.n	2419e <_dtoa_r+0x3ea>
   2419c:	e081      	b.n	242a2 <_dtoa_r+0x4ee>
   2419e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   241a0:	2b00      	cmp	r3, #0
   241a2:	dd3e      	ble.n	24222 <_dtoa_r+0x46e>
   241a4:	9810      	ldr	r0, [sp, #64]	; 0x40
   241a6:	9911      	ldr	r1, [sp, #68]	; 0x44
   241a8:	9b03      	ldr	r3, [sp, #12]
   241aa:	2200      	movs	r2, #0
   241ac:	1e5e      	subs	r6, r3, #1
   241ae:	4bb6      	ldr	r3, [pc, #728]	; (24488 <_dtoa_r+0x6d4>)
   241b0:	f003 fbf8 	bl	279a4 <__aeabi_dmul>
   241b4:	9006      	str	r0, [sp, #24]
   241b6:	9107      	str	r1, [sp, #28]
   241b8:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   241ba:	3401      	adds	r4, #1
   241bc:	0020      	movs	r0, r4
   241be:	f004 f9db 	bl	28578 <__aeabi_i2d>
   241c2:	9a06      	ldr	r2, [sp, #24]
   241c4:	9b07      	ldr	r3, [sp, #28]
   241c6:	f003 fbed 	bl	279a4 <__aeabi_dmul>
   241ca:	2200      	movs	r2, #0
   241cc:	4baf      	ldr	r3, [pc, #700]	; (2448c <_dtoa_r+0x6d8>)
   241ce:	f002 fca5 	bl	26b1c <__aeabi_dadd>
   241d2:	9012      	str	r0, [sp, #72]	; 0x48
   241d4:	9113      	str	r1, [sp, #76]	; 0x4c
   241d6:	9b12      	ldr	r3, [sp, #72]	; 0x48
   241d8:	9c13      	ldr	r4, [sp, #76]	; 0x4c
   241da:	4aad      	ldr	r2, [pc, #692]	; (24490 <_dtoa_r+0x6dc>)
   241dc:	9310      	str	r3, [sp, #64]	; 0x40
   241de:	9411      	str	r4, [sp, #68]	; 0x44
   241e0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   241e2:	189c      	adds	r4, r3, r2
   241e4:	9411      	str	r4, [sp, #68]	; 0x44
   241e6:	2d00      	cmp	r5, #0
   241e8:	d15e      	bne.n	242a8 <_dtoa_r+0x4f4>
   241ea:	9806      	ldr	r0, [sp, #24]
   241ec:	9907      	ldr	r1, [sp, #28]
   241ee:	2200      	movs	r2, #0
   241f0:	4ba8      	ldr	r3, [pc, #672]	; (24494 <_dtoa_r+0x6e0>)
   241f2:	f003 fe57 	bl	27ea4 <__aeabi_dsub>
   241f6:	9a10      	ldr	r2, [sp, #64]	; 0x40
   241f8:	0023      	movs	r3, r4
   241fa:	9006      	str	r0, [sp, #24]
   241fc:	9107      	str	r1, [sp, #28]
   241fe:	f001 fd09 	bl	25c14 <__aeabi_dcmpgt>
   24202:	2800      	cmp	r0, #0
   24204:	d000      	beq.n	24208 <_dtoa_r+0x454>
   24206:	e301      	b.n	2480c <_dtoa_r+0xa58>
   24208:	48a3      	ldr	r0, [pc, #652]	; (24498 <_dtoa_r+0x6e4>)
   2420a:	9913      	ldr	r1, [sp, #76]	; 0x4c
   2420c:	4684      	mov	ip, r0
   2420e:	4461      	add	r1, ip
   24210:	000b      	movs	r3, r1
   24212:	9806      	ldr	r0, [sp, #24]
   24214:	9907      	ldr	r1, [sp, #28]
   24216:	9a10      	ldr	r2, [sp, #64]	; 0x40
   24218:	f001 fce8 	bl	25bec <__aeabi_dcmplt>
   2421c:	2800      	cmp	r0, #0
   2421e:	d000      	beq.n	24222 <_dtoa_r+0x46e>
   24220:	e2e8      	b.n	247f4 <_dtoa_r+0xa40>
   24222:	9b14      	ldr	r3, [sp, #80]	; 0x50
   24224:	9c15      	ldr	r4, [sp, #84]	; 0x54
   24226:	9306      	str	r3, [sp, #24]
   24228:	9407      	str	r4, [sp, #28]
   2422a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
   2422c:	2b00      	cmp	r3, #0
   2422e:	da00      	bge.n	24232 <_dtoa_r+0x47e>
   24230:	e157      	b.n	244e2 <_dtoa_r+0x72e>
   24232:	9a03      	ldr	r2, [sp, #12]
   24234:	2a0e      	cmp	r2, #14
   24236:	dd00      	ble.n	2423a <_dtoa_r+0x486>
   24238:	e153      	b.n	244e2 <_dtoa_r+0x72e>
   2423a:	4b90      	ldr	r3, [pc, #576]	; (2447c <_dtoa_r+0x6c8>)
   2423c:	00d2      	lsls	r2, r2, #3
   2423e:	189b      	adds	r3, r3, r2
   24240:	685c      	ldr	r4, [r3, #4]
   24242:	681b      	ldr	r3, [r3, #0]
   24244:	9308      	str	r3, [sp, #32]
   24246:	9409      	str	r4, [sp, #36]	; 0x24
   24248:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   2424a:	2b00      	cmp	r3, #0
   2424c:	db00      	blt.n	24250 <_dtoa_r+0x49c>
   2424e:	e0ce      	b.n	243ee <_dtoa_r+0x63a>
   24250:	2f00      	cmp	r7, #0
   24252:	dd00      	ble.n	24256 <_dtoa_r+0x4a2>
   24254:	e0cb      	b.n	243ee <_dtoa_r+0x63a>
   24256:	d000      	beq.n	2425a <_dtoa_r+0x4a6>
   24258:	e2cf      	b.n	247fa <_dtoa_r+0xa46>
   2425a:	9808      	ldr	r0, [sp, #32]
   2425c:	9909      	ldr	r1, [sp, #36]	; 0x24
   2425e:	2200      	movs	r2, #0
   24260:	4b8c      	ldr	r3, [pc, #560]	; (24494 <_dtoa_r+0x6e0>)
   24262:	f003 fb9f 	bl	279a4 <__aeabi_dmul>
   24266:	9a06      	ldr	r2, [sp, #24]
   24268:	9b07      	ldr	r3, [sp, #28]
   2426a:	f001 fcdd 	bl	25c28 <__aeabi_dcmpge>
   2426e:	003e      	movs	r6, r7
   24270:	9708      	str	r7, [sp, #32]
   24272:	2800      	cmp	r0, #0
   24274:	d000      	beq.n	24278 <_dtoa_r+0x4c4>
   24276:	e2a4      	b.n	247c2 <_dtoa_r+0xa0e>
   24278:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   2427a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   2427c:	1c5d      	adds	r5, r3, #1
   2427e:	2331      	movs	r3, #49	; 0x31
   24280:	7013      	strb	r3, [r2, #0]
   24282:	9b03      	ldr	r3, [sp, #12]
   24284:	3301      	adds	r3, #1
   24286:	9303      	str	r3, [sp, #12]
   24288:	e29f      	b.n	247ca <_dtoa_r+0xa16>
   2428a:	2201      	movs	r2, #1
   2428c:	4215      	tst	r5, r2
   2428e:	d005      	beq.n	2429c <_dtoa_r+0x4e8>
   24290:	18a4      	adds	r4, r4, r2
   24292:	6832      	ldr	r2, [r6, #0]
   24294:	6873      	ldr	r3, [r6, #4]
   24296:	f003 fb85 	bl	279a4 <__aeabi_dmul>
   2429a:	2301      	movs	r3, #1
   2429c:	106d      	asrs	r5, r5, #1
   2429e:	3608      	adds	r6, #8
   242a0:	e763      	b.n	2416a <_dtoa_r+0x3b6>
   242a2:	9e03      	ldr	r6, [sp, #12]
   242a4:	003d      	movs	r5, r7
   242a6:	e789      	b.n	241bc <_dtoa_r+0x408>
   242a8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   242aa:	1e69      	subs	r1, r5, #1
   242ac:	1952      	adds	r2, r2, r5
   242ae:	9217      	str	r2, [sp, #92]	; 0x5c
   242b0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   242b2:	4b72      	ldr	r3, [pc, #456]	; (2447c <_dtoa_r+0x6c8>)
   242b4:	00c9      	lsls	r1, r1, #3
   242b6:	2a00      	cmp	r2, #0
   242b8:	d04a      	beq.n	24350 <_dtoa_r+0x59c>
   242ba:	185b      	adds	r3, r3, r1
   242bc:	681a      	ldr	r2, [r3, #0]
   242be:	685b      	ldr	r3, [r3, #4]
   242c0:	2000      	movs	r0, #0
   242c2:	4976      	ldr	r1, [pc, #472]	; (2449c <_dtoa_r+0x6e8>)
   242c4:	f002 ff3a 	bl	2713c <__aeabi_ddiv>
   242c8:	9a10      	ldr	r2, [sp, #64]	; 0x40
   242ca:	9b11      	ldr	r3, [sp, #68]	; 0x44
   242cc:	f003 fdea 	bl	27ea4 <__aeabi_dsub>
   242d0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   242d2:	9010      	str	r0, [sp, #64]	; 0x40
   242d4:	9111      	str	r1, [sp, #68]	; 0x44
   242d6:	9312      	str	r3, [sp, #72]	; 0x48
   242d8:	9806      	ldr	r0, [sp, #24]
   242da:	9907      	ldr	r1, [sp, #28]
   242dc:	f004 f918 	bl	28510 <__aeabi_d2iz>
   242e0:	0004      	movs	r4, r0
   242e2:	f004 f949 	bl	28578 <__aeabi_i2d>
   242e6:	0002      	movs	r2, r0
   242e8:	000b      	movs	r3, r1
   242ea:	9806      	ldr	r0, [sp, #24]
   242ec:	9907      	ldr	r1, [sp, #28]
   242ee:	f003 fdd9 	bl	27ea4 <__aeabi_dsub>
   242f2:	9b12      	ldr	r3, [sp, #72]	; 0x48
   242f4:	3430      	adds	r4, #48	; 0x30
   242f6:	1c5d      	adds	r5, r3, #1
   242f8:	701c      	strb	r4, [r3, #0]
   242fa:	9a10      	ldr	r2, [sp, #64]	; 0x40
   242fc:	9b11      	ldr	r3, [sp, #68]	; 0x44
   242fe:	9006      	str	r0, [sp, #24]
   24300:	9107      	str	r1, [sp, #28]
   24302:	f001 fc73 	bl	25bec <__aeabi_dcmplt>
   24306:	2800      	cmp	r0, #0
   24308:	d165      	bne.n	243d6 <_dtoa_r+0x622>
   2430a:	9a06      	ldr	r2, [sp, #24]
   2430c:	9b07      	ldr	r3, [sp, #28]
   2430e:	2000      	movs	r0, #0
   24310:	495c      	ldr	r1, [pc, #368]	; (24484 <_dtoa_r+0x6d0>)
   24312:	f003 fdc7 	bl	27ea4 <__aeabi_dsub>
   24316:	9a10      	ldr	r2, [sp, #64]	; 0x40
   24318:	9b11      	ldr	r3, [sp, #68]	; 0x44
   2431a:	f001 fc67 	bl	25bec <__aeabi_dcmplt>
   2431e:	2800      	cmp	r0, #0
   24320:	d000      	beq.n	24324 <_dtoa_r+0x570>
   24322:	e0be      	b.n	244a2 <_dtoa_r+0x6ee>
   24324:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   24326:	429d      	cmp	r5, r3
   24328:	d100      	bne.n	2432c <_dtoa_r+0x578>
   2432a:	e77a      	b.n	24222 <_dtoa_r+0x46e>
   2432c:	9810      	ldr	r0, [sp, #64]	; 0x40
   2432e:	9911      	ldr	r1, [sp, #68]	; 0x44
   24330:	2200      	movs	r2, #0
   24332:	4b55      	ldr	r3, [pc, #340]	; (24488 <_dtoa_r+0x6d4>)
   24334:	f003 fb36 	bl	279a4 <__aeabi_dmul>
   24338:	2200      	movs	r2, #0
   2433a:	9010      	str	r0, [sp, #64]	; 0x40
   2433c:	9111      	str	r1, [sp, #68]	; 0x44
   2433e:	9806      	ldr	r0, [sp, #24]
   24340:	9907      	ldr	r1, [sp, #28]
   24342:	4b51      	ldr	r3, [pc, #324]	; (24488 <_dtoa_r+0x6d4>)
   24344:	f003 fb2e 	bl	279a4 <__aeabi_dmul>
   24348:	9512      	str	r5, [sp, #72]	; 0x48
   2434a:	9006      	str	r0, [sp, #24]
   2434c:	9107      	str	r1, [sp, #28]
   2434e:	e7c3      	b.n	242d8 <_dtoa_r+0x524>
   24350:	1859      	adds	r1, r3, r1
   24352:	6808      	ldr	r0, [r1, #0]
   24354:	6849      	ldr	r1, [r1, #4]
   24356:	9a10      	ldr	r2, [sp, #64]	; 0x40
   24358:	9b11      	ldr	r3, [sp, #68]	; 0x44
   2435a:	f003 fb23 	bl	279a4 <__aeabi_dmul>
   2435e:	9010      	str	r0, [sp, #64]	; 0x40
   24360:	9111      	str	r1, [sp, #68]	; 0x44
   24362:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   24364:	9d17      	ldr	r5, [sp, #92]	; 0x5c
   24366:	9806      	ldr	r0, [sp, #24]
   24368:	9907      	ldr	r1, [sp, #28]
   2436a:	f004 f8d1 	bl	28510 <__aeabi_d2iz>
   2436e:	9012      	str	r0, [sp, #72]	; 0x48
   24370:	f004 f902 	bl	28578 <__aeabi_i2d>
   24374:	0002      	movs	r2, r0
   24376:	000b      	movs	r3, r1
   24378:	9806      	ldr	r0, [sp, #24]
   2437a:	9907      	ldr	r1, [sp, #28]
   2437c:	f003 fd92 	bl	27ea4 <__aeabi_dsub>
   24380:	9b12      	ldr	r3, [sp, #72]	; 0x48
   24382:	9006      	str	r0, [sp, #24]
   24384:	9107      	str	r1, [sp, #28]
   24386:	3330      	adds	r3, #48	; 0x30
   24388:	7023      	strb	r3, [r4, #0]
   2438a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   2438c:	3401      	adds	r4, #1
   2438e:	2200      	movs	r2, #0
   24390:	42a3      	cmp	r3, r4
   24392:	d124      	bne.n	243de <_dtoa_r+0x62a>
   24394:	4b41      	ldr	r3, [pc, #260]	; (2449c <_dtoa_r+0x6e8>)
   24396:	9810      	ldr	r0, [sp, #64]	; 0x40
   24398:	9911      	ldr	r1, [sp, #68]	; 0x44
   2439a:	f002 fbbf 	bl	26b1c <__aeabi_dadd>
   2439e:	0002      	movs	r2, r0
   243a0:	000b      	movs	r3, r1
   243a2:	9806      	ldr	r0, [sp, #24]
   243a4:	9907      	ldr	r1, [sp, #28]
   243a6:	f001 fc35 	bl	25c14 <__aeabi_dcmpgt>
   243aa:	2800      	cmp	r0, #0
   243ac:	d000      	beq.n	243b0 <_dtoa_r+0x5fc>
   243ae:	e078      	b.n	244a2 <_dtoa_r+0x6ee>
   243b0:	9a10      	ldr	r2, [sp, #64]	; 0x40
   243b2:	9b11      	ldr	r3, [sp, #68]	; 0x44
   243b4:	2000      	movs	r0, #0
   243b6:	4939      	ldr	r1, [pc, #228]	; (2449c <_dtoa_r+0x6e8>)
   243b8:	f003 fd74 	bl	27ea4 <__aeabi_dsub>
   243bc:	0002      	movs	r2, r0
   243be:	000b      	movs	r3, r1
   243c0:	9806      	ldr	r0, [sp, #24]
   243c2:	9907      	ldr	r1, [sp, #28]
   243c4:	f001 fc12 	bl	25bec <__aeabi_dcmplt>
   243c8:	2800      	cmp	r0, #0
   243ca:	d100      	bne.n	243ce <_dtoa_r+0x61a>
   243cc:	e729      	b.n	24222 <_dtoa_r+0x46e>
   243ce:	1e6b      	subs	r3, r5, #1
   243d0:	781a      	ldrb	r2, [r3, #0]
   243d2:	2a30      	cmp	r2, #48	; 0x30
   243d4:	d001      	beq.n	243da <_dtoa_r+0x626>
   243d6:	9603      	str	r6, [sp, #12]
   243d8:	e03f      	b.n	2445a <_dtoa_r+0x6a6>
   243da:	001d      	movs	r5, r3
   243dc:	e7f7      	b.n	243ce <_dtoa_r+0x61a>
   243de:	9806      	ldr	r0, [sp, #24]
   243e0:	9907      	ldr	r1, [sp, #28]
   243e2:	4b29      	ldr	r3, [pc, #164]	; (24488 <_dtoa_r+0x6d4>)
   243e4:	f003 fade 	bl	279a4 <__aeabi_dmul>
   243e8:	9006      	str	r0, [sp, #24]
   243ea:	9107      	str	r1, [sp, #28]
   243ec:	e7bb      	b.n	24366 <_dtoa_r+0x5b2>
   243ee:	9e0a      	ldr	r6, [sp, #40]	; 0x28
   243f0:	9a08      	ldr	r2, [sp, #32]
   243f2:	9b09      	ldr	r3, [sp, #36]	; 0x24
   243f4:	9806      	ldr	r0, [sp, #24]
   243f6:	9907      	ldr	r1, [sp, #28]
   243f8:	f002 fea0 	bl	2713c <__aeabi_ddiv>
   243fc:	f004 f888 	bl	28510 <__aeabi_d2iz>
   24400:	0004      	movs	r4, r0
   24402:	f004 f8b9 	bl	28578 <__aeabi_i2d>
   24406:	9a08      	ldr	r2, [sp, #32]
   24408:	9b09      	ldr	r3, [sp, #36]	; 0x24
   2440a:	f003 facb 	bl	279a4 <__aeabi_dmul>
   2440e:	000b      	movs	r3, r1
   24410:	0002      	movs	r2, r0
   24412:	9806      	ldr	r0, [sp, #24]
   24414:	9907      	ldr	r1, [sp, #28]
   24416:	f003 fd45 	bl	27ea4 <__aeabi_dsub>
   2441a:	0023      	movs	r3, r4
   2441c:	3330      	adds	r3, #48	; 0x30
   2441e:	7033      	strb	r3, [r6, #0]
   24420:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   24422:	1c75      	adds	r5, r6, #1
   24424:	1aeb      	subs	r3, r5, r3
   24426:	429f      	cmp	r7, r3
   24428:	d14c      	bne.n	244c4 <_dtoa_r+0x710>
   2442a:	0002      	movs	r2, r0
   2442c:	000b      	movs	r3, r1
   2442e:	f002 fb75 	bl	26b1c <__aeabi_dadd>
   24432:	0006      	movs	r6, r0
   24434:	000f      	movs	r7, r1
   24436:	0002      	movs	r2, r0
   24438:	000b      	movs	r3, r1
   2443a:	9808      	ldr	r0, [sp, #32]
   2443c:	9909      	ldr	r1, [sp, #36]	; 0x24
   2443e:	f001 fbd5 	bl	25bec <__aeabi_dcmplt>
   24442:	2800      	cmp	r0, #0
   24444:	d12c      	bne.n	244a0 <_dtoa_r+0x6ec>
   24446:	9808      	ldr	r0, [sp, #32]
   24448:	9909      	ldr	r1, [sp, #36]	; 0x24
   2444a:	0032      	movs	r2, r6
   2444c:	003b      	movs	r3, r7
   2444e:	f001 fbc7 	bl	25be0 <__aeabi_dcmpeq>
   24452:	2800      	cmp	r0, #0
   24454:	d001      	beq.n	2445a <_dtoa_r+0x6a6>
   24456:	07e3      	lsls	r3, r4, #31
   24458:	d422      	bmi.n	244a0 <_dtoa_r+0x6ec>
   2445a:	9905      	ldr	r1, [sp, #20]
   2445c:	9804      	ldr	r0, [sp, #16]
   2445e:	f000 fcfe 	bl	24e5e <_Bfree>
   24462:	2300      	movs	r3, #0
   24464:	702b      	strb	r3, [r5, #0]
   24466:	9b03      	ldr	r3, [sp, #12]
   24468:	9a24      	ldr	r2, [sp, #144]	; 0x90
   2446a:	3301      	adds	r3, #1
   2446c:	6013      	str	r3, [r2, #0]
   2446e:	9b26      	ldr	r3, [sp, #152]	; 0x98
   24470:	2b00      	cmp	r3, #0
   24472:	d100      	bne.n	24476 <_dtoa_r+0x6c2>
   24474:	e275      	b.n	24962 <_dtoa_r+0xbae>
   24476:	601d      	str	r5, [r3, #0]
   24478:	e273      	b.n	24962 <_dtoa_r+0xbae>
   2447a:	46c0      	nop			; (mov r8, r8)
   2447c:	0002b740 	.word	0x0002b740
   24480:	0002b718 	.word	0x0002b718
   24484:	3ff00000 	.word	0x3ff00000
   24488:	40240000 	.word	0x40240000
   2448c:	401c0000 	.word	0x401c0000
   24490:	fcc00000 	.word	0xfcc00000
   24494:	40140000 	.word	0x40140000
   24498:	7cc00000 	.word	0x7cc00000
   2449c:	3fe00000 	.word	0x3fe00000
   244a0:	9e03      	ldr	r6, [sp, #12]
   244a2:	1e6b      	subs	r3, r5, #1
   244a4:	781a      	ldrb	r2, [r3, #0]
   244a6:	2a39      	cmp	r2, #57	; 0x39
   244a8:	d106      	bne.n	244b8 <_dtoa_r+0x704>
   244aa:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   244ac:	429a      	cmp	r2, r3
   244ae:	d107      	bne.n	244c0 <_dtoa_r+0x70c>
   244b0:	2330      	movs	r3, #48	; 0x30
   244b2:	7013      	strb	r3, [r2, #0]
   244b4:	0013      	movs	r3, r2
   244b6:	3601      	adds	r6, #1
   244b8:	781a      	ldrb	r2, [r3, #0]
   244ba:	3201      	adds	r2, #1
   244bc:	701a      	strb	r2, [r3, #0]
   244be:	e78a      	b.n	243d6 <_dtoa_r+0x622>
   244c0:	001d      	movs	r5, r3
   244c2:	e7ee      	b.n	244a2 <_dtoa_r+0x6ee>
   244c4:	2200      	movs	r2, #0
   244c6:	4bcf      	ldr	r3, [pc, #828]	; (24804 <_dtoa_r+0xa50>)
   244c8:	f003 fa6c 	bl	279a4 <__aeabi_dmul>
   244cc:	2200      	movs	r2, #0
   244ce:	2300      	movs	r3, #0
   244d0:	9006      	str	r0, [sp, #24]
   244d2:	9107      	str	r1, [sp, #28]
   244d4:	002e      	movs	r6, r5
   244d6:	f001 fb83 	bl	25be0 <__aeabi_dcmpeq>
   244da:	2800      	cmp	r0, #0
   244dc:	d100      	bne.n	244e0 <_dtoa_r+0x72c>
   244de:	e787      	b.n	243f0 <_dtoa_r+0x63c>
   244e0:	e7bb      	b.n	2445a <_dtoa_r+0x6a6>
   244e2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   244e4:	2a00      	cmp	r2, #0
   244e6:	d100      	bne.n	244ea <_dtoa_r+0x736>
   244e8:	e087      	b.n	245fa <_dtoa_r+0x846>
   244ea:	9a22      	ldr	r2, [sp, #136]	; 0x88
   244ec:	2a01      	cmp	r2, #1
   244ee:	dc6e      	bgt.n	245ce <_dtoa_r+0x81a>
   244f0:	9a18      	ldr	r2, [sp, #96]	; 0x60
   244f2:	2a00      	cmp	r2, #0
   244f4:	d067      	beq.n	245c6 <_dtoa_r+0x812>
   244f6:	4ac4      	ldr	r2, [pc, #784]	; (24808 <_dtoa_r+0xa54>)
   244f8:	189b      	adds	r3, r3, r2
   244fa:	9d08      	ldr	r5, [sp, #32]
   244fc:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
   244fe:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   24500:	2101      	movs	r1, #1
   24502:	18d2      	adds	r2, r2, r3
   24504:	920b      	str	r2, [sp, #44]	; 0x2c
   24506:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   24508:	9804      	ldr	r0, [sp, #16]
   2450a:	18d3      	adds	r3, r2, r3
   2450c:	930c      	str	r3, [sp, #48]	; 0x30
   2450e:	f000 fd44 	bl	24f9a <__i2b>
   24512:	0006      	movs	r6, r0
   24514:	2c00      	cmp	r4, #0
   24516:	dd0e      	ble.n	24536 <_dtoa_r+0x782>
   24518:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   2451a:	2b00      	cmp	r3, #0
   2451c:	dd0b      	ble.n	24536 <_dtoa_r+0x782>
   2451e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   24520:	0023      	movs	r3, r4
   24522:	4294      	cmp	r4, r2
   24524:	dd00      	ble.n	24528 <_dtoa_r+0x774>
   24526:	0013      	movs	r3, r2
   24528:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   2452a:	1ae4      	subs	r4, r4, r3
   2452c:	1ad2      	subs	r2, r2, r3
   2452e:	920b      	str	r2, [sp, #44]	; 0x2c
   24530:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   24532:	1ad3      	subs	r3, r2, r3
   24534:	930c      	str	r3, [sp, #48]	; 0x30
   24536:	9b08      	ldr	r3, [sp, #32]
   24538:	2b00      	cmp	r3, #0
   2453a:	d01e      	beq.n	2457a <_dtoa_r+0x7c6>
   2453c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   2453e:	2b00      	cmp	r3, #0
   24540:	d05f      	beq.n	24602 <_dtoa_r+0x84e>
   24542:	2d00      	cmp	r5, #0
   24544:	dd11      	ble.n	2456a <_dtoa_r+0x7b6>
   24546:	0031      	movs	r1, r6
   24548:	002a      	movs	r2, r5
   2454a:	9804      	ldr	r0, [sp, #16]
   2454c:	f000 fdbe 	bl	250cc <__pow5mult>
   24550:	9a05      	ldr	r2, [sp, #20]
   24552:	0001      	movs	r1, r0
   24554:	0006      	movs	r6, r0
   24556:	9804      	ldr	r0, [sp, #16]
   24558:	f000 fd28 	bl	24fac <__multiply>
   2455c:	9905      	ldr	r1, [sp, #20]
   2455e:	9010      	str	r0, [sp, #64]	; 0x40
   24560:	9804      	ldr	r0, [sp, #16]
   24562:	f000 fc7c 	bl	24e5e <_Bfree>
   24566:	9b10      	ldr	r3, [sp, #64]	; 0x40
   24568:	9305      	str	r3, [sp, #20]
   2456a:	9b08      	ldr	r3, [sp, #32]
   2456c:	1b5a      	subs	r2, r3, r5
   2456e:	d004      	beq.n	2457a <_dtoa_r+0x7c6>
   24570:	9905      	ldr	r1, [sp, #20]
   24572:	9804      	ldr	r0, [sp, #16]
   24574:	f000 fdaa 	bl	250cc <__pow5mult>
   24578:	9005      	str	r0, [sp, #20]
   2457a:	2101      	movs	r1, #1
   2457c:	9804      	ldr	r0, [sp, #16]
   2457e:	f000 fd0c 	bl	24f9a <__i2b>
   24582:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   24584:	9008      	str	r0, [sp, #32]
   24586:	2b00      	cmp	r3, #0
   24588:	dd3d      	ble.n	24606 <_dtoa_r+0x852>
   2458a:	001a      	movs	r2, r3
   2458c:	0001      	movs	r1, r0
   2458e:	9804      	ldr	r0, [sp, #16]
   24590:	f000 fd9c 	bl	250cc <__pow5mult>
   24594:	9b22      	ldr	r3, [sp, #136]	; 0x88
   24596:	9008      	str	r0, [sp, #32]
   24598:	2500      	movs	r5, #0
   2459a:	2b01      	cmp	r3, #1
   2459c:	dc3b      	bgt.n	24616 <_dtoa_r+0x862>
   2459e:	2500      	movs	r5, #0
   245a0:	9b06      	ldr	r3, [sp, #24]
   245a2:	42ab      	cmp	r3, r5
   245a4:	d133      	bne.n	2460e <_dtoa_r+0x85a>
   245a6:	9b07      	ldr	r3, [sp, #28]
   245a8:	031b      	lsls	r3, r3, #12
   245aa:	42ab      	cmp	r3, r5
   245ac:	d12f      	bne.n	2460e <_dtoa_r+0x85a>
   245ae:	9b19      	ldr	r3, [sp, #100]	; 0x64
   245b0:	9a07      	ldr	r2, [sp, #28]
   245b2:	4213      	tst	r3, r2
   245b4:	d02b      	beq.n	2460e <_dtoa_r+0x85a>
   245b6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   245b8:	3501      	adds	r5, #1
   245ba:	3301      	adds	r3, #1
   245bc:	930b      	str	r3, [sp, #44]	; 0x2c
   245be:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   245c0:	3301      	adds	r3, #1
   245c2:	930c      	str	r3, [sp, #48]	; 0x30
   245c4:	e023      	b.n	2460e <_dtoa_r+0x85a>
   245c6:	2336      	movs	r3, #54	; 0x36
   245c8:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   245ca:	1a9b      	subs	r3, r3, r2
   245cc:	e795      	b.n	244fa <_dtoa_r+0x746>
   245ce:	9b08      	ldr	r3, [sp, #32]
   245d0:	1e7d      	subs	r5, r7, #1
   245d2:	42ab      	cmp	r3, r5
   245d4:	db06      	blt.n	245e4 <_dtoa_r+0x830>
   245d6:	1b5d      	subs	r5, r3, r5
   245d8:	2f00      	cmp	r7, #0
   245da:	da0b      	bge.n	245f4 <_dtoa_r+0x840>
   245dc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   245de:	1bdc      	subs	r4, r3, r7
   245e0:	2300      	movs	r3, #0
   245e2:	e78c      	b.n	244fe <_dtoa_r+0x74a>
   245e4:	9b08      	ldr	r3, [sp, #32]
   245e6:	9508      	str	r5, [sp, #32]
   245e8:	1aea      	subs	r2, r5, r3
   245ea:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   245ec:	2500      	movs	r5, #0
   245ee:	189b      	adds	r3, r3, r2
   245f0:	930f      	str	r3, [sp, #60]	; 0x3c
   245f2:	e7f1      	b.n	245d8 <_dtoa_r+0x824>
   245f4:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
   245f6:	003b      	movs	r3, r7
   245f8:	e781      	b.n	244fe <_dtoa_r+0x74a>
   245fa:	9d08      	ldr	r5, [sp, #32]
   245fc:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
   245fe:	9e0e      	ldr	r6, [sp, #56]	; 0x38
   24600:	e788      	b.n	24514 <_dtoa_r+0x760>
   24602:	9a08      	ldr	r2, [sp, #32]
   24604:	e7b4      	b.n	24570 <_dtoa_r+0x7bc>
   24606:	9b22      	ldr	r3, [sp, #136]	; 0x88
   24608:	2500      	movs	r5, #0
   2460a:	2b01      	cmp	r3, #1
   2460c:	ddc7      	ble.n	2459e <_dtoa_r+0x7ea>
   2460e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   24610:	2001      	movs	r0, #1
   24612:	2b00      	cmp	r3, #0
   24614:	d00b      	beq.n	2462e <_dtoa_r+0x87a>
   24616:	9b08      	ldr	r3, [sp, #32]
   24618:	9a08      	ldr	r2, [sp, #32]
   2461a:	691b      	ldr	r3, [r3, #16]
   2461c:	930f      	str	r3, [sp, #60]	; 0x3c
   2461e:	3303      	adds	r3, #3
   24620:	009b      	lsls	r3, r3, #2
   24622:	18d3      	adds	r3, r2, r3
   24624:	6858      	ldr	r0, [r3, #4]
   24626:	f000 fc6f 	bl	24f08 <__hi0bits>
   2462a:	2320      	movs	r3, #32
   2462c:	1a18      	subs	r0, r3, r0
   2462e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   24630:	18c0      	adds	r0, r0, r3
   24632:	231f      	movs	r3, #31
   24634:	4018      	ands	r0, r3
   24636:	d100      	bne.n	2463a <_dtoa_r+0x886>
   24638:	e0ab      	b.n	24792 <_dtoa_r+0x9de>
   2463a:	3301      	adds	r3, #1
   2463c:	1a1b      	subs	r3, r3, r0
   2463e:	2b04      	cmp	r3, #4
   24640:	dc00      	bgt.n	24644 <_dtoa_r+0x890>
   24642:	e09b      	b.n	2477c <_dtoa_r+0x9c8>
   24644:	231c      	movs	r3, #28
   24646:	1a18      	subs	r0, r3, r0
   24648:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   2464a:	1824      	adds	r4, r4, r0
   2464c:	181b      	adds	r3, r3, r0
   2464e:	930b      	str	r3, [sp, #44]	; 0x2c
   24650:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   24652:	181b      	adds	r3, r3, r0
   24654:	930c      	str	r3, [sp, #48]	; 0x30
   24656:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   24658:	2b00      	cmp	r3, #0
   2465a:	dd05      	ble.n	24668 <_dtoa_r+0x8b4>
   2465c:	001a      	movs	r2, r3
   2465e:	9905      	ldr	r1, [sp, #20]
   24660:	9804      	ldr	r0, [sp, #16]
   24662:	f000 fd85 	bl	25170 <__lshift>
   24666:	9005      	str	r0, [sp, #20]
   24668:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   2466a:	2b00      	cmp	r3, #0
   2466c:	dd05      	ble.n	2467a <_dtoa_r+0x8c6>
   2466e:	001a      	movs	r2, r3
   24670:	9908      	ldr	r1, [sp, #32]
   24672:	9804      	ldr	r0, [sp, #16]
   24674:	f000 fd7c 	bl	25170 <__lshift>
   24678:	9008      	str	r0, [sp, #32]
   2467a:	9b16      	ldr	r3, [sp, #88]	; 0x58
   2467c:	2b00      	cmp	r3, #0
   2467e:	d100      	bne.n	24682 <_dtoa_r+0x8ce>
   24680:	e089      	b.n	24796 <_dtoa_r+0x9e2>
   24682:	9908      	ldr	r1, [sp, #32]
   24684:	9805      	ldr	r0, [sp, #20]
   24686:	f000 fdc4 	bl	25212 <__mcmp>
   2468a:	2800      	cmp	r0, #0
   2468c:	db00      	blt.n	24690 <_dtoa_r+0x8dc>
   2468e:	e082      	b.n	24796 <_dtoa_r+0x9e2>
   24690:	9b03      	ldr	r3, [sp, #12]
   24692:	220a      	movs	r2, #10
   24694:	3b01      	subs	r3, #1
   24696:	9303      	str	r3, [sp, #12]
   24698:	9905      	ldr	r1, [sp, #20]
   2469a:	2300      	movs	r3, #0
   2469c:	9804      	ldr	r0, [sp, #16]
   2469e:	f000 fbf7 	bl	24e90 <__multadd>
   246a2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   246a4:	9005      	str	r0, [sp, #20]
   246a6:	2b00      	cmp	r3, #0
   246a8:	d100      	bne.n	246ac <_dtoa_r+0x8f8>
   246aa:	e15d      	b.n	24968 <_dtoa_r+0xbb4>
   246ac:	2300      	movs	r3, #0
   246ae:	0031      	movs	r1, r6
   246b0:	220a      	movs	r2, #10
   246b2:	9804      	ldr	r0, [sp, #16]
   246b4:	f000 fbec 	bl	24e90 <__multadd>
   246b8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   246ba:	0006      	movs	r6, r0
   246bc:	2b00      	cmp	r3, #0
   246be:	dc02      	bgt.n	246c6 <_dtoa_r+0x912>
   246c0:	9b22      	ldr	r3, [sp, #136]	; 0x88
   246c2:	2b02      	cmp	r3, #2
   246c4:	dc6d      	bgt.n	247a2 <_dtoa_r+0x9ee>
   246c6:	2c00      	cmp	r4, #0
   246c8:	dd05      	ble.n	246d6 <_dtoa_r+0x922>
   246ca:	0031      	movs	r1, r6
   246cc:	0022      	movs	r2, r4
   246ce:	9804      	ldr	r0, [sp, #16]
   246d0:	f000 fd4e 	bl	25170 <__lshift>
   246d4:	0006      	movs	r6, r0
   246d6:	0030      	movs	r0, r6
   246d8:	2d00      	cmp	r5, #0
   246da:	d011      	beq.n	24700 <_dtoa_r+0x94c>
   246dc:	6871      	ldr	r1, [r6, #4]
   246de:	9804      	ldr	r0, [sp, #16]
   246e0:	f000 fb85 	bl	24dee <_Balloc>
   246e4:	0031      	movs	r1, r6
   246e6:	0004      	movs	r4, r0
   246e8:	6933      	ldr	r3, [r6, #16]
   246ea:	310c      	adds	r1, #12
   246ec:	1c9a      	adds	r2, r3, #2
   246ee:	0092      	lsls	r2, r2, #2
   246f0:	300c      	adds	r0, #12
   246f2:	f7fe fa8d 	bl	22c10 <memcpy>
   246f6:	2201      	movs	r2, #1
   246f8:	0021      	movs	r1, r4
   246fa:	9804      	ldr	r0, [sp, #16]
   246fc:	f000 fd38 	bl	25170 <__lshift>
   24700:	9f0d      	ldr	r7, [sp, #52]	; 0x34
   24702:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   24704:	3f01      	subs	r7, #1
   24706:	930b      	str	r3, [sp, #44]	; 0x2c
   24708:	19db      	adds	r3, r3, r7
   2470a:	0037      	movs	r7, r6
   2470c:	0006      	movs	r6, r0
   2470e:	930f      	str	r3, [sp, #60]	; 0x3c
   24710:	9908      	ldr	r1, [sp, #32]
   24712:	9805      	ldr	r0, [sp, #20]
   24714:	f7ff faca 	bl	23cac <quorem>
   24718:	0039      	movs	r1, r7
   2471a:	900d      	str	r0, [sp, #52]	; 0x34
   2471c:	0004      	movs	r4, r0
   2471e:	9805      	ldr	r0, [sp, #20]
   24720:	f000 fd77 	bl	25212 <__mcmp>
   24724:	0032      	movs	r2, r6
   24726:	900e      	str	r0, [sp, #56]	; 0x38
   24728:	9908      	ldr	r1, [sp, #32]
   2472a:	9804      	ldr	r0, [sp, #16]
   2472c:	f000 fd8a 	bl	25244 <__mdiff>
   24730:	2301      	movs	r3, #1
   24732:	930c      	str	r3, [sp, #48]	; 0x30
   24734:	68c3      	ldr	r3, [r0, #12]
   24736:	3430      	adds	r4, #48	; 0x30
   24738:	0005      	movs	r5, r0
   2473a:	2b00      	cmp	r3, #0
   2473c:	d104      	bne.n	24748 <_dtoa_r+0x994>
   2473e:	0001      	movs	r1, r0
   24740:	9805      	ldr	r0, [sp, #20]
   24742:	f000 fd66 	bl	25212 <__mcmp>
   24746:	900c      	str	r0, [sp, #48]	; 0x30
   24748:	0029      	movs	r1, r5
   2474a:	9804      	ldr	r0, [sp, #16]
   2474c:	f000 fb87 	bl	24e5e <_Bfree>
   24750:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   24752:	9a22      	ldr	r2, [sp, #136]	; 0x88
   24754:	4313      	orrs	r3, r2
   24756:	d000      	beq.n	2475a <_dtoa_r+0x9a6>
   24758:	e089      	b.n	2486e <_dtoa_r+0xaba>
   2475a:	9a06      	ldr	r2, [sp, #24]
   2475c:	3301      	adds	r3, #1
   2475e:	4213      	tst	r3, r2
   24760:	d000      	beq.n	24764 <_dtoa_r+0x9b0>
   24762:	e084      	b.n	2486e <_dtoa_r+0xaba>
   24764:	2c39      	cmp	r4, #57	; 0x39
   24766:	d100      	bne.n	2476a <_dtoa_r+0x9b6>
   24768:	e0a3      	b.n	248b2 <_dtoa_r+0xafe>
   2476a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   2476c:	2b00      	cmp	r3, #0
   2476e:	dd01      	ble.n	24774 <_dtoa_r+0x9c0>
   24770:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   24772:	3431      	adds	r4, #49	; 0x31
   24774:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   24776:	1c5d      	adds	r5, r3, #1
   24778:	701c      	strb	r4, [r3, #0]
   2477a:	e027      	b.n	247cc <_dtoa_r+0xa18>
   2477c:	2b04      	cmp	r3, #4
   2477e:	d100      	bne.n	24782 <_dtoa_r+0x9ce>
   24780:	e769      	b.n	24656 <_dtoa_r+0x8a2>
   24782:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   24784:	331c      	adds	r3, #28
   24786:	18d2      	adds	r2, r2, r3
   24788:	920b      	str	r2, [sp, #44]	; 0x2c
   2478a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   2478c:	18e4      	adds	r4, r4, r3
   2478e:	18d3      	adds	r3, r2, r3
   24790:	e760      	b.n	24654 <_dtoa_r+0x8a0>
   24792:	0003      	movs	r3, r0
   24794:	e7f5      	b.n	24782 <_dtoa_r+0x9ce>
   24796:	2f00      	cmp	r7, #0
   24798:	dc3c      	bgt.n	24814 <_dtoa_r+0xa60>
   2479a:	9b22      	ldr	r3, [sp, #136]	; 0x88
   2479c:	2b02      	cmp	r3, #2
   2479e:	dd39      	ble.n	24814 <_dtoa_r+0xa60>
   247a0:	970d      	str	r7, [sp, #52]	; 0x34
   247a2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   247a4:	2b00      	cmp	r3, #0
   247a6:	d10c      	bne.n	247c2 <_dtoa_r+0xa0e>
   247a8:	9908      	ldr	r1, [sp, #32]
   247aa:	2205      	movs	r2, #5
   247ac:	9804      	ldr	r0, [sp, #16]
   247ae:	f000 fb6f 	bl	24e90 <__multadd>
   247b2:	9008      	str	r0, [sp, #32]
   247b4:	0001      	movs	r1, r0
   247b6:	9805      	ldr	r0, [sp, #20]
   247b8:	f000 fd2b 	bl	25212 <__mcmp>
   247bc:	2800      	cmp	r0, #0
   247be:	dd00      	ble.n	247c2 <_dtoa_r+0xa0e>
   247c0:	e55a      	b.n	24278 <_dtoa_r+0x4c4>
   247c2:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   247c4:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   247c6:	43db      	mvns	r3, r3
   247c8:	9303      	str	r3, [sp, #12]
   247ca:	2700      	movs	r7, #0
   247cc:	9908      	ldr	r1, [sp, #32]
   247ce:	9804      	ldr	r0, [sp, #16]
   247d0:	f000 fb45 	bl	24e5e <_Bfree>
   247d4:	2e00      	cmp	r6, #0
   247d6:	d100      	bne.n	247da <_dtoa_r+0xa26>
   247d8:	e63f      	b.n	2445a <_dtoa_r+0x6a6>
   247da:	2f00      	cmp	r7, #0
   247dc:	d005      	beq.n	247ea <_dtoa_r+0xa36>
   247de:	42b7      	cmp	r7, r6
   247e0:	d003      	beq.n	247ea <_dtoa_r+0xa36>
   247e2:	0039      	movs	r1, r7
   247e4:	9804      	ldr	r0, [sp, #16]
   247e6:	f000 fb3a 	bl	24e5e <_Bfree>
   247ea:	0031      	movs	r1, r6
   247ec:	9804      	ldr	r0, [sp, #16]
   247ee:	f000 fb36 	bl	24e5e <_Bfree>
   247f2:	e632      	b.n	2445a <_dtoa_r+0x6a6>
   247f4:	9508      	str	r5, [sp, #32]
   247f6:	002e      	movs	r6, r5
   247f8:	e7e3      	b.n	247c2 <_dtoa_r+0xa0e>
   247fa:	2300      	movs	r3, #0
   247fc:	9308      	str	r3, [sp, #32]
   247fe:	001e      	movs	r6, r3
   24800:	e7df      	b.n	247c2 <_dtoa_r+0xa0e>
   24802:	46c0      	nop			; (mov r8, r8)
   24804:	40240000 	.word	0x40240000
   24808:	00000433 	.word	0x00000433
   2480c:	9603      	str	r6, [sp, #12]
   2480e:	9508      	str	r5, [sp, #32]
   24810:	002e      	movs	r6, r5
   24812:	e531      	b.n	24278 <_dtoa_r+0x4c4>
   24814:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   24816:	970d      	str	r7, [sp, #52]	; 0x34
   24818:	2b00      	cmp	r3, #0
   2481a:	d000      	beq.n	2481e <_dtoa_r+0xa6a>
   2481c:	e753      	b.n	246c6 <_dtoa_r+0x912>
   2481e:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   24820:	9908      	ldr	r1, [sp, #32]
   24822:	9805      	ldr	r0, [sp, #20]
   24824:	f7ff fa42 	bl	23cac <quorem>
   24828:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   2482a:	3030      	adds	r0, #48	; 0x30
   2482c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   2482e:	7028      	strb	r0, [r5, #0]
   24830:	3501      	adds	r5, #1
   24832:	0004      	movs	r4, r0
   24834:	1aeb      	subs	r3, r5, r3
   24836:	429a      	cmp	r2, r3
   24838:	dc78      	bgt.n	2492c <_dtoa_r+0xb78>
   2483a:	1e15      	subs	r5, r2, #0
   2483c:	dc00      	bgt.n	24840 <_dtoa_r+0xa8c>
   2483e:	2501      	movs	r5, #1
   24840:	2700      	movs	r7, #0
   24842:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   24844:	195d      	adds	r5, r3, r5
   24846:	9905      	ldr	r1, [sp, #20]
   24848:	2201      	movs	r2, #1
   2484a:	9804      	ldr	r0, [sp, #16]
   2484c:	f000 fc90 	bl	25170 <__lshift>
   24850:	9908      	ldr	r1, [sp, #32]
   24852:	9005      	str	r0, [sp, #20]
   24854:	f000 fcdd 	bl	25212 <__mcmp>
   24858:	2800      	cmp	r0, #0
   2485a:	dc2f      	bgt.n	248bc <_dtoa_r+0xb08>
   2485c:	d101      	bne.n	24862 <_dtoa_r+0xaae>
   2485e:	07e3      	lsls	r3, r4, #31
   24860:	d42c      	bmi.n	248bc <_dtoa_r+0xb08>
   24862:	1e6b      	subs	r3, r5, #1
   24864:	781a      	ldrb	r2, [r3, #0]
   24866:	2a30      	cmp	r2, #48	; 0x30
   24868:	d1b0      	bne.n	247cc <_dtoa_r+0xa18>
   2486a:	001d      	movs	r5, r3
   2486c:	e7f9      	b.n	24862 <_dtoa_r+0xaae>
   2486e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   24870:	2b00      	cmp	r3, #0
   24872:	db07      	blt.n	24884 <_dtoa_r+0xad0>
   24874:	001d      	movs	r5, r3
   24876:	9b22      	ldr	r3, [sp, #136]	; 0x88
   24878:	431d      	orrs	r5, r3
   2487a:	d126      	bne.n	248ca <_dtoa_r+0xb16>
   2487c:	2301      	movs	r3, #1
   2487e:	9a06      	ldr	r2, [sp, #24]
   24880:	4213      	tst	r3, r2
   24882:	d122      	bne.n	248ca <_dtoa_r+0xb16>
   24884:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   24886:	2b00      	cmp	r3, #0
   24888:	dc00      	bgt.n	2488c <_dtoa_r+0xad8>
   2488a:	e773      	b.n	24774 <_dtoa_r+0x9c0>
   2488c:	9905      	ldr	r1, [sp, #20]
   2488e:	2201      	movs	r2, #1
   24890:	9804      	ldr	r0, [sp, #16]
   24892:	f000 fc6d 	bl	25170 <__lshift>
   24896:	9908      	ldr	r1, [sp, #32]
   24898:	9005      	str	r0, [sp, #20]
   2489a:	f000 fcba 	bl	25212 <__mcmp>
   2489e:	2800      	cmp	r0, #0
   248a0:	dc04      	bgt.n	248ac <_dtoa_r+0xaf8>
   248a2:	d000      	beq.n	248a6 <_dtoa_r+0xaf2>
   248a4:	e766      	b.n	24774 <_dtoa_r+0x9c0>
   248a6:	07e3      	lsls	r3, r4, #31
   248a8:	d400      	bmi.n	248ac <_dtoa_r+0xaf8>
   248aa:	e763      	b.n	24774 <_dtoa_r+0x9c0>
   248ac:	2c39      	cmp	r4, #57	; 0x39
   248ae:	d000      	beq.n	248b2 <_dtoa_r+0xafe>
   248b0:	e75e      	b.n	24770 <_dtoa_r+0x9bc>
   248b2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   248b4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   248b6:	1c5d      	adds	r5, r3, #1
   248b8:	2339      	movs	r3, #57	; 0x39
   248ba:	7013      	strb	r3, [r2, #0]
   248bc:	1e6b      	subs	r3, r5, #1
   248be:	781a      	ldrb	r2, [r3, #0]
   248c0:	2a39      	cmp	r2, #57	; 0x39
   248c2:	d03b      	beq.n	2493c <_dtoa_r+0xb88>
   248c4:	3201      	adds	r2, #1
   248c6:	701a      	strb	r2, [r3, #0]
   248c8:	e780      	b.n	247cc <_dtoa_r+0xa18>
   248ca:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   248cc:	3301      	adds	r3, #1
   248ce:	930d      	str	r3, [sp, #52]	; 0x34
   248d0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   248d2:	2b00      	cmp	r3, #0
   248d4:	dd05      	ble.n	248e2 <_dtoa_r+0xb2e>
   248d6:	2c39      	cmp	r4, #57	; 0x39
   248d8:	d0eb      	beq.n	248b2 <_dtoa_r+0xafe>
   248da:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   248dc:	3401      	adds	r4, #1
   248de:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   248e0:	e74a      	b.n	24778 <_dtoa_r+0x9c4>
   248e2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   248e4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   248e6:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   248e8:	701c      	strb	r4, [r3, #0]
   248ea:	4293      	cmp	r3, r2
   248ec:	d0ab      	beq.n	24846 <_dtoa_r+0xa92>
   248ee:	2300      	movs	r3, #0
   248f0:	220a      	movs	r2, #10
   248f2:	9905      	ldr	r1, [sp, #20]
   248f4:	9804      	ldr	r0, [sp, #16]
   248f6:	f000 facb 	bl	24e90 <__multadd>
   248fa:	2300      	movs	r3, #0
   248fc:	9005      	str	r0, [sp, #20]
   248fe:	220a      	movs	r2, #10
   24900:	0039      	movs	r1, r7
   24902:	9804      	ldr	r0, [sp, #16]
   24904:	42b7      	cmp	r7, r6
   24906:	d106      	bne.n	24916 <_dtoa_r+0xb62>
   24908:	f000 fac2 	bl	24e90 <__multadd>
   2490c:	0007      	movs	r7, r0
   2490e:	0006      	movs	r6, r0
   24910:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   24912:	930b      	str	r3, [sp, #44]	; 0x2c
   24914:	e6fc      	b.n	24710 <_dtoa_r+0x95c>
   24916:	f000 fabb 	bl	24e90 <__multadd>
   2491a:	0031      	movs	r1, r6
   2491c:	0007      	movs	r7, r0
   2491e:	2300      	movs	r3, #0
   24920:	220a      	movs	r2, #10
   24922:	9804      	ldr	r0, [sp, #16]
   24924:	f000 fab4 	bl	24e90 <__multadd>
   24928:	0006      	movs	r6, r0
   2492a:	e7f1      	b.n	24910 <_dtoa_r+0xb5c>
   2492c:	2300      	movs	r3, #0
   2492e:	220a      	movs	r2, #10
   24930:	9905      	ldr	r1, [sp, #20]
   24932:	9804      	ldr	r0, [sp, #16]
   24934:	f000 faac 	bl	24e90 <__multadd>
   24938:	9005      	str	r0, [sp, #20]
   2493a:	e771      	b.n	24820 <_dtoa_r+0xa6c>
   2493c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   2493e:	429a      	cmp	r2, r3
   24940:	d105      	bne.n	2494e <_dtoa_r+0xb9a>
   24942:	9b03      	ldr	r3, [sp, #12]
   24944:	3301      	adds	r3, #1
   24946:	9303      	str	r3, [sp, #12]
   24948:	2331      	movs	r3, #49	; 0x31
   2494a:	7013      	strb	r3, [r2, #0]
   2494c:	e73e      	b.n	247cc <_dtoa_r+0xa18>
   2494e:	001d      	movs	r5, r3
   24950:	e7b4      	b.n	248bc <_dtoa_r+0xb08>
   24952:	4b0a      	ldr	r3, [pc, #40]	; (2497c <_dtoa_r+0xbc8>)
   24954:	9a26      	ldr	r2, [sp, #152]	; 0x98
   24956:	930a      	str	r3, [sp, #40]	; 0x28
   24958:	4b09      	ldr	r3, [pc, #36]	; (24980 <_dtoa_r+0xbcc>)
   2495a:	2a00      	cmp	r2, #0
   2495c:	d001      	beq.n	24962 <_dtoa_r+0xbae>
   2495e:	9a26      	ldr	r2, [sp, #152]	; 0x98
   24960:	6013      	str	r3, [r2, #0]
   24962:	980a      	ldr	r0, [sp, #40]	; 0x28
   24964:	b01d      	add	sp, #116	; 0x74
   24966:	bdf0      	pop	{r4, r5, r6, r7, pc}
   24968:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   2496a:	2b00      	cmp	r3, #0
   2496c:	dd00      	ble.n	24970 <_dtoa_r+0xbbc>
   2496e:	e756      	b.n	2481e <_dtoa_r+0xa6a>
   24970:	9b22      	ldr	r3, [sp, #136]	; 0x88
   24972:	2b02      	cmp	r3, #2
   24974:	dc00      	bgt.n	24978 <_dtoa_r+0xbc4>
   24976:	e752      	b.n	2481e <_dtoa_r+0xa6a>
   24978:	e713      	b.n	247a2 <_dtoa_r+0x9ee>
   2497a:	46c0      	nop			; (mov r8, r8)
   2497c:	0002b6a2 	.word	0x0002b6a2
   24980:	0002b6aa 	.word	0x0002b6aa

00024984 <__sflush_r>:
   24984:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   24986:	898a      	ldrh	r2, [r1, #12]
   24988:	0005      	movs	r5, r0
   2498a:	000c      	movs	r4, r1
   2498c:	0713      	lsls	r3, r2, #28
   2498e:	d460      	bmi.n	24a52 <__sflush_r+0xce>
   24990:	684b      	ldr	r3, [r1, #4]
   24992:	2b00      	cmp	r3, #0
   24994:	dc04      	bgt.n	249a0 <__sflush_r+0x1c>
   24996:	6c0b      	ldr	r3, [r1, #64]	; 0x40
   24998:	2b00      	cmp	r3, #0
   2499a:	dc01      	bgt.n	249a0 <__sflush_r+0x1c>
   2499c:	2000      	movs	r0, #0
   2499e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   249a0:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
   249a2:	2f00      	cmp	r7, #0
   249a4:	d0fa      	beq.n	2499c <__sflush_r+0x18>
   249a6:	2300      	movs	r3, #0
   249a8:	682e      	ldr	r6, [r5, #0]
   249aa:	602b      	str	r3, [r5, #0]
   249ac:	2380      	movs	r3, #128	; 0x80
   249ae:	015b      	lsls	r3, r3, #5
   249b0:	401a      	ands	r2, r3
   249b2:	d034      	beq.n	24a1e <__sflush_r+0x9a>
   249b4:	6d60      	ldr	r0, [r4, #84]	; 0x54
   249b6:	89a3      	ldrh	r3, [r4, #12]
   249b8:	075b      	lsls	r3, r3, #29
   249ba:	d506      	bpl.n	249ca <__sflush_r+0x46>
   249bc:	6863      	ldr	r3, [r4, #4]
   249be:	1ac0      	subs	r0, r0, r3
   249c0:	6b63      	ldr	r3, [r4, #52]	; 0x34
   249c2:	2b00      	cmp	r3, #0
   249c4:	d001      	beq.n	249ca <__sflush_r+0x46>
   249c6:	6c23      	ldr	r3, [r4, #64]	; 0x40
   249c8:	1ac0      	subs	r0, r0, r3
   249ca:	0002      	movs	r2, r0
   249cc:	6a21      	ldr	r1, [r4, #32]
   249ce:	2300      	movs	r3, #0
   249d0:	0028      	movs	r0, r5
   249d2:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
   249d4:	47b8      	blx	r7
   249d6:	89a1      	ldrh	r1, [r4, #12]
   249d8:	1c43      	adds	r3, r0, #1
   249da:	d106      	bne.n	249ea <__sflush_r+0x66>
   249dc:	682b      	ldr	r3, [r5, #0]
   249de:	2b1d      	cmp	r3, #29
   249e0:	d831      	bhi.n	24a46 <__sflush_r+0xc2>
   249e2:	4a2c      	ldr	r2, [pc, #176]	; (24a94 <__sflush_r+0x110>)
   249e4:	40da      	lsrs	r2, r3
   249e6:	07d3      	lsls	r3, r2, #31
   249e8:	d52d      	bpl.n	24a46 <__sflush_r+0xc2>
   249ea:	2300      	movs	r3, #0
   249ec:	6063      	str	r3, [r4, #4]
   249ee:	6923      	ldr	r3, [r4, #16]
   249f0:	6023      	str	r3, [r4, #0]
   249f2:	04cb      	lsls	r3, r1, #19
   249f4:	d505      	bpl.n	24a02 <__sflush_r+0x7e>
   249f6:	1c43      	adds	r3, r0, #1
   249f8:	d102      	bne.n	24a00 <__sflush_r+0x7c>
   249fa:	682b      	ldr	r3, [r5, #0]
   249fc:	2b00      	cmp	r3, #0
   249fe:	d100      	bne.n	24a02 <__sflush_r+0x7e>
   24a00:	6560      	str	r0, [r4, #84]	; 0x54
   24a02:	6b61      	ldr	r1, [r4, #52]	; 0x34
   24a04:	602e      	str	r6, [r5, #0]
   24a06:	2900      	cmp	r1, #0
   24a08:	d0c8      	beq.n	2499c <__sflush_r+0x18>
   24a0a:	0023      	movs	r3, r4
   24a0c:	3344      	adds	r3, #68	; 0x44
   24a0e:	4299      	cmp	r1, r3
   24a10:	d002      	beq.n	24a18 <__sflush_r+0x94>
   24a12:	0028      	movs	r0, r5
   24a14:	f7fe f920 	bl	22c58 <_free_r>
   24a18:	2000      	movs	r0, #0
   24a1a:	6360      	str	r0, [r4, #52]	; 0x34
   24a1c:	e7bf      	b.n	2499e <__sflush_r+0x1a>
   24a1e:	2301      	movs	r3, #1
   24a20:	6a21      	ldr	r1, [r4, #32]
   24a22:	0028      	movs	r0, r5
   24a24:	47b8      	blx	r7
   24a26:	1c43      	adds	r3, r0, #1
   24a28:	d1c5      	bne.n	249b6 <__sflush_r+0x32>
   24a2a:	682b      	ldr	r3, [r5, #0]
   24a2c:	2b00      	cmp	r3, #0
   24a2e:	d0c2      	beq.n	249b6 <__sflush_r+0x32>
   24a30:	2b1d      	cmp	r3, #29
   24a32:	d001      	beq.n	24a38 <__sflush_r+0xb4>
   24a34:	2b16      	cmp	r3, #22
   24a36:	d101      	bne.n	24a3c <__sflush_r+0xb8>
   24a38:	602e      	str	r6, [r5, #0]
   24a3a:	e7af      	b.n	2499c <__sflush_r+0x18>
   24a3c:	2340      	movs	r3, #64	; 0x40
   24a3e:	89a2      	ldrh	r2, [r4, #12]
   24a40:	4313      	orrs	r3, r2
   24a42:	81a3      	strh	r3, [r4, #12]
   24a44:	e7ab      	b.n	2499e <__sflush_r+0x1a>
   24a46:	2340      	movs	r3, #64	; 0x40
   24a48:	430b      	orrs	r3, r1
   24a4a:	2001      	movs	r0, #1
   24a4c:	81a3      	strh	r3, [r4, #12]
   24a4e:	4240      	negs	r0, r0
   24a50:	e7a5      	b.n	2499e <__sflush_r+0x1a>
   24a52:	690f      	ldr	r7, [r1, #16]
   24a54:	2f00      	cmp	r7, #0
   24a56:	d0a1      	beq.n	2499c <__sflush_r+0x18>
   24a58:	680b      	ldr	r3, [r1, #0]
   24a5a:	600f      	str	r7, [r1, #0]
   24a5c:	1bdb      	subs	r3, r3, r7
   24a5e:	9301      	str	r3, [sp, #4]
   24a60:	2300      	movs	r3, #0
   24a62:	0792      	lsls	r2, r2, #30
   24a64:	d100      	bne.n	24a68 <__sflush_r+0xe4>
   24a66:	694b      	ldr	r3, [r1, #20]
   24a68:	60a3      	str	r3, [r4, #8]
   24a6a:	9b01      	ldr	r3, [sp, #4]
   24a6c:	2b00      	cmp	r3, #0
   24a6e:	dc00      	bgt.n	24a72 <__sflush_r+0xee>
   24a70:	e794      	b.n	2499c <__sflush_r+0x18>
   24a72:	9b01      	ldr	r3, [sp, #4]
   24a74:	003a      	movs	r2, r7
   24a76:	6a21      	ldr	r1, [r4, #32]
   24a78:	0028      	movs	r0, r5
   24a7a:	6aa6      	ldr	r6, [r4, #40]	; 0x28
   24a7c:	47b0      	blx	r6
   24a7e:	2800      	cmp	r0, #0
   24a80:	dc03      	bgt.n	24a8a <__sflush_r+0x106>
   24a82:	2340      	movs	r3, #64	; 0x40
   24a84:	89a2      	ldrh	r2, [r4, #12]
   24a86:	4313      	orrs	r3, r2
   24a88:	e7df      	b.n	24a4a <__sflush_r+0xc6>
   24a8a:	9b01      	ldr	r3, [sp, #4]
   24a8c:	183f      	adds	r7, r7, r0
   24a8e:	1a1b      	subs	r3, r3, r0
   24a90:	9301      	str	r3, [sp, #4]
   24a92:	e7ea      	b.n	24a6a <__sflush_r+0xe6>
   24a94:	20400001 	.word	0x20400001

00024a98 <_fflush_r>:
   24a98:	690b      	ldr	r3, [r1, #16]
   24a9a:	b570      	push	{r4, r5, r6, lr}
   24a9c:	0005      	movs	r5, r0
   24a9e:	000c      	movs	r4, r1
   24aa0:	2b00      	cmp	r3, #0
   24aa2:	d101      	bne.n	24aa8 <_fflush_r+0x10>
   24aa4:	2000      	movs	r0, #0
   24aa6:	bd70      	pop	{r4, r5, r6, pc}
   24aa8:	2800      	cmp	r0, #0
   24aaa:	d004      	beq.n	24ab6 <_fflush_r+0x1e>
   24aac:	6983      	ldr	r3, [r0, #24]
   24aae:	2b00      	cmp	r3, #0
   24ab0:	d101      	bne.n	24ab6 <_fflush_r+0x1e>
   24ab2:	f000 f85f 	bl	24b74 <__sinit>
   24ab6:	4b0b      	ldr	r3, [pc, #44]	; (24ae4 <_fflush_r+0x4c>)
   24ab8:	429c      	cmp	r4, r3
   24aba:	d109      	bne.n	24ad0 <_fflush_r+0x38>
   24abc:	686c      	ldr	r4, [r5, #4]
   24abe:	220c      	movs	r2, #12
   24ac0:	5ea3      	ldrsh	r3, [r4, r2]
   24ac2:	2b00      	cmp	r3, #0
   24ac4:	d0ee      	beq.n	24aa4 <_fflush_r+0xc>
   24ac6:	0021      	movs	r1, r4
   24ac8:	0028      	movs	r0, r5
   24aca:	f7ff ff5b 	bl	24984 <__sflush_r>
   24ace:	e7ea      	b.n	24aa6 <_fflush_r+0xe>
   24ad0:	4b05      	ldr	r3, [pc, #20]	; (24ae8 <_fflush_r+0x50>)
   24ad2:	429c      	cmp	r4, r3
   24ad4:	d101      	bne.n	24ada <_fflush_r+0x42>
   24ad6:	68ac      	ldr	r4, [r5, #8]
   24ad8:	e7f1      	b.n	24abe <_fflush_r+0x26>
   24ada:	4b04      	ldr	r3, [pc, #16]	; (24aec <_fflush_r+0x54>)
   24adc:	429c      	cmp	r4, r3
   24ade:	d1ee      	bne.n	24abe <_fflush_r+0x26>
   24ae0:	68ec      	ldr	r4, [r5, #12]
   24ae2:	e7ec      	b.n	24abe <_fflush_r+0x26>
   24ae4:	0002b6d0 	.word	0x0002b6d0
   24ae8:	0002b6f0 	.word	0x0002b6f0
   24aec:	0002b6b0 	.word	0x0002b6b0

00024af0 <_cleanup_r>:
   24af0:	b510      	push	{r4, lr}
   24af2:	4902      	ldr	r1, [pc, #8]	; (24afc <_cleanup_r+0xc>)
   24af4:	f000 f8b2 	bl	24c5c <_fwalk_reent>
   24af8:	bd10      	pop	{r4, pc}
   24afa:	46c0      	nop			; (mov r8, r8)
   24afc:	00024a99 	.word	0x00024a99

00024b00 <std.isra.0>:
   24b00:	2300      	movs	r3, #0
   24b02:	b510      	push	{r4, lr}
   24b04:	0004      	movs	r4, r0
   24b06:	6003      	str	r3, [r0, #0]
   24b08:	6043      	str	r3, [r0, #4]
   24b0a:	6083      	str	r3, [r0, #8]
   24b0c:	8181      	strh	r1, [r0, #12]
   24b0e:	6643      	str	r3, [r0, #100]	; 0x64
   24b10:	81c2      	strh	r2, [r0, #14]
   24b12:	6103      	str	r3, [r0, #16]
   24b14:	6143      	str	r3, [r0, #20]
   24b16:	6183      	str	r3, [r0, #24]
   24b18:	0019      	movs	r1, r3
   24b1a:	2208      	movs	r2, #8
   24b1c:	305c      	adds	r0, #92	; 0x5c
   24b1e:	f7fe f892 	bl	22c46 <memset>
   24b22:	4b05      	ldr	r3, [pc, #20]	; (24b38 <std.isra.0+0x38>)
   24b24:	6224      	str	r4, [r4, #32]
   24b26:	6263      	str	r3, [r4, #36]	; 0x24
   24b28:	4b04      	ldr	r3, [pc, #16]	; (24b3c <std.isra.0+0x3c>)
   24b2a:	62a3      	str	r3, [r4, #40]	; 0x28
   24b2c:	4b04      	ldr	r3, [pc, #16]	; (24b40 <std.isra.0+0x40>)
   24b2e:	62e3      	str	r3, [r4, #44]	; 0x2c
   24b30:	4b04      	ldr	r3, [pc, #16]	; (24b44 <std.isra.0+0x44>)
   24b32:	6323      	str	r3, [r4, #48]	; 0x30
   24b34:	bd10      	pop	{r4, pc}
   24b36:	46c0      	nop			; (mov r8, r8)
   24b38:	0002569d 	.word	0x0002569d
   24b3c:	000256c5 	.word	0x000256c5
   24b40:	000256fd 	.word	0x000256fd
   24b44:	00025729 	.word	0x00025729

00024b48 <__sfmoreglue>:
   24b48:	b570      	push	{r4, r5, r6, lr}
   24b4a:	2568      	movs	r5, #104	; 0x68
   24b4c:	1e4a      	subs	r2, r1, #1
   24b4e:	4355      	muls	r5, r2
   24b50:	000e      	movs	r6, r1
   24b52:	0029      	movs	r1, r5
   24b54:	3174      	adds	r1, #116	; 0x74
   24b56:	f7fe f8c9 	bl	22cec <_malloc_r>
   24b5a:	1e04      	subs	r4, r0, #0
   24b5c:	d008      	beq.n	24b70 <__sfmoreglue+0x28>
   24b5e:	2100      	movs	r1, #0
   24b60:	002a      	movs	r2, r5
   24b62:	6001      	str	r1, [r0, #0]
   24b64:	6046      	str	r6, [r0, #4]
   24b66:	300c      	adds	r0, #12
   24b68:	60a0      	str	r0, [r4, #8]
   24b6a:	3268      	adds	r2, #104	; 0x68
   24b6c:	f7fe f86b 	bl	22c46 <memset>
   24b70:	0020      	movs	r0, r4
   24b72:	bd70      	pop	{r4, r5, r6, pc}

00024b74 <__sinit>:
   24b74:	6983      	ldr	r3, [r0, #24]
   24b76:	b513      	push	{r0, r1, r4, lr}
   24b78:	0004      	movs	r4, r0
   24b7a:	2b00      	cmp	r3, #0
   24b7c:	d128      	bne.n	24bd0 <__sinit+0x5c>
   24b7e:	6483      	str	r3, [r0, #72]	; 0x48
   24b80:	64c3      	str	r3, [r0, #76]	; 0x4c
   24b82:	6503      	str	r3, [r0, #80]	; 0x50
   24b84:	4b13      	ldr	r3, [pc, #76]	; (24bd4 <__sinit+0x60>)
   24b86:	4a14      	ldr	r2, [pc, #80]	; (24bd8 <__sinit+0x64>)
   24b88:	681b      	ldr	r3, [r3, #0]
   24b8a:	6282      	str	r2, [r0, #40]	; 0x28
   24b8c:	9301      	str	r3, [sp, #4]
   24b8e:	4298      	cmp	r0, r3
   24b90:	d101      	bne.n	24b96 <__sinit+0x22>
   24b92:	2301      	movs	r3, #1
   24b94:	6183      	str	r3, [r0, #24]
   24b96:	0020      	movs	r0, r4
   24b98:	f000 f820 	bl	24bdc <__sfp>
   24b9c:	6060      	str	r0, [r4, #4]
   24b9e:	0020      	movs	r0, r4
   24ba0:	f000 f81c 	bl	24bdc <__sfp>
   24ba4:	60a0      	str	r0, [r4, #8]
   24ba6:	0020      	movs	r0, r4
   24ba8:	f000 f818 	bl	24bdc <__sfp>
   24bac:	2200      	movs	r2, #0
   24bae:	60e0      	str	r0, [r4, #12]
   24bb0:	2104      	movs	r1, #4
   24bb2:	6860      	ldr	r0, [r4, #4]
   24bb4:	f7ff ffa4 	bl	24b00 <std.isra.0>
   24bb8:	2201      	movs	r2, #1
   24bba:	2109      	movs	r1, #9
   24bbc:	68a0      	ldr	r0, [r4, #8]
   24bbe:	f7ff ff9f 	bl	24b00 <std.isra.0>
   24bc2:	2202      	movs	r2, #2
   24bc4:	2112      	movs	r1, #18
   24bc6:	68e0      	ldr	r0, [r4, #12]
   24bc8:	f7ff ff9a 	bl	24b00 <std.isra.0>
   24bcc:	2301      	movs	r3, #1
   24bce:	61a3      	str	r3, [r4, #24]
   24bd0:	bd13      	pop	{r0, r1, r4, pc}
   24bd2:	46c0      	nop			; (mov r8, r8)
   24bd4:	0002b66c 	.word	0x0002b66c
   24bd8:	00024af1 	.word	0x00024af1

00024bdc <__sfp>:
   24bdc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   24bde:	4b1e      	ldr	r3, [pc, #120]	; (24c58 <__sfp+0x7c>)
   24be0:	0007      	movs	r7, r0
   24be2:	681e      	ldr	r6, [r3, #0]
   24be4:	69b3      	ldr	r3, [r6, #24]
   24be6:	2b00      	cmp	r3, #0
   24be8:	d102      	bne.n	24bf0 <__sfp+0x14>
   24bea:	0030      	movs	r0, r6
   24bec:	f7ff ffc2 	bl	24b74 <__sinit>
   24bf0:	3648      	adds	r6, #72	; 0x48
   24bf2:	68b4      	ldr	r4, [r6, #8]
   24bf4:	6873      	ldr	r3, [r6, #4]
   24bf6:	3b01      	subs	r3, #1
   24bf8:	d504      	bpl.n	24c04 <__sfp+0x28>
   24bfa:	6833      	ldr	r3, [r6, #0]
   24bfc:	2b00      	cmp	r3, #0
   24bfe:	d007      	beq.n	24c10 <__sfp+0x34>
   24c00:	6836      	ldr	r6, [r6, #0]
   24c02:	e7f6      	b.n	24bf2 <__sfp+0x16>
   24c04:	220c      	movs	r2, #12
   24c06:	5ea5      	ldrsh	r5, [r4, r2]
   24c08:	2d00      	cmp	r5, #0
   24c0a:	d00d      	beq.n	24c28 <__sfp+0x4c>
   24c0c:	3468      	adds	r4, #104	; 0x68
   24c0e:	e7f2      	b.n	24bf6 <__sfp+0x1a>
   24c10:	2104      	movs	r1, #4
   24c12:	0038      	movs	r0, r7
   24c14:	f7ff ff98 	bl	24b48 <__sfmoreglue>
   24c18:	6030      	str	r0, [r6, #0]
   24c1a:	2800      	cmp	r0, #0
   24c1c:	d1f0      	bne.n	24c00 <__sfp+0x24>
   24c1e:	230c      	movs	r3, #12
   24c20:	0004      	movs	r4, r0
   24c22:	603b      	str	r3, [r7, #0]
   24c24:	0020      	movs	r0, r4
   24c26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   24c28:	2301      	movs	r3, #1
   24c2a:	0020      	movs	r0, r4
   24c2c:	425b      	negs	r3, r3
   24c2e:	81e3      	strh	r3, [r4, #14]
   24c30:	3302      	adds	r3, #2
   24c32:	81a3      	strh	r3, [r4, #12]
   24c34:	6665      	str	r5, [r4, #100]	; 0x64
   24c36:	6025      	str	r5, [r4, #0]
   24c38:	60a5      	str	r5, [r4, #8]
   24c3a:	6065      	str	r5, [r4, #4]
   24c3c:	6125      	str	r5, [r4, #16]
   24c3e:	6165      	str	r5, [r4, #20]
   24c40:	61a5      	str	r5, [r4, #24]
   24c42:	2208      	movs	r2, #8
   24c44:	0029      	movs	r1, r5
   24c46:	305c      	adds	r0, #92	; 0x5c
   24c48:	f7fd fffd 	bl	22c46 <memset>
   24c4c:	6365      	str	r5, [r4, #52]	; 0x34
   24c4e:	63a5      	str	r5, [r4, #56]	; 0x38
   24c50:	64a5      	str	r5, [r4, #72]	; 0x48
   24c52:	64e5      	str	r5, [r4, #76]	; 0x4c
   24c54:	e7e6      	b.n	24c24 <__sfp+0x48>
   24c56:	46c0      	nop			; (mov r8, r8)
   24c58:	0002b66c 	.word	0x0002b66c

00024c5c <_fwalk_reent>:
   24c5c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   24c5e:	0004      	movs	r4, r0
   24c60:	0007      	movs	r7, r0
   24c62:	2600      	movs	r6, #0
   24c64:	9101      	str	r1, [sp, #4]
   24c66:	3448      	adds	r4, #72	; 0x48
   24c68:	2c00      	cmp	r4, #0
   24c6a:	d101      	bne.n	24c70 <_fwalk_reent+0x14>
   24c6c:	0030      	movs	r0, r6
   24c6e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   24c70:	6863      	ldr	r3, [r4, #4]
   24c72:	68a5      	ldr	r5, [r4, #8]
   24c74:	9300      	str	r3, [sp, #0]
   24c76:	9b00      	ldr	r3, [sp, #0]
   24c78:	3b01      	subs	r3, #1
   24c7a:	9300      	str	r3, [sp, #0]
   24c7c:	d501      	bpl.n	24c82 <_fwalk_reent+0x26>
   24c7e:	6824      	ldr	r4, [r4, #0]
   24c80:	e7f2      	b.n	24c68 <_fwalk_reent+0xc>
   24c82:	89ab      	ldrh	r3, [r5, #12]
   24c84:	2b01      	cmp	r3, #1
   24c86:	d908      	bls.n	24c9a <_fwalk_reent+0x3e>
   24c88:	220e      	movs	r2, #14
   24c8a:	5eab      	ldrsh	r3, [r5, r2]
   24c8c:	3301      	adds	r3, #1
   24c8e:	d004      	beq.n	24c9a <_fwalk_reent+0x3e>
   24c90:	0029      	movs	r1, r5
   24c92:	0038      	movs	r0, r7
   24c94:	9b01      	ldr	r3, [sp, #4]
   24c96:	4798      	blx	r3
   24c98:	4306      	orrs	r6, r0
   24c9a:	3568      	adds	r5, #104	; 0x68
   24c9c:	e7eb      	b.n	24c76 <_fwalk_reent+0x1a>

00024c9e <__locale_ctype_ptr_l>:
   24c9e:	30ec      	adds	r0, #236	; 0xec
   24ca0:	6800      	ldr	r0, [r0, #0]
   24ca2:	4770      	bx	lr

00024ca4 <__locale_ctype_ptr>:
   24ca4:	4b04      	ldr	r3, [pc, #16]	; (24cb8 <__locale_ctype_ptr+0x14>)
   24ca6:	681b      	ldr	r3, [r3, #0]
   24ca8:	6a1b      	ldr	r3, [r3, #32]
   24caa:	2b00      	cmp	r3, #0
   24cac:	d100      	bne.n	24cb0 <__locale_ctype_ptr+0xc>
   24cae:	4b03      	ldr	r3, [pc, #12]	; (24cbc <__locale_ctype_ptr+0x18>)
   24cb0:	33ec      	adds	r3, #236	; 0xec
   24cb2:	6818      	ldr	r0, [r3, #0]
   24cb4:	4770      	bx	lr
   24cb6:	46c0      	nop			; (mov r8, r8)
   24cb8:	2000020c 	.word	0x2000020c
   24cbc:	20000270 	.word	0x20000270

00024cc0 <_localeconv_r>:
   24cc0:	4b03      	ldr	r3, [pc, #12]	; (24cd0 <_localeconv_r+0x10>)
   24cc2:	681b      	ldr	r3, [r3, #0]
   24cc4:	6a18      	ldr	r0, [r3, #32]
   24cc6:	2800      	cmp	r0, #0
   24cc8:	d100      	bne.n	24ccc <_localeconv_r+0xc>
   24cca:	4802      	ldr	r0, [pc, #8]	; (24cd4 <_localeconv_r+0x14>)
   24ccc:	30f0      	adds	r0, #240	; 0xf0
   24cce:	4770      	bx	lr
   24cd0:	2000020c 	.word	0x2000020c
   24cd4:	20000270 	.word	0x20000270

00024cd8 <__swhatbuf_r>:
   24cd8:	b570      	push	{r4, r5, r6, lr}
   24cda:	000e      	movs	r6, r1
   24cdc:	001d      	movs	r5, r3
   24cde:	230e      	movs	r3, #14
   24ce0:	5ec9      	ldrsh	r1, [r1, r3]
   24ce2:	b090      	sub	sp, #64	; 0x40
   24ce4:	0014      	movs	r4, r2
   24ce6:	2900      	cmp	r1, #0
   24ce8:	da07      	bge.n	24cfa <__swhatbuf_r+0x22>
   24cea:	2300      	movs	r3, #0
   24cec:	602b      	str	r3, [r5, #0]
   24cee:	89b3      	ldrh	r3, [r6, #12]
   24cf0:	061b      	lsls	r3, r3, #24
   24cf2:	d411      	bmi.n	24d18 <__swhatbuf_r+0x40>
   24cf4:	2380      	movs	r3, #128	; 0x80
   24cf6:	00db      	lsls	r3, r3, #3
   24cf8:	e00f      	b.n	24d1a <__swhatbuf_r+0x42>
   24cfa:	aa01      	add	r2, sp, #4
   24cfc:	f000 fd5a 	bl	257b4 <_fstat_r>
   24d00:	2800      	cmp	r0, #0
   24d02:	dbf2      	blt.n	24cea <__swhatbuf_r+0x12>
   24d04:	22f0      	movs	r2, #240	; 0xf0
   24d06:	9b02      	ldr	r3, [sp, #8]
   24d08:	0212      	lsls	r2, r2, #8
   24d0a:	4013      	ands	r3, r2
   24d0c:	4a05      	ldr	r2, [pc, #20]	; (24d24 <__swhatbuf_r+0x4c>)
   24d0e:	189b      	adds	r3, r3, r2
   24d10:	425a      	negs	r2, r3
   24d12:	4153      	adcs	r3, r2
   24d14:	602b      	str	r3, [r5, #0]
   24d16:	e7ed      	b.n	24cf4 <__swhatbuf_r+0x1c>
   24d18:	2340      	movs	r3, #64	; 0x40
   24d1a:	2000      	movs	r0, #0
   24d1c:	6023      	str	r3, [r4, #0]
   24d1e:	b010      	add	sp, #64	; 0x40
   24d20:	bd70      	pop	{r4, r5, r6, pc}
   24d22:	46c0      	nop			; (mov r8, r8)
   24d24:	ffffe000 	.word	0xffffe000

00024d28 <__smakebuf_r>:
   24d28:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   24d2a:	2602      	movs	r6, #2
   24d2c:	898b      	ldrh	r3, [r1, #12]
   24d2e:	0005      	movs	r5, r0
   24d30:	000c      	movs	r4, r1
   24d32:	4233      	tst	r3, r6
   24d34:	d006      	beq.n	24d44 <__smakebuf_r+0x1c>
   24d36:	0023      	movs	r3, r4
   24d38:	3347      	adds	r3, #71	; 0x47
   24d3a:	6023      	str	r3, [r4, #0]
   24d3c:	6123      	str	r3, [r4, #16]
   24d3e:	2301      	movs	r3, #1
   24d40:	6163      	str	r3, [r4, #20]
   24d42:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
   24d44:	ab01      	add	r3, sp, #4
   24d46:	466a      	mov	r2, sp
   24d48:	f7ff ffc6 	bl	24cd8 <__swhatbuf_r>
   24d4c:	9900      	ldr	r1, [sp, #0]
   24d4e:	0007      	movs	r7, r0
   24d50:	0028      	movs	r0, r5
   24d52:	f7fd ffcb 	bl	22cec <_malloc_r>
   24d56:	2800      	cmp	r0, #0
   24d58:	d108      	bne.n	24d6c <__smakebuf_r+0x44>
   24d5a:	220c      	movs	r2, #12
   24d5c:	5ea3      	ldrsh	r3, [r4, r2]
   24d5e:	059a      	lsls	r2, r3, #22
   24d60:	d4ef      	bmi.n	24d42 <__smakebuf_r+0x1a>
   24d62:	2203      	movs	r2, #3
   24d64:	4393      	bics	r3, r2
   24d66:	431e      	orrs	r6, r3
   24d68:	81a6      	strh	r6, [r4, #12]
   24d6a:	e7e4      	b.n	24d36 <__smakebuf_r+0xe>
   24d6c:	4b0f      	ldr	r3, [pc, #60]	; (24dac <__smakebuf_r+0x84>)
   24d6e:	62ab      	str	r3, [r5, #40]	; 0x28
   24d70:	2380      	movs	r3, #128	; 0x80
   24d72:	89a2      	ldrh	r2, [r4, #12]
   24d74:	6020      	str	r0, [r4, #0]
   24d76:	4313      	orrs	r3, r2
   24d78:	81a3      	strh	r3, [r4, #12]
   24d7a:	9b00      	ldr	r3, [sp, #0]
   24d7c:	6120      	str	r0, [r4, #16]
   24d7e:	6163      	str	r3, [r4, #20]
   24d80:	9b01      	ldr	r3, [sp, #4]
   24d82:	2b00      	cmp	r3, #0
   24d84:	d00d      	beq.n	24da2 <__smakebuf_r+0x7a>
   24d86:	230e      	movs	r3, #14
   24d88:	5ee1      	ldrsh	r1, [r4, r3]
   24d8a:	0028      	movs	r0, r5
   24d8c:	f000 fd24 	bl	257d8 <_isatty_r>
   24d90:	2800      	cmp	r0, #0
   24d92:	d006      	beq.n	24da2 <__smakebuf_r+0x7a>
   24d94:	2203      	movs	r2, #3
   24d96:	89a3      	ldrh	r3, [r4, #12]
   24d98:	4393      	bics	r3, r2
   24d9a:	001a      	movs	r2, r3
   24d9c:	2301      	movs	r3, #1
   24d9e:	4313      	orrs	r3, r2
   24da0:	81a3      	strh	r3, [r4, #12]
   24da2:	89a0      	ldrh	r0, [r4, #12]
   24da4:	4338      	orrs	r0, r7
   24da6:	81a0      	strh	r0, [r4, #12]
   24da8:	e7cb      	b.n	24d42 <__smakebuf_r+0x1a>
   24daa:	46c0      	nop			; (mov r8, r8)
   24dac:	00024af1 	.word	0x00024af1

00024db0 <__ascii_mbtowc>:
   24db0:	b082      	sub	sp, #8
   24db2:	2900      	cmp	r1, #0
   24db4:	d100      	bne.n	24db8 <__ascii_mbtowc+0x8>
   24db6:	a901      	add	r1, sp, #4
   24db8:	1e10      	subs	r0, r2, #0
   24dba:	d006      	beq.n	24dca <__ascii_mbtowc+0x1a>
   24dbc:	2b00      	cmp	r3, #0
   24dbe:	d006      	beq.n	24dce <__ascii_mbtowc+0x1e>
   24dc0:	7813      	ldrb	r3, [r2, #0]
   24dc2:	600b      	str	r3, [r1, #0]
   24dc4:	7810      	ldrb	r0, [r2, #0]
   24dc6:	1e43      	subs	r3, r0, #1
   24dc8:	4198      	sbcs	r0, r3
   24dca:	b002      	add	sp, #8
   24dcc:	4770      	bx	lr
   24dce:	2002      	movs	r0, #2
   24dd0:	4240      	negs	r0, r0
   24dd2:	e7fa      	b.n	24dca <__ascii_mbtowc+0x1a>

00024dd4 <memchr>:
   24dd4:	b2c9      	uxtb	r1, r1
   24dd6:	1882      	adds	r2, r0, r2
   24dd8:	4290      	cmp	r0, r2
   24dda:	d101      	bne.n	24de0 <memchr+0xc>
   24ddc:	2000      	movs	r0, #0
   24dde:	4770      	bx	lr
   24de0:	7803      	ldrb	r3, [r0, #0]
   24de2:	428b      	cmp	r3, r1
   24de4:	d0fb      	beq.n	24dde <memchr+0xa>
   24de6:	3001      	adds	r0, #1
   24de8:	e7f6      	b.n	24dd8 <memchr+0x4>

00024dea <__malloc_lock>:
   24dea:	4770      	bx	lr

00024dec <__malloc_unlock>:
   24dec:	4770      	bx	lr

00024dee <_Balloc>:
   24dee:	b570      	push	{r4, r5, r6, lr}
   24df0:	6a46      	ldr	r6, [r0, #36]	; 0x24
   24df2:	0004      	movs	r4, r0
   24df4:	000d      	movs	r5, r1
   24df6:	2e00      	cmp	r6, #0
   24df8:	d107      	bne.n	24e0a <_Balloc+0x1c>
   24dfa:	2010      	movs	r0, #16
   24dfc:	f7fd fef4 	bl	22be8 <malloc>
   24e00:	6260      	str	r0, [r4, #36]	; 0x24
   24e02:	6046      	str	r6, [r0, #4]
   24e04:	6086      	str	r6, [r0, #8]
   24e06:	6006      	str	r6, [r0, #0]
   24e08:	60c6      	str	r6, [r0, #12]
   24e0a:	6a66      	ldr	r6, [r4, #36]	; 0x24
   24e0c:	68f3      	ldr	r3, [r6, #12]
   24e0e:	2b00      	cmp	r3, #0
   24e10:	d013      	beq.n	24e3a <_Balloc+0x4c>
   24e12:	6a63      	ldr	r3, [r4, #36]	; 0x24
   24e14:	00aa      	lsls	r2, r5, #2
   24e16:	68db      	ldr	r3, [r3, #12]
   24e18:	189b      	adds	r3, r3, r2
   24e1a:	6818      	ldr	r0, [r3, #0]
   24e1c:	2800      	cmp	r0, #0
   24e1e:	d118      	bne.n	24e52 <_Balloc+0x64>
   24e20:	2101      	movs	r1, #1
   24e22:	000e      	movs	r6, r1
   24e24:	40ae      	lsls	r6, r5
   24e26:	1d72      	adds	r2, r6, #5
   24e28:	0092      	lsls	r2, r2, #2
   24e2a:	0020      	movs	r0, r4
   24e2c:	f000 fac2 	bl	253b4 <_calloc_r>
   24e30:	2800      	cmp	r0, #0
   24e32:	d00c      	beq.n	24e4e <_Balloc+0x60>
   24e34:	6045      	str	r5, [r0, #4]
   24e36:	6086      	str	r6, [r0, #8]
   24e38:	e00d      	b.n	24e56 <_Balloc+0x68>
   24e3a:	2221      	movs	r2, #33	; 0x21
   24e3c:	2104      	movs	r1, #4
   24e3e:	0020      	movs	r0, r4
   24e40:	f000 fab8 	bl	253b4 <_calloc_r>
   24e44:	6a63      	ldr	r3, [r4, #36]	; 0x24
   24e46:	60f0      	str	r0, [r6, #12]
   24e48:	68db      	ldr	r3, [r3, #12]
   24e4a:	2b00      	cmp	r3, #0
   24e4c:	d1e1      	bne.n	24e12 <_Balloc+0x24>
   24e4e:	2000      	movs	r0, #0
   24e50:	bd70      	pop	{r4, r5, r6, pc}
   24e52:	6802      	ldr	r2, [r0, #0]
   24e54:	601a      	str	r2, [r3, #0]
   24e56:	2300      	movs	r3, #0
   24e58:	6103      	str	r3, [r0, #16]
   24e5a:	60c3      	str	r3, [r0, #12]
   24e5c:	e7f8      	b.n	24e50 <_Balloc+0x62>

00024e5e <_Bfree>:
   24e5e:	b570      	push	{r4, r5, r6, lr}
   24e60:	6a44      	ldr	r4, [r0, #36]	; 0x24
   24e62:	0006      	movs	r6, r0
   24e64:	000d      	movs	r5, r1
   24e66:	2c00      	cmp	r4, #0
   24e68:	d107      	bne.n	24e7a <_Bfree+0x1c>
   24e6a:	2010      	movs	r0, #16
   24e6c:	f7fd febc 	bl	22be8 <malloc>
   24e70:	6270      	str	r0, [r6, #36]	; 0x24
   24e72:	6044      	str	r4, [r0, #4]
   24e74:	6084      	str	r4, [r0, #8]
   24e76:	6004      	str	r4, [r0, #0]
   24e78:	60c4      	str	r4, [r0, #12]
   24e7a:	2d00      	cmp	r5, #0
   24e7c:	d007      	beq.n	24e8e <_Bfree+0x30>
   24e7e:	6a73      	ldr	r3, [r6, #36]	; 0x24
   24e80:	686a      	ldr	r2, [r5, #4]
   24e82:	68db      	ldr	r3, [r3, #12]
   24e84:	0092      	lsls	r2, r2, #2
   24e86:	189b      	adds	r3, r3, r2
   24e88:	681a      	ldr	r2, [r3, #0]
   24e8a:	602a      	str	r2, [r5, #0]
   24e8c:	601d      	str	r5, [r3, #0]
   24e8e:	bd70      	pop	{r4, r5, r6, pc}

00024e90 <__multadd>:
   24e90:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   24e92:	001e      	movs	r6, r3
   24e94:	2314      	movs	r3, #20
   24e96:	469c      	mov	ip, r3
   24e98:	0007      	movs	r7, r0
   24e9a:	000c      	movs	r4, r1
   24e9c:	2000      	movs	r0, #0
   24e9e:	690d      	ldr	r5, [r1, #16]
   24ea0:	448c      	add	ip, r1
   24ea2:	4663      	mov	r3, ip
   24ea4:	8819      	ldrh	r1, [r3, #0]
   24ea6:	681b      	ldr	r3, [r3, #0]
   24ea8:	4351      	muls	r1, r2
   24eaa:	0c1b      	lsrs	r3, r3, #16
   24eac:	4353      	muls	r3, r2
   24eae:	1989      	adds	r1, r1, r6
   24eb0:	0c0e      	lsrs	r6, r1, #16
   24eb2:	199b      	adds	r3, r3, r6
   24eb4:	b289      	uxth	r1, r1
   24eb6:	0c1e      	lsrs	r6, r3, #16
   24eb8:	041b      	lsls	r3, r3, #16
   24eba:	185b      	adds	r3, r3, r1
   24ebc:	4661      	mov	r1, ip
   24ebe:	3001      	adds	r0, #1
   24ec0:	c108      	stmia	r1!, {r3}
   24ec2:	468c      	mov	ip, r1
   24ec4:	4285      	cmp	r5, r0
   24ec6:	dcec      	bgt.n	24ea2 <__multadd+0x12>
   24ec8:	2e00      	cmp	r6, #0
   24eca:	d01b      	beq.n	24f04 <__multadd+0x74>
   24ecc:	68a3      	ldr	r3, [r4, #8]
   24ece:	429d      	cmp	r5, r3
   24ed0:	db12      	blt.n	24ef8 <__multadd+0x68>
   24ed2:	6863      	ldr	r3, [r4, #4]
   24ed4:	0038      	movs	r0, r7
   24ed6:	1c59      	adds	r1, r3, #1
   24ed8:	f7ff ff89 	bl	24dee <_Balloc>
   24edc:	0021      	movs	r1, r4
   24ede:	6923      	ldr	r3, [r4, #16]
   24ee0:	9001      	str	r0, [sp, #4]
   24ee2:	1c9a      	adds	r2, r3, #2
   24ee4:	0092      	lsls	r2, r2, #2
   24ee6:	310c      	adds	r1, #12
   24ee8:	300c      	adds	r0, #12
   24eea:	f7fd fe91 	bl	22c10 <memcpy>
   24eee:	0021      	movs	r1, r4
   24ef0:	0038      	movs	r0, r7
   24ef2:	f7ff ffb4 	bl	24e5e <_Bfree>
   24ef6:	9c01      	ldr	r4, [sp, #4]
   24ef8:	1d2b      	adds	r3, r5, #4
   24efa:	009b      	lsls	r3, r3, #2
   24efc:	18e3      	adds	r3, r4, r3
   24efe:	3501      	adds	r5, #1
   24f00:	605e      	str	r6, [r3, #4]
   24f02:	6125      	str	r5, [r4, #16]
   24f04:	0020      	movs	r0, r4
   24f06:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

00024f08 <__hi0bits>:
   24f08:	0003      	movs	r3, r0
   24f0a:	0c02      	lsrs	r2, r0, #16
   24f0c:	2000      	movs	r0, #0
   24f0e:	4282      	cmp	r2, r0
   24f10:	d101      	bne.n	24f16 <__hi0bits+0xe>
   24f12:	041b      	lsls	r3, r3, #16
   24f14:	3010      	adds	r0, #16
   24f16:	0e1a      	lsrs	r2, r3, #24
   24f18:	d101      	bne.n	24f1e <__hi0bits+0x16>
   24f1a:	3008      	adds	r0, #8
   24f1c:	021b      	lsls	r3, r3, #8
   24f1e:	0f1a      	lsrs	r2, r3, #28
   24f20:	d101      	bne.n	24f26 <__hi0bits+0x1e>
   24f22:	3004      	adds	r0, #4
   24f24:	011b      	lsls	r3, r3, #4
   24f26:	0f9a      	lsrs	r2, r3, #30
   24f28:	d101      	bne.n	24f2e <__hi0bits+0x26>
   24f2a:	3002      	adds	r0, #2
   24f2c:	009b      	lsls	r3, r3, #2
   24f2e:	2b00      	cmp	r3, #0
   24f30:	db03      	blt.n	24f3a <__hi0bits+0x32>
   24f32:	3001      	adds	r0, #1
   24f34:	005b      	lsls	r3, r3, #1
   24f36:	d400      	bmi.n	24f3a <__hi0bits+0x32>
   24f38:	2020      	movs	r0, #32
   24f3a:	4770      	bx	lr

00024f3c <__lo0bits>:
   24f3c:	2207      	movs	r2, #7
   24f3e:	6803      	ldr	r3, [r0, #0]
   24f40:	b510      	push	{r4, lr}
   24f42:	0001      	movs	r1, r0
   24f44:	401a      	ands	r2, r3
   24f46:	d00d      	beq.n	24f64 <__lo0bits+0x28>
   24f48:	2401      	movs	r4, #1
   24f4a:	2000      	movs	r0, #0
   24f4c:	4223      	tst	r3, r4
   24f4e:	d105      	bne.n	24f5c <__lo0bits+0x20>
   24f50:	3002      	adds	r0, #2
   24f52:	4203      	tst	r3, r0
   24f54:	d003      	beq.n	24f5e <__lo0bits+0x22>
   24f56:	40e3      	lsrs	r3, r4
   24f58:	0020      	movs	r0, r4
   24f5a:	600b      	str	r3, [r1, #0]
   24f5c:	bd10      	pop	{r4, pc}
   24f5e:	089b      	lsrs	r3, r3, #2
   24f60:	600b      	str	r3, [r1, #0]
   24f62:	e7fb      	b.n	24f5c <__lo0bits+0x20>
   24f64:	b29c      	uxth	r4, r3
   24f66:	0010      	movs	r0, r2
   24f68:	2c00      	cmp	r4, #0
   24f6a:	d101      	bne.n	24f70 <__lo0bits+0x34>
   24f6c:	2010      	movs	r0, #16
   24f6e:	0c1b      	lsrs	r3, r3, #16
   24f70:	b2da      	uxtb	r2, r3
   24f72:	2a00      	cmp	r2, #0
   24f74:	d101      	bne.n	24f7a <__lo0bits+0x3e>
   24f76:	3008      	adds	r0, #8
   24f78:	0a1b      	lsrs	r3, r3, #8
   24f7a:	071a      	lsls	r2, r3, #28
   24f7c:	d101      	bne.n	24f82 <__lo0bits+0x46>
   24f7e:	3004      	adds	r0, #4
   24f80:	091b      	lsrs	r3, r3, #4
   24f82:	079a      	lsls	r2, r3, #30
   24f84:	d101      	bne.n	24f8a <__lo0bits+0x4e>
   24f86:	3002      	adds	r0, #2
   24f88:	089b      	lsrs	r3, r3, #2
   24f8a:	07da      	lsls	r2, r3, #31
   24f8c:	d4e8      	bmi.n	24f60 <__lo0bits+0x24>
   24f8e:	085b      	lsrs	r3, r3, #1
   24f90:	d001      	beq.n	24f96 <__lo0bits+0x5a>
   24f92:	3001      	adds	r0, #1
   24f94:	e7e4      	b.n	24f60 <__lo0bits+0x24>
   24f96:	2020      	movs	r0, #32
   24f98:	e7e0      	b.n	24f5c <__lo0bits+0x20>

00024f9a <__i2b>:
   24f9a:	b510      	push	{r4, lr}
   24f9c:	000c      	movs	r4, r1
   24f9e:	2101      	movs	r1, #1
   24fa0:	f7ff ff25 	bl	24dee <_Balloc>
   24fa4:	2301      	movs	r3, #1
   24fa6:	6144      	str	r4, [r0, #20]
   24fa8:	6103      	str	r3, [r0, #16]
   24faa:	bd10      	pop	{r4, pc}

00024fac <__multiply>:
   24fac:	b5f0      	push	{r4, r5, r6, r7, lr}
   24fae:	690b      	ldr	r3, [r1, #16]
   24fb0:	0015      	movs	r5, r2
   24fb2:	6912      	ldr	r2, [r2, #16]
   24fb4:	b089      	sub	sp, #36	; 0x24
   24fb6:	000c      	movs	r4, r1
   24fb8:	4293      	cmp	r3, r2
   24fba:	da01      	bge.n	24fc0 <__multiply+0x14>
   24fbc:	002c      	movs	r4, r5
   24fbe:	000d      	movs	r5, r1
   24fc0:	6927      	ldr	r7, [r4, #16]
   24fc2:	692e      	ldr	r6, [r5, #16]
   24fc4:	68a2      	ldr	r2, [r4, #8]
   24fc6:	19bb      	adds	r3, r7, r6
   24fc8:	6861      	ldr	r1, [r4, #4]
   24fca:	9301      	str	r3, [sp, #4]
   24fcc:	4293      	cmp	r3, r2
   24fce:	dd00      	ble.n	24fd2 <__multiply+0x26>
   24fd0:	3101      	adds	r1, #1
   24fd2:	f7ff ff0c 	bl	24dee <_Balloc>
   24fd6:	0003      	movs	r3, r0
   24fd8:	3314      	adds	r3, #20
   24fda:	9300      	str	r3, [sp, #0]
   24fdc:	9a00      	ldr	r2, [sp, #0]
   24fde:	19bb      	adds	r3, r7, r6
   24fe0:	4694      	mov	ip, r2
   24fe2:	009b      	lsls	r3, r3, #2
   24fe4:	449c      	add	ip, r3
   24fe6:	0013      	movs	r3, r2
   24fe8:	2200      	movs	r2, #0
   24fea:	9004      	str	r0, [sp, #16]
   24fec:	4563      	cmp	r3, ip
   24fee:	d31c      	bcc.n	2502a <__multiply+0x7e>
   24ff0:	002a      	movs	r2, r5
   24ff2:	3414      	adds	r4, #20
   24ff4:	00bf      	lsls	r7, r7, #2
   24ff6:	19e3      	adds	r3, r4, r7
   24ff8:	3214      	adds	r2, #20
   24ffa:	00b6      	lsls	r6, r6, #2
   24ffc:	9305      	str	r3, [sp, #20]
   24ffe:	1993      	adds	r3, r2, r6
   25000:	9402      	str	r4, [sp, #8]
   25002:	9306      	str	r3, [sp, #24]
   25004:	9b06      	ldr	r3, [sp, #24]
   25006:	429a      	cmp	r2, r3
   25008:	d311      	bcc.n	2502e <__multiply+0x82>
   2500a:	9b01      	ldr	r3, [sp, #4]
   2500c:	2b00      	cmp	r3, #0
   2500e:	dd06      	ble.n	2501e <__multiply+0x72>
   25010:	2304      	movs	r3, #4
   25012:	425b      	negs	r3, r3
   25014:	449c      	add	ip, r3
   25016:	4663      	mov	r3, ip
   25018:	681b      	ldr	r3, [r3, #0]
   2501a:	2b00      	cmp	r3, #0
   2501c:	d051      	beq.n	250c2 <__multiply+0x116>
   2501e:	9b04      	ldr	r3, [sp, #16]
   25020:	9a01      	ldr	r2, [sp, #4]
   25022:	0018      	movs	r0, r3
   25024:	611a      	str	r2, [r3, #16]
   25026:	b009      	add	sp, #36	; 0x24
   25028:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2502a:	c304      	stmia	r3!, {r2}
   2502c:	e7de      	b.n	24fec <__multiply+0x40>
   2502e:	8814      	ldrh	r4, [r2, #0]
   25030:	2c00      	cmp	r4, #0
   25032:	d01e      	beq.n	25072 <__multiply+0xc6>
   25034:	2600      	movs	r6, #0
   25036:	9d00      	ldr	r5, [sp, #0]
   25038:	9f02      	ldr	r7, [sp, #8]
   2503a:	cf01      	ldmia	r7!, {r0}
   2503c:	9507      	str	r5, [sp, #28]
   2503e:	cd08      	ldmia	r5!, {r3}
   25040:	9303      	str	r3, [sp, #12]
   25042:	b283      	uxth	r3, r0
   25044:	4363      	muls	r3, r4
   25046:	0019      	movs	r1, r3
   25048:	466b      	mov	r3, sp
   2504a:	0c00      	lsrs	r0, r0, #16
   2504c:	899b      	ldrh	r3, [r3, #12]
   2504e:	4360      	muls	r0, r4
   25050:	18cb      	adds	r3, r1, r3
   25052:	9903      	ldr	r1, [sp, #12]
   25054:	199b      	adds	r3, r3, r6
   25056:	0c09      	lsrs	r1, r1, #16
   25058:	1841      	adds	r1, r0, r1
   2505a:	0c18      	lsrs	r0, r3, #16
   2505c:	1809      	adds	r1, r1, r0
   2505e:	0c0e      	lsrs	r6, r1, #16
   25060:	b29b      	uxth	r3, r3
   25062:	0409      	lsls	r1, r1, #16
   25064:	430b      	orrs	r3, r1
   25066:	9907      	ldr	r1, [sp, #28]
   25068:	600b      	str	r3, [r1, #0]
   2506a:	9b05      	ldr	r3, [sp, #20]
   2506c:	42bb      	cmp	r3, r7
   2506e:	d8e4      	bhi.n	2503a <__multiply+0x8e>
   25070:	602e      	str	r6, [r5, #0]
   25072:	6813      	ldr	r3, [r2, #0]
   25074:	0c1b      	lsrs	r3, r3, #16
   25076:	9303      	str	r3, [sp, #12]
   25078:	d01e      	beq.n	250b8 <__multiply+0x10c>
   2507a:	2600      	movs	r6, #0
   2507c:	9b00      	ldr	r3, [sp, #0]
   2507e:	9c02      	ldr	r4, [sp, #8]
   25080:	681b      	ldr	r3, [r3, #0]
   25082:	9800      	ldr	r0, [sp, #0]
   25084:	0007      	movs	r7, r0
   25086:	8821      	ldrh	r1, [r4, #0]
   25088:	9d03      	ldr	r5, [sp, #12]
   2508a:	b29b      	uxth	r3, r3
   2508c:	4369      	muls	r1, r5
   2508e:	c820      	ldmia	r0!, {r5}
   25090:	0c2d      	lsrs	r5, r5, #16
   25092:	1949      	adds	r1, r1, r5
   25094:	198e      	adds	r6, r1, r6
   25096:	0431      	lsls	r1, r6, #16
   25098:	430b      	orrs	r3, r1
   2509a:	603b      	str	r3, [r7, #0]
   2509c:	cc08      	ldmia	r4!, {r3}
   2509e:	9903      	ldr	r1, [sp, #12]
   250a0:	0c1b      	lsrs	r3, r3, #16
   250a2:	434b      	muls	r3, r1
   250a4:	6879      	ldr	r1, [r7, #4]
   250a6:	0c36      	lsrs	r6, r6, #16
   250a8:	b289      	uxth	r1, r1
   250aa:	185b      	adds	r3, r3, r1
   250ac:	9905      	ldr	r1, [sp, #20]
   250ae:	199b      	adds	r3, r3, r6
   250b0:	0c1e      	lsrs	r6, r3, #16
   250b2:	42a1      	cmp	r1, r4
   250b4:	d8e6      	bhi.n	25084 <__multiply+0xd8>
   250b6:	6003      	str	r3, [r0, #0]
   250b8:	9b00      	ldr	r3, [sp, #0]
   250ba:	3204      	adds	r2, #4
   250bc:	3304      	adds	r3, #4
   250be:	9300      	str	r3, [sp, #0]
   250c0:	e7a0      	b.n	25004 <__multiply+0x58>
   250c2:	9b01      	ldr	r3, [sp, #4]
   250c4:	3b01      	subs	r3, #1
   250c6:	9301      	str	r3, [sp, #4]
   250c8:	e79f      	b.n	2500a <__multiply+0x5e>
	...

000250cc <__pow5mult>:
   250cc:	2303      	movs	r3, #3
   250ce:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   250d0:	4013      	ands	r3, r2
   250d2:	0005      	movs	r5, r0
   250d4:	000e      	movs	r6, r1
   250d6:	0014      	movs	r4, r2
   250d8:	2b00      	cmp	r3, #0
   250da:	d008      	beq.n	250ee <__pow5mult+0x22>
   250dc:	4922      	ldr	r1, [pc, #136]	; (25168 <__pow5mult+0x9c>)
   250de:	3b01      	subs	r3, #1
   250e0:	009a      	lsls	r2, r3, #2
   250e2:	5852      	ldr	r2, [r2, r1]
   250e4:	2300      	movs	r3, #0
   250e6:	0031      	movs	r1, r6
   250e8:	f7ff fed2 	bl	24e90 <__multadd>
   250ec:	0006      	movs	r6, r0
   250ee:	10a3      	asrs	r3, r4, #2
   250f0:	9301      	str	r3, [sp, #4]
   250f2:	d036      	beq.n	25162 <__pow5mult+0x96>
   250f4:	6a6c      	ldr	r4, [r5, #36]	; 0x24
   250f6:	2c00      	cmp	r4, #0
   250f8:	d107      	bne.n	2510a <__pow5mult+0x3e>
   250fa:	2010      	movs	r0, #16
   250fc:	f7fd fd74 	bl	22be8 <malloc>
   25100:	6268      	str	r0, [r5, #36]	; 0x24
   25102:	6044      	str	r4, [r0, #4]
   25104:	6084      	str	r4, [r0, #8]
   25106:	6004      	str	r4, [r0, #0]
   25108:	60c4      	str	r4, [r0, #12]
   2510a:	6a6f      	ldr	r7, [r5, #36]	; 0x24
   2510c:	68bc      	ldr	r4, [r7, #8]
   2510e:	2c00      	cmp	r4, #0
   25110:	d107      	bne.n	25122 <__pow5mult+0x56>
   25112:	4916      	ldr	r1, [pc, #88]	; (2516c <__pow5mult+0xa0>)
   25114:	0028      	movs	r0, r5
   25116:	f7ff ff40 	bl	24f9a <__i2b>
   2511a:	2300      	movs	r3, #0
   2511c:	0004      	movs	r4, r0
   2511e:	60b8      	str	r0, [r7, #8]
   25120:	6003      	str	r3, [r0, #0]
   25122:	2201      	movs	r2, #1
   25124:	9b01      	ldr	r3, [sp, #4]
   25126:	4213      	tst	r3, r2
   25128:	d00a      	beq.n	25140 <__pow5mult+0x74>
   2512a:	0031      	movs	r1, r6
   2512c:	0022      	movs	r2, r4
   2512e:	0028      	movs	r0, r5
   25130:	f7ff ff3c 	bl	24fac <__multiply>
   25134:	0007      	movs	r7, r0
   25136:	0031      	movs	r1, r6
   25138:	0028      	movs	r0, r5
   2513a:	f7ff fe90 	bl	24e5e <_Bfree>
   2513e:	003e      	movs	r6, r7
   25140:	9b01      	ldr	r3, [sp, #4]
   25142:	105b      	asrs	r3, r3, #1
   25144:	9301      	str	r3, [sp, #4]
   25146:	d00c      	beq.n	25162 <__pow5mult+0x96>
   25148:	6820      	ldr	r0, [r4, #0]
   2514a:	2800      	cmp	r0, #0
   2514c:	d107      	bne.n	2515e <__pow5mult+0x92>
   2514e:	0022      	movs	r2, r4
   25150:	0021      	movs	r1, r4
   25152:	0028      	movs	r0, r5
   25154:	f7ff ff2a 	bl	24fac <__multiply>
   25158:	2300      	movs	r3, #0
   2515a:	6020      	str	r0, [r4, #0]
   2515c:	6003      	str	r3, [r0, #0]
   2515e:	0004      	movs	r4, r0
   25160:	e7df      	b.n	25122 <__pow5mult+0x56>
   25162:	0030      	movs	r0, r6
   25164:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   25166:	46c0      	nop			; (mov r8, r8)
   25168:	0002b808 	.word	0x0002b808
   2516c:	00000271 	.word	0x00000271

00025170 <__lshift>:
   25170:	b5f0      	push	{r4, r5, r6, r7, lr}
   25172:	000d      	movs	r5, r1
   25174:	0017      	movs	r7, r2
   25176:	692b      	ldr	r3, [r5, #16]
   25178:	1154      	asrs	r4, r2, #5
   2517a:	b085      	sub	sp, #20
   2517c:	18e3      	adds	r3, r4, r3
   2517e:	9302      	str	r3, [sp, #8]
   25180:	3301      	adds	r3, #1
   25182:	9301      	str	r3, [sp, #4]
   25184:	6849      	ldr	r1, [r1, #4]
   25186:	68ab      	ldr	r3, [r5, #8]
   25188:	9003      	str	r0, [sp, #12]
   2518a:	9a01      	ldr	r2, [sp, #4]
   2518c:	4293      	cmp	r3, r2
   2518e:	db34      	blt.n	251fa <__lshift+0x8a>
   25190:	9803      	ldr	r0, [sp, #12]
   25192:	f7ff fe2c 	bl	24dee <_Balloc>
   25196:	2300      	movs	r3, #0
   25198:	0002      	movs	r2, r0
   2519a:	0006      	movs	r6, r0
   2519c:	0019      	movs	r1, r3
   2519e:	3214      	adds	r2, #20
   251a0:	42a3      	cmp	r3, r4
   251a2:	db2d      	blt.n	25200 <__lshift+0x90>
   251a4:	43e3      	mvns	r3, r4
   251a6:	17db      	asrs	r3, r3, #31
   251a8:	401c      	ands	r4, r3
   251aa:	002b      	movs	r3, r5
   251ac:	211f      	movs	r1, #31
   251ae:	00a4      	lsls	r4, r4, #2
   251b0:	1914      	adds	r4, r2, r4
   251b2:	692a      	ldr	r2, [r5, #16]
   251b4:	3314      	adds	r3, #20
   251b6:	0092      	lsls	r2, r2, #2
   251b8:	189a      	adds	r2, r3, r2
   251ba:	400f      	ands	r7, r1
   251bc:	d024      	beq.n	25208 <__lshift+0x98>
   251be:	3101      	adds	r1, #1
   251c0:	1bc9      	subs	r1, r1, r7
   251c2:	468c      	mov	ip, r1
   251c4:	2100      	movs	r1, #0
   251c6:	6818      	ldr	r0, [r3, #0]
   251c8:	40b8      	lsls	r0, r7
   251ca:	4301      	orrs	r1, r0
   251cc:	4660      	mov	r0, ip
   251ce:	6021      	str	r1, [r4, #0]
   251d0:	cb02      	ldmia	r3!, {r1}
   251d2:	3404      	adds	r4, #4
   251d4:	40c1      	lsrs	r1, r0
   251d6:	429a      	cmp	r2, r3
   251d8:	d8f5      	bhi.n	251c6 <__lshift+0x56>
   251da:	6021      	str	r1, [r4, #0]
   251dc:	2900      	cmp	r1, #0
   251de:	d002      	beq.n	251e6 <__lshift+0x76>
   251e0:	9b02      	ldr	r3, [sp, #8]
   251e2:	3302      	adds	r3, #2
   251e4:	9301      	str	r3, [sp, #4]
   251e6:	9b01      	ldr	r3, [sp, #4]
   251e8:	9803      	ldr	r0, [sp, #12]
   251ea:	3b01      	subs	r3, #1
   251ec:	6133      	str	r3, [r6, #16]
   251ee:	0029      	movs	r1, r5
   251f0:	f7ff fe35 	bl	24e5e <_Bfree>
   251f4:	0030      	movs	r0, r6
   251f6:	b005      	add	sp, #20
   251f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   251fa:	3101      	adds	r1, #1
   251fc:	005b      	lsls	r3, r3, #1
   251fe:	e7c4      	b.n	2518a <__lshift+0x1a>
   25200:	0098      	lsls	r0, r3, #2
   25202:	5011      	str	r1, [r2, r0]
   25204:	3301      	adds	r3, #1
   25206:	e7cb      	b.n	251a0 <__lshift+0x30>
   25208:	cb02      	ldmia	r3!, {r1}
   2520a:	c402      	stmia	r4!, {r1}
   2520c:	429a      	cmp	r2, r3
   2520e:	d8fb      	bhi.n	25208 <__lshift+0x98>
   25210:	e7e9      	b.n	251e6 <__lshift+0x76>

00025212 <__mcmp>:
   25212:	690a      	ldr	r2, [r1, #16]
   25214:	6903      	ldr	r3, [r0, #16]
   25216:	b530      	push	{r4, r5, lr}
   25218:	1a9b      	subs	r3, r3, r2
   2521a:	d10e      	bne.n	2523a <__mcmp+0x28>
   2521c:	0092      	lsls	r2, r2, #2
   2521e:	3014      	adds	r0, #20
   25220:	3114      	adds	r1, #20
   25222:	1884      	adds	r4, r0, r2
   25224:	1889      	adds	r1, r1, r2
   25226:	3c04      	subs	r4, #4
   25228:	3904      	subs	r1, #4
   2522a:	6822      	ldr	r2, [r4, #0]
   2522c:	680d      	ldr	r5, [r1, #0]
   2522e:	42aa      	cmp	r2, r5
   25230:	d005      	beq.n	2523e <__mcmp+0x2c>
   25232:	42aa      	cmp	r2, r5
   25234:	4192      	sbcs	r2, r2
   25236:	2301      	movs	r3, #1
   25238:	4313      	orrs	r3, r2
   2523a:	0018      	movs	r0, r3
   2523c:	bd30      	pop	{r4, r5, pc}
   2523e:	42a0      	cmp	r0, r4
   25240:	d3f1      	bcc.n	25226 <__mcmp+0x14>
   25242:	e7fa      	b.n	2523a <__mcmp+0x28>

00025244 <__mdiff>:
   25244:	b5f0      	push	{r4, r5, r6, r7, lr}
   25246:	000d      	movs	r5, r1
   25248:	b085      	sub	sp, #20
   2524a:	0007      	movs	r7, r0
   2524c:	0011      	movs	r1, r2
   2524e:	0028      	movs	r0, r5
   25250:	0014      	movs	r4, r2
   25252:	f7ff ffde 	bl	25212 <__mcmp>
   25256:	1e06      	subs	r6, r0, #0
   25258:	d108      	bne.n	2526c <__mdiff+0x28>
   2525a:	0001      	movs	r1, r0
   2525c:	0038      	movs	r0, r7
   2525e:	f7ff fdc6 	bl	24dee <_Balloc>
   25262:	2301      	movs	r3, #1
   25264:	6146      	str	r6, [r0, #20]
   25266:	6103      	str	r3, [r0, #16]
   25268:	b005      	add	sp, #20
   2526a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2526c:	2301      	movs	r3, #1
   2526e:	9301      	str	r3, [sp, #4]
   25270:	2800      	cmp	r0, #0
   25272:	db04      	blt.n	2527e <__mdiff+0x3a>
   25274:	0023      	movs	r3, r4
   25276:	002c      	movs	r4, r5
   25278:	001d      	movs	r5, r3
   2527a:	2300      	movs	r3, #0
   2527c:	9301      	str	r3, [sp, #4]
   2527e:	6861      	ldr	r1, [r4, #4]
   25280:	0038      	movs	r0, r7
   25282:	f7ff fdb4 	bl	24dee <_Balloc>
   25286:	002f      	movs	r7, r5
   25288:	2200      	movs	r2, #0
   2528a:	9b01      	ldr	r3, [sp, #4]
   2528c:	6926      	ldr	r6, [r4, #16]
   2528e:	60c3      	str	r3, [r0, #12]
   25290:	3414      	adds	r4, #20
   25292:	00b3      	lsls	r3, r6, #2
   25294:	18e3      	adds	r3, r4, r3
   25296:	9302      	str	r3, [sp, #8]
   25298:	692b      	ldr	r3, [r5, #16]
   2529a:	3714      	adds	r7, #20
   2529c:	009b      	lsls	r3, r3, #2
   2529e:	18fb      	adds	r3, r7, r3
   252a0:	9303      	str	r3, [sp, #12]
   252a2:	0003      	movs	r3, r0
   252a4:	4694      	mov	ip, r2
   252a6:	3314      	adds	r3, #20
   252a8:	cc20      	ldmia	r4!, {r5}
   252aa:	cf04      	ldmia	r7!, {r2}
   252ac:	9201      	str	r2, [sp, #4]
   252ae:	b2aa      	uxth	r2, r5
   252b0:	4494      	add	ip, r2
   252b2:	466a      	mov	r2, sp
   252b4:	4661      	mov	r1, ip
   252b6:	8892      	ldrh	r2, [r2, #4]
   252b8:	0c2d      	lsrs	r5, r5, #16
   252ba:	1a8a      	subs	r2, r1, r2
   252bc:	9901      	ldr	r1, [sp, #4]
   252be:	0c09      	lsrs	r1, r1, #16
   252c0:	1a69      	subs	r1, r5, r1
   252c2:	1415      	asrs	r5, r2, #16
   252c4:	1949      	adds	r1, r1, r5
   252c6:	140d      	asrs	r5, r1, #16
   252c8:	b292      	uxth	r2, r2
   252ca:	0409      	lsls	r1, r1, #16
   252cc:	430a      	orrs	r2, r1
   252ce:	601a      	str	r2, [r3, #0]
   252d0:	9a03      	ldr	r2, [sp, #12]
   252d2:	46ac      	mov	ip, r5
   252d4:	3304      	adds	r3, #4
   252d6:	42ba      	cmp	r2, r7
   252d8:	d8e6      	bhi.n	252a8 <__mdiff+0x64>
   252da:	9902      	ldr	r1, [sp, #8]
   252dc:	001a      	movs	r2, r3
   252de:	428c      	cmp	r4, r1
   252e0:	d305      	bcc.n	252ee <__mdiff+0xaa>
   252e2:	3a04      	subs	r2, #4
   252e4:	6813      	ldr	r3, [r2, #0]
   252e6:	2b00      	cmp	r3, #0
   252e8:	d00e      	beq.n	25308 <__mdiff+0xc4>
   252ea:	6106      	str	r6, [r0, #16]
   252ec:	e7bc      	b.n	25268 <__mdiff+0x24>
   252ee:	cc04      	ldmia	r4!, {r2}
   252f0:	b291      	uxth	r1, r2
   252f2:	4461      	add	r1, ip
   252f4:	140d      	asrs	r5, r1, #16
   252f6:	0c12      	lsrs	r2, r2, #16
   252f8:	1952      	adds	r2, r2, r5
   252fa:	1415      	asrs	r5, r2, #16
   252fc:	b289      	uxth	r1, r1
   252fe:	0412      	lsls	r2, r2, #16
   25300:	430a      	orrs	r2, r1
   25302:	46ac      	mov	ip, r5
   25304:	c304      	stmia	r3!, {r2}
   25306:	e7e8      	b.n	252da <__mdiff+0x96>
   25308:	3e01      	subs	r6, #1
   2530a:	e7ea      	b.n	252e2 <__mdiff+0x9e>

0002530c <__d2b>:
   2530c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   2530e:	001d      	movs	r5, r3
   25310:	2101      	movs	r1, #1
   25312:	9f08      	ldr	r7, [sp, #32]
   25314:	0014      	movs	r4, r2
   25316:	f7ff fd6a 	bl	24dee <_Balloc>
   2531a:	032b      	lsls	r3, r5, #12
   2531c:	006d      	lsls	r5, r5, #1
   2531e:	0006      	movs	r6, r0
   25320:	0b1b      	lsrs	r3, r3, #12
   25322:	0d6d      	lsrs	r5, r5, #21
   25324:	d124      	bne.n	25370 <__d2b+0x64>
   25326:	9301      	str	r3, [sp, #4]
   25328:	2c00      	cmp	r4, #0
   2532a:	d027      	beq.n	2537c <__d2b+0x70>
   2532c:	4668      	mov	r0, sp
   2532e:	9400      	str	r4, [sp, #0]
   25330:	f7ff fe04 	bl	24f3c <__lo0bits>
   25334:	9c00      	ldr	r4, [sp, #0]
   25336:	2800      	cmp	r0, #0
   25338:	d01e      	beq.n	25378 <__d2b+0x6c>
   2533a:	9b01      	ldr	r3, [sp, #4]
   2533c:	2120      	movs	r1, #32
   2533e:	001a      	movs	r2, r3
   25340:	1a09      	subs	r1, r1, r0
   25342:	408a      	lsls	r2, r1
   25344:	40c3      	lsrs	r3, r0
   25346:	4322      	orrs	r2, r4
   25348:	6172      	str	r2, [r6, #20]
   2534a:	9301      	str	r3, [sp, #4]
   2534c:	9c01      	ldr	r4, [sp, #4]
   2534e:	61b4      	str	r4, [r6, #24]
   25350:	1e63      	subs	r3, r4, #1
   25352:	419c      	sbcs	r4, r3
   25354:	3401      	adds	r4, #1
   25356:	6134      	str	r4, [r6, #16]
   25358:	2d00      	cmp	r5, #0
   2535a:	d018      	beq.n	2538e <__d2b+0x82>
   2535c:	4b12      	ldr	r3, [pc, #72]	; (253a8 <__d2b+0x9c>)
   2535e:	18ed      	adds	r5, r5, r3
   25360:	2335      	movs	r3, #53	; 0x35
   25362:	182d      	adds	r5, r5, r0
   25364:	603d      	str	r5, [r7, #0]
   25366:	1a18      	subs	r0, r3, r0
   25368:	9b09      	ldr	r3, [sp, #36]	; 0x24
   2536a:	6018      	str	r0, [r3, #0]
   2536c:	0030      	movs	r0, r6
   2536e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
   25370:	2280      	movs	r2, #128	; 0x80
   25372:	0352      	lsls	r2, r2, #13
   25374:	4313      	orrs	r3, r2
   25376:	e7d6      	b.n	25326 <__d2b+0x1a>
   25378:	6174      	str	r4, [r6, #20]
   2537a:	e7e7      	b.n	2534c <__d2b+0x40>
   2537c:	a801      	add	r0, sp, #4
   2537e:	f7ff fddd 	bl	24f3c <__lo0bits>
   25382:	2401      	movs	r4, #1
   25384:	9b01      	ldr	r3, [sp, #4]
   25386:	6134      	str	r4, [r6, #16]
   25388:	6173      	str	r3, [r6, #20]
   2538a:	3020      	adds	r0, #32
   2538c:	e7e4      	b.n	25358 <__d2b+0x4c>
   2538e:	4b07      	ldr	r3, [pc, #28]	; (253ac <__d2b+0xa0>)
   25390:	18c0      	adds	r0, r0, r3
   25392:	4b07      	ldr	r3, [pc, #28]	; (253b0 <__d2b+0xa4>)
   25394:	6038      	str	r0, [r7, #0]
   25396:	18e3      	adds	r3, r4, r3
   25398:	009b      	lsls	r3, r3, #2
   2539a:	18f3      	adds	r3, r6, r3
   2539c:	6958      	ldr	r0, [r3, #20]
   2539e:	f7ff fdb3 	bl	24f08 <__hi0bits>
   253a2:	0164      	lsls	r4, r4, #5
   253a4:	1a20      	subs	r0, r4, r0
   253a6:	e7df      	b.n	25368 <__d2b+0x5c>
   253a8:	fffffbcd 	.word	0xfffffbcd
   253ac:	fffffbce 	.word	0xfffffbce
   253b0:	3fffffff 	.word	0x3fffffff

000253b4 <_calloc_r>:
   253b4:	434a      	muls	r2, r1
   253b6:	b570      	push	{r4, r5, r6, lr}
   253b8:	0011      	movs	r1, r2
   253ba:	0014      	movs	r4, r2
   253bc:	f7fd fc96 	bl	22cec <_malloc_r>
   253c0:	1e05      	subs	r5, r0, #0
   253c2:	d003      	beq.n	253cc <_calloc_r+0x18>
   253c4:	0022      	movs	r2, r4
   253c6:	2100      	movs	r1, #0
   253c8:	f7fd fc3d 	bl	22c46 <memset>
   253cc:	0028      	movs	r0, r5
   253ce:	bd70      	pop	{r4, r5, r6, pc}

000253d0 <__ssputs_r>:
   253d0:	b5f0      	push	{r4, r5, r6, r7, lr}
   253d2:	688e      	ldr	r6, [r1, #8]
   253d4:	b085      	sub	sp, #20
   253d6:	0007      	movs	r7, r0
   253d8:	000c      	movs	r4, r1
   253da:	9203      	str	r2, [sp, #12]
   253dc:	9301      	str	r3, [sp, #4]
   253de:	429e      	cmp	r6, r3
   253e0:	d839      	bhi.n	25456 <__ssputs_r+0x86>
   253e2:	2390      	movs	r3, #144	; 0x90
   253e4:	898a      	ldrh	r2, [r1, #12]
   253e6:	00db      	lsls	r3, r3, #3
   253e8:	421a      	tst	r2, r3
   253ea:	d034      	beq.n	25456 <__ssputs_r+0x86>
   253ec:	2503      	movs	r5, #3
   253ee:	6909      	ldr	r1, [r1, #16]
   253f0:	6823      	ldr	r3, [r4, #0]
   253f2:	1a5b      	subs	r3, r3, r1
   253f4:	9302      	str	r3, [sp, #8]
   253f6:	6963      	ldr	r3, [r4, #20]
   253f8:	9802      	ldr	r0, [sp, #8]
   253fa:	435d      	muls	r5, r3
   253fc:	0feb      	lsrs	r3, r5, #31
   253fe:	195d      	adds	r5, r3, r5
   25400:	9b01      	ldr	r3, [sp, #4]
   25402:	106d      	asrs	r5, r5, #1
   25404:	3301      	adds	r3, #1
   25406:	181b      	adds	r3, r3, r0
   25408:	42ab      	cmp	r3, r5
   2540a:	d900      	bls.n	2540e <__ssputs_r+0x3e>
   2540c:	001d      	movs	r5, r3
   2540e:	0553      	lsls	r3, r2, #21
   25410:	d532      	bpl.n	25478 <__ssputs_r+0xa8>
   25412:	0029      	movs	r1, r5
   25414:	0038      	movs	r0, r7
   25416:	f7fd fc69 	bl	22cec <_malloc_r>
   2541a:	1e06      	subs	r6, r0, #0
   2541c:	d109      	bne.n	25432 <__ssputs_r+0x62>
   2541e:	230c      	movs	r3, #12
   25420:	603b      	str	r3, [r7, #0]
   25422:	2340      	movs	r3, #64	; 0x40
   25424:	2001      	movs	r0, #1
   25426:	89a2      	ldrh	r2, [r4, #12]
   25428:	4240      	negs	r0, r0
   2542a:	4313      	orrs	r3, r2
   2542c:	81a3      	strh	r3, [r4, #12]
   2542e:	b005      	add	sp, #20
   25430:	bdf0      	pop	{r4, r5, r6, r7, pc}
   25432:	9a02      	ldr	r2, [sp, #8]
   25434:	6921      	ldr	r1, [r4, #16]
   25436:	f7fd fbeb 	bl	22c10 <memcpy>
   2543a:	89a3      	ldrh	r3, [r4, #12]
   2543c:	4a14      	ldr	r2, [pc, #80]	; (25490 <__ssputs_r+0xc0>)
   2543e:	401a      	ands	r2, r3
   25440:	2380      	movs	r3, #128	; 0x80
   25442:	4313      	orrs	r3, r2
   25444:	81a3      	strh	r3, [r4, #12]
   25446:	9b02      	ldr	r3, [sp, #8]
   25448:	6126      	str	r6, [r4, #16]
   2544a:	18f6      	adds	r6, r6, r3
   2544c:	6026      	str	r6, [r4, #0]
   2544e:	6165      	str	r5, [r4, #20]
   25450:	9e01      	ldr	r6, [sp, #4]
   25452:	1aed      	subs	r5, r5, r3
   25454:	60a5      	str	r5, [r4, #8]
   25456:	9b01      	ldr	r3, [sp, #4]
   25458:	42b3      	cmp	r3, r6
   2545a:	d200      	bcs.n	2545e <__ssputs_r+0x8e>
   2545c:	001e      	movs	r6, r3
   2545e:	0032      	movs	r2, r6
   25460:	9903      	ldr	r1, [sp, #12]
   25462:	6820      	ldr	r0, [r4, #0]
   25464:	f7fd fbdd 	bl	22c22 <memmove>
   25468:	68a3      	ldr	r3, [r4, #8]
   2546a:	2000      	movs	r0, #0
   2546c:	1b9b      	subs	r3, r3, r6
   2546e:	60a3      	str	r3, [r4, #8]
   25470:	6823      	ldr	r3, [r4, #0]
   25472:	199e      	adds	r6, r3, r6
   25474:	6026      	str	r6, [r4, #0]
   25476:	e7da      	b.n	2542e <__ssputs_r+0x5e>
   25478:	002a      	movs	r2, r5
   2547a:	0038      	movs	r0, r7
   2547c:	f000 f9d2 	bl	25824 <_realloc_r>
   25480:	1e06      	subs	r6, r0, #0
   25482:	d1e0      	bne.n	25446 <__ssputs_r+0x76>
   25484:	6921      	ldr	r1, [r4, #16]
   25486:	0038      	movs	r0, r7
   25488:	f7fd fbe6 	bl	22c58 <_free_r>
   2548c:	e7c7      	b.n	2541e <__ssputs_r+0x4e>
   2548e:	46c0      	nop			; (mov r8, r8)
   25490:	fffffb7f 	.word	0xfffffb7f

00025494 <_svfiprintf_r>:
   25494:	b5f0      	push	{r4, r5, r6, r7, lr}
   25496:	b09f      	sub	sp, #124	; 0x7c
   25498:	9002      	str	r0, [sp, #8]
   2549a:	9305      	str	r3, [sp, #20]
   2549c:	898b      	ldrh	r3, [r1, #12]
   2549e:	000f      	movs	r7, r1
   254a0:	0016      	movs	r6, r2
   254a2:	061b      	lsls	r3, r3, #24
   254a4:	d511      	bpl.n	254ca <_svfiprintf_r+0x36>
   254a6:	690b      	ldr	r3, [r1, #16]
   254a8:	2b00      	cmp	r3, #0
   254aa:	d10e      	bne.n	254ca <_svfiprintf_r+0x36>
   254ac:	2140      	movs	r1, #64	; 0x40
   254ae:	f7fd fc1d 	bl	22cec <_malloc_r>
   254b2:	6038      	str	r0, [r7, #0]
   254b4:	6138      	str	r0, [r7, #16]
   254b6:	2800      	cmp	r0, #0
   254b8:	d105      	bne.n	254c6 <_svfiprintf_r+0x32>
   254ba:	230c      	movs	r3, #12
   254bc:	9a02      	ldr	r2, [sp, #8]
   254be:	3801      	subs	r0, #1
   254c0:	6013      	str	r3, [r2, #0]
   254c2:	b01f      	add	sp, #124	; 0x7c
   254c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   254c6:	2340      	movs	r3, #64	; 0x40
   254c8:	617b      	str	r3, [r7, #20]
   254ca:	2300      	movs	r3, #0
   254cc:	ad06      	add	r5, sp, #24
   254ce:	616b      	str	r3, [r5, #20]
   254d0:	3320      	adds	r3, #32
   254d2:	766b      	strb	r3, [r5, #25]
   254d4:	3310      	adds	r3, #16
   254d6:	76ab      	strb	r3, [r5, #26]
   254d8:	0034      	movs	r4, r6
   254da:	7823      	ldrb	r3, [r4, #0]
   254dc:	2b00      	cmp	r3, #0
   254de:	d147      	bne.n	25570 <_svfiprintf_r+0xdc>
   254e0:	1ba3      	subs	r3, r4, r6
   254e2:	9304      	str	r3, [sp, #16]
   254e4:	d00d      	beq.n	25502 <_svfiprintf_r+0x6e>
   254e6:	1ba3      	subs	r3, r4, r6
   254e8:	0032      	movs	r2, r6
   254ea:	0039      	movs	r1, r7
   254ec:	9802      	ldr	r0, [sp, #8]
   254ee:	f7ff ff6f 	bl	253d0 <__ssputs_r>
   254f2:	1c43      	adds	r3, r0, #1
   254f4:	d100      	bne.n	254f8 <_svfiprintf_r+0x64>
   254f6:	e0b5      	b.n	25664 <_svfiprintf_r+0x1d0>
   254f8:	696a      	ldr	r2, [r5, #20]
   254fa:	9b04      	ldr	r3, [sp, #16]
   254fc:	4694      	mov	ip, r2
   254fe:	4463      	add	r3, ip
   25500:	616b      	str	r3, [r5, #20]
   25502:	7823      	ldrb	r3, [r4, #0]
   25504:	2b00      	cmp	r3, #0
   25506:	d100      	bne.n	2550a <_svfiprintf_r+0x76>
   25508:	e0ac      	b.n	25664 <_svfiprintf_r+0x1d0>
   2550a:	2201      	movs	r2, #1
   2550c:	2300      	movs	r3, #0
   2550e:	4252      	negs	r2, r2
   25510:	606a      	str	r2, [r5, #4]
   25512:	a902      	add	r1, sp, #8
   25514:	3254      	adds	r2, #84	; 0x54
   25516:	1852      	adds	r2, r2, r1
   25518:	3401      	adds	r4, #1
   2551a:	602b      	str	r3, [r5, #0]
   2551c:	60eb      	str	r3, [r5, #12]
   2551e:	60ab      	str	r3, [r5, #8]
   25520:	7013      	strb	r3, [r2, #0]
   25522:	65ab      	str	r3, [r5, #88]	; 0x58
   25524:	4e58      	ldr	r6, [pc, #352]	; (25688 <_svfiprintf_r+0x1f4>)
   25526:	2205      	movs	r2, #5
   25528:	7821      	ldrb	r1, [r4, #0]
   2552a:	0030      	movs	r0, r6
   2552c:	f7ff fc52 	bl	24dd4 <memchr>
   25530:	1c62      	adds	r2, r4, #1
   25532:	2800      	cmp	r0, #0
   25534:	d120      	bne.n	25578 <_svfiprintf_r+0xe4>
   25536:	6829      	ldr	r1, [r5, #0]
   25538:	06cb      	lsls	r3, r1, #27
   2553a:	d504      	bpl.n	25546 <_svfiprintf_r+0xb2>
   2553c:	2353      	movs	r3, #83	; 0x53
   2553e:	ae02      	add	r6, sp, #8
   25540:	3020      	adds	r0, #32
   25542:	199b      	adds	r3, r3, r6
   25544:	7018      	strb	r0, [r3, #0]
   25546:	070b      	lsls	r3, r1, #28
   25548:	d504      	bpl.n	25554 <_svfiprintf_r+0xc0>
   2554a:	2353      	movs	r3, #83	; 0x53
   2554c:	202b      	movs	r0, #43	; 0x2b
   2554e:	ae02      	add	r6, sp, #8
   25550:	199b      	adds	r3, r3, r6
   25552:	7018      	strb	r0, [r3, #0]
   25554:	7823      	ldrb	r3, [r4, #0]
   25556:	2b2a      	cmp	r3, #42	; 0x2a
   25558:	d016      	beq.n	25588 <_svfiprintf_r+0xf4>
   2555a:	2000      	movs	r0, #0
   2555c:	210a      	movs	r1, #10
   2555e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   25560:	7822      	ldrb	r2, [r4, #0]
   25562:	3a30      	subs	r2, #48	; 0x30
   25564:	2a09      	cmp	r2, #9
   25566:	d955      	bls.n	25614 <_svfiprintf_r+0x180>
   25568:	2800      	cmp	r0, #0
   2556a:	d015      	beq.n	25598 <_svfiprintf_r+0x104>
   2556c:	9309      	str	r3, [sp, #36]	; 0x24
   2556e:	e013      	b.n	25598 <_svfiprintf_r+0x104>
   25570:	2b25      	cmp	r3, #37	; 0x25
   25572:	d0b5      	beq.n	254e0 <_svfiprintf_r+0x4c>
   25574:	3401      	adds	r4, #1
   25576:	e7b0      	b.n	254da <_svfiprintf_r+0x46>
   25578:	2301      	movs	r3, #1
   2557a:	1b80      	subs	r0, r0, r6
   2557c:	4083      	lsls	r3, r0
   2557e:	6829      	ldr	r1, [r5, #0]
   25580:	0014      	movs	r4, r2
   25582:	430b      	orrs	r3, r1
   25584:	602b      	str	r3, [r5, #0]
   25586:	e7cd      	b.n	25524 <_svfiprintf_r+0x90>
   25588:	9b05      	ldr	r3, [sp, #20]
   2558a:	1d18      	adds	r0, r3, #4
   2558c:	681b      	ldr	r3, [r3, #0]
   2558e:	9005      	str	r0, [sp, #20]
   25590:	2b00      	cmp	r3, #0
   25592:	db39      	blt.n	25608 <_svfiprintf_r+0x174>
   25594:	9309      	str	r3, [sp, #36]	; 0x24
   25596:	0014      	movs	r4, r2
   25598:	7823      	ldrb	r3, [r4, #0]
   2559a:	2b2e      	cmp	r3, #46	; 0x2e
   2559c:	d10b      	bne.n	255b6 <_svfiprintf_r+0x122>
   2559e:	7863      	ldrb	r3, [r4, #1]
   255a0:	1c62      	adds	r2, r4, #1
   255a2:	2b2a      	cmp	r3, #42	; 0x2a
   255a4:	d13e      	bne.n	25624 <_svfiprintf_r+0x190>
   255a6:	9b05      	ldr	r3, [sp, #20]
   255a8:	3402      	adds	r4, #2
   255aa:	1d1a      	adds	r2, r3, #4
   255ac:	681b      	ldr	r3, [r3, #0]
   255ae:	9205      	str	r2, [sp, #20]
   255b0:	2b00      	cmp	r3, #0
   255b2:	db34      	blt.n	2561e <_svfiprintf_r+0x18a>
   255b4:	9307      	str	r3, [sp, #28]
   255b6:	4e35      	ldr	r6, [pc, #212]	; (2568c <_svfiprintf_r+0x1f8>)
   255b8:	7821      	ldrb	r1, [r4, #0]
   255ba:	2203      	movs	r2, #3
   255bc:	0030      	movs	r0, r6
   255be:	f7ff fc09 	bl	24dd4 <memchr>
   255c2:	2800      	cmp	r0, #0
   255c4:	d006      	beq.n	255d4 <_svfiprintf_r+0x140>
   255c6:	2340      	movs	r3, #64	; 0x40
   255c8:	1b80      	subs	r0, r0, r6
   255ca:	4083      	lsls	r3, r0
   255cc:	682a      	ldr	r2, [r5, #0]
   255ce:	3401      	adds	r4, #1
   255d0:	4313      	orrs	r3, r2
   255d2:	602b      	str	r3, [r5, #0]
   255d4:	7821      	ldrb	r1, [r4, #0]
   255d6:	2206      	movs	r2, #6
   255d8:	482d      	ldr	r0, [pc, #180]	; (25690 <_svfiprintf_r+0x1fc>)
   255da:	1c66      	adds	r6, r4, #1
   255dc:	7629      	strb	r1, [r5, #24]
   255de:	f7ff fbf9 	bl	24dd4 <memchr>
   255e2:	2800      	cmp	r0, #0
   255e4:	d046      	beq.n	25674 <_svfiprintf_r+0x1e0>
   255e6:	4b2b      	ldr	r3, [pc, #172]	; (25694 <_svfiprintf_r+0x200>)
   255e8:	2b00      	cmp	r3, #0
   255ea:	d12f      	bne.n	2564c <_svfiprintf_r+0x1b8>
   255ec:	6829      	ldr	r1, [r5, #0]
   255ee:	9b05      	ldr	r3, [sp, #20]
   255f0:	2207      	movs	r2, #7
   255f2:	05c9      	lsls	r1, r1, #23
   255f4:	d528      	bpl.n	25648 <_svfiprintf_r+0x1b4>
   255f6:	189b      	adds	r3, r3, r2
   255f8:	4393      	bics	r3, r2
   255fa:	3308      	adds	r3, #8
   255fc:	9305      	str	r3, [sp, #20]
   255fe:	696b      	ldr	r3, [r5, #20]
   25600:	9a03      	ldr	r2, [sp, #12]
   25602:	189b      	adds	r3, r3, r2
   25604:	616b      	str	r3, [r5, #20]
   25606:	e767      	b.n	254d8 <_svfiprintf_r+0x44>
   25608:	425b      	negs	r3, r3
   2560a:	60eb      	str	r3, [r5, #12]
   2560c:	2302      	movs	r3, #2
   2560e:	430b      	orrs	r3, r1
   25610:	602b      	str	r3, [r5, #0]
   25612:	e7c0      	b.n	25596 <_svfiprintf_r+0x102>
   25614:	434b      	muls	r3, r1
   25616:	3401      	adds	r4, #1
   25618:	189b      	adds	r3, r3, r2
   2561a:	2001      	movs	r0, #1
   2561c:	e7a0      	b.n	25560 <_svfiprintf_r+0xcc>
   2561e:	2301      	movs	r3, #1
   25620:	425b      	negs	r3, r3
   25622:	e7c7      	b.n	255b4 <_svfiprintf_r+0x120>
   25624:	2300      	movs	r3, #0
   25626:	0014      	movs	r4, r2
   25628:	200a      	movs	r0, #10
   2562a:	001a      	movs	r2, r3
   2562c:	606b      	str	r3, [r5, #4]
   2562e:	7821      	ldrb	r1, [r4, #0]
   25630:	3930      	subs	r1, #48	; 0x30
   25632:	2909      	cmp	r1, #9
   25634:	d903      	bls.n	2563e <_svfiprintf_r+0x1aa>
   25636:	2b00      	cmp	r3, #0
   25638:	d0bd      	beq.n	255b6 <_svfiprintf_r+0x122>
   2563a:	9207      	str	r2, [sp, #28]
   2563c:	e7bb      	b.n	255b6 <_svfiprintf_r+0x122>
   2563e:	4342      	muls	r2, r0
   25640:	3401      	adds	r4, #1
   25642:	1852      	adds	r2, r2, r1
   25644:	2301      	movs	r3, #1
   25646:	e7f2      	b.n	2562e <_svfiprintf_r+0x19a>
   25648:	3307      	adds	r3, #7
   2564a:	e7d5      	b.n	255f8 <_svfiprintf_r+0x164>
   2564c:	ab05      	add	r3, sp, #20
   2564e:	9300      	str	r3, [sp, #0]
   25650:	003a      	movs	r2, r7
   25652:	4b11      	ldr	r3, [pc, #68]	; (25698 <_svfiprintf_r+0x204>)
   25654:	0029      	movs	r1, r5
   25656:	9802      	ldr	r0, [sp, #8]
   25658:	f7fd fc42 	bl	22ee0 <_printf_float>
   2565c:	9003      	str	r0, [sp, #12]
   2565e:	9b03      	ldr	r3, [sp, #12]
   25660:	3301      	adds	r3, #1
   25662:	d1cc      	bne.n	255fe <_svfiprintf_r+0x16a>
   25664:	89bb      	ldrh	r3, [r7, #12]
   25666:	980b      	ldr	r0, [sp, #44]	; 0x2c
   25668:	065b      	lsls	r3, r3, #25
   2566a:	d400      	bmi.n	2566e <_svfiprintf_r+0x1da>
   2566c:	e729      	b.n	254c2 <_svfiprintf_r+0x2e>
   2566e:	2001      	movs	r0, #1
   25670:	4240      	negs	r0, r0
   25672:	e726      	b.n	254c2 <_svfiprintf_r+0x2e>
   25674:	ab05      	add	r3, sp, #20
   25676:	9300      	str	r3, [sp, #0]
   25678:	003a      	movs	r2, r7
   2567a:	4b07      	ldr	r3, [pc, #28]	; (25698 <_svfiprintf_r+0x204>)
   2567c:	0029      	movs	r1, r5
   2567e:	9802      	ldr	r0, [sp, #8]
   25680:	f7fd fee8 	bl	23454 <_printf_i>
   25684:	e7ea      	b.n	2565c <_svfiprintf_r+0x1c8>
   25686:	46c0      	nop			; (mov r8, r8)
   25688:	0002b814 	.word	0x0002b814
   2568c:	0002b81a 	.word	0x0002b81a
   25690:	0002b81e 	.word	0x0002b81e
   25694:	00022ee1 	.word	0x00022ee1
   25698:	000253d1 	.word	0x000253d1

0002569c <__sread>:
   2569c:	b570      	push	{r4, r5, r6, lr}
   2569e:	000c      	movs	r4, r1
   256a0:	250e      	movs	r5, #14
   256a2:	5f49      	ldrsh	r1, [r1, r5]
   256a4:	f000 f8e4 	bl	25870 <_read_r>
   256a8:	2800      	cmp	r0, #0
   256aa:	db03      	blt.n	256b4 <__sread+0x18>
   256ac:	6d63      	ldr	r3, [r4, #84]	; 0x54
   256ae:	181b      	adds	r3, r3, r0
   256b0:	6563      	str	r3, [r4, #84]	; 0x54
   256b2:	bd70      	pop	{r4, r5, r6, pc}
   256b4:	89a3      	ldrh	r3, [r4, #12]
   256b6:	4a02      	ldr	r2, [pc, #8]	; (256c0 <__sread+0x24>)
   256b8:	4013      	ands	r3, r2
   256ba:	81a3      	strh	r3, [r4, #12]
   256bc:	e7f9      	b.n	256b2 <__sread+0x16>
   256be:	46c0      	nop			; (mov r8, r8)
   256c0:	ffffefff 	.word	0xffffefff

000256c4 <__swrite>:
   256c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   256c6:	001f      	movs	r7, r3
   256c8:	898b      	ldrh	r3, [r1, #12]
   256ca:	0005      	movs	r5, r0
   256cc:	000c      	movs	r4, r1
   256ce:	0016      	movs	r6, r2
   256d0:	05db      	lsls	r3, r3, #23
   256d2:	d505      	bpl.n	256e0 <__swrite+0x1c>
   256d4:	230e      	movs	r3, #14
   256d6:	5ec9      	ldrsh	r1, [r1, r3]
   256d8:	2200      	movs	r2, #0
   256da:	2302      	movs	r3, #2
   256dc:	f000 f88e 	bl	257fc <_lseek_r>
   256e0:	89a3      	ldrh	r3, [r4, #12]
   256e2:	4a05      	ldr	r2, [pc, #20]	; (256f8 <__swrite+0x34>)
   256e4:	0028      	movs	r0, r5
   256e6:	4013      	ands	r3, r2
   256e8:	81a3      	strh	r3, [r4, #12]
   256ea:	0032      	movs	r2, r6
   256ec:	230e      	movs	r3, #14
   256ee:	5ee1      	ldrsh	r1, [r4, r3]
   256f0:	003b      	movs	r3, r7
   256f2:	f000 f839 	bl	25768 <_write_r>
   256f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   256f8:	ffffefff 	.word	0xffffefff

000256fc <__sseek>:
   256fc:	b570      	push	{r4, r5, r6, lr}
   256fe:	000c      	movs	r4, r1
   25700:	250e      	movs	r5, #14
   25702:	5f49      	ldrsh	r1, [r1, r5]
   25704:	f000 f87a 	bl	257fc <_lseek_r>
   25708:	89a3      	ldrh	r3, [r4, #12]
   2570a:	1c42      	adds	r2, r0, #1
   2570c:	d103      	bne.n	25716 <__sseek+0x1a>
   2570e:	4a05      	ldr	r2, [pc, #20]	; (25724 <__sseek+0x28>)
   25710:	4013      	ands	r3, r2
   25712:	81a3      	strh	r3, [r4, #12]
   25714:	bd70      	pop	{r4, r5, r6, pc}
   25716:	2280      	movs	r2, #128	; 0x80
   25718:	0152      	lsls	r2, r2, #5
   2571a:	4313      	orrs	r3, r2
   2571c:	81a3      	strh	r3, [r4, #12]
   2571e:	6560      	str	r0, [r4, #84]	; 0x54
   25720:	e7f8      	b.n	25714 <__sseek+0x18>
   25722:	46c0      	nop			; (mov r8, r8)
   25724:	ffffefff 	.word	0xffffefff

00025728 <__sclose>:
   25728:	b510      	push	{r4, lr}
   2572a:	230e      	movs	r3, #14
   2572c:	5ec9      	ldrsh	r1, [r1, r3]
   2572e:	f000 f82f 	bl	25790 <_close_r>
   25732:	bd10      	pop	{r4, pc}

00025734 <strchr>:
   25734:	b2c9      	uxtb	r1, r1
   25736:	7803      	ldrb	r3, [r0, #0]
   25738:	2b00      	cmp	r3, #0
   2573a:	d004      	beq.n	25746 <strchr+0x12>
   2573c:	4299      	cmp	r1, r3
   2573e:	d100      	bne.n	25742 <strchr+0xe>
   25740:	4770      	bx	lr
   25742:	3001      	adds	r0, #1
   25744:	e7f7      	b.n	25736 <strchr+0x2>
   25746:	424b      	negs	r3, r1
   25748:	4159      	adcs	r1, r3
   2574a:	4249      	negs	r1, r1
   2574c:	4008      	ands	r0, r1
   2574e:	e7f7      	b.n	25740 <strchr+0xc>

00025750 <__ascii_wctomb>:
   25750:	1e0b      	subs	r3, r1, #0
   25752:	d004      	beq.n	2575e <__ascii_wctomb+0xe>
   25754:	2aff      	cmp	r2, #255	; 0xff
   25756:	d904      	bls.n	25762 <__ascii_wctomb+0x12>
   25758:	238a      	movs	r3, #138	; 0x8a
   2575a:	6003      	str	r3, [r0, #0]
   2575c:	3b8b      	subs	r3, #139	; 0x8b
   2575e:	0018      	movs	r0, r3
   25760:	4770      	bx	lr
   25762:	700a      	strb	r2, [r1, #0]
   25764:	2301      	movs	r3, #1
   25766:	e7fa      	b.n	2575e <__ascii_wctomb+0xe>

00025768 <_write_r>:
   25768:	b570      	push	{r4, r5, r6, lr}
   2576a:	0005      	movs	r5, r0
   2576c:	0008      	movs	r0, r1
   2576e:	0011      	movs	r1, r2
   25770:	2200      	movs	r2, #0
   25772:	4c06      	ldr	r4, [pc, #24]	; (2578c <_write_r+0x24>)
   25774:	6022      	str	r2, [r4, #0]
   25776:	001a      	movs	r2, r3
   25778:	f7f9 fc5a 	bl	1f030 <_write>
   2577c:	1c43      	adds	r3, r0, #1
   2577e:	d103      	bne.n	25788 <_write_r+0x20>
   25780:	6823      	ldr	r3, [r4, #0]
   25782:	2b00      	cmp	r3, #0
   25784:	d000      	beq.n	25788 <_write_r+0x20>
   25786:	602b      	str	r3, [r5, #0]
   25788:	bd70      	pop	{r4, r5, r6, pc}
   2578a:	46c0      	nop			; (mov r8, r8)
   2578c:	20005760 	.word	0x20005760

00025790 <_close_r>:
   25790:	2300      	movs	r3, #0
   25792:	b570      	push	{r4, r5, r6, lr}
   25794:	4c06      	ldr	r4, [pc, #24]	; (257b0 <_close_r+0x20>)
   25796:	0005      	movs	r5, r0
   25798:	0008      	movs	r0, r1
   2579a:	6023      	str	r3, [r4, #0]
   2579c:	f7f9 fc72 	bl	1f084 <_close>
   257a0:	1c43      	adds	r3, r0, #1
   257a2:	d103      	bne.n	257ac <_close_r+0x1c>
   257a4:	6823      	ldr	r3, [r4, #0]
   257a6:	2b00      	cmp	r3, #0
   257a8:	d000      	beq.n	257ac <_close_r+0x1c>
   257aa:	602b      	str	r3, [r5, #0]
   257ac:	bd70      	pop	{r4, r5, r6, pc}
   257ae:	46c0      	nop			; (mov r8, r8)
   257b0:	20005760 	.word	0x20005760

000257b4 <_fstat_r>:
   257b4:	2300      	movs	r3, #0
   257b6:	b570      	push	{r4, r5, r6, lr}
   257b8:	4c06      	ldr	r4, [pc, #24]	; (257d4 <_fstat_r+0x20>)
   257ba:	0005      	movs	r5, r0
   257bc:	0008      	movs	r0, r1
   257be:	0011      	movs	r1, r2
   257c0:	6023      	str	r3, [r4, #0]
   257c2:	f7f9 fc62 	bl	1f08a <_fstat>
   257c6:	1c43      	adds	r3, r0, #1
   257c8:	d103      	bne.n	257d2 <_fstat_r+0x1e>
   257ca:	6823      	ldr	r3, [r4, #0]
   257cc:	2b00      	cmp	r3, #0
   257ce:	d000      	beq.n	257d2 <_fstat_r+0x1e>
   257d0:	602b      	str	r3, [r5, #0]
   257d2:	bd70      	pop	{r4, r5, r6, pc}
   257d4:	20005760 	.word	0x20005760

000257d8 <_isatty_r>:
   257d8:	2300      	movs	r3, #0
   257da:	b570      	push	{r4, r5, r6, lr}
   257dc:	4c06      	ldr	r4, [pc, #24]	; (257f8 <_isatty_r+0x20>)
   257de:	0005      	movs	r5, r0
   257e0:	0008      	movs	r0, r1
   257e2:	6023      	str	r3, [r4, #0]
   257e4:	f7f9 fc56 	bl	1f094 <_isatty>
   257e8:	1c43      	adds	r3, r0, #1
   257ea:	d103      	bne.n	257f4 <_isatty_r+0x1c>
   257ec:	6823      	ldr	r3, [r4, #0]
   257ee:	2b00      	cmp	r3, #0
   257f0:	d000      	beq.n	257f4 <_isatty_r+0x1c>
   257f2:	602b      	str	r3, [r5, #0]
   257f4:	bd70      	pop	{r4, r5, r6, pc}
   257f6:	46c0      	nop			; (mov r8, r8)
   257f8:	20005760 	.word	0x20005760

000257fc <_lseek_r>:
   257fc:	b570      	push	{r4, r5, r6, lr}
   257fe:	0005      	movs	r5, r0
   25800:	0008      	movs	r0, r1
   25802:	0011      	movs	r1, r2
   25804:	2200      	movs	r2, #0
   25806:	4c06      	ldr	r4, [pc, #24]	; (25820 <_lseek_r+0x24>)
   25808:	6022      	str	r2, [r4, #0]
   2580a:	001a      	movs	r2, r3
   2580c:	f7f9 fc44 	bl	1f098 <_lseek>
   25810:	1c43      	adds	r3, r0, #1
   25812:	d103      	bne.n	2581c <_lseek_r+0x20>
   25814:	6823      	ldr	r3, [r4, #0]
   25816:	2b00      	cmp	r3, #0
   25818:	d000      	beq.n	2581c <_lseek_r+0x20>
   2581a:	602b      	str	r3, [r5, #0]
   2581c:	bd70      	pop	{r4, r5, r6, pc}
   2581e:	46c0      	nop			; (mov r8, r8)
   25820:	20005760 	.word	0x20005760

00025824 <_realloc_r>:
   25824:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   25826:	0007      	movs	r7, r0
   25828:	000d      	movs	r5, r1
   2582a:	0016      	movs	r6, r2
   2582c:	2900      	cmp	r1, #0
   2582e:	d105      	bne.n	2583c <_realloc_r+0x18>
   25830:	0011      	movs	r1, r2
   25832:	f7fd fa5b 	bl	22cec <_malloc_r>
   25836:	0004      	movs	r4, r0
   25838:	0020      	movs	r0, r4
   2583a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2583c:	2a00      	cmp	r2, #0
   2583e:	d103      	bne.n	25848 <_realloc_r+0x24>
   25840:	f7fd fa0a 	bl	22c58 <_free_r>
   25844:	0034      	movs	r4, r6
   25846:	e7f7      	b.n	25838 <_realloc_r+0x14>
   25848:	f000 f826 	bl	25898 <_malloc_usable_size_r>
   2584c:	002c      	movs	r4, r5
   2584e:	4286      	cmp	r6, r0
   25850:	d9f2      	bls.n	25838 <_realloc_r+0x14>
   25852:	0031      	movs	r1, r6
   25854:	0038      	movs	r0, r7
   25856:	f7fd fa49 	bl	22cec <_malloc_r>
   2585a:	1e04      	subs	r4, r0, #0
   2585c:	d0ec      	beq.n	25838 <_realloc_r+0x14>
   2585e:	0029      	movs	r1, r5
   25860:	0032      	movs	r2, r6
   25862:	f7fd f9d5 	bl	22c10 <memcpy>
   25866:	0029      	movs	r1, r5
   25868:	0038      	movs	r0, r7
   2586a:	f7fd f9f5 	bl	22c58 <_free_r>
   2586e:	e7e3      	b.n	25838 <_realloc_r+0x14>

00025870 <_read_r>:
   25870:	b570      	push	{r4, r5, r6, lr}
   25872:	0005      	movs	r5, r0
   25874:	0008      	movs	r0, r1
   25876:	0011      	movs	r1, r2
   25878:	2200      	movs	r2, #0
   2587a:	4c06      	ldr	r4, [pc, #24]	; (25894 <_read_r+0x24>)
   2587c:	6022      	str	r2, [r4, #0]
   2587e:	001a      	movs	r2, r3
   25880:	f7f9 fbba 	bl	1eff8 <_read>
   25884:	1c43      	adds	r3, r0, #1
   25886:	d103      	bne.n	25890 <_read_r+0x20>
   25888:	6823      	ldr	r3, [r4, #0]
   2588a:	2b00      	cmp	r3, #0
   2588c:	d000      	beq.n	25890 <_read_r+0x20>
   2588e:	602b      	str	r3, [r5, #0]
   25890:	bd70      	pop	{r4, r5, r6, pc}
   25892:	46c0      	nop			; (mov r8, r8)
   25894:	20005760 	.word	0x20005760

00025898 <_malloc_usable_size_r>:
   25898:	1f0b      	subs	r3, r1, #4
   2589a:	681b      	ldr	r3, [r3, #0]
   2589c:	1f18      	subs	r0, r3, #4
   2589e:	2b00      	cmp	r3, #0
   258a0:	da01      	bge.n	258a6 <_malloc_usable_size_r+0xe>
   258a2:	580b      	ldr	r3, [r1, r0]
   258a4:	18c0      	adds	r0, r0, r3
   258a6:	4770      	bx	lr

000258a8 <__gnu_thumb1_case_uqi>:
   258a8:	b402      	push	{r1}
   258aa:	4671      	mov	r1, lr
   258ac:	0849      	lsrs	r1, r1, #1
   258ae:	0049      	lsls	r1, r1, #1
   258b0:	5c09      	ldrb	r1, [r1, r0]
   258b2:	0049      	lsls	r1, r1, #1
   258b4:	448e      	add	lr, r1
   258b6:	bc02      	pop	{r1}
   258b8:	4770      	bx	lr
   258ba:	46c0      	nop			; (mov r8, r8)

000258bc <__udivsi3>:
   258bc:	2200      	movs	r2, #0
   258be:	0843      	lsrs	r3, r0, #1
   258c0:	428b      	cmp	r3, r1
   258c2:	d374      	bcc.n	259ae <__udivsi3+0xf2>
   258c4:	0903      	lsrs	r3, r0, #4
   258c6:	428b      	cmp	r3, r1
   258c8:	d35f      	bcc.n	2598a <__udivsi3+0xce>
   258ca:	0a03      	lsrs	r3, r0, #8
   258cc:	428b      	cmp	r3, r1
   258ce:	d344      	bcc.n	2595a <__udivsi3+0x9e>
   258d0:	0b03      	lsrs	r3, r0, #12
   258d2:	428b      	cmp	r3, r1
   258d4:	d328      	bcc.n	25928 <__udivsi3+0x6c>
   258d6:	0c03      	lsrs	r3, r0, #16
   258d8:	428b      	cmp	r3, r1
   258da:	d30d      	bcc.n	258f8 <__udivsi3+0x3c>
   258dc:	22ff      	movs	r2, #255	; 0xff
   258de:	0209      	lsls	r1, r1, #8
   258e0:	ba12      	rev	r2, r2
   258e2:	0c03      	lsrs	r3, r0, #16
   258e4:	428b      	cmp	r3, r1
   258e6:	d302      	bcc.n	258ee <__udivsi3+0x32>
   258e8:	1212      	asrs	r2, r2, #8
   258ea:	0209      	lsls	r1, r1, #8
   258ec:	d065      	beq.n	259ba <__udivsi3+0xfe>
   258ee:	0b03      	lsrs	r3, r0, #12
   258f0:	428b      	cmp	r3, r1
   258f2:	d319      	bcc.n	25928 <__udivsi3+0x6c>
   258f4:	e000      	b.n	258f8 <__udivsi3+0x3c>
   258f6:	0a09      	lsrs	r1, r1, #8
   258f8:	0bc3      	lsrs	r3, r0, #15
   258fa:	428b      	cmp	r3, r1
   258fc:	d301      	bcc.n	25902 <__udivsi3+0x46>
   258fe:	03cb      	lsls	r3, r1, #15
   25900:	1ac0      	subs	r0, r0, r3
   25902:	4152      	adcs	r2, r2
   25904:	0b83      	lsrs	r3, r0, #14
   25906:	428b      	cmp	r3, r1
   25908:	d301      	bcc.n	2590e <__udivsi3+0x52>
   2590a:	038b      	lsls	r3, r1, #14
   2590c:	1ac0      	subs	r0, r0, r3
   2590e:	4152      	adcs	r2, r2
   25910:	0b43      	lsrs	r3, r0, #13
   25912:	428b      	cmp	r3, r1
   25914:	d301      	bcc.n	2591a <__udivsi3+0x5e>
   25916:	034b      	lsls	r3, r1, #13
   25918:	1ac0      	subs	r0, r0, r3
   2591a:	4152      	adcs	r2, r2
   2591c:	0b03      	lsrs	r3, r0, #12
   2591e:	428b      	cmp	r3, r1
   25920:	d301      	bcc.n	25926 <__udivsi3+0x6a>
   25922:	030b      	lsls	r3, r1, #12
   25924:	1ac0      	subs	r0, r0, r3
   25926:	4152      	adcs	r2, r2
   25928:	0ac3      	lsrs	r3, r0, #11
   2592a:	428b      	cmp	r3, r1
   2592c:	d301      	bcc.n	25932 <__udivsi3+0x76>
   2592e:	02cb      	lsls	r3, r1, #11
   25930:	1ac0      	subs	r0, r0, r3
   25932:	4152      	adcs	r2, r2
   25934:	0a83      	lsrs	r3, r0, #10
   25936:	428b      	cmp	r3, r1
   25938:	d301      	bcc.n	2593e <__udivsi3+0x82>
   2593a:	028b      	lsls	r3, r1, #10
   2593c:	1ac0      	subs	r0, r0, r3
   2593e:	4152      	adcs	r2, r2
   25940:	0a43      	lsrs	r3, r0, #9
   25942:	428b      	cmp	r3, r1
   25944:	d301      	bcc.n	2594a <__udivsi3+0x8e>
   25946:	024b      	lsls	r3, r1, #9
   25948:	1ac0      	subs	r0, r0, r3
   2594a:	4152      	adcs	r2, r2
   2594c:	0a03      	lsrs	r3, r0, #8
   2594e:	428b      	cmp	r3, r1
   25950:	d301      	bcc.n	25956 <__udivsi3+0x9a>
   25952:	020b      	lsls	r3, r1, #8
   25954:	1ac0      	subs	r0, r0, r3
   25956:	4152      	adcs	r2, r2
   25958:	d2cd      	bcs.n	258f6 <__udivsi3+0x3a>
   2595a:	09c3      	lsrs	r3, r0, #7
   2595c:	428b      	cmp	r3, r1
   2595e:	d301      	bcc.n	25964 <__udivsi3+0xa8>
   25960:	01cb      	lsls	r3, r1, #7
   25962:	1ac0      	subs	r0, r0, r3
   25964:	4152      	adcs	r2, r2
   25966:	0983      	lsrs	r3, r0, #6
   25968:	428b      	cmp	r3, r1
   2596a:	d301      	bcc.n	25970 <__udivsi3+0xb4>
   2596c:	018b      	lsls	r3, r1, #6
   2596e:	1ac0      	subs	r0, r0, r3
   25970:	4152      	adcs	r2, r2
   25972:	0943      	lsrs	r3, r0, #5
   25974:	428b      	cmp	r3, r1
   25976:	d301      	bcc.n	2597c <__udivsi3+0xc0>
   25978:	014b      	lsls	r3, r1, #5
   2597a:	1ac0      	subs	r0, r0, r3
   2597c:	4152      	adcs	r2, r2
   2597e:	0903      	lsrs	r3, r0, #4
   25980:	428b      	cmp	r3, r1
   25982:	d301      	bcc.n	25988 <__udivsi3+0xcc>
   25984:	010b      	lsls	r3, r1, #4
   25986:	1ac0      	subs	r0, r0, r3
   25988:	4152      	adcs	r2, r2
   2598a:	08c3      	lsrs	r3, r0, #3
   2598c:	428b      	cmp	r3, r1
   2598e:	d301      	bcc.n	25994 <__udivsi3+0xd8>
   25990:	00cb      	lsls	r3, r1, #3
   25992:	1ac0      	subs	r0, r0, r3
   25994:	4152      	adcs	r2, r2
   25996:	0883      	lsrs	r3, r0, #2
   25998:	428b      	cmp	r3, r1
   2599a:	d301      	bcc.n	259a0 <__udivsi3+0xe4>
   2599c:	008b      	lsls	r3, r1, #2
   2599e:	1ac0      	subs	r0, r0, r3
   259a0:	4152      	adcs	r2, r2
   259a2:	0843      	lsrs	r3, r0, #1
   259a4:	428b      	cmp	r3, r1
   259a6:	d301      	bcc.n	259ac <__udivsi3+0xf0>
   259a8:	004b      	lsls	r3, r1, #1
   259aa:	1ac0      	subs	r0, r0, r3
   259ac:	4152      	adcs	r2, r2
   259ae:	1a41      	subs	r1, r0, r1
   259b0:	d200      	bcs.n	259b4 <__udivsi3+0xf8>
   259b2:	4601      	mov	r1, r0
   259b4:	4152      	adcs	r2, r2
   259b6:	4610      	mov	r0, r2
   259b8:	4770      	bx	lr
   259ba:	e7ff      	b.n	259bc <__udivsi3+0x100>
   259bc:	b501      	push	{r0, lr}
   259be:	2000      	movs	r0, #0
   259c0:	f000 f8f0 	bl	25ba4 <__aeabi_idiv0>
   259c4:	bd02      	pop	{r1, pc}
   259c6:	46c0      	nop			; (mov r8, r8)

000259c8 <__aeabi_uidivmod>:
   259c8:	2900      	cmp	r1, #0
   259ca:	d0f7      	beq.n	259bc <__udivsi3+0x100>
   259cc:	e776      	b.n	258bc <__udivsi3>
   259ce:	4770      	bx	lr

000259d0 <__divsi3>:
   259d0:	4603      	mov	r3, r0
   259d2:	430b      	orrs	r3, r1
   259d4:	d47f      	bmi.n	25ad6 <__divsi3+0x106>
   259d6:	2200      	movs	r2, #0
   259d8:	0843      	lsrs	r3, r0, #1
   259da:	428b      	cmp	r3, r1
   259dc:	d374      	bcc.n	25ac8 <__divsi3+0xf8>
   259de:	0903      	lsrs	r3, r0, #4
   259e0:	428b      	cmp	r3, r1
   259e2:	d35f      	bcc.n	25aa4 <__divsi3+0xd4>
   259e4:	0a03      	lsrs	r3, r0, #8
   259e6:	428b      	cmp	r3, r1
   259e8:	d344      	bcc.n	25a74 <__divsi3+0xa4>
   259ea:	0b03      	lsrs	r3, r0, #12
   259ec:	428b      	cmp	r3, r1
   259ee:	d328      	bcc.n	25a42 <__divsi3+0x72>
   259f0:	0c03      	lsrs	r3, r0, #16
   259f2:	428b      	cmp	r3, r1
   259f4:	d30d      	bcc.n	25a12 <__divsi3+0x42>
   259f6:	22ff      	movs	r2, #255	; 0xff
   259f8:	0209      	lsls	r1, r1, #8
   259fa:	ba12      	rev	r2, r2
   259fc:	0c03      	lsrs	r3, r0, #16
   259fe:	428b      	cmp	r3, r1
   25a00:	d302      	bcc.n	25a08 <__divsi3+0x38>
   25a02:	1212      	asrs	r2, r2, #8
   25a04:	0209      	lsls	r1, r1, #8
   25a06:	d065      	beq.n	25ad4 <__divsi3+0x104>
   25a08:	0b03      	lsrs	r3, r0, #12
   25a0a:	428b      	cmp	r3, r1
   25a0c:	d319      	bcc.n	25a42 <__divsi3+0x72>
   25a0e:	e000      	b.n	25a12 <__divsi3+0x42>
   25a10:	0a09      	lsrs	r1, r1, #8
   25a12:	0bc3      	lsrs	r3, r0, #15
   25a14:	428b      	cmp	r3, r1
   25a16:	d301      	bcc.n	25a1c <__divsi3+0x4c>
   25a18:	03cb      	lsls	r3, r1, #15
   25a1a:	1ac0      	subs	r0, r0, r3
   25a1c:	4152      	adcs	r2, r2
   25a1e:	0b83      	lsrs	r3, r0, #14
   25a20:	428b      	cmp	r3, r1
   25a22:	d301      	bcc.n	25a28 <__divsi3+0x58>
   25a24:	038b      	lsls	r3, r1, #14
   25a26:	1ac0      	subs	r0, r0, r3
   25a28:	4152      	adcs	r2, r2
   25a2a:	0b43      	lsrs	r3, r0, #13
   25a2c:	428b      	cmp	r3, r1
   25a2e:	d301      	bcc.n	25a34 <__divsi3+0x64>
   25a30:	034b      	lsls	r3, r1, #13
   25a32:	1ac0      	subs	r0, r0, r3
   25a34:	4152      	adcs	r2, r2
   25a36:	0b03      	lsrs	r3, r0, #12
   25a38:	428b      	cmp	r3, r1
   25a3a:	d301      	bcc.n	25a40 <__divsi3+0x70>
   25a3c:	030b      	lsls	r3, r1, #12
   25a3e:	1ac0      	subs	r0, r0, r3
   25a40:	4152      	adcs	r2, r2
   25a42:	0ac3      	lsrs	r3, r0, #11
   25a44:	428b      	cmp	r3, r1
   25a46:	d301      	bcc.n	25a4c <__divsi3+0x7c>
   25a48:	02cb      	lsls	r3, r1, #11
   25a4a:	1ac0      	subs	r0, r0, r3
   25a4c:	4152      	adcs	r2, r2
   25a4e:	0a83      	lsrs	r3, r0, #10
   25a50:	428b      	cmp	r3, r1
   25a52:	d301      	bcc.n	25a58 <__divsi3+0x88>
   25a54:	028b      	lsls	r3, r1, #10
   25a56:	1ac0      	subs	r0, r0, r3
   25a58:	4152      	adcs	r2, r2
   25a5a:	0a43      	lsrs	r3, r0, #9
   25a5c:	428b      	cmp	r3, r1
   25a5e:	d301      	bcc.n	25a64 <__divsi3+0x94>
   25a60:	024b      	lsls	r3, r1, #9
   25a62:	1ac0      	subs	r0, r0, r3
   25a64:	4152      	adcs	r2, r2
   25a66:	0a03      	lsrs	r3, r0, #8
   25a68:	428b      	cmp	r3, r1
   25a6a:	d301      	bcc.n	25a70 <__divsi3+0xa0>
   25a6c:	020b      	lsls	r3, r1, #8
   25a6e:	1ac0      	subs	r0, r0, r3
   25a70:	4152      	adcs	r2, r2
   25a72:	d2cd      	bcs.n	25a10 <__divsi3+0x40>
   25a74:	09c3      	lsrs	r3, r0, #7
   25a76:	428b      	cmp	r3, r1
   25a78:	d301      	bcc.n	25a7e <__divsi3+0xae>
   25a7a:	01cb      	lsls	r3, r1, #7
   25a7c:	1ac0      	subs	r0, r0, r3
   25a7e:	4152      	adcs	r2, r2
   25a80:	0983      	lsrs	r3, r0, #6
   25a82:	428b      	cmp	r3, r1
   25a84:	d301      	bcc.n	25a8a <__divsi3+0xba>
   25a86:	018b      	lsls	r3, r1, #6
   25a88:	1ac0      	subs	r0, r0, r3
   25a8a:	4152      	adcs	r2, r2
   25a8c:	0943      	lsrs	r3, r0, #5
   25a8e:	428b      	cmp	r3, r1
   25a90:	d301      	bcc.n	25a96 <__divsi3+0xc6>
   25a92:	014b      	lsls	r3, r1, #5
   25a94:	1ac0      	subs	r0, r0, r3
   25a96:	4152      	adcs	r2, r2
   25a98:	0903      	lsrs	r3, r0, #4
   25a9a:	428b      	cmp	r3, r1
   25a9c:	d301      	bcc.n	25aa2 <__divsi3+0xd2>
   25a9e:	010b      	lsls	r3, r1, #4
   25aa0:	1ac0      	subs	r0, r0, r3
   25aa2:	4152      	adcs	r2, r2
   25aa4:	08c3      	lsrs	r3, r0, #3
   25aa6:	428b      	cmp	r3, r1
   25aa8:	d301      	bcc.n	25aae <__divsi3+0xde>
   25aaa:	00cb      	lsls	r3, r1, #3
   25aac:	1ac0      	subs	r0, r0, r3
   25aae:	4152      	adcs	r2, r2
   25ab0:	0883      	lsrs	r3, r0, #2
   25ab2:	428b      	cmp	r3, r1
   25ab4:	d301      	bcc.n	25aba <__divsi3+0xea>
   25ab6:	008b      	lsls	r3, r1, #2
   25ab8:	1ac0      	subs	r0, r0, r3
   25aba:	4152      	adcs	r2, r2
   25abc:	0843      	lsrs	r3, r0, #1
   25abe:	428b      	cmp	r3, r1
   25ac0:	d301      	bcc.n	25ac6 <__divsi3+0xf6>
   25ac2:	004b      	lsls	r3, r1, #1
   25ac4:	1ac0      	subs	r0, r0, r3
   25ac6:	4152      	adcs	r2, r2
   25ac8:	1a41      	subs	r1, r0, r1
   25aca:	d200      	bcs.n	25ace <__divsi3+0xfe>
   25acc:	4601      	mov	r1, r0
   25ace:	4152      	adcs	r2, r2
   25ad0:	4610      	mov	r0, r2
   25ad2:	4770      	bx	lr
   25ad4:	e05d      	b.n	25b92 <__divsi3+0x1c2>
   25ad6:	0fca      	lsrs	r2, r1, #31
   25ad8:	d000      	beq.n	25adc <__divsi3+0x10c>
   25ada:	4249      	negs	r1, r1
   25adc:	1003      	asrs	r3, r0, #32
   25ade:	d300      	bcc.n	25ae2 <__divsi3+0x112>
   25ae0:	4240      	negs	r0, r0
   25ae2:	4053      	eors	r3, r2
   25ae4:	2200      	movs	r2, #0
   25ae6:	469c      	mov	ip, r3
   25ae8:	0903      	lsrs	r3, r0, #4
   25aea:	428b      	cmp	r3, r1
   25aec:	d32d      	bcc.n	25b4a <__divsi3+0x17a>
   25aee:	0a03      	lsrs	r3, r0, #8
   25af0:	428b      	cmp	r3, r1
   25af2:	d312      	bcc.n	25b1a <__divsi3+0x14a>
   25af4:	22fc      	movs	r2, #252	; 0xfc
   25af6:	0189      	lsls	r1, r1, #6
   25af8:	ba12      	rev	r2, r2
   25afa:	0a03      	lsrs	r3, r0, #8
   25afc:	428b      	cmp	r3, r1
   25afe:	d30c      	bcc.n	25b1a <__divsi3+0x14a>
   25b00:	0189      	lsls	r1, r1, #6
   25b02:	1192      	asrs	r2, r2, #6
   25b04:	428b      	cmp	r3, r1
   25b06:	d308      	bcc.n	25b1a <__divsi3+0x14a>
   25b08:	0189      	lsls	r1, r1, #6
   25b0a:	1192      	asrs	r2, r2, #6
   25b0c:	428b      	cmp	r3, r1
   25b0e:	d304      	bcc.n	25b1a <__divsi3+0x14a>
   25b10:	0189      	lsls	r1, r1, #6
   25b12:	d03a      	beq.n	25b8a <__divsi3+0x1ba>
   25b14:	1192      	asrs	r2, r2, #6
   25b16:	e000      	b.n	25b1a <__divsi3+0x14a>
   25b18:	0989      	lsrs	r1, r1, #6
   25b1a:	09c3      	lsrs	r3, r0, #7
   25b1c:	428b      	cmp	r3, r1
   25b1e:	d301      	bcc.n	25b24 <__divsi3+0x154>
   25b20:	01cb      	lsls	r3, r1, #7
   25b22:	1ac0      	subs	r0, r0, r3
   25b24:	4152      	adcs	r2, r2
   25b26:	0983      	lsrs	r3, r0, #6
   25b28:	428b      	cmp	r3, r1
   25b2a:	d301      	bcc.n	25b30 <__divsi3+0x160>
   25b2c:	018b      	lsls	r3, r1, #6
   25b2e:	1ac0      	subs	r0, r0, r3
   25b30:	4152      	adcs	r2, r2
   25b32:	0943      	lsrs	r3, r0, #5
   25b34:	428b      	cmp	r3, r1
   25b36:	d301      	bcc.n	25b3c <__divsi3+0x16c>
   25b38:	014b      	lsls	r3, r1, #5
   25b3a:	1ac0      	subs	r0, r0, r3
   25b3c:	4152      	adcs	r2, r2
   25b3e:	0903      	lsrs	r3, r0, #4
   25b40:	428b      	cmp	r3, r1
   25b42:	d301      	bcc.n	25b48 <__divsi3+0x178>
   25b44:	010b      	lsls	r3, r1, #4
   25b46:	1ac0      	subs	r0, r0, r3
   25b48:	4152      	adcs	r2, r2
   25b4a:	08c3      	lsrs	r3, r0, #3
   25b4c:	428b      	cmp	r3, r1
   25b4e:	d301      	bcc.n	25b54 <__divsi3+0x184>
   25b50:	00cb      	lsls	r3, r1, #3
   25b52:	1ac0      	subs	r0, r0, r3
   25b54:	4152      	adcs	r2, r2
   25b56:	0883      	lsrs	r3, r0, #2
   25b58:	428b      	cmp	r3, r1
   25b5a:	d301      	bcc.n	25b60 <__divsi3+0x190>
   25b5c:	008b      	lsls	r3, r1, #2
   25b5e:	1ac0      	subs	r0, r0, r3
   25b60:	4152      	adcs	r2, r2
   25b62:	d2d9      	bcs.n	25b18 <__divsi3+0x148>
   25b64:	0843      	lsrs	r3, r0, #1
   25b66:	428b      	cmp	r3, r1
   25b68:	d301      	bcc.n	25b6e <__divsi3+0x19e>
   25b6a:	004b      	lsls	r3, r1, #1
   25b6c:	1ac0      	subs	r0, r0, r3
   25b6e:	4152      	adcs	r2, r2
   25b70:	1a41      	subs	r1, r0, r1
   25b72:	d200      	bcs.n	25b76 <__divsi3+0x1a6>
   25b74:	4601      	mov	r1, r0
   25b76:	4663      	mov	r3, ip
   25b78:	4152      	adcs	r2, r2
   25b7a:	105b      	asrs	r3, r3, #1
   25b7c:	4610      	mov	r0, r2
   25b7e:	d301      	bcc.n	25b84 <__divsi3+0x1b4>
   25b80:	4240      	negs	r0, r0
   25b82:	2b00      	cmp	r3, #0
   25b84:	d500      	bpl.n	25b88 <__divsi3+0x1b8>
   25b86:	4249      	negs	r1, r1
   25b88:	4770      	bx	lr
   25b8a:	4663      	mov	r3, ip
   25b8c:	105b      	asrs	r3, r3, #1
   25b8e:	d300      	bcc.n	25b92 <__divsi3+0x1c2>
   25b90:	4240      	negs	r0, r0
   25b92:	b501      	push	{r0, lr}
   25b94:	2000      	movs	r0, #0
   25b96:	f000 f805 	bl	25ba4 <__aeabi_idiv0>
   25b9a:	bd02      	pop	{r1, pc}

00025b9c <__aeabi_idivmod>:
   25b9c:	2900      	cmp	r1, #0
   25b9e:	d0f8      	beq.n	25b92 <__divsi3+0x1c2>
   25ba0:	e716      	b.n	259d0 <__divsi3>
   25ba2:	4770      	bx	lr

00025ba4 <__aeabi_idiv0>:
   25ba4:	4770      	bx	lr
   25ba6:	46c0      	nop			; (mov r8, r8)

00025ba8 <__aeabi_llsl>:
   25ba8:	4091      	lsls	r1, r2
   25baa:	1c03      	adds	r3, r0, #0
   25bac:	4090      	lsls	r0, r2
   25bae:	469c      	mov	ip, r3
   25bb0:	3a20      	subs	r2, #32
   25bb2:	4093      	lsls	r3, r2
   25bb4:	4319      	orrs	r1, r3
   25bb6:	4252      	negs	r2, r2
   25bb8:	4663      	mov	r3, ip
   25bba:	40d3      	lsrs	r3, r2
   25bbc:	4319      	orrs	r1, r3
   25bbe:	4770      	bx	lr

00025bc0 <__aeabi_cdrcmple>:
   25bc0:	4684      	mov	ip, r0
   25bc2:	1c10      	adds	r0, r2, #0
   25bc4:	4662      	mov	r2, ip
   25bc6:	468c      	mov	ip, r1
   25bc8:	1c19      	adds	r1, r3, #0
   25bca:	4663      	mov	r3, ip
   25bcc:	e000      	b.n	25bd0 <__aeabi_cdcmpeq>
   25bce:	46c0      	nop			; (mov r8, r8)

00025bd0 <__aeabi_cdcmpeq>:
   25bd0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   25bd2:	f001 fe85 	bl	278e0 <__ledf2>
   25bd6:	2800      	cmp	r0, #0
   25bd8:	d401      	bmi.n	25bde <__aeabi_cdcmpeq+0xe>
   25bda:	2100      	movs	r1, #0
   25bdc:	42c8      	cmn	r0, r1
   25bde:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

00025be0 <__aeabi_dcmpeq>:
   25be0:	b510      	push	{r4, lr}
   25be2:	f001 fddf 	bl	277a4 <__eqdf2>
   25be6:	4240      	negs	r0, r0
   25be8:	3001      	adds	r0, #1
   25bea:	bd10      	pop	{r4, pc}

00025bec <__aeabi_dcmplt>:
   25bec:	b510      	push	{r4, lr}
   25bee:	f001 fe77 	bl	278e0 <__ledf2>
   25bf2:	2800      	cmp	r0, #0
   25bf4:	db01      	blt.n	25bfa <__aeabi_dcmplt+0xe>
   25bf6:	2000      	movs	r0, #0
   25bf8:	bd10      	pop	{r4, pc}
   25bfa:	2001      	movs	r0, #1
   25bfc:	bd10      	pop	{r4, pc}
   25bfe:	46c0      	nop			; (mov r8, r8)

00025c00 <__aeabi_dcmple>:
   25c00:	b510      	push	{r4, lr}
   25c02:	f001 fe6d 	bl	278e0 <__ledf2>
   25c06:	2800      	cmp	r0, #0
   25c08:	dd01      	ble.n	25c0e <__aeabi_dcmple+0xe>
   25c0a:	2000      	movs	r0, #0
   25c0c:	bd10      	pop	{r4, pc}
   25c0e:	2001      	movs	r0, #1
   25c10:	bd10      	pop	{r4, pc}
   25c12:	46c0      	nop			; (mov r8, r8)

00025c14 <__aeabi_dcmpgt>:
   25c14:	b510      	push	{r4, lr}
   25c16:	f001 fdff 	bl	27818 <__gedf2>
   25c1a:	2800      	cmp	r0, #0
   25c1c:	dc01      	bgt.n	25c22 <__aeabi_dcmpgt+0xe>
   25c1e:	2000      	movs	r0, #0
   25c20:	bd10      	pop	{r4, pc}
   25c22:	2001      	movs	r0, #1
   25c24:	bd10      	pop	{r4, pc}
   25c26:	46c0      	nop			; (mov r8, r8)

00025c28 <__aeabi_dcmpge>:
   25c28:	b510      	push	{r4, lr}
   25c2a:	f001 fdf5 	bl	27818 <__gedf2>
   25c2e:	2800      	cmp	r0, #0
   25c30:	da01      	bge.n	25c36 <__aeabi_dcmpge+0xe>
   25c32:	2000      	movs	r0, #0
   25c34:	bd10      	pop	{r4, pc}
   25c36:	2001      	movs	r0, #1
   25c38:	bd10      	pop	{r4, pc}
   25c3a:	46c0      	nop			; (mov r8, r8)

00025c3c <__aeabi_cfrcmple>:
   25c3c:	4684      	mov	ip, r0
   25c3e:	1c08      	adds	r0, r1, #0
   25c40:	4661      	mov	r1, ip
   25c42:	e7ff      	b.n	25c44 <__aeabi_cfcmpeq>

00025c44 <__aeabi_cfcmpeq>:
   25c44:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   25c46:	f000 fbb5 	bl	263b4 <__lesf2>
   25c4a:	2800      	cmp	r0, #0
   25c4c:	d401      	bmi.n	25c52 <__aeabi_cfcmpeq+0xe>
   25c4e:	2100      	movs	r1, #0
   25c50:	42c8      	cmn	r0, r1
   25c52:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

00025c54 <__aeabi_fcmpeq>:
   25c54:	b510      	push	{r4, lr}
   25c56:	f000 fb47 	bl	262e8 <__eqsf2>
   25c5a:	4240      	negs	r0, r0
   25c5c:	3001      	adds	r0, #1
   25c5e:	bd10      	pop	{r4, pc}

00025c60 <__aeabi_fcmplt>:
   25c60:	b510      	push	{r4, lr}
   25c62:	f000 fba7 	bl	263b4 <__lesf2>
   25c66:	2800      	cmp	r0, #0
   25c68:	db01      	blt.n	25c6e <__aeabi_fcmplt+0xe>
   25c6a:	2000      	movs	r0, #0
   25c6c:	bd10      	pop	{r4, pc}
   25c6e:	2001      	movs	r0, #1
   25c70:	bd10      	pop	{r4, pc}
   25c72:	46c0      	nop			; (mov r8, r8)

00025c74 <__aeabi_fcmple>:
   25c74:	b510      	push	{r4, lr}
   25c76:	f000 fb9d 	bl	263b4 <__lesf2>
   25c7a:	2800      	cmp	r0, #0
   25c7c:	dd01      	ble.n	25c82 <__aeabi_fcmple+0xe>
   25c7e:	2000      	movs	r0, #0
   25c80:	bd10      	pop	{r4, pc}
   25c82:	2001      	movs	r0, #1
   25c84:	bd10      	pop	{r4, pc}
   25c86:	46c0      	nop			; (mov r8, r8)

00025c88 <__aeabi_fcmpgt>:
   25c88:	b510      	push	{r4, lr}
   25c8a:	f000 fb53 	bl	26334 <__gesf2>
   25c8e:	2800      	cmp	r0, #0
   25c90:	dc01      	bgt.n	25c96 <__aeabi_fcmpgt+0xe>
   25c92:	2000      	movs	r0, #0
   25c94:	bd10      	pop	{r4, pc}
   25c96:	2001      	movs	r0, #1
   25c98:	bd10      	pop	{r4, pc}
   25c9a:	46c0      	nop			; (mov r8, r8)

00025c9c <__aeabi_fcmpge>:
   25c9c:	b510      	push	{r4, lr}
   25c9e:	f000 fb49 	bl	26334 <__gesf2>
   25ca2:	2800      	cmp	r0, #0
   25ca4:	da01      	bge.n	25caa <__aeabi_fcmpge+0xe>
   25ca6:	2000      	movs	r0, #0
   25ca8:	bd10      	pop	{r4, pc}
   25caa:	2001      	movs	r0, #1
   25cac:	bd10      	pop	{r4, pc}
   25cae:	46c0      	nop			; (mov r8, r8)

00025cb0 <__aeabi_lmul>:
   25cb0:	b5f0      	push	{r4, r5, r6, r7, lr}
   25cb2:	46ce      	mov	lr, r9
   25cb4:	4647      	mov	r7, r8
   25cb6:	0415      	lsls	r5, r2, #16
   25cb8:	0c2d      	lsrs	r5, r5, #16
   25cba:	002e      	movs	r6, r5
   25cbc:	b580      	push	{r7, lr}
   25cbe:	0407      	lsls	r7, r0, #16
   25cc0:	0c14      	lsrs	r4, r2, #16
   25cc2:	0c3f      	lsrs	r7, r7, #16
   25cc4:	4699      	mov	r9, r3
   25cc6:	0c03      	lsrs	r3, r0, #16
   25cc8:	437e      	muls	r6, r7
   25cca:	435d      	muls	r5, r3
   25ccc:	4367      	muls	r7, r4
   25cce:	4363      	muls	r3, r4
   25cd0:	197f      	adds	r7, r7, r5
   25cd2:	0c34      	lsrs	r4, r6, #16
   25cd4:	19e4      	adds	r4, r4, r7
   25cd6:	469c      	mov	ip, r3
   25cd8:	42a5      	cmp	r5, r4
   25cda:	d903      	bls.n	25ce4 <__aeabi_lmul+0x34>
   25cdc:	2380      	movs	r3, #128	; 0x80
   25cde:	025b      	lsls	r3, r3, #9
   25ce0:	4698      	mov	r8, r3
   25ce2:	44c4      	add	ip, r8
   25ce4:	464b      	mov	r3, r9
   25ce6:	4351      	muls	r1, r2
   25ce8:	4343      	muls	r3, r0
   25cea:	0436      	lsls	r6, r6, #16
   25cec:	0c36      	lsrs	r6, r6, #16
   25cee:	0c25      	lsrs	r5, r4, #16
   25cf0:	0424      	lsls	r4, r4, #16
   25cf2:	4465      	add	r5, ip
   25cf4:	19a4      	adds	r4, r4, r6
   25cf6:	1859      	adds	r1, r3, r1
   25cf8:	1949      	adds	r1, r1, r5
   25cfa:	0020      	movs	r0, r4
   25cfc:	bc0c      	pop	{r2, r3}
   25cfe:	4690      	mov	r8, r2
   25d00:	4699      	mov	r9, r3
   25d02:	bdf0      	pop	{r4, r5, r6, r7, pc}

00025d04 <__aeabi_f2uiz>:
   25d04:	219e      	movs	r1, #158	; 0x9e
   25d06:	b510      	push	{r4, lr}
   25d08:	05c9      	lsls	r1, r1, #23
   25d0a:	1c04      	adds	r4, r0, #0
   25d0c:	f7ff ffc6 	bl	25c9c <__aeabi_fcmpge>
   25d10:	2800      	cmp	r0, #0
   25d12:	d103      	bne.n	25d1c <__aeabi_f2uiz+0x18>
   25d14:	1c20      	adds	r0, r4, #0
   25d16:	f000 fe4b 	bl	269b0 <__aeabi_f2iz>
   25d1a:	bd10      	pop	{r4, pc}
   25d1c:	219e      	movs	r1, #158	; 0x9e
   25d1e:	1c20      	adds	r0, r4, #0
   25d20:	05c9      	lsls	r1, r1, #23
   25d22:	f000 fca9 	bl	26678 <__aeabi_fsub>
   25d26:	f000 fe43 	bl	269b0 <__aeabi_f2iz>
   25d2a:	2380      	movs	r3, #128	; 0x80
   25d2c:	061b      	lsls	r3, r3, #24
   25d2e:	469c      	mov	ip, r3
   25d30:	4460      	add	r0, ip
   25d32:	e7f2      	b.n	25d1a <__aeabi_f2uiz+0x16>

00025d34 <__aeabi_fadd>:
   25d34:	b5f0      	push	{r4, r5, r6, r7, lr}
   25d36:	46c6      	mov	lr, r8
   25d38:	024e      	lsls	r6, r1, #9
   25d3a:	0247      	lsls	r7, r0, #9
   25d3c:	0a76      	lsrs	r6, r6, #9
   25d3e:	0a7b      	lsrs	r3, r7, #9
   25d40:	0044      	lsls	r4, r0, #1
   25d42:	0fc5      	lsrs	r5, r0, #31
   25d44:	00f7      	lsls	r7, r6, #3
   25d46:	0048      	lsls	r0, r1, #1
   25d48:	4698      	mov	r8, r3
   25d4a:	b500      	push	{lr}
   25d4c:	0e24      	lsrs	r4, r4, #24
   25d4e:	002a      	movs	r2, r5
   25d50:	00db      	lsls	r3, r3, #3
   25d52:	0e00      	lsrs	r0, r0, #24
   25d54:	0fc9      	lsrs	r1, r1, #31
   25d56:	46bc      	mov	ip, r7
   25d58:	428d      	cmp	r5, r1
   25d5a:	d067      	beq.n	25e2c <__aeabi_fadd+0xf8>
   25d5c:	1a22      	subs	r2, r4, r0
   25d5e:	2a00      	cmp	r2, #0
   25d60:	dc00      	bgt.n	25d64 <__aeabi_fadd+0x30>
   25d62:	e0a5      	b.n	25eb0 <__aeabi_fadd+0x17c>
   25d64:	2800      	cmp	r0, #0
   25d66:	d13a      	bne.n	25dde <__aeabi_fadd+0xaa>
   25d68:	2f00      	cmp	r7, #0
   25d6a:	d100      	bne.n	25d6e <__aeabi_fadd+0x3a>
   25d6c:	e093      	b.n	25e96 <__aeabi_fadd+0x162>
   25d6e:	1e51      	subs	r1, r2, #1
   25d70:	2900      	cmp	r1, #0
   25d72:	d000      	beq.n	25d76 <__aeabi_fadd+0x42>
   25d74:	e0bc      	b.n	25ef0 <__aeabi_fadd+0x1bc>
   25d76:	2401      	movs	r4, #1
   25d78:	1bdb      	subs	r3, r3, r7
   25d7a:	015a      	lsls	r2, r3, #5
   25d7c:	d546      	bpl.n	25e0c <__aeabi_fadd+0xd8>
   25d7e:	019b      	lsls	r3, r3, #6
   25d80:	099e      	lsrs	r6, r3, #6
   25d82:	0030      	movs	r0, r6
   25d84:	f002 fcc4 	bl	28710 <__clzsi2>
   25d88:	3805      	subs	r0, #5
   25d8a:	4086      	lsls	r6, r0
   25d8c:	4284      	cmp	r4, r0
   25d8e:	dd00      	ble.n	25d92 <__aeabi_fadd+0x5e>
   25d90:	e09d      	b.n	25ece <__aeabi_fadd+0x19a>
   25d92:	1b04      	subs	r4, r0, r4
   25d94:	0032      	movs	r2, r6
   25d96:	2020      	movs	r0, #32
   25d98:	3401      	adds	r4, #1
   25d9a:	40e2      	lsrs	r2, r4
   25d9c:	1b04      	subs	r4, r0, r4
   25d9e:	40a6      	lsls	r6, r4
   25da0:	0033      	movs	r3, r6
   25da2:	1e5e      	subs	r6, r3, #1
   25da4:	41b3      	sbcs	r3, r6
   25da6:	2400      	movs	r4, #0
   25da8:	4313      	orrs	r3, r2
   25daa:	075a      	lsls	r2, r3, #29
   25dac:	d004      	beq.n	25db8 <__aeabi_fadd+0x84>
   25dae:	220f      	movs	r2, #15
   25db0:	401a      	ands	r2, r3
   25db2:	2a04      	cmp	r2, #4
   25db4:	d000      	beq.n	25db8 <__aeabi_fadd+0x84>
   25db6:	3304      	adds	r3, #4
   25db8:	015a      	lsls	r2, r3, #5
   25dba:	d529      	bpl.n	25e10 <__aeabi_fadd+0xdc>
   25dbc:	3401      	adds	r4, #1
   25dbe:	2cff      	cmp	r4, #255	; 0xff
   25dc0:	d100      	bne.n	25dc4 <__aeabi_fadd+0x90>
   25dc2:	e081      	b.n	25ec8 <__aeabi_fadd+0x194>
   25dc4:	002a      	movs	r2, r5
   25dc6:	019b      	lsls	r3, r3, #6
   25dc8:	0a5b      	lsrs	r3, r3, #9
   25dca:	b2e4      	uxtb	r4, r4
   25dcc:	025b      	lsls	r3, r3, #9
   25dce:	05e4      	lsls	r4, r4, #23
   25dd0:	0a58      	lsrs	r0, r3, #9
   25dd2:	07d2      	lsls	r2, r2, #31
   25dd4:	4320      	orrs	r0, r4
   25dd6:	4310      	orrs	r0, r2
   25dd8:	bc04      	pop	{r2}
   25dda:	4690      	mov	r8, r2
   25ddc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   25dde:	2cff      	cmp	r4, #255	; 0xff
   25de0:	d0e3      	beq.n	25daa <__aeabi_fadd+0x76>
   25de2:	2180      	movs	r1, #128	; 0x80
   25de4:	0038      	movs	r0, r7
   25de6:	04c9      	lsls	r1, r1, #19
   25de8:	4308      	orrs	r0, r1
   25dea:	4684      	mov	ip, r0
   25dec:	2a1b      	cmp	r2, #27
   25dee:	dd00      	ble.n	25df2 <__aeabi_fadd+0xbe>
   25df0:	e082      	b.n	25ef8 <__aeabi_fadd+0x1c4>
   25df2:	2020      	movs	r0, #32
   25df4:	4661      	mov	r1, ip
   25df6:	40d1      	lsrs	r1, r2
   25df8:	1a82      	subs	r2, r0, r2
   25dfa:	4660      	mov	r0, ip
   25dfc:	4090      	lsls	r0, r2
   25dfe:	0002      	movs	r2, r0
   25e00:	1e50      	subs	r0, r2, #1
   25e02:	4182      	sbcs	r2, r0
   25e04:	430a      	orrs	r2, r1
   25e06:	1a9b      	subs	r3, r3, r2
   25e08:	015a      	lsls	r2, r3, #5
   25e0a:	d4b8      	bmi.n	25d7e <__aeabi_fadd+0x4a>
   25e0c:	075a      	lsls	r2, r3, #29
   25e0e:	d1ce      	bne.n	25dae <__aeabi_fadd+0x7a>
   25e10:	08de      	lsrs	r6, r3, #3
   25e12:	002a      	movs	r2, r5
   25e14:	2cff      	cmp	r4, #255	; 0xff
   25e16:	d13a      	bne.n	25e8e <__aeabi_fadd+0x15a>
   25e18:	2e00      	cmp	r6, #0
   25e1a:	d100      	bne.n	25e1e <__aeabi_fadd+0xea>
   25e1c:	e0ae      	b.n	25f7c <__aeabi_fadd+0x248>
   25e1e:	2380      	movs	r3, #128	; 0x80
   25e20:	03db      	lsls	r3, r3, #15
   25e22:	4333      	orrs	r3, r6
   25e24:	025b      	lsls	r3, r3, #9
   25e26:	0a5b      	lsrs	r3, r3, #9
   25e28:	24ff      	movs	r4, #255	; 0xff
   25e2a:	e7cf      	b.n	25dcc <__aeabi_fadd+0x98>
   25e2c:	1a21      	subs	r1, r4, r0
   25e2e:	2900      	cmp	r1, #0
   25e30:	dd52      	ble.n	25ed8 <__aeabi_fadd+0x1a4>
   25e32:	2800      	cmp	r0, #0
   25e34:	d031      	beq.n	25e9a <__aeabi_fadd+0x166>
   25e36:	2cff      	cmp	r4, #255	; 0xff
   25e38:	d0b7      	beq.n	25daa <__aeabi_fadd+0x76>
   25e3a:	2080      	movs	r0, #128	; 0x80
   25e3c:	003e      	movs	r6, r7
   25e3e:	04c0      	lsls	r0, r0, #19
   25e40:	4306      	orrs	r6, r0
   25e42:	46b4      	mov	ip, r6
   25e44:	291b      	cmp	r1, #27
   25e46:	dd00      	ble.n	25e4a <__aeabi_fadd+0x116>
   25e48:	e0aa      	b.n	25fa0 <__aeabi_fadd+0x26c>
   25e4a:	2620      	movs	r6, #32
   25e4c:	4660      	mov	r0, ip
   25e4e:	40c8      	lsrs	r0, r1
   25e50:	1a71      	subs	r1, r6, r1
   25e52:	4666      	mov	r6, ip
   25e54:	408e      	lsls	r6, r1
   25e56:	0031      	movs	r1, r6
   25e58:	1e4e      	subs	r6, r1, #1
   25e5a:	41b1      	sbcs	r1, r6
   25e5c:	4301      	orrs	r1, r0
   25e5e:	185b      	adds	r3, r3, r1
   25e60:	0159      	lsls	r1, r3, #5
   25e62:	d5d3      	bpl.n	25e0c <__aeabi_fadd+0xd8>
   25e64:	3401      	adds	r4, #1
   25e66:	2cff      	cmp	r4, #255	; 0xff
   25e68:	d100      	bne.n	25e6c <__aeabi_fadd+0x138>
   25e6a:	e087      	b.n	25f7c <__aeabi_fadd+0x248>
   25e6c:	2201      	movs	r2, #1
   25e6e:	4978      	ldr	r1, [pc, #480]	; (26050 <__aeabi_fadd+0x31c>)
   25e70:	401a      	ands	r2, r3
   25e72:	085b      	lsrs	r3, r3, #1
   25e74:	400b      	ands	r3, r1
   25e76:	4313      	orrs	r3, r2
   25e78:	e797      	b.n	25daa <__aeabi_fadd+0x76>
   25e7a:	2c00      	cmp	r4, #0
   25e7c:	d000      	beq.n	25e80 <__aeabi_fadd+0x14c>
   25e7e:	e0a7      	b.n	25fd0 <__aeabi_fadd+0x29c>
   25e80:	2b00      	cmp	r3, #0
   25e82:	d000      	beq.n	25e86 <__aeabi_fadd+0x152>
   25e84:	e0b6      	b.n	25ff4 <__aeabi_fadd+0x2c0>
   25e86:	1e3b      	subs	r3, r7, #0
   25e88:	d162      	bne.n	25f50 <__aeabi_fadd+0x21c>
   25e8a:	2600      	movs	r6, #0
   25e8c:	2200      	movs	r2, #0
   25e8e:	0273      	lsls	r3, r6, #9
   25e90:	0a5b      	lsrs	r3, r3, #9
   25e92:	b2e4      	uxtb	r4, r4
   25e94:	e79a      	b.n	25dcc <__aeabi_fadd+0x98>
   25e96:	0014      	movs	r4, r2
   25e98:	e787      	b.n	25daa <__aeabi_fadd+0x76>
   25e9a:	2f00      	cmp	r7, #0
   25e9c:	d04d      	beq.n	25f3a <__aeabi_fadd+0x206>
   25e9e:	1e48      	subs	r0, r1, #1
   25ea0:	2800      	cmp	r0, #0
   25ea2:	d157      	bne.n	25f54 <__aeabi_fadd+0x220>
   25ea4:	4463      	add	r3, ip
   25ea6:	2401      	movs	r4, #1
   25ea8:	015a      	lsls	r2, r3, #5
   25eaa:	d5af      	bpl.n	25e0c <__aeabi_fadd+0xd8>
   25eac:	2402      	movs	r4, #2
   25eae:	e7dd      	b.n	25e6c <__aeabi_fadd+0x138>
   25eb0:	2a00      	cmp	r2, #0
   25eb2:	d124      	bne.n	25efe <__aeabi_fadd+0x1ca>
   25eb4:	1c62      	adds	r2, r4, #1
   25eb6:	b2d2      	uxtb	r2, r2
   25eb8:	2a01      	cmp	r2, #1
   25eba:	ddde      	ble.n	25e7a <__aeabi_fadd+0x146>
   25ebc:	1bde      	subs	r6, r3, r7
   25ebe:	0172      	lsls	r2, r6, #5
   25ec0:	d535      	bpl.n	25f2e <__aeabi_fadd+0x1fa>
   25ec2:	1afe      	subs	r6, r7, r3
   25ec4:	000d      	movs	r5, r1
   25ec6:	e75c      	b.n	25d82 <__aeabi_fadd+0x4e>
   25ec8:	002a      	movs	r2, r5
   25eca:	2300      	movs	r3, #0
   25ecc:	e77e      	b.n	25dcc <__aeabi_fadd+0x98>
   25ece:	0033      	movs	r3, r6
   25ed0:	4a60      	ldr	r2, [pc, #384]	; (26054 <__aeabi_fadd+0x320>)
   25ed2:	1a24      	subs	r4, r4, r0
   25ed4:	4013      	ands	r3, r2
   25ed6:	e768      	b.n	25daa <__aeabi_fadd+0x76>
   25ed8:	2900      	cmp	r1, #0
   25eda:	d163      	bne.n	25fa4 <__aeabi_fadd+0x270>
   25edc:	1c61      	adds	r1, r4, #1
   25ede:	b2c8      	uxtb	r0, r1
   25ee0:	2801      	cmp	r0, #1
   25ee2:	dd4e      	ble.n	25f82 <__aeabi_fadd+0x24e>
   25ee4:	29ff      	cmp	r1, #255	; 0xff
   25ee6:	d049      	beq.n	25f7c <__aeabi_fadd+0x248>
   25ee8:	4463      	add	r3, ip
   25eea:	085b      	lsrs	r3, r3, #1
   25eec:	000c      	movs	r4, r1
   25eee:	e75c      	b.n	25daa <__aeabi_fadd+0x76>
   25ef0:	2aff      	cmp	r2, #255	; 0xff
   25ef2:	d041      	beq.n	25f78 <__aeabi_fadd+0x244>
   25ef4:	000a      	movs	r2, r1
   25ef6:	e779      	b.n	25dec <__aeabi_fadd+0xb8>
   25ef8:	2201      	movs	r2, #1
   25efa:	1a9b      	subs	r3, r3, r2
   25efc:	e784      	b.n	25e08 <__aeabi_fadd+0xd4>
   25efe:	2c00      	cmp	r4, #0
   25f00:	d01d      	beq.n	25f3e <__aeabi_fadd+0x20a>
   25f02:	28ff      	cmp	r0, #255	; 0xff
   25f04:	d022      	beq.n	25f4c <__aeabi_fadd+0x218>
   25f06:	2480      	movs	r4, #128	; 0x80
   25f08:	04e4      	lsls	r4, r4, #19
   25f0a:	4252      	negs	r2, r2
   25f0c:	4323      	orrs	r3, r4
   25f0e:	2a1b      	cmp	r2, #27
   25f10:	dd00      	ble.n	25f14 <__aeabi_fadd+0x1e0>
   25f12:	e08a      	b.n	2602a <__aeabi_fadd+0x2f6>
   25f14:	001c      	movs	r4, r3
   25f16:	2520      	movs	r5, #32
   25f18:	40d4      	lsrs	r4, r2
   25f1a:	1aaa      	subs	r2, r5, r2
   25f1c:	4093      	lsls	r3, r2
   25f1e:	1e5a      	subs	r2, r3, #1
   25f20:	4193      	sbcs	r3, r2
   25f22:	4323      	orrs	r3, r4
   25f24:	4662      	mov	r2, ip
   25f26:	0004      	movs	r4, r0
   25f28:	1ad3      	subs	r3, r2, r3
   25f2a:	000d      	movs	r5, r1
   25f2c:	e725      	b.n	25d7a <__aeabi_fadd+0x46>
   25f2e:	2e00      	cmp	r6, #0
   25f30:	d000      	beq.n	25f34 <__aeabi_fadd+0x200>
   25f32:	e726      	b.n	25d82 <__aeabi_fadd+0x4e>
   25f34:	2200      	movs	r2, #0
   25f36:	2400      	movs	r4, #0
   25f38:	e7a9      	b.n	25e8e <__aeabi_fadd+0x15a>
   25f3a:	000c      	movs	r4, r1
   25f3c:	e735      	b.n	25daa <__aeabi_fadd+0x76>
   25f3e:	2b00      	cmp	r3, #0
   25f40:	d04d      	beq.n	25fde <__aeabi_fadd+0x2aa>
   25f42:	43d2      	mvns	r2, r2
   25f44:	2a00      	cmp	r2, #0
   25f46:	d0ed      	beq.n	25f24 <__aeabi_fadd+0x1f0>
   25f48:	28ff      	cmp	r0, #255	; 0xff
   25f4a:	d1e0      	bne.n	25f0e <__aeabi_fadd+0x1da>
   25f4c:	4663      	mov	r3, ip
   25f4e:	24ff      	movs	r4, #255	; 0xff
   25f50:	000d      	movs	r5, r1
   25f52:	e72a      	b.n	25daa <__aeabi_fadd+0x76>
   25f54:	29ff      	cmp	r1, #255	; 0xff
   25f56:	d00f      	beq.n	25f78 <__aeabi_fadd+0x244>
   25f58:	0001      	movs	r1, r0
   25f5a:	e773      	b.n	25e44 <__aeabi_fadd+0x110>
   25f5c:	2b00      	cmp	r3, #0
   25f5e:	d061      	beq.n	26024 <__aeabi_fadd+0x2f0>
   25f60:	24ff      	movs	r4, #255	; 0xff
   25f62:	2f00      	cmp	r7, #0
   25f64:	d100      	bne.n	25f68 <__aeabi_fadd+0x234>
   25f66:	e720      	b.n	25daa <__aeabi_fadd+0x76>
   25f68:	2280      	movs	r2, #128	; 0x80
   25f6a:	4641      	mov	r1, r8
   25f6c:	03d2      	lsls	r2, r2, #15
   25f6e:	4211      	tst	r1, r2
   25f70:	d002      	beq.n	25f78 <__aeabi_fadd+0x244>
   25f72:	4216      	tst	r6, r2
   25f74:	d100      	bne.n	25f78 <__aeabi_fadd+0x244>
   25f76:	003b      	movs	r3, r7
   25f78:	24ff      	movs	r4, #255	; 0xff
   25f7a:	e716      	b.n	25daa <__aeabi_fadd+0x76>
   25f7c:	24ff      	movs	r4, #255	; 0xff
   25f7e:	2300      	movs	r3, #0
   25f80:	e724      	b.n	25dcc <__aeabi_fadd+0x98>
   25f82:	2c00      	cmp	r4, #0
   25f84:	d1ea      	bne.n	25f5c <__aeabi_fadd+0x228>
   25f86:	2b00      	cmp	r3, #0
   25f88:	d058      	beq.n	2603c <__aeabi_fadd+0x308>
   25f8a:	2f00      	cmp	r7, #0
   25f8c:	d100      	bne.n	25f90 <__aeabi_fadd+0x25c>
   25f8e:	e70c      	b.n	25daa <__aeabi_fadd+0x76>
   25f90:	4463      	add	r3, ip
   25f92:	015a      	lsls	r2, r3, #5
   25f94:	d400      	bmi.n	25f98 <__aeabi_fadd+0x264>
   25f96:	e739      	b.n	25e0c <__aeabi_fadd+0xd8>
   25f98:	4a2e      	ldr	r2, [pc, #184]	; (26054 <__aeabi_fadd+0x320>)
   25f9a:	000c      	movs	r4, r1
   25f9c:	4013      	ands	r3, r2
   25f9e:	e704      	b.n	25daa <__aeabi_fadd+0x76>
   25fa0:	2101      	movs	r1, #1
   25fa2:	e75c      	b.n	25e5e <__aeabi_fadd+0x12a>
   25fa4:	2c00      	cmp	r4, #0
   25fa6:	d11e      	bne.n	25fe6 <__aeabi_fadd+0x2b2>
   25fa8:	2b00      	cmp	r3, #0
   25faa:	d040      	beq.n	2602e <__aeabi_fadd+0x2fa>
   25fac:	43c9      	mvns	r1, r1
   25fae:	2900      	cmp	r1, #0
   25fb0:	d00b      	beq.n	25fca <__aeabi_fadd+0x296>
   25fb2:	28ff      	cmp	r0, #255	; 0xff
   25fb4:	d036      	beq.n	26024 <__aeabi_fadd+0x2f0>
   25fb6:	291b      	cmp	r1, #27
   25fb8:	dc47      	bgt.n	2604a <__aeabi_fadd+0x316>
   25fba:	001c      	movs	r4, r3
   25fbc:	2620      	movs	r6, #32
   25fbe:	40cc      	lsrs	r4, r1
   25fc0:	1a71      	subs	r1, r6, r1
   25fc2:	408b      	lsls	r3, r1
   25fc4:	1e59      	subs	r1, r3, #1
   25fc6:	418b      	sbcs	r3, r1
   25fc8:	4323      	orrs	r3, r4
   25fca:	4463      	add	r3, ip
   25fcc:	0004      	movs	r4, r0
   25fce:	e747      	b.n	25e60 <__aeabi_fadd+0x12c>
   25fd0:	2b00      	cmp	r3, #0
   25fd2:	d118      	bne.n	26006 <__aeabi_fadd+0x2d2>
   25fd4:	1e3b      	subs	r3, r7, #0
   25fd6:	d02d      	beq.n	26034 <__aeabi_fadd+0x300>
   25fd8:	000d      	movs	r5, r1
   25fda:	24ff      	movs	r4, #255	; 0xff
   25fdc:	e6e5      	b.n	25daa <__aeabi_fadd+0x76>
   25fde:	003b      	movs	r3, r7
   25fe0:	0004      	movs	r4, r0
   25fe2:	000d      	movs	r5, r1
   25fe4:	e6e1      	b.n	25daa <__aeabi_fadd+0x76>
   25fe6:	28ff      	cmp	r0, #255	; 0xff
   25fe8:	d01c      	beq.n	26024 <__aeabi_fadd+0x2f0>
   25fea:	2480      	movs	r4, #128	; 0x80
   25fec:	04e4      	lsls	r4, r4, #19
   25fee:	4249      	negs	r1, r1
   25ff0:	4323      	orrs	r3, r4
   25ff2:	e7e0      	b.n	25fb6 <__aeabi_fadd+0x282>
   25ff4:	2f00      	cmp	r7, #0
   25ff6:	d100      	bne.n	25ffa <__aeabi_fadd+0x2c6>
   25ff8:	e6d7      	b.n	25daa <__aeabi_fadd+0x76>
   25ffa:	1bde      	subs	r6, r3, r7
   25ffc:	0172      	lsls	r2, r6, #5
   25ffe:	d51f      	bpl.n	26040 <__aeabi_fadd+0x30c>
   26000:	1afb      	subs	r3, r7, r3
   26002:	000d      	movs	r5, r1
   26004:	e6d1      	b.n	25daa <__aeabi_fadd+0x76>
   26006:	24ff      	movs	r4, #255	; 0xff
   26008:	2f00      	cmp	r7, #0
   2600a:	d100      	bne.n	2600e <__aeabi_fadd+0x2da>
   2600c:	e6cd      	b.n	25daa <__aeabi_fadd+0x76>
   2600e:	2280      	movs	r2, #128	; 0x80
   26010:	4640      	mov	r0, r8
   26012:	03d2      	lsls	r2, r2, #15
   26014:	4210      	tst	r0, r2
   26016:	d0af      	beq.n	25f78 <__aeabi_fadd+0x244>
   26018:	4216      	tst	r6, r2
   2601a:	d1ad      	bne.n	25f78 <__aeabi_fadd+0x244>
   2601c:	003b      	movs	r3, r7
   2601e:	000d      	movs	r5, r1
   26020:	24ff      	movs	r4, #255	; 0xff
   26022:	e6c2      	b.n	25daa <__aeabi_fadd+0x76>
   26024:	4663      	mov	r3, ip
   26026:	24ff      	movs	r4, #255	; 0xff
   26028:	e6bf      	b.n	25daa <__aeabi_fadd+0x76>
   2602a:	2301      	movs	r3, #1
   2602c:	e77a      	b.n	25f24 <__aeabi_fadd+0x1f0>
   2602e:	003b      	movs	r3, r7
   26030:	0004      	movs	r4, r0
   26032:	e6ba      	b.n	25daa <__aeabi_fadd+0x76>
   26034:	2680      	movs	r6, #128	; 0x80
   26036:	2200      	movs	r2, #0
   26038:	03f6      	lsls	r6, r6, #15
   2603a:	e6f0      	b.n	25e1e <__aeabi_fadd+0xea>
   2603c:	003b      	movs	r3, r7
   2603e:	e6b4      	b.n	25daa <__aeabi_fadd+0x76>
   26040:	1e33      	subs	r3, r6, #0
   26042:	d000      	beq.n	26046 <__aeabi_fadd+0x312>
   26044:	e6e2      	b.n	25e0c <__aeabi_fadd+0xd8>
   26046:	2200      	movs	r2, #0
   26048:	e721      	b.n	25e8e <__aeabi_fadd+0x15a>
   2604a:	2301      	movs	r3, #1
   2604c:	e7bd      	b.n	25fca <__aeabi_fadd+0x296>
   2604e:	46c0      	nop			; (mov r8, r8)
   26050:	7dffffff 	.word	0x7dffffff
   26054:	fbffffff 	.word	0xfbffffff

00026058 <__aeabi_fdiv>:
   26058:	b5f0      	push	{r4, r5, r6, r7, lr}
   2605a:	4657      	mov	r7, sl
   2605c:	464e      	mov	r6, r9
   2605e:	46de      	mov	lr, fp
   26060:	4645      	mov	r5, r8
   26062:	b5e0      	push	{r5, r6, r7, lr}
   26064:	0244      	lsls	r4, r0, #9
   26066:	0043      	lsls	r3, r0, #1
   26068:	0fc6      	lsrs	r6, r0, #31
   2606a:	b083      	sub	sp, #12
   2606c:	1c0f      	adds	r7, r1, #0
   2606e:	0a64      	lsrs	r4, r4, #9
   26070:	0e1b      	lsrs	r3, r3, #24
   26072:	46b2      	mov	sl, r6
   26074:	d053      	beq.n	2611e <__aeabi_fdiv+0xc6>
   26076:	2bff      	cmp	r3, #255	; 0xff
   26078:	d027      	beq.n	260ca <__aeabi_fdiv+0x72>
   2607a:	2280      	movs	r2, #128	; 0x80
   2607c:	00e4      	lsls	r4, r4, #3
   2607e:	04d2      	lsls	r2, r2, #19
   26080:	4314      	orrs	r4, r2
   26082:	227f      	movs	r2, #127	; 0x7f
   26084:	4252      	negs	r2, r2
   26086:	4690      	mov	r8, r2
   26088:	4498      	add	r8, r3
   2608a:	2300      	movs	r3, #0
   2608c:	4699      	mov	r9, r3
   2608e:	469b      	mov	fp, r3
   26090:	027d      	lsls	r5, r7, #9
   26092:	0078      	lsls	r0, r7, #1
   26094:	0ffb      	lsrs	r3, r7, #31
   26096:	0a6d      	lsrs	r5, r5, #9
   26098:	0e00      	lsrs	r0, r0, #24
   2609a:	9300      	str	r3, [sp, #0]
   2609c:	d024      	beq.n	260e8 <__aeabi_fdiv+0x90>
   2609e:	28ff      	cmp	r0, #255	; 0xff
   260a0:	d046      	beq.n	26130 <__aeabi_fdiv+0xd8>
   260a2:	2380      	movs	r3, #128	; 0x80
   260a4:	2100      	movs	r1, #0
   260a6:	00ed      	lsls	r5, r5, #3
   260a8:	04db      	lsls	r3, r3, #19
   260aa:	431d      	orrs	r5, r3
   260ac:	387f      	subs	r0, #127	; 0x7f
   260ae:	4647      	mov	r7, r8
   260b0:	1a38      	subs	r0, r7, r0
   260b2:	464f      	mov	r7, r9
   260b4:	430f      	orrs	r7, r1
   260b6:	00bf      	lsls	r7, r7, #2
   260b8:	46b9      	mov	r9, r7
   260ba:	0033      	movs	r3, r6
   260bc:	9a00      	ldr	r2, [sp, #0]
   260be:	4f87      	ldr	r7, [pc, #540]	; (262dc <__aeabi_fdiv+0x284>)
   260c0:	4053      	eors	r3, r2
   260c2:	464a      	mov	r2, r9
   260c4:	58ba      	ldr	r2, [r7, r2]
   260c6:	9301      	str	r3, [sp, #4]
   260c8:	4697      	mov	pc, r2
   260ca:	2c00      	cmp	r4, #0
   260cc:	d14e      	bne.n	2616c <__aeabi_fdiv+0x114>
   260ce:	2308      	movs	r3, #8
   260d0:	4699      	mov	r9, r3
   260d2:	33f7      	adds	r3, #247	; 0xf7
   260d4:	4698      	mov	r8, r3
   260d6:	3bfd      	subs	r3, #253	; 0xfd
   260d8:	469b      	mov	fp, r3
   260da:	027d      	lsls	r5, r7, #9
   260dc:	0078      	lsls	r0, r7, #1
   260de:	0ffb      	lsrs	r3, r7, #31
   260e0:	0a6d      	lsrs	r5, r5, #9
   260e2:	0e00      	lsrs	r0, r0, #24
   260e4:	9300      	str	r3, [sp, #0]
   260e6:	d1da      	bne.n	2609e <__aeabi_fdiv+0x46>
   260e8:	2d00      	cmp	r5, #0
   260ea:	d126      	bne.n	2613a <__aeabi_fdiv+0xe2>
   260ec:	2000      	movs	r0, #0
   260ee:	2101      	movs	r1, #1
   260f0:	0033      	movs	r3, r6
   260f2:	9a00      	ldr	r2, [sp, #0]
   260f4:	4f7a      	ldr	r7, [pc, #488]	; (262e0 <__aeabi_fdiv+0x288>)
   260f6:	4053      	eors	r3, r2
   260f8:	4642      	mov	r2, r8
   260fa:	1a10      	subs	r0, r2, r0
   260fc:	464a      	mov	r2, r9
   260fe:	430a      	orrs	r2, r1
   26100:	0092      	lsls	r2, r2, #2
   26102:	58ba      	ldr	r2, [r7, r2]
   26104:	001d      	movs	r5, r3
   26106:	4697      	mov	pc, r2
   26108:	9b00      	ldr	r3, [sp, #0]
   2610a:	002c      	movs	r4, r5
   2610c:	469a      	mov	sl, r3
   2610e:	468b      	mov	fp, r1
   26110:	465b      	mov	r3, fp
   26112:	2b02      	cmp	r3, #2
   26114:	d131      	bne.n	2617a <__aeabi_fdiv+0x122>
   26116:	4653      	mov	r3, sl
   26118:	21ff      	movs	r1, #255	; 0xff
   2611a:	2400      	movs	r4, #0
   2611c:	e038      	b.n	26190 <__aeabi_fdiv+0x138>
   2611e:	2c00      	cmp	r4, #0
   26120:	d117      	bne.n	26152 <__aeabi_fdiv+0xfa>
   26122:	2304      	movs	r3, #4
   26124:	4699      	mov	r9, r3
   26126:	2300      	movs	r3, #0
   26128:	4698      	mov	r8, r3
   2612a:	3301      	adds	r3, #1
   2612c:	469b      	mov	fp, r3
   2612e:	e7af      	b.n	26090 <__aeabi_fdiv+0x38>
   26130:	20ff      	movs	r0, #255	; 0xff
   26132:	2d00      	cmp	r5, #0
   26134:	d10b      	bne.n	2614e <__aeabi_fdiv+0xf6>
   26136:	2102      	movs	r1, #2
   26138:	e7da      	b.n	260f0 <__aeabi_fdiv+0x98>
   2613a:	0028      	movs	r0, r5
   2613c:	f002 fae8 	bl	28710 <__clzsi2>
   26140:	1f43      	subs	r3, r0, #5
   26142:	409d      	lsls	r5, r3
   26144:	2376      	movs	r3, #118	; 0x76
   26146:	425b      	negs	r3, r3
   26148:	1a18      	subs	r0, r3, r0
   2614a:	2100      	movs	r1, #0
   2614c:	e7af      	b.n	260ae <__aeabi_fdiv+0x56>
   2614e:	2103      	movs	r1, #3
   26150:	e7ad      	b.n	260ae <__aeabi_fdiv+0x56>
   26152:	0020      	movs	r0, r4
   26154:	f002 fadc 	bl	28710 <__clzsi2>
   26158:	1f43      	subs	r3, r0, #5
   2615a:	409c      	lsls	r4, r3
   2615c:	2376      	movs	r3, #118	; 0x76
   2615e:	425b      	negs	r3, r3
   26160:	1a1b      	subs	r3, r3, r0
   26162:	4698      	mov	r8, r3
   26164:	2300      	movs	r3, #0
   26166:	4699      	mov	r9, r3
   26168:	469b      	mov	fp, r3
   2616a:	e791      	b.n	26090 <__aeabi_fdiv+0x38>
   2616c:	230c      	movs	r3, #12
   2616e:	4699      	mov	r9, r3
   26170:	33f3      	adds	r3, #243	; 0xf3
   26172:	4698      	mov	r8, r3
   26174:	3bfc      	subs	r3, #252	; 0xfc
   26176:	469b      	mov	fp, r3
   26178:	e78a      	b.n	26090 <__aeabi_fdiv+0x38>
   2617a:	2b03      	cmp	r3, #3
   2617c:	d100      	bne.n	26180 <__aeabi_fdiv+0x128>
   2617e:	e0a5      	b.n	262cc <__aeabi_fdiv+0x274>
   26180:	4655      	mov	r5, sl
   26182:	2b01      	cmp	r3, #1
   26184:	d000      	beq.n	26188 <__aeabi_fdiv+0x130>
   26186:	e081      	b.n	2628c <__aeabi_fdiv+0x234>
   26188:	2301      	movs	r3, #1
   2618a:	2100      	movs	r1, #0
   2618c:	2400      	movs	r4, #0
   2618e:	402b      	ands	r3, r5
   26190:	0264      	lsls	r4, r4, #9
   26192:	05c9      	lsls	r1, r1, #23
   26194:	0a60      	lsrs	r0, r4, #9
   26196:	07db      	lsls	r3, r3, #31
   26198:	4308      	orrs	r0, r1
   2619a:	4318      	orrs	r0, r3
   2619c:	b003      	add	sp, #12
   2619e:	bc3c      	pop	{r2, r3, r4, r5}
   261a0:	4690      	mov	r8, r2
   261a2:	4699      	mov	r9, r3
   261a4:	46a2      	mov	sl, r4
   261a6:	46ab      	mov	fp, r5
   261a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   261aa:	2480      	movs	r4, #128	; 0x80
   261ac:	2300      	movs	r3, #0
   261ae:	03e4      	lsls	r4, r4, #15
   261b0:	21ff      	movs	r1, #255	; 0xff
   261b2:	e7ed      	b.n	26190 <__aeabi_fdiv+0x138>
   261b4:	21ff      	movs	r1, #255	; 0xff
   261b6:	2400      	movs	r4, #0
   261b8:	e7ea      	b.n	26190 <__aeabi_fdiv+0x138>
   261ba:	2301      	movs	r3, #1
   261bc:	1a59      	subs	r1, r3, r1
   261be:	291b      	cmp	r1, #27
   261c0:	dd66      	ble.n	26290 <__aeabi_fdiv+0x238>
   261c2:	9a01      	ldr	r2, [sp, #4]
   261c4:	4013      	ands	r3, r2
   261c6:	2100      	movs	r1, #0
   261c8:	2400      	movs	r4, #0
   261ca:	e7e1      	b.n	26190 <__aeabi_fdiv+0x138>
   261cc:	2380      	movs	r3, #128	; 0x80
   261ce:	03db      	lsls	r3, r3, #15
   261d0:	421c      	tst	r4, r3
   261d2:	d038      	beq.n	26246 <__aeabi_fdiv+0x1ee>
   261d4:	421d      	tst	r5, r3
   261d6:	d051      	beq.n	2627c <__aeabi_fdiv+0x224>
   261d8:	431c      	orrs	r4, r3
   261da:	0264      	lsls	r4, r4, #9
   261dc:	0a64      	lsrs	r4, r4, #9
   261de:	0033      	movs	r3, r6
   261e0:	21ff      	movs	r1, #255	; 0xff
   261e2:	e7d5      	b.n	26190 <__aeabi_fdiv+0x138>
   261e4:	0163      	lsls	r3, r4, #5
   261e6:	016c      	lsls	r4, r5, #5
   261e8:	42a3      	cmp	r3, r4
   261ea:	d23b      	bcs.n	26264 <__aeabi_fdiv+0x20c>
   261ec:	261b      	movs	r6, #27
   261ee:	2100      	movs	r1, #0
   261f0:	3801      	subs	r0, #1
   261f2:	2501      	movs	r5, #1
   261f4:	001f      	movs	r7, r3
   261f6:	0049      	lsls	r1, r1, #1
   261f8:	005b      	lsls	r3, r3, #1
   261fa:	2f00      	cmp	r7, #0
   261fc:	db01      	blt.n	26202 <__aeabi_fdiv+0x1aa>
   261fe:	429c      	cmp	r4, r3
   26200:	d801      	bhi.n	26206 <__aeabi_fdiv+0x1ae>
   26202:	1b1b      	subs	r3, r3, r4
   26204:	4329      	orrs	r1, r5
   26206:	3e01      	subs	r6, #1
   26208:	2e00      	cmp	r6, #0
   2620a:	d1f3      	bne.n	261f4 <__aeabi_fdiv+0x19c>
   2620c:	001c      	movs	r4, r3
   2620e:	1e63      	subs	r3, r4, #1
   26210:	419c      	sbcs	r4, r3
   26212:	430c      	orrs	r4, r1
   26214:	0001      	movs	r1, r0
   26216:	317f      	adds	r1, #127	; 0x7f
   26218:	2900      	cmp	r1, #0
   2621a:	ddce      	ble.n	261ba <__aeabi_fdiv+0x162>
   2621c:	0763      	lsls	r3, r4, #29
   2621e:	d004      	beq.n	2622a <__aeabi_fdiv+0x1d2>
   26220:	230f      	movs	r3, #15
   26222:	4023      	ands	r3, r4
   26224:	2b04      	cmp	r3, #4
   26226:	d000      	beq.n	2622a <__aeabi_fdiv+0x1d2>
   26228:	3404      	adds	r4, #4
   2622a:	0123      	lsls	r3, r4, #4
   2622c:	d503      	bpl.n	26236 <__aeabi_fdiv+0x1de>
   2622e:	0001      	movs	r1, r0
   26230:	4b2c      	ldr	r3, [pc, #176]	; (262e4 <__aeabi_fdiv+0x28c>)
   26232:	3180      	adds	r1, #128	; 0x80
   26234:	401c      	ands	r4, r3
   26236:	29fe      	cmp	r1, #254	; 0xfe
   26238:	dd0d      	ble.n	26256 <__aeabi_fdiv+0x1fe>
   2623a:	2301      	movs	r3, #1
   2623c:	9a01      	ldr	r2, [sp, #4]
   2623e:	21ff      	movs	r1, #255	; 0xff
   26240:	4013      	ands	r3, r2
   26242:	2400      	movs	r4, #0
   26244:	e7a4      	b.n	26190 <__aeabi_fdiv+0x138>
   26246:	2380      	movs	r3, #128	; 0x80
   26248:	03db      	lsls	r3, r3, #15
   2624a:	431c      	orrs	r4, r3
   2624c:	0264      	lsls	r4, r4, #9
   2624e:	0a64      	lsrs	r4, r4, #9
   26250:	0033      	movs	r3, r6
   26252:	21ff      	movs	r1, #255	; 0xff
   26254:	e79c      	b.n	26190 <__aeabi_fdiv+0x138>
   26256:	2301      	movs	r3, #1
   26258:	9a01      	ldr	r2, [sp, #4]
   2625a:	01a4      	lsls	r4, r4, #6
   2625c:	0a64      	lsrs	r4, r4, #9
   2625e:	b2c9      	uxtb	r1, r1
   26260:	4013      	ands	r3, r2
   26262:	e795      	b.n	26190 <__aeabi_fdiv+0x138>
   26264:	1b1b      	subs	r3, r3, r4
   26266:	261a      	movs	r6, #26
   26268:	2101      	movs	r1, #1
   2626a:	e7c2      	b.n	261f2 <__aeabi_fdiv+0x19a>
   2626c:	9b00      	ldr	r3, [sp, #0]
   2626e:	468b      	mov	fp, r1
   26270:	469a      	mov	sl, r3
   26272:	2400      	movs	r4, #0
   26274:	e74c      	b.n	26110 <__aeabi_fdiv+0xb8>
   26276:	0263      	lsls	r3, r4, #9
   26278:	d5e5      	bpl.n	26246 <__aeabi_fdiv+0x1ee>
   2627a:	2500      	movs	r5, #0
   2627c:	2480      	movs	r4, #128	; 0x80
   2627e:	03e4      	lsls	r4, r4, #15
   26280:	432c      	orrs	r4, r5
   26282:	0264      	lsls	r4, r4, #9
   26284:	0a64      	lsrs	r4, r4, #9
   26286:	9b00      	ldr	r3, [sp, #0]
   26288:	21ff      	movs	r1, #255	; 0xff
   2628a:	e781      	b.n	26190 <__aeabi_fdiv+0x138>
   2628c:	9501      	str	r5, [sp, #4]
   2628e:	e7c1      	b.n	26214 <__aeabi_fdiv+0x1bc>
   26290:	0023      	movs	r3, r4
   26292:	2020      	movs	r0, #32
   26294:	40cb      	lsrs	r3, r1
   26296:	1a41      	subs	r1, r0, r1
   26298:	408c      	lsls	r4, r1
   2629a:	1e61      	subs	r1, r4, #1
   2629c:	418c      	sbcs	r4, r1
   2629e:	431c      	orrs	r4, r3
   262a0:	0763      	lsls	r3, r4, #29
   262a2:	d004      	beq.n	262ae <__aeabi_fdiv+0x256>
   262a4:	230f      	movs	r3, #15
   262a6:	4023      	ands	r3, r4
   262a8:	2b04      	cmp	r3, #4
   262aa:	d000      	beq.n	262ae <__aeabi_fdiv+0x256>
   262ac:	3404      	adds	r4, #4
   262ae:	0163      	lsls	r3, r4, #5
   262b0:	d505      	bpl.n	262be <__aeabi_fdiv+0x266>
   262b2:	2301      	movs	r3, #1
   262b4:	9a01      	ldr	r2, [sp, #4]
   262b6:	2101      	movs	r1, #1
   262b8:	4013      	ands	r3, r2
   262ba:	2400      	movs	r4, #0
   262bc:	e768      	b.n	26190 <__aeabi_fdiv+0x138>
   262be:	2301      	movs	r3, #1
   262c0:	9a01      	ldr	r2, [sp, #4]
   262c2:	01a4      	lsls	r4, r4, #6
   262c4:	0a64      	lsrs	r4, r4, #9
   262c6:	4013      	ands	r3, r2
   262c8:	2100      	movs	r1, #0
   262ca:	e761      	b.n	26190 <__aeabi_fdiv+0x138>
   262cc:	2380      	movs	r3, #128	; 0x80
   262ce:	03db      	lsls	r3, r3, #15
   262d0:	431c      	orrs	r4, r3
   262d2:	0264      	lsls	r4, r4, #9
   262d4:	0a64      	lsrs	r4, r4, #9
   262d6:	4653      	mov	r3, sl
   262d8:	21ff      	movs	r1, #255	; 0xff
   262da:	e759      	b.n	26190 <__aeabi_fdiv+0x138>
   262dc:	0002b928 	.word	0x0002b928
   262e0:	0002b968 	.word	0x0002b968
   262e4:	f7ffffff 	.word	0xf7ffffff

000262e8 <__eqsf2>:
   262e8:	b570      	push	{r4, r5, r6, lr}
   262ea:	0042      	lsls	r2, r0, #1
   262ec:	0245      	lsls	r5, r0, #9
   262ee:	024e      	lsls	r6, r1, #9
   262f0:	004c      	lsls	r4, r1, #1
   262f2:	0fc3      	lsrs	r3, r0, #31
   262f4:	0a6d      	lsrs	r5, r5, #9
   262f6:	0e12      	lsrs	r2, r2, #24
   262f8:	0a76      	lsrs	r6, r6, #9
   262fa:	0e24      	lsrs	r4, r4, #24
   262fc:	0fc9      	lsrs	r1, r1, #31
   262fe:	2001      	movs	r0, #1
   26300:	2aff      	cmp	r2, #255	; 0xff
   26302:	d006      	beq.n	26312 <__eqsf2+0x2a>
   26304:	2cff      	cmp	r4, #255	; 0xff
   26306:	d003      	beq.n	26310 <__eqsf2+0x28>
   26308:	42a2      	cmp	r2, r4
   2630a:	d101      	bne.n	26310 <__eqsf2+0x28>
   2630c:	42b5      	cmp	r5, r6
   2630e:	d006      	beq.n	2631e <__eqsf2+0x36>
   26310:	bd70      	pop	{r4, r5, r6, pc}
   26312:	2d00      	cmp	r5, #0
   26314:	d1fc      	bne.n	26310 <__eqsf2+0x28>
   26316:	2cff      	cmp	r4, #255	; 0xff
   26318:	d1fa      	bne.n	26310 <__eqsf2+0x28>
   2631a:	2e00      	cmp	r6, #0
   2631c:	d1f8      	bne.n	26310 <__eqsf2+0x28>
   2631e:	428b      	cmp	r3, r1
   26320:	d006      	beq.n	26330 <__eqsf2+0x48>
   26322:	2001      	movs	r0, #1
   26324:	2a00      	cmp	r2, #0
   26326:	d1f3      	bne.n	26310 <__eqsf2+0x28>
   26328:	0028      	movs	r0, r5
   2632a:	1e45      	subs	r5, r0, #1
   2632c:	41a8      	sbcs	r0, r5
   2632e:	e7ef      	b.n	26310 <__eqsf2+0x28>
   26330:	2000      	movs	r0, #0
   26332:	e7ed      	b.n	26310 <__eqsf2+0x28>

00026334 <__gesf2>:
   26334:	b5f0      	push	{r4, r5, r6, r7, lr}
   26336:	0042      	lsls	r2, r0, #1
   26338:	0245      	lsls	r5, r0, #9
   2633a:	024c      	lsls	r4, r1, #9
   2633c:	0fc3      	lsrs	r3, r0, #31
   2633e:	0048      	lsls	r0, r1, #1
   26340:	0a6d      	lsrs	r5, r5, #9
   26342:	0e12      	lsrs	r2, r2, #24
   26344:	0a64      	lsrs	r4, r4, #9
   26346:	0e00      	lsrs	r0, r0, #24
   26348:	0fc9      	lsrs	r1, r1, #31
   2634a:	2aff      	cmp	r2, #255	; 0xff
   2634c:	d01e      	beq.n	2638c <__gesf2+0x58>
   2634e:	28ff      	cmp	r0, #255	; 0xff
   26350:	d021      	beq.n	26396 <__gesf2+0x62>
   26352:	2a00      	cmp	r2, #0
   26354:	d10a      	bne.n	2636c <__gesf2+0x38>
   26356:	426e      	negs	r6, r5
   26358:	416e      	adcs	r6, r5
   2635a:	b2f6      	uxtb	r6, r6
   2635c:	2800      	cmp	r0, #0
   2635e:	d10f      	bne.n	26380 <__gesf2+0x4c>
   26360:	2c00      	cmp	r4, #0
   26362:	d10d      	bne.n	26380 <__gesf2+0x4c>
   26364:	2000      	movs	r0, #0
   26366:	2d00      	cmp	r5, #0
   26368:	d009      	beq.n	2637e <__gesf2+0x4a>
   2636a:	e005      	b.n	26378 <__gesf2+0x44>
   2636c:	2800      	cmp	r0, #0
   2636e:	d101      	bne.n	26374 <__gesf2+0x40>
   26370:	2c00      	cmp	r4, #0
   26372:	d001      	beq.n	26378 <__gesf2+0x44>
   26374:	428b      	cmp	r3, r1
   26376:	d011      	beq.n	2639c <__gesf2+0x68>
   26378:	2101      	movs	r1, #1
   2637a:	4258      	negs	r0, r3
   2637c:	4308      	orrs	r0, r1
   2637e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   26380:	2e00      	cmp	r6, #0
   26382:	d0f7      	beq.n	26374 <__gesf2+0x40>
   26384:	2001      	movs	r0, #1
   26386:	3901      	subs	r1, #1
   26388:	4308      	orrs	r0, r1
   2638a:	e7f8      	b.n	2637e <__gesf2+0x4a>
   2638c:	2d00      	cmp	r5, #0
   2638e:	d0de      	beq.n	2634e <__gesf2+0x1a>
   26390:	2002      	movs	r0, #2
   26392:	4240      	negs	r0, r0
   26394:	e7f3      	b.n	2637e <__gesf2+0x4a>
   26396:	2c00      	cmp	r4, #0
   26398:	d0db      	beq.n	26352 <__gesf2+0x1e>
   2639a:	e7f9      	b.n	26390 <__gesf2+0x5c>
   2639c:	4282      	cmp	r2, r0
   2639e:	dceb      	bgt.n	26378 <__gesf2+0x44>
   263a0:	db04      	blt.n	263ac <__gesf2+0x78>
   263a2:	42a5      	cmp	r5, r4
   263a4:	d8e8      	bhi.n	26378 <__gesf2+0x44>
   263a6:	2000      	movs	r0, #0
   263a8:	42a5      	cmp	r5, r4
   263aa:	d2e8      	bcs.n	2637e <__gesf2+0x4a>
   263ac:	2101      	movs	r1, #1
   263ae:	1e58      	subs	r0, r3, #1
   263b0:	4308      	orrs	r0, r1
   263b2:	e7e4      	b.n	2637e <__gesf2+0x4a>

000263b4 <__lesf2>:
   263b4:	b5f0      	push	{r4, r5, r6, r7, lr}
   263b6:	0042      	lsls	r2, r0, #1
   263b8:	024d      	lsls	r5, r1, #9
   263ba:	004c      	lsls	r4, r1, #1
   263bc:	0246      	lsls	r6, r0, #9
   263be:	0a76      	lsrs	r6, r6, #9
   263c0:	0e12      	lsrs	r2, r2, #24
   263c2:	0fc3      	lsrs	r3, r0, #31
   263c4:	0a6d      	lsrs	r5, r5, #9
   263c6:	0e24      	lsrs	r4, r4, #24
   263c8:	0fc9      	lsrs	r1, r1, #31
   263ca:	2aff      	cmp	r2, #255	; 0xff
   263cc:	d016      	beq.n	263fc <__lesf2+0x48>
   263ce:	2cff      	cmp	r4, #255	; 0xff
   263d0:	d018      	beq.n	26404 <__lesf2+0x50>
   263d2:	2a00      	cmp	r2, #0
   263d4:	d10a      	bne.n	263ec <__lesf2+0x38>
   263d6:	4270      	negs	r0, r6
   263d8:	4170      	adcs	r0, r6
   263da:	b2c0      	uxtb	r0, r0
   263dc:	2c00      	cmp	r4, #0
   263de:	d015      	beq.n	2640c <__lesf2+0x58>
   263e0:	2800      	cmp	r0, #0
   263e2:	d005      	beq.n	263f0 <__lesf2+0x3c>
   263e4:	2001      	movs	r0, #1
   263e6:	3901      	subs	r1, #1
   263e8:	4308      	orrs	r0, r1
   263ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
   263ec:	2c00      	cmp	r4, #0
   263ee:	d013      	beq.n	26418 <__lesf2+0x64>
   263f0:	4299      	cmp	r1, r3
   263f2:	d014      	beq.n	2641e <__lesf2+0x6a>
   263f4:	2001      	movs	r0, #1
   263f6:	425b      	negs	r3, r3
   263f8:	4318      	orrs	r0, r3
   263fa:	e7f6      	b.n	263ea <__lesf2+0x36>
   263fc:	2002      	movs	r0, #2
   263fe:	2e00      	cmp	r6, #0
   26400:	d1f3      	bne.n	263ea <__lesf2+0x36>
   26402:	e7e4      	b.n	263ce <__lesf2+0x1a>
   26404:	2002      	movs	r0, #2
   26406:	2d00      	cmp	r5, #0
   26408:	d1ef      	bne.n	263ea <__lesf2+0x36>
   2640a:	e7e2      	b.n	263d2 <__lesf2+0x1e>
   2640c:	2d00      	cmp	r5, #0
   2640e:	d1e7      	bne.n	263e0 <__lesf2+0x2c>
   26410:	2000      	movs	r0, #0
   26412:	2e00      	cmp	r6, #0
   26414:	d0e9      	beq.n	263ea <__lesf2+0x36>
   26416:	e7ed      	b.n	263f4 <__lesf2+0x40>
   26418:	2d00      	cmp	r5, #0
   2641a:	d1e9      	bne.n	263f0 <__lesf2+0x3c>
   2641c:	e7ea      	b.n	263f4 <__lesf2+0x40>
   2641e:	42a2      	cmp	r2, r4
   26420:	dc06      	bgt.n	26430 <__lesf2+0x7c>
   26422:	dbdf      	blt.n	263e4 <__lesf2+0x30>
   26424:	42ae      	cmp	r6, r5
   26426:	d803      	bhi.n	26430 <__lesf2+0x7c>
   26428:	2000      	movs	r0, #0
   2642a:	42ae      	cmp	r6, r5
   2642c:	d3da      	bcc.n	263e4 <__lesf2+0x30>
   2642e:	e7dc      	b.n	263ea <__lesf2+0x36>
   26430:	2001      	movs	r0, #1
   26432:	4249      	negs	r1, r1
   26434:	4308      	orrs	r0, r1
   26436:	e7d8      	b.n	263ea <__lesf2+0x36>

00026438 <__aeabi_fmul>:
   26438:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2643a:	4657      	mov	r7, sl
   2643c:	464e      	mov	r6, r9
   2643e:	4645      	mov	r5, r8
   26440:	46de      	mov	lr, fp
   26442:	b5e0      	push	{r5, r6, r7, lr}
   26444:	0247      	lsls	r7, r0, #9
   26446:	0046      	lsls	r6, r0, #1
   26448:	4688      	mov	r8, r1
   2644a:	0a7f      	lsrs	r7, r7, #9
   2644c:	0e36      	lsrs	r6, r6, #24
   2644e:	0fc4      	lsrs	r4, r0, #31
   26450:	2e00      	cmp	r6, #0
   26452:	d047      	beq.n	264e4 <__aeabi_fmul+0xac>
   26454:	2eff      	cmp	r6, #255	; 0xff
   26456:	d024      	beq.n	264a2 <__aeabi_fmul+0x6a>
   26458:	00fb      	lsls	r3, r7, #3
   2645a:	2780      	movs	r7, #128	; 0x80
   2645c:	04ff      	lsls	r7, r7, #19
   2645e:	431f      	orrs	r7, r3
   26460:	2300      	movs	r3, #0
   26462:	4699      	mov	r9, r3
   26464:	469a      	mov	sl, r3
   26466:	3e7f      	subs	r6, #127	; 0x7f
   26468:	4643      	mov	r3, r8
   2646a:	025d      	lsls	r5, r3, #9
   2646c:	0058      	lsls	r0, r3, #1
   2646e:	0fdb      	lsrs	r3, r3, #31
   26470:	0a6d      	lsrs	r5, r5, #9
   26472:	0e00      	lsrs	r0, r0, #24
   26474:	4698      	mov	r8, r3
   26476:	d043      	beq.n	26500 <__aeabi_fmul+0xc8>
   26478:	28ff      	cmp	r0, #255	; 0xff
   2647a:	d03b      	beq.n	264f4 <__aeabi_fmul+0xbc>
   2647c:	00eb      	lsls	r3, r5, #3
   2647e:	2580      	movs	r5, #128	; 0x80
   26480:	2200      	movs	r2, #0
   26482:	04ed      	lsls	r5, r5, #19
   26484:	431d      	orrs	r5, r3
   26486:	387f      	subs	r0, #127	; 0x7f
   26488:	1836      	adds	r6, r6, r0
   2648a:	1c73      	adds	r3, r6, #1
   2648c:	4641      	mov	r1, r8
   2648e:	469b      	mov	fp, r3
   26490:	464b      	mov	r3, r9
   26492:	4061      	eors	r1, r4
   26494:	4313      	orrs	r3, r2
   26496:	2b0f      	cmp	r3, #15
   26498:	d864      	bhi.n	26564 <__aeabi_fmul+0x12c>
   2649a:	4875      	ldr	r0, [pc, #468]	; (26670 <__aeabi_fmul+0x238>)
   2649c:	009b      	lsls	r3, r3, #2
   2649e:	58c3      	ldr	r3, [r0, r3]
   264a0:	469f      	mov	pc, r3
   264a2:	2f00      	cmp	r7, #0
   264a4:	d142      	bne.n	2652c <__aeabi_fmul+0xf4>
   264a6:	2308      	movs	r3, #8
   264a8:	4699      	mov	r9, r3
   264aa:	3b06      	subs	r3, #6
   264ac:	26ff      	movs	r6, #255	; 0xff
   264ae:	469a      	mov	sl, r3
   264b0:	e7da      	b.n	26468 <__aeabi_fmul+0x30>
   264b2:	4641      	mov	r1, r8
   264b4:	2a02      	cmp	r2, #2
   264b6:	d028      	beq.n	2650a <__aeabi_fmul+0xd2>
   264b8:	2a03      	cmp	r2, #3
   264ba:	d100      	bne.n	264be <__aeabi_fmul+0x86>
   264bc:	e0ce      	b.n	2665c <__aeabi_fmul+0x224>
   264be:	2a01      	cmp	r2, #1
   264c0:	d000      	beq.n	264c4 <__aeabi_fmul+0x8c>
   264c2:	e0ac      	b.n	2661e <__aeabi_fmul+0x1e6>
   264c4:	4011      	ands	r1, r2
   264c6:	2000      	movs	r0, #0
   264c8:	2200      	movs	r2, #0
   264ca:	b2cc      	uxtb	r4, r1
   264cc:	0240      	lsls	r0, r0, #9
   264ce:	05d2      	lsls	r2, r2, #23
   264d0:	0a40      	lsrs	r0, r0, #9
   264d2:	07e4      	lsls	r4, r4, #31
   264d4:	4310      	orrs	r0, r2
   264d6:	4320      	orrs	r0, r4
   264d8:	bc3c      	pop	{r2, r3, r4, r5}
   264da:	4690      	mov	r8, r2
   264dc:	4699      	mov	r9, r3
   264de:	46a2      	mov	sl, r4
   264e0:	46ab      	mov	fp, r5
   264e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   264e4:	2f00      	cmp	r7, #0
   264e6:	d115      	bne.n	26514 <__aeabi_fmul+0xdc>
   264e8:	2304      	movs	r3, #4
   264ea:	4699      	mov	r9, r3
   264ec:	3b03      	subs	r3, #3
   264ee:	2600      	movs	r6, #0
   264f0:	469a      	mov	sl, r3
   264f2:	e7b9      	b.n	26468 <__aeabi_fmul+0x30>
   264f4:	20ff      	movs	r0, #255	; 0xff
   264f6:	2202      	movs	r2, #2
   264f8:	2d00      	cmp	r5, #0
   264fa:	d0c5      	beq.n	26488 <__aeabi_fmul+0x50>
   264fc:	2203      	movs	r2, #3
   264fe:	e7c3      	b.n	26488 <__aeabi_fmul+0x50>
   26500:	2d00      	cmp	r5, #0
   26502:	d119      	bne.n	26538 <__aeabi_fmul+0x100>
   26504:	2000      	movs	r0, #0
   26506:	2201      	movs	r2, #1
   26508:	e7be      	b.n	26488 <__aeabi_fmul+0x50>
   2650a:	2401      	movs	r4, #1
   2650c:	22ff      	movs	r2, #255	; 0xff
   2650e:	400c      	ands	r4, r1
   26510:	2000      	movs	r0, #0
   26512:	e7db      	b.n	264cc <__aeabi_fmul+0x94>
   26514:	0038      	movs	r0, r7
   26516:	f002 f8fb 	bl	28710 <__clzsi2>
   2651a:	2676      	movs	r6, #118	; 0x76
   2651c:	1f43      	subs	r3, r0, #5
   2651e:	409f      	lsls	r7, r3
   26520:	2300      	movs	r3, #0
   26522:	4276      	negs	r6, r6
   26524:	1a36      	subs	r6, r6, r0
   26526:	4699      	mov	r9, r3
   26528:	469a      	mov	sl, r3
   2652a:	e79d      	b.n	26468 <__aeabi_fmul+0x30>
   2652c:	230c      	movs	r3, #12
   2652e:	4699      	mov	r9, r3
   26530:	3b09      	subs	r3, #9
   26532:	26ff      	movs	r6, #255	; 0xff
   26534:	469a      	mov	sl, r3
   26536:	e797      	b.n	26468 <__aeabi_fmul+0x30>
   26538:	0028      	movs	r0, r5
   2653a:	f002 f8e9 	bl	28710 <__clzsi2>
   2653e:	1f43      	subs	r3, r0, #5
   26540:	409d      	lsls	r5, r3
   26542:	2376      	movs	r3, #118	; 0x76
   26544:	425b      	negs	r3, r3
   26546:	1a18      	subs	r0, r3, r0
   26548:	2200      	movs	r2, #0
   2654a:	e79d      	b.n	26488 <__aeabi_fmul+0x50>
   2654c:	2080      	movs	r0, #128	; 0x80
   2654e:	2400      	movs	r4, #0
   26550:	03c0      	lsls	r0, r0, #15
   26552:	22ff      	movs	r2, #255	; 0xff
   26554:	e7ba      	b.n	264cc <__aeabi_fmul+0x94>
   26556:	003d      	movs	r5, r7
   26558:	4652      	mov	r2, sl
   2655a:	e7ab      	b.n	264b4 <__aeabi_fmul+0x7c>
   2655c:	003d      	movs	r5, r7
   2655e:	0021      	movs	r1, r4
   26560:	4652      	mov	r2, sl
   26562:	e7a7      	b.n	264b4 <__aeabi_fmul+0x7c>
   26564:	0c3b      	lsrs	r3, r7, #16
   26566:	469c      	mov	ip, r3
   26568:	042a      	lsls	r2, r5, #16
   2656a:	0c12      	lsrs	r2, r2, #16
   2656c:	0c2b      	lsrs	r3, r5, #16
   2656e:	0014      	movs	r4, r2
   26570:	4660      	mov	r0, ip
   26572:	4665      	mov	r5, ip
   26574:	043f      	lsls	r7, r7, #16
   26576:	0c3f      	lsrs	r7, r7, #16
   26578:	437c      	muls	r4, r7
   2657a:	4342      	muls	r2, r0
   2657c:	435d      	muls	r5, r3
   2657e:	437b      	muls	r3, r7
   26580:	0c27      	lsrs	r7, r4, #16
   26582:	189b      	adds	r3, r3, r2
   26584:	18ff      	adds	r7, r7, r3
   26586:	42ba      	cmp	r2, r7
   26588:	d903      	bls.n	26592 <__aeabi_fmul+0x15a>
   2658a:	2380      	movs	r3, #128	; 0x80
   2658c:	025b      	lsls	r3, r3, #9
   2658e:	469c      	mov	ip, r3
   26590:	4465      	add	r5, ip
   26592:	0424      	lsls	r4, r4, #16
   26594:	043a      	lsls	r2, r7, #16
   26596:	0c24      	lsrs	r4, r4, #16
   26598:	1912      	adds	r2, r2, r4
   2659a:	0193      	lsls	r3, r2, #6
   2659c:	1e5c      	subs	r4, r3, #1
   2659e:	41a3      	sbcs	r3, r4
   265a0:	0c3f      	lsrs	r7, r7, #16
   265a2:	0e92      	lsrs	r2, r2, #26
   265a4:	197d      	adds	r5, r7, r5
   265a6:	431a      	orrs	r2, r3
   265a8:	01ad      	lsls	r5, r5, #6
   265aa:	4315      	orrs	r5, r2
   265ac:	012b      	lsls	r3, r5, #4
   265ae:	d504      	bpl.n	265ba <__aeabi_fmul+0x182>
   265b0:	2301      	movs	r3, #1
   265b2:	465e      	mov	r6, fp
   265b4:	086a      	lsrs	r2, r5, #1
   265b6:	401d      	ands	r5, r3
   265b8:	4315      	orrs	r5, r2
   265ba:	0032      	movs	r2, r6
   265bc:	327f      	adds	r2, #127	; 0x7f
   265be:	2a00      	cmp	r2, #0
   265c0:	dd25      	ble.n	2660e <__aeabi_fmul+0x1d6>
   265c2:	076b      	lsls	r3, r5, #29
   265c4:	d004      	beq.n	265d0 <__aeabi_fmul+0x198>
   265c6:	230f      	movs	r3, #15
   265c8:	402b      	ands	r3, r5
   265ca:	2b04      	cmp	r3, #4
   265cc:	d000      	beq.n	265d0 <__aeabi_fmul+0x198>
   265ce:	3504      	adds	r5, #4
   265d0:	012b      	lsls	r3, r5, #4
   265d2:	d503      	bpl.n	265dc <__aeabi_fmul+0x1a4>
   265d4:	0032      	movs	r2, r6
   265d6:	4b27      	ldr	r3, [pc, #156]	; (26674 <__aeabi_fmul+0x23c>)
   265d8:	3280      	adds	r2, #128	; 0x80
   265da:	401d      	ands	r5, r3
   265dc:	2afe      	cmp	r2, #254	; 0xfe
   265de:	dc94      	bgt.n	2650a <__aeabi_fmul+0xd2>
   265e0:	2401      	movs	r4, #1
   265e2:	01a8      	lsls	r0, r5, #6
   265e4:	0a40      	lsrs	r0, r0, #9
   265e6:	b2d2      	uxtb	r2, r2
   265e8:	400c      	ands	r4, r1
   265ea:	e76f      	b.n	264cc <__aeabi_fmul+0x94>
   265ec:	2080      	movs	r0, #128	; 0x80
   265ee:	03c0      	lsls	r0, r0, #15
   265f0:	4207      	tst	r7, r0
   265f2:	d007      	beq.n	26604 <__aeabi_fmul+0x1cc>
   265f4:	4205      	tst	r5, r0
   265f6:	d105      	bne.n	26604 <__aeabi_fmul+0x1cc>
   265f8:	4328      	orrs	r0, r5
   265fa:	0240      	lsls	r0, r0, #9
   265fc:	0a40      	lsrs	r0, r0, #9
   265fe:	4644      	mov	r4, r8
   26600:	22ff      	movs	r2, #255	; 0xff
   26602:	e763      	b.n	264cc <__aeabi_fmul+0x94>
   26604:	4338      	orrs	r0, r7
   26606:	0240      	lsls	r0, r0, #9
   26608:	0a40      	lsrs	r0, r0, #9
   2660a:	22ff      	movs	r2, #255	; 0xff
   2660c:	e75e      	b.n	264cc <__aeabi_fmul+0x94>
   2660e:	2401      	movs	r4, #1
   26610:	1aa3      	subs	r3, r4, r2
   26612:	2b1b      	cmp	r3, #27
   26614:	dd05      	ble.n	26622 <__aeabi_fmul+0x1ea>
   26616:	400c      	ands	r4, r1
   26618:	2200      	movs	r2, #0
   2661a:	2000      	movs	r0, #0
   2661c:	e756      	b.n	264cc <__aeabi_fmul+0x94>
   2661e:	465e      	mov	r6, fp
   26620:	e7cb      	b.n	265ba <__aeabi_fmul+0x182>
   26622:	002a      	movs	r2, r5
   26624:	2020      	movs	r0, #32
   26626:	40da      	lsrs	r2, r3
   26628:	1ac3      	subs	r3, r0, r3
   2662a:	409d      	lsls	r5, r3
   2662c:	002b      	movs	r3, r5
   2662e:	1e5d      	subs	r5, r3, #1
   26630:	41ab      	sbcs	r3, r5
   26632:	4313      	orrs	r3, r2
   26634:	075a      	lsls	r2, r3, #29
   26636:	d004      	beq.n	26642 <__aeabi_fmul+0x20a>
   26638:	220f      	movs	r2, #15
   2663a:	401a      	ands	r2, r3
   2663c:	2a04      	cmp	r2, #4
   2663e:	d000      	beq.n	26642 <__aeabi_fmul+0x20a>
   26640:	3304      	adds	r3, #4
   26642:	015a      	lsls	r2, r3, #5
   26644:	d504      	bpl.n	26650 <__aeabi_fmul+0x218>
   26646:	2401      	movs	r4, #1
   26648:	2201      	movs	r2, #1
   2664a:	400c      	ands	r4, r1
   2664c:	2000      	movs	r0, #0
   2664e:	e73d      	b.n	264cc <__aeabi_fmul+0x94>
   26650:	2401      	movs	r4, #1
   26652:	019b      	lsls	r3, r3, #6
   26654:	0a58      	lsrs	r0, r3, #9
   26656:	400c      	ands	r4, r1
   26658:	2200      	movs	r2, #0
   2665a:	e737      	b.n	264cc <__aeabi_fmul+0x94>
   2665c:	2080      	movs	r0, #128	; 0x80
   2665e:	2401      	movs	r4, #1
   26660:	03c0      	lsls	r0, r0, #15
   26662:	4328      	orrs	r0, r5
   26664:	0240      	lsls	r0, r0, #9
   26666:	0a40      	lsrs	r0, r0, #9
   26668:	400c      	ands	r4, r1
   2666a:	22ff      	movs	r2, #255	; 0xff
   2666c:	e72e      	b.n	264cc <__aeabi_fmul+0x94>
   2666e:	46c0      	nop			; (mov r8, r8)
   26670:	0002b9a8 	.word	0x0002b9a8
   26674:	f7ffffff 	.word	0xf7ffffff

00026678 <__aeabi_fsub>:
   26678:	b5f0      	push	{r4, r5, r6, r7, lr}
   2667a:	464f      	mov	r7, r9
   2667c:	46d6      	mov	lr, sl
   2667e:	4646      	mov	r6, r8
   26680:	0044      	lsls	r4, r0, #1
   26682:	b5c0      	push	{r6, r7, lr}
   26684:	0fc2      	lsrs	r2, r0, #31
   26686:	0247      	lsls	r7, r0, #9
   26688:	0248      	lsls	r0, r1, #9
   2668a:	0a40      	lsrs	r0, r0, #9
   2668c:	4684      	mov	ip, r0
   2668e:	4666      	mov	r6, ip
   26690:	0a7b      	lsrs	r3, r7, #9
   26692:	0048      	lsls	r0, r1, #1
   26694:	0fc9      	lsrs	r1, r1, #31
   26696:	469a      	mov	sl, r3
   26698:	0e24      	lsrs	r4, r4, #24
   2669a:	0015      	movs	r5, r2
   2669c:	00db      	lsls	r3, r3, #3
   2669e:	0e00      	lsrs	r0, r0, #24
   266a0:	4689      	mov	r9, r1
   266a2:	00f6      	lsls	r6, r6, #3
   266a4:	28ff      	cmp	r0, #255	; 0xff
   266a6:	d100      	bne.n	266aa <__aeabi_fsub+0x32>
   266a8:	e08f      	b.n	267ca <__aeabi_fsub+0x152>
   266aa:	2101      	movs	r1, #1
   266ac:	464f      	mov	r7, r9
   266ae:	404f      	eors	r7, r1
   266b0:	0039      	movs	r1, r7
   266b2:	4291      	cmp	r1, r2
   266b4:	d066      	beq.n	26784 <__aeabi_fsub+0x10c>
   266b6:	1a22      	subs	r2, r4, r0
   266b8:	2a00      	cmp	r2, #0
   266ba:	dc00      	bgt.n	266be <__aeabi_fsub+0x46>
   266bc:	e09d      	b.n	267fa <__aeabi_fsub+0x182>
   266be:	2800      	cmp	r0, #0
   266c0:	d13d      	bne.n	2673e <__aeabi_fsub+0xc6>
   266c2:	2e00      	cmp	r6, #0
   266c4:	d100      	bne.n	266c8 <__aeabi_fsub+0x50>
   266c6:	e08b      	b.n	267e0 <__aeabi_fsub+0x168>
   266c8:	1e51      	subs	r1, r2, #1
   266ca:	2900      	cmp	r1, #0
   266cc:	d000      	beq.n	266d0 <__aeabi_fsub+0x58>
   266ce:	e0b5      	b.n	2683c <__aeabi_fsub+0x1c4>
   266d0:	2401      	movs	r4, #1
   266d2:	1b9b      	subs	r3, r3, r6
   266d4:	015a      	lsls	r2, r3, #5
   266d6:	d544      	bpl.n	26762 <__aeabi_fsub+0xea>
   266d8:	019b      	lsls	r3, r3, #6
   266da:	099f      	lsrs	r7, r3, #6
   266dc:	0038      	movs	r0, r7
   266de:	f002 f817 	bl	28710 <__clzsi2>
   266e2:	3805      	subs	r0, #5
   266e4:	4087      	lsls	r7, r0
   266e6:	4284      	cmp	r4, r0
   266e8:	dd00      	ble.n	266ec <__aeabi_fsub+0x74>
   266ea:	e096      	b.n	2681a <__aeabi_fsub+0x1a2>
   266ec:	1b04      	subs	r4, r0, r4
   266ee:	003a      	movs	r2, r7
   266f0:	2020      	movs	r0, #32
   266f2:	3401      	adds	r4, #1
   266f4:	40e2      	lsrs	r2, r4
   266f6:	1b04      	subs	r4, r0, r4
   266f8:	40a7      	lsls	r7, r4
   266fa:	003b      	movs	r3, r7
   266fc:	1e5f      	subs	r7, r3, #1
   266fe:	41bb      	sbcs	r3, r7
   26700:	2400      	movs	r4, #0
   26702:	4313      	orrs	r3, r2
   26704:	075a      	lsls	r2, r3, #29
   26706:	d004      	beq.n	26712 <__aeabi_fsub+0x9a>
   26708:	220f      	movs	r2, #15
   2670a:	401a      	ands	r2, r3
   2670c:	2a04      	cmp	r2, #4
   2670e:	d000      	beq.n	26712 <__aeabi_fsub+0x9a>
   26710:	3304      	adds	r3, #4
   26712:	015a      	lsls	r2, r3, #5
   26714:	d527      	bpl.n	26766 <__aeabi_fsub+0xee>
   26716:	3401      	adds	r4, #1
   26718:	2cff      	cmp	r4, #255	; 0xff
   2671a:	d100      	bne.n	2671e <__aeabi_fsub+0xa6>
   2671c:	e079      	b.n	26812 <__aeabi_fsub+0x19a>
   2671e:	2201      	movs	r2, #1
   26720:	019b      	lsls	r3, r3, #6
   26722:	0a5b      	lsrs	r3, r3, #9
   26724:	b2e4      	uxtb	r4, r4
   26726:	402a      	ands	r2, r5
   26728:	025b      	lsls	r3, r3, #9
   2672a:	05e4      	lsls	r4, r4, #23
   2672c:	0a58      	lsrs	r0, r3, #9
   2672e:	07d2      	lsls	r2, r2, #31
   26730:	4320      	orrs	r0, r4
   26732:	4310      	orrs	r0, r2
   26734:	bc1c      	pop	{r2, r3, r4}
   26736:	4690      	mov	r8, r2
   26738:	4699      	mov	r9, r3
   2673a:	46a2      	mov	sl, r4
   2673c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2673e:	2cff      	cmp	r4, #255	; 0xff
   26740:	d0e0      	beq.n	26704 <__aeabi_fsub+0x8c>
   26742:	2180      	movs	r1, #128	; 0x80
   26744:	04c9      	lsls	r1, r1, #19
   26746:	430e      	orrs	r6, r1
   26748:	2a1b      	cmp	r2, #27
   2674a:	dc7b      	bgt.n	26844 <__aeabi_fsub+0x1cc>
   2674c:	0031      	movs	r1, r6
   2674e:	2020      	movs	r0, #32
   26750:	40d1      	lsrs	r1, r2
   26752:	1a82      	subs	r2, r0, r2
   26754:	4096      	lsls	r6, r2
   26756:	1e72      	subs	r2, r6, #1
   26758:	4196      	sbcs	r6, r2
   2675a:	430e      	orrs	r6, r1
   2675c:	1b9b      	subs	r3, r3, r6
   2675e:	015a      	lsls	r2, r3, #5
   26760:	d4ba      	bmi.n	266d8 <__aeabi_fsub+0x60>
   26762:	075a      	lsls	r2, r3, #29
   26764:	d1d0      	bne.n	26708 <__aeabi_fsub+0x90>
   26766:	2201      	movs	r2, #1
   26768:	08df      	lsrs	r7, r3, #3
   2676a:	402a      	ands	r2, r5
   2676c:	2cff      	cmp	r4, #255	; 0xff
   2676e:	d133      	bne.n	267d8 <__aeabi_fsub+0x160>
   26770:	2f00      	cmp	r7, #0
   26772:	d100      	bne.n	26776 <__aeabi_fsub+0xfe>
   26774:	e0a8      	b.n	268c8 <__aeabi_fsub+0x250>
   26776:	2380      	movs	r3, #128	; 0x80
   26778:	03db      	lsls	r3, r3, #15
   2677a:	433b      	orrs	r3, r7
   2677c:	025b      	lsls	r3, r3, #9
   2677e:	0a5b      	lsrs	r3, r3, #9
   26780:	24ff      	movs	r4, #255	; 0xff
   26782:	e7d1      	b.n	26728 <__aeabi_fsub+0xb0>
   26784:	1a21      	subs	r1, r4, r0
   26786:	2900      	cmp	r1, #0
   26788:	dd4c      	ble.n	26824 <__aeabi_fsub+0x1ac>
   2678a:	2800      	cmp	r0, #0
   2678c:	d02a      	beq.n	267e4 <__aeabi_fsub+0x16c>
   2678e:	2cff      	cmp	r4, #255	; 0xff
   26790:	d0b8      	beq.n	26704 <__aeabi_fsub+0x8c>
   26792:	2080      	movs	r0, #128	; 0x80
   26794:	04c0      	lsls	r0, r0, #19
   26796:	4306      	orrs	r6, r0
   26798:	291b      	cmp	r1, #27
   2679a:	dd00      	ble.n	2679e <__aeabi_fsub+0x126>
   2679c:	e0af      	b.n	268fe <__aeabi_fsub+0x286>
   2679e:	0030      	movs	r0, r6
   267a0:	2720      	movs	r7, #32
   267a2:	40c8      	lsrs	r0, r1
   267a4:	1a79      	subs	r1, r7, r1
   267a6:	408e      	lsls	r6, r1
   267a8:	1e71      	subs	r1, r6, #1
   267aa:	418e      	sbcs	r6, r1
   267ac:	4306      	orrs	r6, r0
   267ae:	199b      	adds	r3, r3, r6
   267b0:	0159      	lsls	r1, r3, #5
   267b2:	d5d6      	bpl.n	26762 <__aeabi_fsub+0xea>
   267b4:	3401      	adds	r4, #1
   267b6:	2cff      	cmp	r4, #255	; 0xff
   267b8:	d100      	bne.n	267bc <__aeabi_fsub+0x144>
   267ba:	e085      	b.n	268c8 <__aeabi_fsub+0x250>
   267bc:	2201      	movs	r2, #1
   267be:	497a      	ldr	r1, [pc, #488]	; (269a8 <__aeabi_fsub+0x330>)
   267c0:	401a      	ands	r2, r3
   267c2:	085b      	lsrs	r3, r3, #1
   267c4:	400b      	ands	r3, r1
   267c6:	4313      	orrs	r3, r2
   267c8:	e79c      	b.n	26704 <__aeabi_fsub+0x8c>
   267ca:	2e00      	cmp	r6, #0
   267cc:	d000      	beq.n	267d0 <__aeabi_fsub+0x158>
   267ce:	e770      	b.n	266b2 <__aeabi_fsub+0x3a>
   267d0:	e76b      	b.n	266aa <__aeabi_fsub+0x32>
   267d2:	1e3b      	subs	r3, r7, #0
   267d4:	d1c5      	bne.n	26762 <__aeabi_fsub+0xea>
   267d6:	2200      	movs	r2, #0
   267d8:	027b      	lsls	r3, r7, #9
   267da:	0a5b      	lsrs	r3, r3, #9
   267dc:	b2e4      	uxtb	r4, r4
   267de:	e7a3      	b.n	26728 <__aeabi_fsub+0xb0>
   267e0:	0014      	movs	r4, r2
   267e2:	e78f      	b.n	26704 <__aeabi_fsub+0x8c>
   267e4:	2e00      	cmp	r6, #0
   267e6:	d04d      	beq.n	26884 <__aeabi_fsub+0x20c>
   267e8:	1e48      	subs	r0, r1, #1
   267ea:	2800      	cmp	r0, #0
   267ec:	d157      	bne.n	2689e <__aeabi_fsub+0x226>
   267ee:	199b      	adds	r3, r3, r6
   267f0:	2401      	movs	r4, #1
   267f2:	015a      	lsls	r2, r3, #5
   267f4:	d5b5      	bpl.n	26762 <__aeabi_fsub+0xea>
   267f6:	2402      	movs	r4, #2
   267f8:	e7e0      	b.n	267bc <__aeabi_fsub+0x144>
   267fa:	2a00      	cmp	r2, #0
   267fc:	d125      	bne.n	2684a <__aeabi_fsub+0x1d2>
   267fe:	1c62      	adds	r2, r4, #1
   26800:	b2d2      	uxtb	r2, r2
   26802:	2a01      	cmp	r2, #1
   26804:	dd72      	ble.n	268ec <__aeabi_fsub+0x274>
   26806:	1b9f      	subs	r7, r3, r6
   26808:	017a      	lsls	r2, r7, #5
   2680a:	d535      	bpl.n	26878 <__aeabi_fsub+0x200>
   2680c:	1af7      	subs	r7, r6, r3
   2680e:	000d      	movs	r5, r1
   26810:	e764      	b.n	266dc <__aeabi_fsub+0x64>
   26812:	2201      	movs	r2, #1
   26814:	2300      	movs	r3, #0
   26816:	402a      	ands	r2, r5
   26818:	e786      	b.n	26728 <__aeabi_fsub+0xb0>
   2681a:	003b      	movs	r3, r7
   2681c:	4a63      	ldr	r2, [pc, #396]	; (269ac <__aeabi_fsub+0x334>)
   2681e:	1a24      	subs	r4, r4, r0
   26820:	4013      	ands	r3, r2
   26822:	e76f      	b.n	26704 <__aeabi_fsub+0x8c>
   26824:	2900      	cmp	r1, #0
   26826:	d16c      	bne.n	26902 <__aeabi_fsub+0x28a>
   26828:	1c61      	adds	r1, r4, #1
   2682a:	b2c8      	uxtb	r0, r1
   2682c:	2801      	cmp	r0, #1
   2682e:	dd4e      	ble.n	268ce <__aeabi_fsub+0x256>
   26830:	29ff      	cmp	r1, #255	; 0xff
   26832:	d049      	beq.n	268c8 <__aeabi_fsub+0x250>
   26834:	199b      	adds	r3, r3, r6
   26836:	085b      	lsrs	r3, r3, #1
   26838:	000c      	movs	r4, r1
   2683a:	e763      	b.n	26704 <__aeabi_fsub+0x8c>
   2683c:	2aff      	cmp	r2, #255	; 0xff
   2683e:	d041      	beq.n	268c4 <__aeabi_fsub+0x24c>
   26840:	000a      	movs	r2, r1
   26842:	e781      	b.n	26748 <__aeabi_fsub+0xd0>
   26844:	2601      	movs	r6, #1
   26846:	1b9b      	subs	r3, r3, r6
   26848:	e789      	b.n	2675e <__aeabi_fsub+0xe6>
   2684a:	2c00      	cmp	r4, #0
   2684c:	d01c      	beq.n	26888 <__aeabi_fsub+0x210>
   2684e:	28ff      	cmp	r0, #255	; 0xff
   26850:	d021      	beq.n	26896 <__aeabi_fsub+0x21e>
   26852:	2480      	movs	r4, #128	; 0x80
   26854:	04e4      	lsls	r4, r4, #19
   26856:	4252      	negs	r2, r2
   26858:	4323      	orrs	r3, r4
   2685a:	2a1b      	cmp	r2, #27
   2685c:	dd00      	ble.n	26860 <__aeabi_fsub+0x1e8>
   2685e:	e096      	b.n	2698e <__aeabi_fsub+0x316>
   26860:	001c      	movs	r4, r3
   26862:	2520      	movs	r5, #32
   26864:	40d4      	lsrs	r4, r2
   26866:	1aaa      	subs	r2, r5, r2
   26868:	4093      	lsls	r3, r2
   2686a:	1e5a      	subs	r2, r3, #1
   2686c:	4193      	sbcs	r3, r2
   2686e:	4323      	orrs	r3, r4
   26870:	1af3      	subs	r3, r6, r3
   26872:	0004      	movs	r4, r0
   26874:	000d      	movs	r5, r1
   26876:	e72d      	b.n	266d4 <__aeabi_fsub+0x5c>
   26878:	2f00      	cmp	r7, #0
   2687a:	d000      	beq.n	2687e <__aeabi_fsub+0x206>
   2687c:	e72e      	b.n	266dc <__aeabi_fsub+0x64>
   2687e:	2200      	movs	r2, #0
   26880:	2400      	movs	r4, #0
   26882:	e7a9      	b.n	267d8 <__aeabi_fsub+0x160>
   26884:	000c      	movs	r4, r1
   26886:	e73d      	b.n	26704 <__aeabi_fsub+0x8c>
   26888:	2b00      	cmp	r3, #0
   2688a:	d058      	beq.n	2693e <__aeabi_fsub+0x2c6>
   2688c:	43d2      	mvns	r2, r2
   2688e:	2a00      	cmp	r2, #0
   26890:	d0ee      	beq.n	26870 <__aeabi_fsub+0x1f8>
   26892:	28ff      	cmp	r0, #255	; 0xff
   26894:	d1e1      	bne.n	2685a <__aeabi_fsub+0x1e2>
   26896:	0033      	movs	r3, r6
   26898:	24ff      	movs	r4, #255	; 0xff
   2689a:	000d      	movs	r5, r1
   2689c:	e732      	b.n	26704 <__aeabi_fsub+0x8c>
   2689e:	29ff      	cmp	r1, #255	; 0xff
   268a0:	d010      	beq.n	268c4 <__aeabi_fsub+0x24c>
   268a2:	0001      	movs	r1, r0
   268a4:	e778      	b.n	26798 <__aeabi_fsub+0x120>
   268a6:	2b00      	cmp	r3, #0
   268a8:	d06e      	beq.n	26988 <__aeabi_fsub+0x310>
   268aa:	24ff      	movs	r4, #255	; 0xff
   268ac:	2e00      	cmp	r6, #0
   268ae:	d100      	bne.n	268b2 <__aeabi_fsub+0x23a>
   268b0:	e728      	b.n	26704 <__aeabi_fsub+0x8c>
   268b2:	2280      	movs	r2, #128	; 0x80
   268b4:	4651      	mov	r1, sl
   268b6:	03d2      	lsls	r2, r2, #15
   268b8:	4211      	tst	r1, r2
   268ba:	d003      	beq.n	268c4 <__aeabi_fsub+0x24c>
   268bc:	4661      	mov	r1, ip
   268be:	4211      	tst	r1, r2
   268c0:	d100      	bne.n	268c4 <__aeabi_fsub+0x24c>
   268c2:	0033      	movs	r3, r6
   268c4:	24ff      	movs	r4, #255	; 0xff
   268c6:	e71d      	b.n	26704 <__aeabi_fsub+0x8c>
   268c8:	24ff      	movs	r4, #255	; 0xff
   268ca:	2300      	movs	r3, #0
   268cc:	e72c      	b.n	26728 <__aeabi_fsub+0xb0>
   268ce:	2c00      	cmp	r4, #0
   268d0:	d1e9      	bne.n	268a6 <__aeabi_fsub+0x22e>
   268d2:	2b00      	cmp	r3, #0
   268d4:	d063      	beq.n	2699e <__aeabi_fsub+0x326>
   268d6:	2e00      	cmp	r6, #0
   268d8:	d100      	bne.n	268dc <__aeabi_fsub+0x264>
   268da:	e713      	b.n	26704 <__aeabi_fsub+0x8c>
   268dc:	199b      	adds	r3, r3, r6
   268de:	015a      	lsls	r2, r3, #5
   268e0:	d400      	bmi.n	268e4 <__aeabi_fsub+0x26c>
   268e2:	e73e      	b.n	26762 <__aeabi_fsub+0xea>
   268e4:	4a31      	ldr	r2, [pc, #196]	; (269ac <__aeabi_fsub+0x334>)
   268e6:	000c      	movs	r4, r1
   268e8:	4013      	ands	r3, r2
   268ea:	e70b      	b.n	26704 <__aeabi_fsub+0x8c>
   268ec:	2c00      	cmp	r4, #0
   268ee:	d11e      	bne.n	2692e <__aeabi_fsub+0x2b6>
   268f0:	2b00      	cmp	r3, #0
   268f2:	d12f      	bne.n	26954 <__aeabi_fsub+0x2dc>
   268f4:	2e00      	cmp	r6, #0
   268f6:	d04f      	beq.n	26998 <__aeabi_fsub+0x320>
   268f8:	0033      	movs	r3, r6
   268fa:	000d      	movs	r5, r1
   268fc:	e702      	b.n	26704 <__aeabi_fsub+0x8c>
   268fe:	2601      	movs	r6, #1
   26900:	e755      	b.n	267ae <__aeabi_fsub+0x136>
   26902:	2c00      	cmp	r4, #0
   26904:	d11f      	bne.n	26946 <__aeabi_fsub+0x2ce>
   26906:	2b00      	cmp	r3, #0
   26908:	d043      	beq.n	26992 <__aeabi_fsub+0x31a>
   2690a:	43c9      	mvns	r1, r1
   2690c:	2900      	cmp	r1, #0
   2690e:	d00b      	beq.n	26928 <__aeabi_fsub+0x2b0>
   26910:	28ff      	cmp	r0, #255	; 0xff
   26912:	d039      	beq.n	26988 <__aeabi_fsub+0x310>
   26914:	291b      	cmp	r1, #27
   26916:	dc44      	bgt.n	269a2 <__aeabi_fsub+0x32a>
   26918:	001c      	movs	r4, r3
   2691a:	2720      	movs	r7, #32
   2691c:	40cc      	lsrs	r4, r1
   2691e:	1a79      	subs	r1, r7, r1
   26920:	408b      	lsls	r3, r1
   26922:	1e59      	subs	r1, r3, #1
   26924:	418b      	sbcs	r3, r1
   26926:	4323      	orrs	r3, r4
   26928:	199b      	adds	r3, r3, r6
   2692a:	0004      	movs	r4, r0
   2692c:	e740      	b.n	267b0 <__aeabi_fsub+0x138>
   2692e:	2b00      	cmp	r3, #0
   26930:	d11a      	bne.n	26968 <__aeabi_fsub+0x2f0>
   26932:	2e00      	cmp	r6, #0
   26934:	d124      	bne.n	26980 <__aeabi_fsub+0x308>
   26936:	2780      	movs	r7, #128	; 0x80
   26938:	2200      	movs	r2, #0
   2693a:	03ff      	lsls	r7, r7, #15
   2693c:	e71b      	b.n	26776 <__aeabi_fsub+0xfe>
   2693e:	0033      	movs	r3, r6
   26940:	0004      	movs	r4, r0
   26942:	000d      	movs	r5, r1
   26944:	e6de      	b.n	26704 <__aeabi_fsub+0x8c>
   26946:	28ff      	cmp	r0, #255	; 0xff
   26948:	d01e      	beq.n	26988 <__aeabi_fsub+0x310>
   2694a:	2480      	movs	r4, #128	; 0x80
   2694c:	04e4      	lsls	r4, r4, #19
   2694e:	4249      	negs	r1, r1
   26950:	4323      	orrs	r3, r4
   26952:	e7df      	b.n	26914 <__aeabi_fsub+0x29c>
   26954:	2e00      	cmp	r6, #0
   26956:	d100      	bne.n	2695a <__aeabi_fsub+0x2e2>
   26958:	e6d4      	b.n	26704 <__aeabi_fsub+0x8c>
   2695a:	1b9f      	subs	r7, r3, r6
   2695c:	017a      	lsls	r2, r7, #5
   2695e:	d400      	bmi.n	26962 <__aeabi_fsub+0x2ea>
   26960:	e737      	b.n	267d2 <__aeabi_fsub+0x15a>
   26962:	1af3      	subs	r3, r6, r3
   26964:	000d      	movs	r5, r1
   26966:	e6cd      	b.n	26704 <__aeabi_fsub+0x8c>
   26968:	24ff      	movs	r4, #255	; 0xff
   2696a:	2e00      	cmp	r6, #0
   2696c:	d100      	bne.n	26970 <__aeabi_fsub+0x2f8>
   2696e:	e6c9      	b.n	26704 <__aeabi_fsub+0x8c>
   26970:	2280      	movs	r2, #128	; 0x80
   26972:	4650      	mov	r0, sl
   26974:	03d2      	lsls	r2, r2, #15
   26976:	4210      	tst	r0, r2
   26978:	d0a4      	beq.n	268c4 <__aeabi_fsub+0x24c>
   2697a:	4660      	mov	r0, ip
   2697c:	4210      	tst	r0, r2
   2697e:	d1a1      	bne.n	268c4 <__aeabi_fsub+0x24c>
   26980:	0033      	movs	r3, r6
   26982:	000d      	movs	r5, r1
   26984:	24ff      	movs	r4, #255	; 0xff
   26986:	e6bd      	b.n	26704 <__aeabi_fsub+0x8c>
   26988:	0033      	movs	r3, r6
   2698a:	24ff      	movs	r4, #255	; 0xff
   2698c:	e6ba      	b.n	26704 <__aeabi_fsub+0x8c>
   2698e:	2301      	movs	r3, #1
   26990:	e76e      	b.n	26870 <__aeabi_fsub+0x1f8>
   26992:	0033      	movs	r3, r6
   26994:	0004      	movs	r4, r0
   26996:	e6b5      	b.n	26704 <__aeabi_fsub+0x8c>
   26998:	2700      	movs	r7, #0
   2699a:	2200      	movs	r2, #0
   2699c:	e71c      	b.n	267d8 <__aeabi_fsub+0x160>
   2699e:	0033      	movs	r3, r6
   269a0:	e6b0      	b.n	26704 <__aeabi_fsub+0x8c>
   269a2:	2301      	movs	r3, #1
   269a4:	e7c0      	b.n	26928 <__aeabi_fsub+0x2b0>
   269a6:	46c0      	nop			; (mov r8, r8)
   269a8:	7dffffff 	.word	0x7dffffff
   269ac:	fbffffff 	.word	0xfbffffff

000269b0 <__aeabi_f2iz>:
   269b0:	0241      	lsls	r1, r0, #9
   269b2:	0043      	lsls	r3, r0, #1
   269b4:	0fc2      	lsrs	r2, r0, #31
   269b6:	0a49      	lsrs	r1, r1, #9
   269b8:	0e1b      	lsrs	r3, r3, #24
   269ba:	2000      	movs	r0, #0
   269bc:	2b7e      	cmp	r3, #126	; 0x7e
   269be:	dd0d      	ble.n	269dc <__aeabi_f2iz+0x2c>
   269c0:	2b9d      	cmp	r3, #157	; 0x9d
   269c2:	dc0c      	bgt.n	269de <__aeabi_f2iz+0x2e>
   269c4:	2080      	movs	r0, #128	; 0x80
   269c6:	0400      	lsls	r0, r0, #16
   269c8:	4301      	orrs	r1, r0
   269ca:	2b95      	cmp	r3, #149	; 0x95
   269cc:	dc0a      	bgt.n	269e4 <__aeabi_f2iz+0x34>
   269ce:	2096      	movs	r0, #150	; 0x96
   269d0:	1ac3      	subs	r3, r0, r3
   269d2:	40d9      	lsrs	r1, r3
   269d4:	4248      	negs	r0, r1
   269d6:	2a00      	cmp	r2, #0
   269d8:	d100      	bne.n	269dc <__aeabi_f2iz+0x2c>
   269da:	0008      	movs	r0, r1
   269dc:	4770      	bx	lr
   269de:	4b03      	ldr	r3, [pc, #12]	; (269ec <__aeabi_f2iz+0x3c>)
   269e0:	18d0      	adds	r0, r2, r3
   269e2:	e7fb      	b.n	269dc <__aeabi_f2iz+0x2c>
   269e4:	3b96      	subs	r3, #150	; 0x96
   269e6:	4099      	lsls	r1, r3
   269e8:	e7f4      	b.n	269d4 <__aeabi_f2iz+0x24>
   269ea:	46c0      	nop			; (mov r8, r8)
   269ec:	7fffffff 	.word	0x7fffffff

000269f0 <__aeabi_i2f>:
   269f0:	b570      	push	{r4, r5, r6, lr}
   269f2:	2800      	cmp	r0, #0
   269f4:	d030      	beq.n	26a58 <__aeabi_i2f+0x68>
   269f6:	17c3      	asrs	r3, r0, #31
   269f8:	18c4      	adds	r4, r0, r3
   269fa:	405c      	eors	r4, r3
   269fc:	0fc5      	lsrs	r5, r0, #31
   269fe:	0020      	movs	r0, r4
   26a00:	f001 fe86 	bl	28710 <__clzsi2>
   26a04:	239e      	movs	r3, #158	; 0x9e
   26a06:	1a1b      	subs	r3, r3, r0
   26a08:	2b96      	cmp	r3, #150	; 0x96
   26a0a:	dc0d      	bgt.n	26a28 <__aeabi_i2f+0x38>
   26a0c:	2296      	movs	r2, #150	; 0x96
   26a0e:	1ad2      	subs	r2, r2, r3
   26a10:	4094      	lsls	r4, r2
   26a12:	002a      	movs	r2, r5
   26a14:	0264      	lsls	r4, r4, #9
   26a16:	0a64      	lsrs	r4, r4, #9
   26a18:	b2db      	uxtb	r3, r3
   26a1a:	0264      	lsls	r4, r4, #9
   26a1c:	05db      	lsls	r3, r3, #23
   26a1e:	0a60      	lsrs	r0, r4, #9
   26a20:	07d2      	lsls	r2, r2, #31
   26a22:	4318      	orrs	r0, r3
   26a24:	4310      	orrs	r0, r2
   26a26:	bd70      	pop	{r4, r5, r6, pc}
   26a28:	2b99      	cmp	r3, #153	; 0x99
   26a2a:	dc19      	bgt.n	26a60 <__aeabi_i2f+0x70>
   26a2c:	2299      	movs	r2, #153	; 0x99
   26a2e:	1ad2      	subs	r2, r2, r3
   26a30:	2a00      	cmp	r2, #0
   26a32:	dd29      	ble.n	26a88 <__aeabi_i2f+0x98>
   26a34:	4094      	lsls	r4, r2
   26a36:	0022      	movs	r2, r4
   26a38:	4c14      	ldr	r4, [pc, #80]	; (26a8c <__aeabi_i2f+0x9c>)
   26a3a:	4014      	ands	r4, r2
   26a3c:	0751      	lsls	r1, r2, #29
   26a3e:	d004      	beq.n	26a4a <__aeabi_i2f+0x5a>
   26a40:	210f      	movs	r1, #15
   26a42:	400a      	ands	r2, r1
   26a44:	2a04      	cmp	r2, #4
   26a46:	d000      	beq.n	26a4a <__aeabi_i2f+0x5a>
   26a48:	3404      	adds	r4, #4
   26a4a:	0162      	lsls	r2, r4, #5
   26a4c:	d413      	bmi.n	26a76 <__aeabi_i2f+0x86>
   26a4e:	01a4      	lsls	r4, r4, #6
   26a50:	0a64      	lsrs	r4, r4, #9
   26a52:	b2db      	uxtb	r3, r3
   26a54:	002a      	movs	r2, r5
   26a56:	e7e0      	b.n	26a1a <__aeabi_i2f+0x2a>
   26a58:	2200      	movs	r2, #0
   26a5a:	2300      	movs	r3, #0
   26a5c:	2400      	movs	r4, #0
   26a5e:	e7dc      	b.n	26a1a <__aeabi_i2f+0x2a>
   26a60:	2205      	movs	r2, #5
   26a62:	0021      	movs	r1, r4
   26a64:	1a12      	subs	r2, r2, r0
   26a66:	40d1      	lsrs	r1, r2
   26a68:	22b9      	movs	r2, #185	; 0xb9
   26a6a:	1ad2      	subs	r2, r2, r3
   26a6c:	4094      	lsls	r4, r2
   26a6e:	1e62      	subs	r2, r4, #1
   26a70:	4194      	sbcs	r4, r2
   26a72:	430c      	orrs	r4, r1
   26a74:	e7da      	b.n	26a2c <__aeabi_i2f+0x3c>
   26a76:	4b05      	ldr	r3, [pc, #20]	; (26a8c <__aeabi_i2f+0x9c>)
   26a78:	002a      	movs	r2, r5
   26a7a:	401c      	ands	r4, r3
   26a7c:	239f      	movs	r3, #159	; 0x9f
   26a7e:	01a4      	lsls	r4, r4, #6
   26a80:	1a1b      	subs	r3, r3, r0
   26a82:	0a64      	lsrs	r4, r4, #9
   26a84:	b2db      	uxtb	r3, r3
   26a86:	e7c8      	b.n	26a1a <__aeabi_i2f+0x2a>
   26a88:	0022      	movs	r2, r4
   26a8a:	e7d5      	b.n	26a38 <__aeabi_i2f+0x48>
   26a8c:	fbffffff 	.word	0xfbffffff

00026a90 <__aeabi_ui2f>:
   26a90:	b510      	push	{r4, lr}
   26a92:	1e04      	subs	r4, r0, #0
   26a94:	d027      	beq.n	26ae6 <__aeabi_ui2f+0x56>
   26a96:	f001 fe3b 	bl	28710 <__clzsi2>
   26a9a:	239e      	movs	r3, #158	; 0x9e
   26a9c:	1a1b      	subs	r3, r3, r0
   26a9e:	2b96      	cmp	r3, #150	; 0x96
   26aa0:	dc0a      	bgt.n	26ab8 <__aeabi_ui2f+0x28>
   26aa2:	2296      	movs	r2, #150	; 0x96
   26aa4:	1ad2      	subs	r2, r2, r3
   26aa6:	4094      	lsls	r4, r2
   26aa8:	0264      	lsls	r4, r4, #9
   26aaa:	0a64      	lsrs	r4, r4, #9
   26aac:	b2db      	uxtb	r3, r3
   26aae:	0264      	lsls	r4, r4, #9
   26ab0:	05db      	lsls	r3, r3, #23
   26ab2:	0a60      	lsrs	r0, r4, #9
   26ab4:	4318      	orrs	r0, r3
   26ab6:	bd10      	pop	{r4, pc}
   26ab8:	2b99      	cmp	r3, #153	; 0x99
   26aba:	dc17      	bgt.n	26aec <__aeabi_ui2f+0x5c>
   26abc:	2299      	movs	r2, #153	; 0x99
   26abe:	1ad2      	subs	r2, r2, r3
   26ac0:	2a00      	cmp	r2, #0
   26ac2:	dd27      	ble.n	26b14 <__aeabi_ui2f+0x84>
   26ac4:	4094      	lsls	r4, r2
   26ac6:	0022      	movs	r2, r4
   26ac8:	4c13      	ldr	r4, [pc, #76]	; (26b18 <__aeabi_ui2f+0x88>)
   26aca:	4014      	ands	r4, r2
   26acc:	0751      	lsls	r1, r2, #29
   26ace:	d004      	beq.n	26ada <__aeabi_ui2f+0x4a>
   26ad0:	210f      	movs	r1, #15
   26ad2:	400a      	ands	r2, r1
   26ad4:	2a04      	cmp	r2, #4
   26ad6:	d000      	beq.n	26ada <__aeabi_ui2f+0x4a>
   26ad8:	3404      	adds	r4, #4
   26ada:	0162      	lsls	r2, r4, #5
   26adc:	d412      	bmi.n	26b04 <__aeabi_ui2f+0x74>
   26ade:	01a4      	lsls	r4, r4, #6
   26ae0:	0a64      	lsrs	r4, r4, #9
   26ae2:	b2db      	uxtb	r3, r3
   26ae4:	e7e3      	b.n	26aae <__aeabi_ui2f+0x1e>
   26ae6:	2300      	movs	r3, #0
   26ae8:	2400      	movs	r4, #0
   26aea:	e7e0      	b.n	26aae <__aeabi_ui2f+0x1e>
   26aec:	22b9      	movs	r2, #185	; 0xb9
   26aee:	0021      	movs	r1, r4
   26af0:	1ad2      	subs	r2, r2, r3
   26af2:	4091      	lsls	r1, r2
   26af4:	000a      	movs	r2, r1
   26af6:	1e51      	subs	r1, r2, #1
   26af8:	418a      	sbcs	r2, r1
   26afa:	2105      	movs	r1, #5
   26afc:	1a09      	subs	r1, r1, r0
   26afe:	40cc      	lsrs	r4, r1
   26b00:	4314      	orrs	r4, r2
   26b02:	e7db      	b.n	26abc <__aeabi_ui2f+0x2c>
   26b04:	4b04      	ldr	r3, [pc, #16]	; (26b18 <__aeabi_ui2f+0x88>)
   26b06:	401c      	ands	r4, r3
   26b08:	239f      	movs	r3, #159	; 0x9f
   26b0a:	01a4      	lsls	r4, r4, #6
   26b0c:	1a1b      	subs	r3, r3, r0
   26b0e:	0a64      	lsrs	r4, r4, #9
   26b10:	b2db      	uxtb	r3, r3
   26b12:	e7cc      	b.n	26aae <__aeabi_ui2f+0x1e>
   26b14:	0022      	movs	r2, r4
   26b16:	e7d7      	b.n	26ac8 <__aeabi_ui2f+0x38>
   26b18:	fbffffff 	.word	0xfbffffff

00026b1c <__aeabi_dadd>:
   26b1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   26b1e:	4645      	mov	r5, r8
   26b20:	46de      	mov	lr, fp
   26b22:	4657      	mov	r7, sl
   26b24:	464e      	mov	r6, r9
   26b26:	030c      	lsls	r4, r1, #12
   26b28:	b5e0      	push	{r5, r6, r7, lr}
   26b2a:	004e      	lsls	r6, r1, #1
   26b2c:	0fc9      	lsrs	r1, r1, #31
   26b2e:	4688      	mov	r8, r1
   26b30:	000d      	movs	r5, r1
   26b32:	0a61      	lsrs	r1, r4, #9
   26b34:	0f44      	lsrs	r4, r0, #29
   26b36:	430c      	orrs	r4, r1
   26b38:	00c7      	lsls	r7, r0, #3
   26b3a:	0319      	lsls	r1, r3, #12
   26b3c:	0058      	lsls	r0, r3, #1
   26b3e:	0fdb      	lsrs	r3, r3, #31
   26b40:	469b      	mov	fp, r3
   26b42:	0a4b      	lsrs	r3, r1, #9
   26b44:	0f51      	lsrs	r1, r2, #29
   26b46:	430b      	orrs	r3, r1
   26b48:	0d76      	lsrs	r6, r6, #21
   26b4a:	0d40      	lsrs	r0, r0, #21
   26b4c:	0019      	movs	r1, r3
   26b4e:	00d2      	lsls	r2, r2, #3
   26b50:	45d8      	cmp	r8, fp
   26b52:	d100      	bne.n	26b56 <__aeabi_dadd+0x3a>
   26b54:	e0ae      	b.n	26cb4 <__aeabi_dadd+0x198>
   26b56:	1a35      	subs	r5, r6, r0
   26b58:	2d00      	cmp	r5, #0
   26b5a:	dc00      	bgt.n	26b5e <__aeabi_dadd+0x42>
   26b5c:	e0f6      	b.n	26d4c <__aeabi_dadd+0x230>
   26b5e:	2800      	cmp	r0, #0
   26b60:	d10f      	bne.n	26b82 <__aeabi_dadd+0x66>
   26b62:	4313      	orrs	r3, r2
   26b64:	d100      	bne.n	26b68 <__aeabi_dadd+0x4c>
   26b66:	e0db      	b.n	26d20 <__aeabi_dadd+0x204>
   26b68:	1e6b      	subs	r3, r5, #1
   26b6a:	2b00      	cmp	r3, #0
   26b6c:	d000      	beq.n	26b70 <__aeabi_dadd+0x54>
   26b6e:	e137      	b.n	26de0 <__aeabi_dadd+0x2c4>
   26b70:	1aba      	subs	r2, r7, r2
   26b72:	4297      	cmp	r7, r2
   26b74:	41bf      	sbcs	r7, r7
   26b76:	1a64      	subs	r4, r4, r1
   26b78:	427f      	negs	r7, r7
   26b7a:	1be4      	subs	r4, r4, r7
   26b7c:	2601      	movs	r6, #1
   26b7e:	0017      	movs	r7, r2
   26b80:	e024      	b.n	26bcc <__aeabi_dadd+0xb0>
   26b82:	4bc6      	ldr	r3, [pc, #792]	; (26e9c <__aeabi_dadd+0x380>)
   26b84:	429e      	cmp	r6, r3
   26b86:	d04d      	beq.n	26c24 <__aeabi_dadd+0x108>
   26b88:	2380      	movs	r3, #128	; 0x80
   26b8a:	041b      	lsls	r3, r3, #16
   26b8c:	4319      	orrs	r1, r3
   26b8e:	2d38      	cmp	r5, #56	; 0x38
   26b90:	dd00      	ble.n	26b94 <__aeabi_dadd+0x78>
   26b92:	e107      	b.n	26da4 <__aeabi_dadd+0x288>
   26b94:	2d1f      	cmp	r5, #31
   26b96:	dd00      	ble.n	26b9a <__aeabi_dadd+0x7e>
   26b98:	e138      	b.n	26e0c <__aeabi_dadd+0x2f0>
   26b9a:	2020      	movs	r0, #32
   26b9c:	1b43      	subs	r3, r0, r5
   26b9e:	469a      	mov	sl, r3
   26ba0:	000b      	movs	r3, r1
   26ba2:	4650      	mov	r0, sl
   26ba4:	4083      	lsls	r3, r0
   26ba6:	4699      	mov	r9, r3
   26ba8:	0013      	movs	r3, r2
   26baa:	4648      	mov	r0, r9
   26bac:	40eb      	lsrs	r3, r5
   26bae:	4318      	orrs	r0, r3
   26bb0:	0003      	movs	r3, r0
   26bb2:	4650      	mov	r0, sl
   26bb4:	4082      	lsls	r2, r0
   26bb6:	1e50      	subs	r0, r2, #1
   26bb8:	4182      	sbcs	r2, r0
   26bba:	40e9      	lsrs	r1, r5
   26bbc:	431a      	orrs	r2, r3
   26bbe:	1aba      	subs	r2, r7, r2
   26bc0:	1a61      	subs	r1, r4, r1
   26bc2:	4297      	cmp	r7, r2
   26bc4:	41a4      	sbcs	r4, r4
   26bc6:	0017      	movs	r7, r2
   26bc8:	4264      	negs	r4, r4
   26bca:	1b0c      	subs	r4, r1, r4
   26bcc:	0223      	lsls	r3, r4, #8
   26bce:	d562      	bpl.n	26c96 <__aeabi_dadd+0x17a>
   26bd0:	0264      	lsls	r4, r4, #9
   26bd2:	0a65      	lsrs	r5, r4, #9
   26bd4:	2d00      	cmp	r5, #0
   26bd6:	d100      	bne.n	26bda <__aeabi_dadd+0xbe>
   26bd8:	e0df      	b.n	26d9a <__aeabi_dadd+0x27e>
   26bda:	0028      	movs	r0, r5
   26bdc:	f001 fd98 	bl	28710 <__clzsi2>
   26be0:	0003      	movs	r3, r0
   26be2:	3b08      	subs	r3, #8
   26be4:	2b1f      	cmp	r3, #31
   26be6:	dd00      	ble.n	26bea <__aeabi_dadd+0xce>
   26be8:	e0d2      	b.n	26d90 <__aeabi_dadd+0x274>
   26bea:	2220      	movs	r2, #32
   26bec:	003c      	movs	r4, r7
   26bee:	1ad2      	subs	r2, r2, r3
   26bf0:	409d      	lsls	r5, r3
   26bf2:	40d4      	lsrs	r4, r2
   26bf4:	409f      	lsls	r7, r3
   26bf6:	4325      	orrs	r5, r4
   26bf8:	429e      	cmp	r6, r3
   26bfa:	dd00      	ble.n	26bfe <__aeabi_dadd+0xe2>
   26bfc:	e0c4      	b.n	26d88 <__aeabi_dadd+0x26c>
   26bfe:	1b9e      	subs	r6, r3, r6
   26c00:	1c73      	adds	r3, r6, #1
   26c02:	2b1f      	cmp	r3, #31
   26c04:	dd00      	ble.n	26c08 <__aeabi_dadd+0xec>
   26c06:	e0f1      	b.n	26dec <__aeabi_dadd+0x2d0>
   26c08:	2220      	movs	r2, #32
   26c0a:	0038      	movs	r0, r7
   26c0c:	0029      	movs	r1, r5
   26c0e:	1ad2      	subs	r2, r2, r3
   26c10:	40d8      	lsrs	r0, r3
   26c12:	4091      	lsls	r1, r2
   26c14:	4097      	lsls	r7, r2
   26c16:	002c      	movs	r4, r5
   26c18:	4301      	orrs	r1, r0
   26c1a:	1e78      	subs	r0, r7, #1
   26c1c:	4187      	sbcs	r7, r0
   26c1e:	40dc      	lsrs	r4, r3
   26c20:	2600      	movs	r6, #0
   26c22:	430f      	orrs	r7, r1
   26c24:	077b      	lsls	r3, r7, #29
   26c26:	d009      	beq.n	26c3c <__aeabi_dadd+0x120>
   26c28:	230f      	movs	r3, #15
   26c2a:	403b      	ands	r3, r7
   26c2c:	2b04      	cmp	r3, #4
   26c2e:	d005      	beq.n	26c3c <__aeabi_dadd+0x120>
   26c30:	1d3b      	adds	r3, r7, #4
   26c32:	42bb      	cmp	r3, r7
   26c34:	41bf      	sbcs	r7, r7
   26c36:	427f      	negs	r7, r7
   26c38:	19e4      	adds	r4, r4, r7
   26c3a:	001f      	movs	r7, r3
   26c3c:	0223      	lsls	r3, r4, #8
   26c3e:	d52c      	bpl.n	26c9a <__aeabi_dadd+0x17e>
   26c40:	4b96      	ldr	r3, [pc, #600]	; (26e9c <__aeabi_dadd+0x380>)
   26c42:	3601      	adds	r6, #1
   26c44:	429e      	cmp	r6, r3
   26c46:	d100      	bne.n	26c4a <__aeabi_dadd+0x12e>
   26c48:	e09a      	b.n	26d80 <__aeabi_dadd+0x264>
   26c4a:	4645      	mov	r5, r8
   26c4c:	4b94      	ldr	r3, [pc, #592]	; (26ea0 <__aeabi_dadd+0x384>)
   26c4e:	08ff      	lsrs	r7, r7, #3
   26c50:	401c      	ands	r4, r3
   26c52:	0760      	lsls	r0, r4, #29
   26c54:	0576      	lsls	r6, r6, #21
   26c56:	0264      	lsls	r4, r4, #9
   26c58:	4307      	orrs	r7, r0
   26c5a:	0b24      	lsrs	r4, r4, #12
   26c5c:	0d76      	lsrs	r6, r6, #21
   26c5e:	2100      	movs	r1, #0
   26c60:	0324      	lsls	r4, r4, #12
   26c62:	0b23      	lsrs	r3, r4, #12
   26c64:	0d0c      	lsrs	r4, r1, #20
   26c66:	4a8f      	ldr	r2, [pc, #572]	; (26ea4 <__aeabi_dadd+0x388>)
   26c68:	0524      	lsls	r4, r4, #20
   26c6a:	431c      	orrs	r4, r3
   26c6c:	4014      	ands	r4, r2
   26c6e:	0533      	lsls	r3, r6, #20
   26c70:	4323      	orrs	r3, r4
   26c72:	005b      	lsls	r3, r3, #1
   26c74:	07ed      	lsls	r5, r5, #31
   26c76:	085b      	lsrs	r3, r3, #1
   26c78:	432b      	orrs	r3, r5
   26c7a:	0038      	movs	r0, r7
   26c7c:	0019      	movs	r1, r3
   26c7e:	bc3c      	pop	{r2, r3, r4, r5}
   26c80:	4690      	mov	r8, r2
   26c82:	4699      	mov	r9, r3
   26c84:	46a2      	mov	sl, r4
   26c86:	46ab      	mov	fp, r5
   26c88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   26c8a:	4664      	mov	r4, ip
   26c8c:	4304      	orrs	r4, r0
   26c8e:	d100      	bne.n	26c92 <__aeabi_dadd+0x176>
   26c90:	e211      	b.n	270b6 <__aeabi_dadd+0x59a>
   26c92:	0004      	movs	r4, r0
   26c94:	4667      	mov	r7, ip
   26c96:	077b      	lsls	r3, r7, #29
   26c98:	d1c6      	bne.n	26c28 <__aeabi_dadd+0x10c>
   26c9a:	4645      	mov	r5, r8
   26c9c:	0760      	lsls	r0, r4, #29
   26c9e:	08ff      	lsrs	r7, r7, #3
   26ca0:	4307      	orrs	r7, r0
   26ca2:	08e4      	lsrs	r4, r4, #3
   26ca4:	4b7d      	ldr	r3, [pc, #500]	; (26e9c <__aeabi_dadd+0x380>)
   26ca6:	429e      	cmp	r6, r3
   26ca8:	d030      	beq.n	26d0c <__aeabi_dadd+0x1f0>
   26caa:	0324      	lsls	r4, r4, #12
   26cac:	0576      	lsls	r6, r6, #21
   26cae:	0b24      	lsrs	r4, r4, #12
   26cb0:	0d76      	lsrs	r6, r6, #21
   26cb2:	e7d4      	b.n	26c5e <__aeabi_dadd+0x142>
   26cb4:	1a33      	subs	r3, r6, r0
   26cb6:	469a      	mov	sl, r3
   26cb8:	2b00      	cmp	r3, #0
   26cba:	dd78      	ble.n	26dae <__aeabi_dadd+0x292>
   26cbc:	2800      	cmp	r0, #0
   26cbe:	d031      	beq.n	26d24 <__aeabi_dadd+0x208>
   26cc0:	4876      	ldr	r0, [pc, #472]	; (26e9c <__aeabi_dadd+0x380>)
   26cc2:	4286      	cmp	r6, r0
   26cc4:	d0ae      	beq.n	26c24 <__aeabi_dadd+0x108>
   26cc6:	2080      	movs	r0, #128	; 0x80
   26cc8:	0400      	lsls	r0, r0, #16
   26cca:	4301      	orrs	r1, r0
   26ccc:	4653      	mov	r3, sl
   26cce:	2b38      	cmp	r3, #56	; 0x38
   26cd0:	dc00      	bgt.n	26cd4 <__aeabi_dadd+0x1b8>
   26cd2:	e0e9      	b.n	26ea8 <__aeabi_dadd+0x38c>
   26cd4:	430a      	orrs	r2, r1
   26cd6:	1e51      	subs	r1, r2, #1
   26cd8:	418a      	sbcs	r2, r1
   26cda:	2100      	movs	r1, #0
   26cdc:	19d2      	adds	r2, r2, r7
   26cde:	42ba      	cmp	r2, r7
   26ce0:	41bf      	sbcs	r7, r7
   26ce2:	1909      	adds	r1, r1, r4
   26ce4:	427c      	negs	r4, r7
   26ce6:	0017      	movs	r7, r2
   26ce8:	190c      	adds	r4, r1, r4
   26cea:	0223      	lsls	r3, r4, #8
   26cec:	d5d3      	bpl.n	26c96 <__aeabi_dadd+0x17a>
   26cee:	4b6b      	ldr	r3, [pc, #428]	; (26e9c <__aeabi_dadd+0x380>)
   26cf0:	3601      	adds	r6, #1
   26cf2:	429e      	cmp	r6, r3
   26cf4:	d100      	bne.n	26cf8 <__aeabi_dadd+0x1dc>
   26cf6:	e13a      	b.n	26f6e <__aeabi_dadd+0x452>
   26cf8:	2001      	movs	r0, #1
   26cfa:	4b69      	ldr	r3, [pc, #420]	; (26ea0 <__aeabi_dadd+0x384>)
   26cfc:	401c      	ands	r4, r3
   26cfe:	087b      	lsrs	r3, r7, #1
   26d00:	4007      	ands	r7, r0
   26d02:	431f      	orrs	r7, r3
   26d04:	07e0      	lsls	r0, r4, #31
   26d06:	4307      	orrs	r7, r0
   26d08:	0864      	lsrs	r4, r4, #1
   26d0a:	e78b      	b.n	26c24 <__aeabi_dadd+0x108>
   26d0c:	0023      	movs	r3, r4
   26d0e:	433b      	orrs	r3, r7
   26d10:	d100      	bne.n	26d14 <__aeabi_dadd+0x1f8>
   26d12:	e1cb      	b.n	270ac <__aeabi_dadd+0x590>
   26d14:	2280      	movs	r2, #128	; 0x80
   26d16:	0312      	lsls	r2, r2, #12
   26d18:	4314      	orrs	r4, r2
   26d1a:	0324      	lsls	r4, r4, #12
   26d1c:	0b24      	lsrs	r4, r4, #12
   26d1e:	e79e      	b.n	26c5e <__aeabi_dadd+0x142>
   26d20:	002e      	movs	r6, r5
   26d22:	e77f      	b.n	26c24 <__aeabi_dadd+0x108>
   26d24:	0008      	movs	r0, r1
   26d26:	4310      	orrs	r0, r2
   26d28:	d100      	bne.n	26d2c <__aeabi_dadd+0x210>
   26d2a:	e0b4      	b.n	26e96 <__aeabi_dadd+0x37a>
   26d2c:	1e58      	subs	r0, r3, #1
   26d2e:	2800      	cmp	r0, #0
   26d30:	d000      	beq.n	26d34 <__aeabi_dadd+0x218>
   26d32:	e0de      	b.n	26ef2 <__aeabi_dadd+0x3d6>
   26d34:	18ba      	adds	r2, r7, r2
   26d36:	42ba      	cmp	r2, r7
   26d38:	419b      	sbcs	r3, r3
   26d3a:	1864      	adds	r4, r4, r1
   26d3c:	425b      	negs	r3, r3
   26d3e:	18e4      	adds	r4, r4, r3
   26d40:	0017      	movs	r7, r2
   26d42:	2601      	movs	r6, #1
   26d44:	0223      	lsls	r3, r4, #8
   26d46:	d5a6      	bpl.n	26c96 <__aeabi_dadd+0x17a>
   26d48:	2602      	movs	r6, #2
   26d4a:	e7d5      	b.n	26cf8 <__aeabi_dadd+0x1dc>
   26d4c:	2d00      	cmp	r5, #0
   26d4e:	d16e      	bne.n	26e2e <__aeabi_dadd+0x312>
   26d50:	1c70      	adds	r0, r6, #1
   26d52:	0540      	lsls	r0, r0, #21
   26d54:	0d40      	lsrs	r0, r0, #21
   26d56:	2801      	cmp	r0, #1
   26d58:	dc00      	bgt.n	26d5c <__aeabi_dadd+0x240>
   26d5a:	e0f9      	b.n	26f50 <__aeabi_dadd+0x434>
   26d5c:	1ab8      	subs	r0, r7, r2
   26d5e:	4684      	mov	ip, r0
   26d60:	4287      	cmp	r7, r0
   26d62:	4180      	sbcs	r0, r0
   26d64:	1ae5      	subs	r5, r4, r3
   26d66:	4240      	negs	r0, r0
   26d68:	1a2d      	subs	r5, r5, r0
   26d6a:	0228      	lsls	r0, r5, #8
   26d6c:	d400      	bmi.n	26d70 <__aeabi_dadd+0x254>
   26d6e:	e089      	b.n	26e84 <__aeabi_dadd+0x368>
   26d70:	1bd7      	subs	r7, r2, r7
   26d72:	42ba      	cmp	r2, r7
   26d74:	4192      	sbcs	r2, r2
   26d76:	1b1c      	subs	r4, r3, r4
   26d78:	4252      	negs	r2, r2
   26d7a:	1aa5      	subs	r5, r4, r2
   26d7c:	46d8      	mov	r8, fp
   26d7e:	e729      	b.n	26bd4 <__aeabi_dadd+0xb8>
   26d80:	4645      	mov	r5, r8
   26d82:	2400      	movs	r4, #0
   26d84:	2700      	movs	r7, #0
   26d86:	e76a      	b.n	26c5e <__aeabi_dadd+0x142>
   26d88:	4c45      	ldr	r4, [pc, #276]	; (26ea0 <__aeabi_dadd+0x384>)
   26d8a:	1af6      	subs	r6, r6, r3
   26d8c:	402c      	ands	r4, r5
   26d8e:	e749      	b.n	26c24 <__aeabi_dadd+0x108>
   26d90:	003d      	movs	r5, r7
   26d92:	3828      	subs	r0, #40	; 0x28
   26d94:	4085      	lsls	r5, r0
   26d96:	2700      	movs	r7, #0
   26d98:	e72e      	b.n	26bf8 <__aeabi_dadd+0xdc>
   26d9a:	0038      	movs	r0, r7
   26d9c:	f001 fcb8 	bl	28710 <__clzsi2>
   26da0:	3020      	adds	r0, #32
   26da2:	e71d      	b.n	26be0 <__aeabi_dadd+0xc4>
   26da4:	430a      	orrs	r2, r1
   26da6:	1e51      	subs	r1, r2, #1
   26da8:	418a      	sbcs	r2, r1
   26daa:	2100      	movs	r1, #0
   26dac:	e707      	b.n	26bbe <__aeabi_dadd+0xa2>
   26dae:	2b00      	cmp	r3, #0
   26db0:	d000      	beq.n	26db4 <__aeabi_dadd+0x298>
   26db2:	e0f3      	b.n	26f9c <__aeabi_dadd+0x480>
   26db4:	1c70      	adds	r0, r6, #1
   26db6:	0543      	lsls	r3, r0, #21
   26db8:	0d5b      	lsrs	r3, r3, #21
   26dba:	2b01      	cmp	r3, #1
   26dbc:	dc00      	bgt.n	26dc0 <__aeabi_dadd+0x2a4>
   26dbe:	e0ad      	b.n	26f1c <__aeabi_dadd+0x400>
   26dc0:	4b36      	ldr	r3, [pc, #216]	; (26e9c <__aeabi_dadd+0x380>)
   26dc2:	4298      	cmp	r0, r3
   26dc4:	d100      	bne.n	26dc8 <__aeabi_dadd+0x2ac>
   26dc6:	e0d1      	b.n	26f6c <__aeabi_dadd+0x450>
   26dc8:	18ba      	adds	r2, r7, r2
   26dca:	42ba      	cmp	r2, r7
   26dcc:	41bf      	sbcs	r7, r7
   26dce:	1864      	adds	r4, r4, r1
   26dd0:	427f      	negs	r7, r7
   26dd2:	19e4      	adds	r4, r4, r7
   26dd4:	07e7      	lsls	r7, r4, #31
   26dd6:	0852      	lsrs	r2, r2, #1
   26dd8:	4317      	orrs	r7, r2
   26dda:	0864      	lsrs	r4, r4, #1
   26ddc:	0006      	movs	r6, r0
   26dde:	e721      	b.n	26c24 <__aeabi_dadd+0x108>
   26de0:	482e      	ldr	r0, [pc, #184]	; (26e9c <__aeabi_dadd+0x380>)
   26de2:	4285      	cmp	r5, r0
   26de4:	d100      	bne.n	26de8 <__aeabi_dadd+0x2cc>
   26de6:	e093      	b.n	26f10 <__aeabi_dadd+0x3f4>
   26de8:	001d      	movs	r5, r3
   26dea:	e6d0      	b.n	26b8e <__aeabi_dadd+0x72>
   26dec:	0029      	movs	r1, r5
   26dee:	3e1f      	subs	r6, #31
   26df0:	40f1      	lsrs	r1, r6
   26df2:	2b20      	cmp	r3, #32
   26df4:	d100      	bne.n	26df8 <__aeabi_dadd+0x2dc>
   26df6:	e08d      	b.n	26f14 <__aeabi_dadd+0x3f8>
   26df8:	2240      	movs	r2, #64	; 0x40
   26dfa:	1ad3      	subs	r3, r2, r3
   26dfc:	409d      	lsls	r5, r3
   26dfe:	432f      	orrs	r7, r5
   26e00:	1e7d      	subs	r5, r7, #1
   26e02:	41af      	sbcs	r7, r5
   26e04:	2400      	movs	r4, #0
   26e06:	430f      	orrs	r7, r1
   26e08:	2600      	movs	r6, #0
   26e0a:	e744      	b.n	26c96 <__aeabi_dadd+0x17a>
   26e0c:	002b      	movs	r3, r5
   26e0e:	0008      	movs	r0, r1
   26e10:	3b20      	subs	r3, #32
   26e12:	40d8      	lsrs	r0, r3
   26e14:	0003      	movs	r3, r0
   26e16:	2d20      	cmp	r5, #32
   26e18:	d100      	bne.n	26e1c <__aeabi_dadd+0x300>
   26e1a:	e07d      	b.n	26f18 <__aeabi_dadd+0x3fc>
   26e1c:	2040      	movs	r0, #64	; 0x40
   26e1e:	1b45      	subs	r5, r0, r5
   26e20:	40a9      	lsls	r1, r5
   26e22:	430a      	orrs	r2, r1
   26e24:	1e51      	subs	r1, r2, #1
   26e26:	418a      	sbcs	r2, r1
   26e28:	2100      	movs	r1, #0
   26e2a:	431a      	orrs	r2, r3
   26e2c:	e6c7      	b.n	26bbe <__aeabi_dadd+0xa2>
   26e2e:	2e00      	cmp	r6, #0
   26e30:	d050      	beq.n	26ed4 <__aeabi_dadd+0x3b8>
   26e32:	4e1a      	ldr	r6, [pc, #104]	; (26e9c <__aeabi_dadd+0x380>)
   26e34:	42b0      	cmp	r0, r6
   26e36:	d057      	beq.n	26ee8 <__aeabi_dadd+0x3cc>
   26e38:	2680      	movs	r6, #128	; 0x80
   26e3a:	426b      	negs	r3, r5
   26e3c:	4699      	mov	r9, r3
   26e3e:	0436      	lsls	r6, r6, #16
   26e40:	4334      	orrs	r4, r6
   26e42:	464b      	mov	r3, r9
   26e44:	2b38      	cmp	r3, #56	; 0x38
   26e46:	dd00      	ble.n	26e4a <__aeabi_dadd+0x32e>
   26e48:	e0d6      	b.n	26ff8 <__aeabi_dadd+0x4dc>
   26e4a:	2b1f      	cmp	r3, #31
   26e4c:	dd00      	ble.n	26e50 <__aeabi_dadd+0x334>
   26e4e:	e135      	b.n	270bc <__aeabi_dadd+0x5a0>
   26e50:	2620      	movs	r6, #32
   26e52:	1af5      	subs	r5, r6, r3
   26e54:	0026      	movs	r6, r4
   26e56:	40ae      	lsls	r6, r5
   26e58:	46b2      	mov	sl, r6
   26e5a:	003e      	movs	r6, r7
   26e5c:	40de      	lsrs	r6, r3
   26e5e:	46ac      	mov	ip, r5
   26e60:	0035      	movs	r5, r6
   26e62:	4656      	mov	r6, sl
   26e64:	432e      	orrs	r6, r5
   26e66:	4665      	mov	r5, ip
   26e68:	40af      	lsls	r7, r5
   26e6a:	1e7d      	subs	r5, r7, #1
   26e6c:	41af      	sbcs	r7, r5
   26e6e:	40dc      	lsrs	r4, r3
   26e70:	4337      	orrs	r7, r6
   26e72:	1bd7      	subs	r7, r2, r7
   26e74:	42ba      	cmp	r2, r7
   26e76:	4192      	sbcs	r2, r2
   26e78:	1b0c      	subs	r4, r1, r4
   26e7a:	4252      	negs	r2, r2
   26e7c:	1aa4      	subs	r4, r4, r2
   26e7e:	0006      	movs	r6, r0
   26e80:	46d8      	mov	r8, fp
   26e82:	e6a3      	b.n	26bcc <__aeabi_dadd+0xb0>
   26e84:	4664      	mov	r4, ip
   26e86:	4667      	mov	r7, ip
   26e88:	432c      	orrs	r4, r5
   26e8a:	d000      	beq.n	26e8e <__aeabi_dadd+0x372>
   26e8c:	e6a2      	b.n	26bd4 <__aeabi_dadd+0xb8>
   26e8e:	2500      	movs	r5, #0
   26e90:	2600      	movs	r6, #0
   26e92:	2700      	movs	r7, #0
   26e94:	e706      	b.n	26ca4 <__aeabi_dadd+0x188>
   26e96:	001e      	movs	r6, r3
   26e98:	e6c4      	b.n	26c24 <__aeabi_dadd+0x108>
   26e9a:	46c0      	nop			; (mov r8, r8)
   26e9c:	000007ff 	.word	0x000007ff
   26ea0:	ff7fffff 	.word	0xff7fffff
   26ea4:	800fffff 	.word	0x800fffff
   26ea8:	2b1f      	cmp	r3, #31
   26eaa:	dc63      	bgt.n	26f74 <__aeabi_dadd+0x458>
   26eac:	2020      	movs	r0, #32
   26eae:	1ac3      	subs	r3, r0, r3
   26eb0:	0008      	movs	r0, r1
   26eb2:	4098      	lsls	r0, r3
   26eb4:	469c      	mov	ip, r3
   26eb6:	4683      	mov	fp, r0
   26eb8:	4653      	mov	r3, sl
   26eba:	0010      	movs	r0, r2
   26ebc:	40d8      	lsrs	r0, r3
   26ebe:	0003      	movs	r3, r0
   26ec0:	4658      	mov	r0, fp
   26ec2:	4318      	orrs	r0, r3
   26ec4:	4663      	mov	r3, ip
   26ec6:	409a      	lsls	r2, r3
   26ec8:	1e53      	subs	r3, r2, #1
   26eca:	419a      	sbcs	r2, r3
   26ecc:	4653      	mov	r3, sl
   26ece:	4302      	orrs	r2, r0
   26ed0:	40d9      	lsrs	r1, r3
   26ed2:	e703      	b.n	26cdc <__aeabi_dadd+0x1c0>
   26ed4:	0026      	movs	r6, r4
   26ed6:	433e      	orrs	r6, r7
   26ed8:	d006      	beq.n	26ee8 <__aeabi_dadd+0x3cc>
   26eda:	43eb      	mvns	r3, r5
   26edc:	4699      	mov	r9, r3
   26ede:	2b00      	cmp	r3, #0
   26ee0:	d0c7      	beq.n	26e72 <__aeabi_dadd+0x356>
   26ee2:	4e94      	ldr	r6, [pc, #592]	; (27134 <__aeabi_dadd+0x618>)
   26ee4:	42b0      	cmp	r0, r6
   26ee6:	d1ac      	bne.n	26e42 <__aeabi_dadd+0x326>
   26ee8:	000c      	movs	r4, r1
   26eea:	0017      	movs	r7, r2
   26eec:	0006      	movs	r6, r0
   26eee:	46d8      	mov	r8, fp
   26ef0:	e698      	b.n	26c24 <__aeabi_dadd+0x108>
   26ef2:	4b90      	ldr	r3, [pc, #576]	; (27134 <__aeabi_dadd+0x618>)
   26ef4:	459a      	cmp	sl, r3
   26ef6:	d00b      	beq.n	26f10 <__aeabi_dadd+0x3f4>
   26ef8:	4682      	mov	sl, r0
   26efa:	e6e7      	b.n	26ccc <__aeabi_dadd+0x1b0>
   26efc:	2800      	cmp	r0, #0
   26efe:	d000      	beq.n	26f02 <__aeabi_dadd+0x3e6>
   26f00:	e09e      	b.n	27040 <__aeabi_dadd+0x524>
   26f02:	0018      	movs	r0, r3
   26f04:	4310      	orrs	r0, r2
   26f06:	d100      	bne.n	26f0a <__aeabi_dadd+0x3ee>
   26f08:	e0e9      	b.n	270de <__aeabi_dadd+0x5c2>
   26f0a:	001c      	movs	r4, r3
   26f0c:	0017      	movs	r7, r2
   26f0e:	46d8      	mov	r8, fp
   26f10:	4e88      	ldr	r6, [pc, #544]	; (27134 <__aeabi_dadd+0x618>)
   26f12:	e687      	b.n	26c24 <__aeabi_dadd+0x108>
   26f14:	2500      	movs	r5, #0
   26f16:	e772      	b.n	26dfe <__aeabi_dadd+0x2e2>
   26f18:	2100      	movs	r1, #0
   26f1a:	e782      	b.n	26e22 <__aeabi_dadd+0x306>
   26f1c:	0023      	movs	r3, r4
   26f1e:	433b      	orrs	r3, r7
   26f20:	2e00      	cmp	r6, #0
   26f22:	d000      	beq.n	26f26 <__aeabi_dadd+0x40a>
   26f24:	e0ab      	b.n	2707e <__aeabi_dadd+0x562>
   26f26:	2b00      	cmp	r3, #0
   26f28:	d100      	bne.n	26f2c <__aeabi_dadd+0x410>
   26f2a:	e0e7      	b.n	270fc <__aeabi_dadd+0x5e0>
   26f2c:	000b      	movs	r3, r1
   26f2e:	4313      	orrs	r3, r2
   26f30:	d100      	bne.n	26f34 <__aeabi_dadd+0x418>
   26f32:	e677      	b.n	26c24 <__aeabi_dadd+0x108>
   26f34:	18ba      	adds	r2, r7, r2
   26f36:	42ba      	cmp	r2, r7
   26f38:	41bf      	sbcs	r7, r7
   26f3a:	1864      	adds	r4, r4, r1
   26f3c:	427f      	negs	r7, r7
   26f3e:	19e4      	adds	r4, r4, r7
   26f40:	0223      	lsls	r3, r4, #8
   26f42:	d400      	bmi.n	26f46 <__aeabi_dadd+0x42a>
   26f44:	e0f2      	b.n	2712c <__aeabi_dadd+0x610>
   26f46:	4b7c      	ldr	r3, [pc, #496]	; (27138 <__aeabi_dadd+0x61c>)
   26f48:	0017      	movs	r7, r2
   26f4a:	401c      	ands	r4, r3
   26f4c:	0006      	movs	r6, r0
   26f4e:	e669      	b.n	26c24 <__aeabi_dadd+0x108>
   26f50:	0020      	movs	r0, r4
   26f52:	4338      	orrs	r0, r7
   26f54:	2e00      	cmp	r6, #0
   26f56:	d1d1      	bne.n	26efc <__aeabi_dadd+0x3e0>
   26f58:	2800      	cmp	r0, #0
   26f5a:	d15b      	bne.n	27014 <__aeabi_dadd+0x4f8>
   26f5c:	001c      	movs	r4, r3
   26f5e:	4314      	orrs	r4, r2
   26f60:	d100      	bne.n	26f64 <__aeabi_dadd+0x448>
   26f62:	e0a8      	b.n	270b6 <__aeabi_dadd+0x59a>
   26f64:	001c      	movs	r4, r3
   26f66:	0017      	movs	r7, r2
   26f68:	46d8      	mov	r8, fp
   26f6a:	e65b      	b.n	26c24 <__aeabi_dadd+0x108>
   26f6c:	0006      	movs	r6, r0
   26f6e:	2400      	movs	r4, #0
   26f70:	2700      	movs	r7, #0
   26f72:	e697      	b.n	26ca4 <__aeabi_dadd+0x188>
   26f74:	4650      	mov	r0, sl
   26f76:	000b      	movs	r3, r1
   26f78:	3820      	subs	r0, #32
   26f7a:	40c3      	lsrs	r3, r0
   26f7c:	4699      	mov	r9, r3
   26f7e:	4653      	mov	r3, sl
   26f80:	2b20      	cmp	r3, #32
   26f82:	d100      	bne.n	26f86 <__aeabi_dadd+0x46a>
   26f84:	e095      	b.n	270b2 <__aeabi_dadd+0x596>
   26f86:	2340      	movs	r3, #64	; 0x40
   26f88:	4650      	mov	r0, sl
   26f8a:	1a1b      	subs	r3, r3, r0
   26f8c:	4099      	lsls	r1, r3
   26f8e:	430a      	orrs	r2, r1
   26f90:	1e51      	subs	r1, r2, #1
   26f92:	418a      	sbcs	r2, r1
   26f94:	464b      	mov	r3, r9
   26f96:	2100      	movs	r1, #0
   26f98:	431a      	orrs	r2, r3
   26f9a:	e69f      	b.n	26cdc <__aeabi_dadd+0x1c0>
   26f9c:	2e00      	cmp	r6, #0
   26f9e:	d130      	bne.n	27002 <__aeabi_dadd+0x4e6>
   26fa0:	0026      	movs	r6, r4
   26fa2:	433e      	orrs	r6, r7
   26fa4:	d067      	beq.n	27076 <__aeabi_dadd+0x55a>
   26fa6:	43db      	mvns	r3, r3
   26fa8:	469a      	mov	sl, r3
   26faa:	2b00      	cmp	r3, #0
   26fac:	d01c      	beq.n	26fe8 <__aeabi_dadd+0x4cc>
   26fae:	4e61      	ldr	r6, [pc, #388]	; (27134 <__aeabi_dadd+0x618>)
   26fb0:	42b0      	cmp	r0, r6
   26fb2:	d060      	beq.n	27076 <__aeabi_dadd+0x55a>
   26fb4:	4653      	mov	r3, sl
   26fb6:	2b38      	cmp	r3, #56	; 0x38
   26fb8:	dd00      	ble.n	26fbc <__aeabi_dadd+0x4a0>
   26fba:	e096      	b.n	270ea <__aeabi_dadd+0x5ce>
   26fbc:	2b1f      	cmp	r3, #31
   26fbe:	dd00      	ble.n	26fc2 <__aeabi_dadd+0x4a6>
   26fc0:	e09f      	b.n	27102 <__aeabi_dadd+0x5e6>
   26fc2:	2620      	movs	r6, #32
   26fc4:	1af3      	subs	r3, r6, r3
   26fc6:	0026      	movs	r6, r4
   26fc8:	409e      	lsls	r6, r3
   26fca:	469c      	mov	ip, r3
   26fcc:	46b3      	mov	fp, r6
   26fce:	4653      	mov	r3, sl
   26fd0:	003e      	movs	r6, r7
   26fd2:	40de      	lsrs	r6, r3
   26fd4:	0033      	movs	r3, r6
   26fd6:	465e      	mov	r6, fp
   26fd8:	431e      	orrs	r6, r3
   26fda:	4663      	mov	r3, ip
   26fdc:	409f      	lsls	r7, r3
   26fde:	1e7b      	subs	r3, r7, #1
   26fe0:	419f      	sbcs	r7, r3
   26fe2:	4653      	mov	r3, sl
   26fe4:	40dc      	lsrs	r4, r3
   26fe6:	4337      	orrs	r7, r6
   26fe8:	18bf      	adds	r7, r7, r2
   26fea:	4297      	cmp	r7, r2
   26fec:	4192      	sbcs	r2, r2
   26fee:	1864      	adds	r4, r4, r1
   26ff0:	4252      	negs	r2, r2
   26ff2:	18a4      	adds	r4, r4, r2
   26ff4:	0006      	movs	r6, r0
   26ff6:	e678      	b.n	26cea <__aeabi_dadd+0x1ce>
   26ff8:	4327      	orrs	r7, r4
   26ffa:	1e7c      	subs	r4, r7, #1
   26ffc:	41a7      	sbcs	r7, r4
   26ffe:	2400      	movs	r4, #0
   27000:	e737      	b.n	26e72 <__aeabi_dadd+0x356>
   27002:	4e4c      	ldr	r6, [pc, #304]	; (27134 <__aeabi_dadd+0x618>)
   27004:	42b0      	cmp	r0, r6
   27006:	d036      	beq.n	27076 <__aeabi_dadd+0x55a>
   27008:	2680      	movs	r6, #128	; 0x80
   2700a:	425b      	negs	r3, r3
   2700c:	0436      	lsls	r6, r6, #16
   2700e:	469a      	mov	sl, r3
   27010:	4334      	orrs	r4, r6
   27012:	e7cf      	b.n	26fb4 <__aeabi_dadd+0x498>
   27014:	0018      	movs	r0, r3
   27016:	4310      	orrs	r0, r2
   27018:	d100      	bne.n	2701c <__aeabi_dadd+0x500>
   2701a:	e603      	b.n	26c24 <__aeabi_dadd+0x108>
   2701c:	1ab8      	subs	r0, r7, r2
   2701e:	4684      	mov	ip, r0
   27020:	4567      	cmp	r7, ip
   27022:	41ad      	sbcs	r5, r5
   27024:	1ae0      	subs	r0, r4, r3
   27026:	426d      	negs	r5, r5
   27028:	1b40      	subs	r0, r0, r5
   2702a:	0205      	lsls	r5, r0, #8
   2702c:	d400      	bmi.n	27030 <__aeabi_dadd+0x514>
   2702e:	e62c      	b.n	26c8a <__aeabi_dadd+0x16e>
   27030:	1bd7      	subs	r7, r2, r7
   27032:	42ba      	cmp	r2, r7
   27034:	4192      	sbcs	r2, r2
   27036:	1b1c      	subs	r4, r3, r4
   27038:	4252      	negs	r2, r2
   2703a:	1aa4      	subs	r4, r4, r2
   2703c:	46d8      	mov	r8, fp
   2703e:	e5f1      	b.n	26c24 <__aeabi_dadd+0x108>
   27040:	0018      	movs	r0, r3
   27042:	4310      	orrs	r0, r2
   27044:	d100      	bne.n	27048 <__aeabi_dadd+0x52c>
   27046:	e763      	b.n	26f10 <__aeabi_dadd+0x3f4>
   27048:	08f8      	lsrs	r0, r7, #3
   2704a:	0767      	lsls	r7, r4, #29
   2704c:	4307      	orrs	r7, r0
   2704e:	2080      	movs	r0, #128	; 0x80
   27050:	08e4      	lsrs	r4, r4, #3
   27052:	0300      	lsls	r0, r0, #12
   27054:	4204      	tst	r4, r0
   27056:	d008      	beq.n	2706a <__aeabi_dadd+0x54e>
   27058:	08dd      	lsrs	r5, r3, #3
   2705a:	4205      	tst	r5, r0
   2705c:	d105      	bne.n	2706a <__aeabi_dadd+0x54e>
   2705e:	08d2      	lsrs	r2, r2, #3
   27060:	0759      	lsls	r1, r3, #29
   27062:	4311      	orrs	r1, r2
   27064:	000f      	movs	r7, r1
   27066:	002c      	movs	r4, r5
   27068:	46d8      	mov	r8, fp
   2706a:	0f7b      	lsrs	r3, r7, #29
   2706c:	00e4      	lsls	r4, r4, #3
   2706e:	431c      	orrs	r4, r3
   27070:	00ff      	lsls	r7, r7, #3
   27072:	4e30      	ldr	r6, [pc, #192]	; (27134 <__aeabi_dadd+0x618>)
   27074:	e5d6      	b.n	26c24 <__aeabi_dadd+0x108>
   27076:	000c      	movs	r4, r1
   27078:	0017      	movs	r7, r2
   2707a:	0006      	movs	r6, r0
   2707c:	e5d2      	b.n	26c24 <__aeabi_dadd+0x108>
   2707e:	2b00      	cmp	r3, #0
   27080:	d038      	beq.n	270f4 <__aeabi_dadd+0x5d8>
   27082:	000b      	movs	r3, r1
   27084:	4313      	orrs	r3, r2
   27086:	d100      	bne.n	2708a <__aeabi_dadd+0x56e>
   27088:	e742      	b.n	26f10 <__aeabi_dadd+0x3f4>
   2708a:	08f8      	lsrs	r0, r7, #3
   2708c:	0767      	lsls	r7, r4, #29
   2708e:	4307      	orrs	r7, r0
   27090:	2080      	movs	r0, #128	; 0x80
   27092:	08e4      	lsrs	r4, r4, #3
   27094:	0300      	lsls	r0, r0, #12
   27096:	4204      	tst	r4, r0
   27098:	d0e7      	beq.n	2706a <__aeabi_dadd+0x54e>
   2709a:	08cb      	lsrs	r3, r1, #3
   2709c:	4203      	tst	r3, r0
   2709e:	d1e4      	bne.n	2706a <__aeabi_dadd+0x54e>
   270a0:	08d2      	lsrs	r2, r2, #3
   270a2:	0749      	lsls	r1, r1, #29
   270a4:	4311      	orrs	r1, r2
   270a6:	000f      	movs	r7, r1
   270a8:	001c      	movs	r4, r3
   270aa:	e7de      	b.n	2706a <__aeabi_dadd+0x54e>
   270ac:	2700      	movs	r7, #0
   270ae:	2400      	movs	r4, #0
   270b0:	e5d5      	b.n	26c5e <__aeabi_dadd+0x142>
   270b2:	2100      	movs	r1, #0
   270b4:	e76b      	b.n	26f8e <__aeabi_dadd+0x472>
   270b6:	2500      	movs	r5, #0
   270b8:	2700      	movs	r7, #0
   270ba:	e5f3      	b.n	26ca4 <__aeabi_dadd+0x188>
   270bc:	464e      	mov	r6, r9
   270be:	0025      	movs	r5, r4
   270c0:	3e20      	subs	r6, #32
   270c2:	40f5      	lsrs	r5, r6
   270c4:	464b      	mov	r3, r9
   270c6:	002e      	movs	r6, r5
   270c8:	2b20      	cmp	r3, #32
   270ca:	d02d      	beq.n	27128 <__aeabi_dadd+0x60c>
   270cc:	2540      	movs	r5, #64	; 0x40
   270ce:	1aed      	subs	r5, r5, r3
   270d0:	40ac      	lsls	r4, r5
   270d2:	4327      	orrs	r7, r4
   270d4:	1e7c      	subs	r4, r7, #1
   270d6:	41a7      	sbcs	r7, r4
   270d8:	2400      	movs	r4, #0
   270da:	4337      	orrs	r7, r6
   270dc:	e6c9      	b.n	26e72 <__aeabi_dadd+0x356>
   270de:	2480      	movs	r4, #128	; 0x80
   270e0:	2500      	movs	r5, #0
   270e2:	0324      	lsls	r4, r4, #12
   270e4:	4e13      	ldr	r6, [pc, #76]	; (27134 <__aeabi_dadd+0x618>)
   270e6:	2700      	movs	r7, #0
   270e8:	e5dc      	b.n	26ca4 <__aeabi_dadd+0x188>
   270ea:	4327      	orrs	r7, r4
   270ec:	1e7c      	subs	r4, r7, #1
   270ee:	41a7      	sbcs	r7, r4
   270f0:	2400      	movs	r4, #0
   270f2:	e779      	b.n	26fe8 <__aeabi_dadd+0x4cc>
   270f4:	000c      	movs	r4, r1
   270f6:	0017      	movs	r7, r2
   270f8:	4e0e      	ldr	r6, [pc, #56]	; (27134 <__aeabi_dadd+0x618>)
   270fa:	e593      	b.n	26c24 <__aeabi_dadd+0x108>
   270fc:	000c      	movs	r4, r1
   270fe:	0017      	movs	r7, r2
   27100:	e590      	b.n	26c24 <__aeabi_dadd+0x108>
   27102:	4656      	mov	r6, sl
   27104:	0023      	movs	r3, r4
   27106:	3e20      	subs	r6, #32
   27108:	40f3      	lsrs	r3, r6
   2710a:	4699      	mov	r9, r3
   2710c:	4653      	mov	r3, sl
   2710e:	2b20      	cmp	r3, #32
   27110:	d00e      	beq.n	27130 <__aeabi_dadd+0x614>
   27112:	2340      	movs	r3, #64	; 0x40
   27114:	4656      	mov	r6, sl
   27116:	1b9b      	subs	r3, r3, r6
   27118:	409c      	lsls	r4, r3
   2711a:	4327      	orrs	r7, r4
   2711c:	1e7c      	subs	r4, r7, #1
   2711e:	41a7      	sbcs	r7, r4
   27120:	464b      	mov	r3, r9
   27122:	2400      	movs	r4, #0
   27124:	431f      	orrs	r7, r3
   27126:	e75f      	b.n	26fe8 <__aeabi_dadd+0x4cc>
   27128:	2400      	movs	r4, #0
   2712a:	e7d2      	b.n	270d2 <__aeabi_dadd+0x5b6>
   2712c:	0017      	movs	r7, r2
   2712e:	e5b2      	b.n	26c96 <__aeabi_dadd+0x17a>
   27130:	2400      	movs	r4, #0
   27132:	e7f2      	b.n	2711a <__aeabi_dadd+0x5fe>
   27134:	000007ff 	.word	0x000007ff
   27138:	ff7fffff 	.word	0xff7fffff

0002713c <__aeabi_ddiv>:
   2713c:	b5f0      	push	{r4, r5, r6, r7, lr}
   2713e:	4657      	mov	r7, sl
   27140:	4645      	mov	r5, r8
   27142:	46de      	mov	lr, fp
   27144:	464e      	mov	r6, r9
   27146:	b5e0      	push	{r5, r6, r7, lr}
   27148:	004c      	lsls	r4, r1, #1
   2714a:	030e      	lsls	r6, r1, #12
   2714c:	b087      	sub	sp, #28
   2714e:	4683      	mov	fp, r0
   27150:	4692      	mov	sl, r2
   27152:	001d      	movs	r5, r3
   27154:	4680      	mov	r8, r0
   27156:	0b36      	lsrs	r6, r6, #12
   27158:	0d64      	lsrs	r4, r4, #21
   2715a:	0fcf      	lsrs	r7, r1, #31
   2715c:	2c00      	cmp	r4, #0
   2715e:	d04f      	beq.n	27200 <__aeabi_ddiv+0xc4>
   27160:	4b6f      	ldr	r3, [pc, #444]	; (27320 <__aeabi_ddiv+0x1e4>)
   27162:	429c      	cmp	r4, r3
   27164:	d035      	beq.n	271d2 <__aeabi_ddiv+0x96>
   27166:	2380      	movs	r3, #128	; 0x80
   27168:	0f42      	lsrs	r2, r0, #29
   2716a:	041b      	lsls	r3, r3, #16
   2716c:	00f6      	lsls	r6, r6, #3
   2716e:	4313      	orrs	r3, r2
   27170:	4333      	orrs	r3, r6
   27172:	4699      	mov	r9, r3
   27174:	00c3      	lsls	r3, r0, #3
   27176:	4698      	mov	r8, r3
   27178:	4b6a      	ldr	r3, [pc, #424]	; (27324 <__aeabi_ddiv+0x1e8>)
   2717a:	2600      	movs	r6, #0
   2717c:	469c      	mov	ip, r3
   2717e:	2300      	movs	r3, #0
   27180:	4464      	add	r4, ip
   27182:	9303      	str	r3, [sp, #12]
   27184:	032b      	lsls	r3, r5, #12
   27186:	0b1b      	lsrs	r3, r3, #12
   27188:	469b      	mov	fp, r3
   2718a:	006b      	lsls	r3, r5, #1
   2718c:	0fed      	lsrs	r5, r5, #31
   2718e:	4650      	mov	r0, sl
   27190:	0d5b      	lsrs	r3, r3, #21
   27192:	9501      	str	r5, [sp, #4]
   27194:	d05e      	beq.n	27254 <__aeabi_ddiv+0x118>
   27196:	4a62      	ldr	r2, [pc, #392]	; (27320 <__aeabi_ddiv+0x1e4>)
   27198:	4293      	cmp	r3, r2
   2719a:	d053      	beq.n	27244 <__aeabi_ddiv+0x108>
   2719c:	465a      	mov	r2, fp
   2719e:	00d1      	lsls	r1, r2, #3
   271a0:	2280      	movs	r2, #128	; 0x80
   271a2:	0f40      	lsrs	r0, r0, #29
   271a4:	0412      	lsls	r2, r2, #16
   271a6:	4302      	orrs	r2, r0
   271a8:	430a      	orrs	r2, r1
   271aa:	4693      	mov	fp, r2
   271ac:	4652      	mov	r2, sl
   271ae:	00d1      	lsls	r1, r2, #3
   271b0:	4a5c      	ldr	r2, [pc, #368]	; (27324 <__aeabi_ddiv+0x1e8>)
   271b2:	4694      	mov	ip, r2
   271b4:	2200      	movs	r2, #0
   271b6:	4463      	add	r3, ip
   271b8:	0038      	movs	r0, r7
   271ba:	4068      	eors	r0, r5
   271bc:	4684      	mov	ip, r0
   271be:	9002      	str	r0, [sp, #8]
   271c0:	1ae4      	subs	r4, r4, r3
   271c2:	4316      	orrs	r6, r2
   271c4:	2e0f      	cmp	r6, #15
   271c6:	d900      	bls.n	271ca <__aeabi_ddiv+0x8e>
   271c8:	e0b4      	b.n	27334 <__aeabi_ddiv+0x1f8>
   271ca:	4b57      	ldr	r3, [pc, #348]	; (27328 <__aeabi_ddiv+0x1ec>)
   271cc:	00b6      	lsls	r6, r6, #2
   271ce:	599b      	ldr	r3, [r3, r6]
   271d0:	469f      	mov	pc, r3
   271d2:	0003      	movs	r3, r0
   271d4:	4333      	orrs	r3, r6
   271d6:	4699      	mov	r9, r3
   271d8:	d16c      	bne.n	272b4 <__aeabi_ddiv+0x178>
   271da:	2300      	movs	r3, #0
   271dc:	4698      	mov	r8, r3
   271de:	3302      	adds	r3, #2
   271e0:	2608      	movs	r6, #8
   271e2:	9303      	str	r3, [sp, #12]
   271e4:	e7ce      	b.n	27184 <__aeabi_ddiv+0x48>
   271e6:	46cb      	mov	fp, r9
   271e8:	4641      	mov	r1, r8
   271ea:	9a03      	ldr	r2, [sp, #12]
   271ec:	9701      	str	r7, [sp, #4]
   271ee:	2a02      	cmp	r2, #2
   271f0:	d165      	bne.n	272be <__aeabi_ddiv+0x182>
   271f2:	9b01      	ldr	r3, [sp, #4]
   271f4:	4c4a      	ldr	r4, [pc, #296]	; (27320 <__aeabi_ddiv+0x1e4>)
   271f6:	469c      	mov	ip, r3
   271f8:	2300      	movs	r3, #0
   271fa:	2200      	movs	r2, #0
   271fc:	4698      	mov	r8, r3
   271fe:	e06b      	b.n	272d8 <__aeabi_ddiv+0x19c>
   27200:	0003      	movs	r3, r0
   27202:	4333      	orrs	r3, r6
   27204:	4699      	mov	r9, r3
   27206:	d04e      	beq.n	272a6 <__aeabi_ddiv+0x16a>
   27208:	2e00      	cmp	r6, #0
   2720a:	d100      	bne.n	2720e <__aeabi_ddiv+0xd2>
   2720c:	e1bc      	b.n	27588 <__aeabi_ddiv+0x44c>
   2720e:	0030      	movs	r0, r6
   27210:	f001 fa7e 	bl	28710 <__clzsi2>
   27214:	0003      	movs	r3, r0
   27216:	3b0b      	subs	r3, #11
   27218:	2b1c      	cmp	r3, #28
   2721a:	dd00      	ble.n	2721e <__aeabi_ddiv+0xe2>
   2721c:	e1ac      	b.n	27578 <__aeabi_ddiv+0x43c>
   2721e:	221d      	movs	r2, #29
   27220:	1ad3      	subs	r3, r2, r3
   27222:	465a      	mov	r2, fp
   27224:	0001      	movs	r1, r0
   27226:	40da      	lsrs	r2, r3
   27228:	3908      	subs	r1, #8
   2722a:	408e      	lsls	r6, r1
   2722c:	0013      	movs	r3, r2
   2722e:	4333      	orrs	r3, r6
   27230:	4699      	mov	r9, r3
   27232:	465b      	mov	r3, fp
   27234:	408b      	lsls	r3, r1
   27236:	4698      	mov	r8, r3
   27238:	2300      	movs	r3, #0
   2723a:	4c3c      	ldr	r4, [pc, #240]	; (2732c <__aeabi_ddiv+0x1f0>)
   2723c:	2600      	movs	r6, #0
   2723e:	1a24      	subs	r4, r4, r0
   27240:	9303      	str	r3, [sp, #12]
   27242:	e79f      	b.n	27184 <__aeabi_ddiv+0x48>
   27244:	4651      	mov	r1, sl
   27246:	465a      	mov	r2, fp
   27248:	4311      	orrs	r1, r2
   2724a:	d129      	bne.n	272a0 <__aeabi_ddiv+0x164>
   2724c:	2200      	movs	r2, #0
   2724e:	4693      	mov	fp, r2
   27250:	3202      	adds	r2, #2
   27252:	e7b1      	b.n	271b8 <__aeabi_ddiv+0x7c>
   27254:	4659      	mov	r1, fp
   27256:	4301      	orrs	r1, r0
   27258:	d01e      	beq.n	27298 <__aeabi_ddiv+0x15c>
   2725a:	465b      	mov	r3, fp
   2725c:	2b00      	cmp	r3, #0
   2725e:	d100      	bne.n	27262 <__aeabi_ddiv+0x126>
   27260:	e19e      	b.n	275a0 <__aeabi_ddiv+0x464>
   27262:	4658      	mov	r0, fp
   27264:	f001 fa54 	bl	28710 <__clzsi2>
   27268:	0003      	movs	r3, r0
   2726a:	3b0b      	subs	r3, #11
   2726c:	2b1c      	cmp	r3, #28
   2726e:	dd00      	ble.n	27272 <__aeabi_ddiv+0x136>
   27270:	e18f      	b.n	27592 <__aeabi_ddiv+0x456>
   27272:	0002      	movs	r2, r0
   27274:	4659      	mov	r1, fp
   27276:	3a08      	subs	r2, #8
   27278:	4091      	lsls	r1, r2
   2727a:	468b      	mov	fp, r1
   2727c:	211d      	movs	r1, #29
   2727e:	1acb      	subs	r3, r1, r3
   27280:	4651      	mov	r1, sl
   27282:	40d9      	lsrs	r1, r3
   27284:	000b      	movs	r3, r1
   27286:	4659      	mov	r1, fp
   27288:	430b      	orrs	r3, r1
   2728a:	4651      	mov	r1, sl
   2728c:	469b      	mov	fp, r3
   2728e:	4091      	lsls	r1, r2
   27290:	4b26      	ldr	r3, [pc, #152]	; (2732c <__aeabi_ddiv+0x1f0>)
   27292:	2200      	movs	r2, #0
   27294:	1a1b      	subs	r3, r3, r0
   27296:	e78f      	b.n	271b8 <__aeabi_ddiv+0x7c>
   27298:	2300      	movs	r3, #0
   2729a:	2201      	movs	r2, #1
   2729c:	469b      	mov	fp, r3
   2729e:	e78b      	b.n	271b8 <__aeabi_ddiv+0x7c>
   272a0:	4651      	mov	r1, sl
   272a2:	2203      	movs	r2, #3
   272a4:	e788      	b.n	271b8 <__aeabi_ddiv+0x7c>
   272a6:	2300      	movs	r3, #0
   272a8:	4698      	mov	r8, r3
   272aa:	3301      	adds	r3, #1
   272ac:	2604      	movs	r6, #4
   272ae:	2400      	movs	r4, #0
   272b0:	9303      	str	r3, [sp, #12]
   272b2:	e767      	b.n	27184 <__aeabi_ddiv+0x48>
   272b4:	2303      	movs	r3, #3
   272b6:	46b1      	mov	r9, r6
   272b8:	9303      	str	r3, [sp, #12]
   272ba:	260c      	movs	r6, #12
   272bc:	e762      	b.n	27184 <__aeabi_ddiv+0x48>
   272be:	2a03      	cmp	r2, #3
   272c0:	d100      	bne.n	272c4 <__aeabi_ddiv+0x188>
   272c2:	e25c      	b.n	2777e <__aeabi_ddiv+0x642>
   272c4:	9b01      	ldr	r3, [sp, #4]
   272c6:	2a01      	cmp	r2, #1
   272c8:	d000      	beq.n	272cc <__aeabi_ddiv+0x190>
   272ca:	e1e4      	b.n	27696 <__aeabi_ddiv+0x55a>
   272cc:	4013      	ands	r3, r2
   272ce:	469c      	mov	ip, r3
   272d0:	2300      	movs	r3, #0
   272d2:	2400      	movs	r4, #0
   272d4:	2200      	movs	r2, #0
   272d6:	4698      	mov	r8, r3
   272d8:	2100      	movs	r1, #0
   272da:	0312      	lsls	r2, r2, #12
   272dc:	0b13      	lsrs	r3, r2, #12
   272de:	0d0a      	lsrs	r2, r1, #20
   272e0:	0512      	lsls	r2, r2, #20
   272e2:	431a      	orrs	r2, r3
   272e4:	0523      	lsls	r3, r4, #20
   272e6:	4c12      	ldr	r4, [pc, #72]	; (27330 <__aeabi_ddiv+0x1f4>)
   272e8:	4640      	mov	r0, r8
   272ea:	4022      	ands	r2, r4
   272ec:	4313      	orrs	r3, r2
   272ee:	4662      	mov	r2, ip
   272f0:	005b      	lsls	r3, r3, #1
   272f2:	07d2      	lsls	r2, r2, #31
   272f4:	085b      	lsrs	r3, r3, #1
   272f6:	4313      	orrs	r3, r2
   272f8:	0019      	movs	r1, r3
   272fa:	b007      	add	sp, #28
   272fc:	bc3c      	pop	{r2, r3, r4, r5}
   272fe:	4690      	mov	r8, r2
   27300:	4699      	mov	r9, r3
   27302:	46a2      	mov	sl, r4
   27304:	46ab      	mov	fp, r5
   27306:	bdf0      	pop	{r4, r5, r6, r7, pc}
   27308:	2300      	movs	r3, #0
   2730a:	2280      	movs	r2, #128	; 0x80
   2730c:	469c      	mov	ip, r3
   2730e:	0312      	lsls	r2, r2, #12
   27310:	4698      	mov	r8, r3
   27312:	4c03      	ldr	r4, [pc, #12]	; (27320 <__aeabi_ddiv+0x1e4>)
   27314:	e7e0      	b.n	272d8 <__aeabi_ddiv+0x19c>
   27316:	2300      	movs	r3, #0
   27318:	4c01      	ldr	r4, [pc, #4]	; (27320 <__aeabi_ddiv+0x1e4>)
   2731a:	2200      	movs	r2, #0
   2731c:	4698      	mov	r8, r3
   2731e:	e7db      	b.n	272d8 <__aeabi_ddiv+0x19c>
   27320:	000007ff 	.word	0x000007ff
   27324:	fffffc01 	.word	0xfffffc01
   27328:	0002b9e8 	.word	0x0002b9e8
   2732c:	fffffc0d 	.word	0xfffffc0d
   27330:	800fffff 	.word	0x800fffff
   27334:	45d9      	cmp	r9, fp
   27336:	d900      	bls.n	2733a <__aeabi_ddiv+0x1fe>
   27338:	e139      	b.n	275ae <__aeabi_ddiv+0x472>
   2733a:	d100      	bne.n	2733e <__aeabi_ddiv+0x202>
   2733c:	e134      	b.n	275a8 <__aeabi_ddiv+0x46c>
   2733e:	2300      	movs	r3, #0
   27340:	4646      	mov	r6, r8
   27342:	464d      	mov	r5, r9
   27344:	469a      	mov	sl, r3
   27346:	3c01      	subs	r4, #1
   27348:	465b      	mov	r3, fp
   2734a:	0e0a      	lsrs	r2, r1, #24
   2734c:	021b      	lsls	r3, r3, #8
   2734e:	431a      	orrs	r2, r3
   27350:	020b      	lsls	r3, r1, #8
   27352:	0c17      	lsrs	r7, r2, #16
   27354:	9303      	str	r3, [sp, #12]
   27356:	0413      	lsls	r3, r2, #16
   27358:	0c1b      	lsrs	r3, r3, #16
   2735a:	0039      	movs	r1, r7
   2735c:	0028      	movs	r0, r5
   2735e:	4690      	mov	r8, r2
   27360:	9301      	str	r3, [sp, #4]
   27362:	f7fe faab 	bl	258bc <__udivsi3>
   27366:	0002      	movs	r2, r0
   27368:	9b01      	ldr	r3, [sp, #4]
   2736a:	4683      	mov	fp, r0
   2736c:	435a      	muls	r2, r3
   2736e:	0028      	movs	r0, r5
   27370:	0039      	movs	r1, r7
   27372:	4691      	mov	r9, r2
   27374:	f7fe fb28 	bl	259c8 <__aeabi_uidivmod>
   27378:	0c35      	lsrs	r5, r6, #16
   2737a:	0409      	lsls	r1, r1, #16
   2737c:	430d      	orrs	r5, r1
   2737e:	45a9      	cmp	r9, r5
   27380:	d90d      	bls.n	2739e <__aeabi_ddiv+0x262>
   27382:	465b      	mov	r3, fp
   27384:	4445      	add	r5, r8
   27386:	3b01      	subs	r3, #1
   27388:	45a8      	cmp	r8, r5
   2738a:	d900      	bls.n	2738e <__aeabi_ddiv+0x252>
   2738c:	e13a      	b.n	27604 <__aeabi_ddiv+0x4c8>
   2738e:	45a9      	cmp	r9, r5
   27390:	d800      	bhi.n	27394 <__aeabi_ddiv+0x258>
   27392:	e137      	b.n	27604 <__aeabi_ddiv+0x4c8>
   27394:	2302      	movs	r3, #2
   27396:	425b      	negs	r3, r3
   27398:	469c      	mov	ip, r3
   2739a:	4445      	add	r5, r8
   2739c:	44e3      	add	fp, ip
   2739e:	464b      	mov	r3, r9
   273a0:	1aeb      	subs	r3, r5, r3
   273a2:	0039      	movs	r1, r7
   273a4:	0018      	movs	r0, r3
   273a6:	9304      	str	r3, [sp, #16]
   273a8:	f7fe fa88 	bl	258bc <__udivsi3>
   273ac:	9b01      	ldr	r3, [sp, #4]
   273ae:	0005      	movs	r5, r0
   273b0:	4343      	muls	r3, r0
   273b2:	0039      	movs	r1, r7
   273b4:	9804      	ldr	r0, [sp, #16]
   273b6:	4699      	mov	r9, r3
   273b8:	f7fe fb06 	bl	259c8 <__aeabi_uidivmod>
   273bc:	0433      	lsls	r3, r6, #16
   273be:	0409      	lsls	r1, r1, #16
   273c0:	0c1b      	lsrs	r3, r3, #16
   273c2:	430b      	orrs	r3, r1
   273c4:	4599      	cmp	r9, r3
   273c6:	d909      	bls.n	273dc <__aeabi_ddiv+0x2a0>
   273c8:	4443      	add	r3, r8
   273ca:	1e6a      	subs	r2, r5, #1
   273cc:	4598      	cmp	r8, r3
   273ce:	d900      	bls.n	273d2 <__aeabi_ddiv+0x296>
   273d0:	e11a      	b.n	27608 <__aeabi_ddiv+0x4cc>
   273d2:	4599      	cmp	r9, r3
   273d4:	d800      	bhi.n	273d8 <__aeabi_ddiv+0x29c>
   273d6:	e117      	b.n	27608 <__aeabi_ddiv+0x4cc>
   273d8:	3d02      	subs	r5, #2
   273da:	4443      	add	r3, r8
   273dc:	464a      	mov	r2, r9
   273de:	1a9b      	subs	r3, r3, r2
   273e0:	465a      	mov	r2, fp
   273e2:	0412      	lsls	r2, r2, #16
   273e4:	432a      	orrs	r2, r5
   273e6:	9903      	ldr	r1, [sp, #12]
   273e8:	4693      	mov	fp, r2
   273ea:	0c10      	lsrs	r0, r2, #16
   273ec:	0c0a      	lsrs	r2, r1, #16
   273ee:	4691      	mov	r9, r2
   273f0:	0409      	lsls	r1, r1, #16
   273f2:	465a      	mov	r2, fp
   273f4:	0c09      	lsrs	r1, r1, #16
   273f6:	464e      	mov	r6, r9
   273f8:	000d      	movs	r5, r1
   273fa:	0412      	lsls	r2, r2, #16
   273fc:	0c12      	lsrs	r2, r2, #16
   273fe:	4345      	muls	r5, r0
   27400:	9105      	str	r1, [sp, #20]
   27402:	4351      	muls	r1, r2
   27404:	4372      	muls	r2, r6
   27406:	4370      	muls	r0, r6
   27408:	1952      	adds	r2, r2, r5
   2740a:	0c0e      	lsrs	r6, r1, #16
   2740c:	18b2      	adds	r2, r6, r2
   2740e:	4295      	cmp	r5, r2
   27410:	d903      	bls.n	2741a <__aeabi_ddiv+0x2de>
   27412:	2580      	movs	r5, #128	; 0x80
   27414:	026d      	lsls	r5, r5, #9
   27416:	46ac      	mov	ip, r5
   27418:	4460      	add	r0, ip
   2741a:	0c15      	lsrs	r5, r2, #16
   2741c:	0409      	lsls	r1, r1, #16
   2741e:	0412      	lsls	r2, r2, #16
   27420:	0c09      	lsrs	r1, r1, #16
   27422:	1828      	adds	r0, r5, r0
   27424:	1852      	adds	r2, r2, r1
   27426:	4283      	cmp	r3, r0
   27428:	d200      	bcs.n	2742c <__aeabi_ddiv+0x2f0>
   2742a:	e0ce      	b.n	275ca <__aeabi_ddiv+0x48e>
   2742c:	d100      	bne.n	27430 <__aeabi_ddiv+0x2f4>
   2742e:	e0c8      	b.n	275c2 <__aeabi_ddiv+0x486>
   27430:	1a1d      	subs	r5, r3, r0
   27432:	4653      	mov	r3, sl
   27434:	1a9e      	subs	r6, r3, r2
   27436:	45b2      	cmp	sl, r6
   27438:	4192      	sbcs	r2, r2
   2743a:	4252      	negs	r2, r2
   2743c:	1aab      	subs	r3, r5, r2
   2743e:	469a      	mov	sl, r3
   27440:	4598      	cmp	r8, r3
   27442:	d100      	bne.n	27446 <__aeabi_ddiv+0x30a>
   27444:	e117      	b.n	27676 <__aeabi_ddiv+0x53a>
   27446:	0039      	movs	r1, r7
   27448:	0018      	movs	r0, r3
   2744a:	f7fe fa37 	bl	258bc <__udivsi3>
   2744e:	9b01      	ldr	r3, [sp, #4]
   27450:	0005      	movs	r5, r0
   27452:	4343      	muls	r3, r0
   27454:	0039      	movs	r1, r7
   27456:	4650      	mov	r0, sl
   27458:	9304      	str	r3, [sp, #16]
   2745a:	f7fe fab5 	bl	259c8 <__aeabi_uidivmod>
   2745e:	9804      	ldr	r0, [sp, #16]
   27460:	040b      	lsls	r3, r1, #16
   27462:	0c31      	lsrs	r1, r6, #16
   27464:	4319      	orrs	r1, r3
   27466:	4288      	cmp	r0, r1
   27468:	d909      	bls.n	2747e <__aeabi_ddiv+0x342>
   2746a:	4441      	add	r1, r8
   2746c:	1e6b      	subs	r3, r5, #1
   2746e:	4588      	cmp	r8, r1
   27470:	d900      	bls.n	27474 <__aeabi_ddiv+0x338>
   27472:	e107      	b.n	27684 <__aeabi_ddiv+0x548>
   27474:	4288      	cmp	r0, r1
   27476:	d800      	bhi.n	2747a <__aeabi_ddiv+0x33e>
   27478:	e104      	b.n	27684 <__aeabi_ddiv+0x548>
   2747a:	3d02      	subs	r5, #2
   2747c:	4441      	add	r1, r8
   2747e:	9b04      	ldr	r3, [sp, #16]
   27480:	1acb      	subs	r3, r1, r3
   27482:	0018      	movs	r0, r3
   27484:	0039      	movs	r1, r7
   27486:	9304      	str	r3, [sp, #16]
   27488:	f7fe fa18 	bl	258bc <__udivsi3>
   2748c:	9b01      	ldr	r3, [sp, #4]
   2748e:	4682      	mov	sl, r0
   27490:	4343      	muls	r3, r0
   27492:	0039      	movs	r1, r7
   27494:	9804      	ldr	r0, [sp, #16]
   27496:	9301      	str	r3, [sp, #4]
   27498:	f7fe fa96 	bl	259c8 <__aeabi_uidivmod>
   2749c:	9801      	ldr	r0, [sp, #4]
   2749e:	040b      	lsls	r3, r1, #16
   274a0:	0431      	lsls	r1, r6, #16
   274a2:	0c09      	lsrs	r1, r1, #16
   274a4:	4319      	orrs	r1, r3
   274a6:	4288      	cmp	r0, r1
   274a8:	d90d      	bls.n	274c6 <__aeabi_ddiv+0x38a>
   274aa:	4653      	mov	r3, sl
   274ac:	4441      	add	r1, r8
   274ae:	3b01      	subs	r3, #1
   274b0:	4588      	cmp	r8, r1
   274b2:	d900      	bls.n	274b6 <__aeabi_ddiv+0x37a>
   274b4:	e0e8      	b.n	27688 <__aeabi_ddiv+0x54c>
   274b6:	4288      	cmp	r0, r1
   274b8:	d800      	bhi.n	274bc <__aeabi_ddiv+0x380>
   274ba:	e0e5      	b.n	27688 <__aeabi_ddiv+0x54c>
   274bc:	2302      	movs	r3, #2
   274be:	425b      	negs	r3, r3
   274c0:	469c      	mov	ip, r3
   274c2:	4441      	add	r1, r8
   274c4:	44e2      	add	sl, ip
   274c6:	9b01      	ldr	r3, [sp, #4]
   274c8:	042d      	lsls	r5, r5, #16
   274ca:	1ace      	subs	r6, r1, r3
   274cc:	4651      	mov	r1, sl
   274ce:	4329      	orrs	r1, r5
   274d0:	9d05      	ldr	r5, [sp, #20]
   274d2:	464f      	mov	r7, r9
   274d4:	002a      	movs	r2, r5
   274d6:	040b      	lsls	r3, r1, #16
   274d8:	0c08      	lsrs	r0, r1, #16
   274da:	0c1b      	lsrs	r3, r3, #16
   274dc:	435a      	muls	r2, r3
   274de:	4345      	muls	r5, r0
   274e0:	437b      	muls	r3, r7
   274e2:	4378      	muls	r0, r7
   274e4:	195b      	adds	r3, r3, r5
   274e6:	0c17      	lsrs	r7, r2, #16
   274e8:	18fb      	adds	r3, r7, r3
   274ea:	429d      	cmp	r5, r3
   274ec:	d903      	bls.n	274f6 <__aeabi_ddiv+0x3ba>
   274ee:	2580      	movs	r5, #128	; 0x80
   274f0:	026d      	lsls	r5, r5, #9
   274f2:	46ac      	mov	ip, r5
   274f4:	4460      	add	r0, ip
   274f6:	0c1d      	lsrs	r5, r3, #16
   274f8:	0412      	lsls	r2, r2, #16
   274fa:	041b      	lsls	r3, r3, #16
   274fc:	0c12      	lsrs	r2, r2, #16
   274fe:	1828      	adds	r0, r5, r0
   27500:	189b      	adds	r3, r3, r2
   27502:	4286      	cmp	r6, r0
   27504:	d200      	bcs.n	27508 <__aeabi_ddiv+0x3cc>
   27506:	e093      	b.n	27630 <__aeabi_ddiv+0x4f4>
   27508:	d100      	bne.n	2750c <__aeabi_ddiv+0x3d0>
   2750a:	e08e      	b.n	2762a <__aeabi_ddiv+0x4ee>
   2750c:	2301      	movs	r3, #1
   2750e:	4319      	orrs	r1, r3
   27510:	4ba0      	ldr	r3, [pc, #640]	; (27794 <__aeabi_ddiv+0x658>)
   27512:	18e3      	adds	r3, r4, r3
   27514:	2b00      	cmp	r3, #0
   27516:	dc00      	bgt.n	2751a <__aeabi_ddiv+0x3de>
   27518:	e099      	b.n	2764e <__aeabi_ddiv+0x512>
   2751a:	074a      	lsls	r2, r1, #29
   2751c:	d000      	beq.n	27520 <__aeabi_ddiv+0x3e4>
   2751e:	e09e      	b.n	2765e <__aeabi_ddiv+0x522>
   27520:	465a      	mov	r2, fp
   27522:	01d2      	lsls	r2, r2, #7
   27524:	d506      	bpl.n	27534 <__aeabi_ddiv+0x3f8>
   27526:	465a      	mov	r2, fp
   27528:	4b9b      	ldr	r3, [pc, #620]	; (27798 <__aeabi_ddiv+0x65c>)
   2752a:	401a      	ands	r2, r3
   2752c:	2380      	movs	r3, #128	; 0x80
   2752e:	4693      	mov	fp, r2
   27530:	00db      	lsls	r3, r3, #3
   27532:	18e3      	adds	r3, r4, r3
   27534:	4a99      	ldr	r2, [pc, #612]	; (2779c <__aeabi_ddiv+0x660>)
   27536:	4293      	cmp	r3, r2
   27538:	dd68      	ble.n	2760c <__aeabi_ddiv+0x4d0>
   2753a:	2301      	movs	r3, #1
   2753c:	9a02      	ldr	r2, [sp, #8]
   2753e:	4c98      	ldr	r4, [pc, #608]	; (277a0 <__aeabi_ddiv+0x664>)
   27540:	401a      	ands	r2, r3
   27542:	2300      	movs	r3, #0
   27544:	4694      	mov	ip, r2
   27546:	4698      	mov	r8, r3
   27548:	2200      	movs	r2, #0
   2754a:	e6c5      	b.n	272d8 <__aeabi_ddiv+0x19c>
   2754c:	2280      	movs	r2, #128	; 0x80
   2754e:	464b      	mov	r3, r9
   27550:	0312      	lsls	r2, r2, #12
   27552:	4213      	tst	r3, r2
   27554:	d00a      	beq.n	2756c <__aeabi_ddiv+0x430>
   27556:	465b      	mov	r3, fp
   27558:	4213      	tst	r3, r2
   2755a:	d106      	bne.n	2756a <__aeabi_ddiv+0x42e>
   2755c:	431a      	orrs	r2, r3
   2755e:	0312      	lsls	r2, r2, #12
   27560:	0b12      	lsrs	r2, r2, #12
   27562:	46ac      	mov	ip, r5
   27564:	4688      	mov	r8, r1
   27566:	4c8e      	ldr	r4, [pc, #568]	; (277a0 <__aeabi_ddiv+0x664>)
   27568:	e6b6      	b.n	272d8 <__aeabi_ddiv+0x19c>
   2756a:	464b      	mov	r3, r9
   2756c:	431a      	orrs	r2, r3
   2756e:	0312      	lsls	r2, r2, #12
   27570:	0b12      	lsrs	r2, r2, #12
   27572:	46bc      	mov	ip, r7
   27574:	4c8a      	ldr	r4, [pc, #552]	; (277a0 <__aeabi_ddiv+0x664>)
   27576:	e6af      	b.n	272d8 <__aeabi_ddiv+0x19c>
   27578:	0003      	movs	r3, r0
   2757a:	465a      	mov	r2, fp
   2757c:	3b28      	subs	r3, #40	; 0x28
   2757e:	409a      	lsls	r2, r3
   27580:	2300      	movs	r3, #0
   27582:	4691      	mov	r9, r2
   27584:	4698      	mov	r8, r3
   27586:	e657      	b.n	27238 <__aeabi_ddiv+0xfc>
   27588:	4658      	mov	r0, fp
   2758a:	f001 f8c1 	bl	28710 <__clzsi2>
   2758e:	3020      	adds	r0, #32
   27590:	e640      	b.n	27214 <__aeabi_ddiv+0xd8>
   27592:	0003      	movs	r3, r0
   27594:	4652      	mov	r2, sl
   27596:	3b28      	subs	r3, #40	; 0x28
   27598:	409a      	lsls	r2, r3
   2759a:	2100      	movs	r1, #0
   2759c:	4693      	mov	fp, r2
   2759e:	e677      	b.n	27290 <__aeabi_ddiv+0x154>
   275a0:	f001 f8b6 	bl	28710 <__clzsi2>
   275a4:	3020      	adds	r0, #32
   275a6:	e65f      	b.n	27268 <__aeabi_ddiv+0x12c>
   275a8:	4588      	cmp	r8, r1
   275aa:	d200      	bcs.n	275ae <__aeabi_ddiv+0x472>
   275ac:	e6c7      	b.n	2733e <__aeabi_ddiv+0x202>
   275ae:	464b      	mov	r3, r9
   275b0:	07de      	lsls	r6, r3, #31
   275b2:	085d      	lsrs	r5, r3, #1
   275b4:	4643      	mov	r3, r8
   275b6:	085b      	lsrs	r3, r3, #1
   275b8:	431e      	orrs	r6, r3
   275ba:	4643      	mov	r3, r8
   275bc:	07db      	lsls	r3, r3, #31
   275be:	469a      	mov	sl, r3
   275c0:	e6c2      	b.n	27348 <__aeabi_ddiv+0x20c>
   275c2:	2500      	movs	r5, #0
   275c4:	4592      	cmp	sl, r2
   275c6:	d300      	bcc.n	275ca <__aeabi_ddiv+0x48e>
   275c8:	e733      	b.n	27432 <__aeabi_ddiv+0x2f6>
   275ca:	9e03      	ldr	r6, [sp, #12]
   275cc:	4659      	mov	r1, fp
   275ce:	46b4      	mov	ip, r6
   275d0:	44e2      	add	sl, ip
   275d2:	45b2      	cmp	sl, r6
   275d4:	41ad      	sbcs	r5, r5
   275d6:	426d      	negs	r5, r5
   275d8:	4445      	add	r5, r8
   275da:	18eb      	adds	r3, r5, r3
   275dc:	3901      	subs	r1, #1
   275de:	4598      	cmp	r8, r3
   275e0:	d207      	bcs.n	275f2 <__aeabi_ddiv+0x4b6>
   275e2:	4298      	cmp	r0, r3
   275e4:	d900      	bls.n	275e8 <__aeabi_ddiv+0x4ac>
   275e6:	e07f      	b.n	276e8 <__aeabi_ddiv+0x5ac>
   275e8:	d100      	bne.n	275ec <__aeabi_ddiv+0x4b0>
   275ea:	e0bc      	b.n	27766 <__aeabi_ddiv+0x62a>
   275ec:	1a1d      	subs	r5, r3, r0
   275ee:	468b      	mov	fp, r1
   275f0:	e71f      	b.n	27432 <__aeabi_ddiv+0x2f6>
   275f2:	4598      	cmp	r8, r3
   275f4:	d1fa      	bne.n	275ec <__aeabi_ddiv+0x4b0>
   275f6:	9d03      	ldr	r5, [sp, #12]
   275f8:	4555      	cmp	r5, sl
   275fa:	d9f2      	bls.n	275e2 <__aeabi_ddiv+0x4a6>
   275fc:	4643      	mov	r3, r8
   275fe:	468b      	mov	fp, r1
   27600:	1a1d      	subs	r5, r3, r0
   27602:	e716      	b.n	27432 <__aeabi_ddiv+0x2f6>
   27604:	469b      	mov	fp, r3
   27606:	e6ca      	b.n	2739e <__aeabi_ddiv+0x262>
   27608:	0015      	movs	r5, r2
   2760a:	e6e7      	b.n	273dc <__aeabi_ddiv+0x2a0>
   2760c:	465a      	mov	r2, fp
   2760e:	08c9      	lsrs	r1, r1, #3
   27610:	0752      	lsls	r2, r2, #29
   27612:	430a      	orrs	r2, r1
   27614:	055b      	lsls	r3, r3, #21
   27616:	4690      	mov	r8, r2
   27618:	0d5c      	lsrs	r4, r3, #21
   2761a:	465a      	mov	r2, fp
   2761c:	2301      	movs	r3, #1
   2761e:	9902      	ldr	r1, [sp, #8]
   27620:	0252      	lsls	r2, r2, #9
   27622:	4019      	ands	r1, r3
   27624:	0b12      	lsrs	r2, r2, #12
   27626:	468c      	mov	ip, r1
   27628:	e656      	b.n	272d8 <__aeabi_ddiv+0x19c>
   2762a:	2b00      	cmp	r3, #0
   2762c:	d100      	bne.n	27630 <__aeabi_ddiv+0x4f4>
   2762e:	e76f      	b.n	27510 <__aeabi_ddiv+0x3d4>
   27630:	4446      	add	r6, r8
   27632:	1e4a      	subs	r2, r1, #1
   27634:	45b0      	cmp	r8, r6
   27636:	d929      	bls.n	2768c <__aeabi_ddiv+0x550>
   27638:	0011      	movs	r1, r2
   2763a:	4286      	cmp	r6, r0
   2763c:	d000      	beq.n	27640 <__aeabi_ddiv+0x504>
   2763e:	e765      	b.n	2750c <__aeabi_ddiv+0x3d0>
   27640:	9a03      	ldr	r2, [sp, #12]
   27642:	4293      	cmp	r3, r2
   27644:	d000      	beq.n	27648 <__aeabi_ddiv+0x50c>
   27646:	e761      	b.n	2750c <__aeabi_ddiv+0x3d0>
   27648:	e762      	b.n	27510 <__aeabi_ddiv+0x3d4>
   2764a:	2101      	movs	r1, #1
   2764c:	4249      	negs	r1, r1
   2764e:	2001      	movs	r0, #1
   27650:	1ac2      	subs	r2, r0, r3
   27652:	2a38      	cmp	r2, #56	; 0x38
   27654:	dd21      	ble.n	2769a <__aeabi_ddiv+0x55e>
   27656:	9b02      	ldr	r3, [sp, #8]
   27658:	4003      	ands	r3, r0
   2765a:	469c      	mov	ip, r3
   2765c:	e638      	b.n	272d0 <__aeabi_ddiv+0x194>
   2765e:	220f      	movs	r2, #15
   27660:	400a      	ands	r2, r1
   27662:	2a04      	cmp	r2, #4
   27664:	d100      	bne.n	27668 <__aeabi_ddiv+0x52c>
   27666:	e75b      	b.n	27520 <__aeabi_ddiv+0x3e4>
   27668:	000a      	movs	r2, r1
   2766a:	1d11      	adds	r1, r2, #4
   2766c:	4291      	cmp	r1, r2
   2766e:	4192      	sbcs	r2, r2
   27670:	4252      	negs	r2, r2
   27672:	4493      	add	fp, r2
   27674:	e754      	b.n	27520 <__aeabi_ddiv+0x3e4>
   27676:	4b47      	ldr	r3, [pc, #284]	; (27794 <__aeabi_ddiv+0x658>)
   27678:	18e3      	adds	r3, r4, r3
   2767a:	2b00      	cmp	r3, #0
   2767c:	dde5      	ble.n	2764a <__aeabi_ddiv+0x50e>
   2767e:	2201      	movs	r2, #1
   27680:	4252      	negs	r2, r2
   27682:	e7f2      	b.n	2766a <__aeabi_ddiv+0x52e>
   27684:	001d      	movs	r5, r3
   27686:	e6fa      	b.n	2747e <__aeabi_ddiv+0x342>
   27688:	469a      	mov	sl, r3
   2768a:	e71c      	b.n	274c6 <__aeabi_ddiv+0x38a>
   2768c:	42b0      	cmp	r0, r6
   2768e:	d839      	bhi.n	27704 <__aeabi_ddiv+0x5c8>
   27690:	d06e      	beq.n	27770 <__aeabi_ddiv+0x634>
   27692:	0011      	movs	r1, r2
   27694:	e73a      	b.n	2750c <__aeabi_ddiv+0x3d0>
   27696:	9302      	str	r3, [sp, #8]
   27698:	e73a      	b.n	27510 <__aeabi_ddiv+0x3d4>
   2769a:	2a1f      	cmp	r2, #31
   2769c:	dc3c      	bgt.n	27718 <__aeabi_ddiv+0x5dc>
   2769e:	2320      	movs	r3, #32
   276a0:	1a9b      	subs	r3, r3, r2
   276a2:	000c      	movs	r4, r1
   276a4:	4658      	mov	r0, fp
   276a6:	4099      	lsls	r1, r3
   276a8:	4098      	lsls	r0, r3
   276aa:	1e4b      	subs	r3, r1, #1
   276ac:	4199      	sbcs	r1, r3
   276ae:	465b      	mov	r3, fp
   276b0:	40d4      	lsrs	r4, r2
   276b2:	40d3      	lsrs	r3, r2
   276b4:	4320      	orrs	r0, r4
   276b6:	4308      	orrs	r0, r1
   276b8:	001a      	movs	r2, r3
   276ba:	0743      	lsls	r3, r0, #29
   276bc:	d009      	beq.n	276d2 <__aeabi_ddiv+0x596>
   276be:	230f      	movs	r3, #15
   276c0:	4003      	ands	r3, r0
   276c2:	2b04      	cmp	r3, #4
   276c4:	d005      	beq.n	276d2 <__aeabi_ddiv+0x596>
   276c6:	0001      	movs	r1, r0
   276c8:	1d08      	adds	r0, r1, #4
   276ca:	4288      	cmp	r0, r1
   276cc:	419b      	sbcs	r3, r3
   276ce:	425b      	negs	r3, r3
   276d0:	18d2      	adds	r2, r2, r3
   276d2:	0213      	lsls	r3, r2, #8
   276d4:	d53a      	bpl.n	2774c <__aeabi_ddiv+0x610>
   276d6:	2301      	movs	r3, #1
   276d8:	9a02      	ldr	r2, [sp, #8]
   276da:	2401      	movs	r4, #1
   276dc:	401a      	ands	r2, r3
   276de:	2300      	movs	r3, #0
   276e0:	4694      	mov	ip, r2
   276e2:	4698      	mov	r8, r3
   276e4:	2200      	movs	r2, #0
   276e6:	e5f7      	b.n	272d8 <__aeabi_ddiv+0x19c>
   276e8:	2102      	movs	r1, #2
   276ea:	4249      	negs	r1, r1
   276ec:	468c      	mov	ip, r1
   276ee:	9d03      	ldr	r5, [sp, #12]
   276f0:	44e3      	add	fp, ip
   276f2:	46ac      	mov	ip, r5
   276f4:	44e2      	add	sl, ip
   276f6:	45aa      	cmp	sl, r5
   276f8:	41ad      	sbcs	r5, r5
   276fa:	426d      	negs	r5, r5
   276fc:	4445      	add	r5, r8
   276fe:	18ed      	adds	r5, r5, r3
   27700:	1a2d      	subs	r5, r5, r0
   27702:	e696      	b.n	27432 <__aeabi_ddiv+0x2f6>
   27704:	1e8a      	subs	r2, r1, #2
   27706:	9903      	ldr	r1, [sp, #12]
   27708:	004d      	lsls	r5, r1, #1
   2770a:	428d      	cmp	r5, r1
   2770c:	4189      	sbcs	r1, r1
   2770e:	4249      	negs	r1, r1
   27710:	4441      	add	r1, r8
   27712:	1876      	adds	r6, r6, r1
   27714:	9503      	str	r5, [sp, #12]
   27716:	e78f      	b.n	27638 <__aeabi_ddiv+0x4fc>
   27718:	201f      	movs	r0, #31
   2771a:	4240      	negs	r0, r0
   2771c:	1ac3      	subs	r3, r0, r3
   2771e:	4658      	mov	r0, fp
   27720:	40d8      	lsrs	r0, r3
   27722:	0003      	movs	r3, r0
   27724:	2a20      	cmp	r2, #32
   27726:	d028      	beq.n	2777a <__aeabi_ddiv+0x63e>
   27728:	2040      	movs	r0, #64	; 0x40
   2772a:	465d      	mov	r5, fp
   2772c:	1a82      	subs	r2, r0, r2
   2772e:	4095      	lsls	r5, r2
   27730:	4329      	orrs	r1, r5
   27732:	1e4a      	subs	r2, r1, #1
   27734:	4191      	sbcs	r1, r2
   27736:	4319      	orrs	r1, r3
   27738:	2307      	movs	r3, #7
   2773a:	2200      	movs	r2, #0
   2773c:	400b      	ands	r3, r1
   2773e:	d009      	beq.n	27754 <__aeabi_ddiv+0x618>
   27740:	230f      	movs	r3, #15
   27742:	2200      	movs	r2, #0
   27744:	400b      	ands	r3, r1
   27746:	0008      	movs	r0, r1
   27748:	2b04      	cmp	r3, #4
   2774a:	d1bd      	bne.n	276c8 <__aeabi_ddiv+0x58c>
   2774c:	0001      	movs	r1, r0
   2774e:	0753      	lsls	r3, r2, #29
   27750:	0252      	lsls	r2, r2, #9
   27752:	0b12      	lsrs	r2, r2, #12
   27754:	08c9      	lsrs	r1, r1, #3
   27756:	4319      	orrs	r1, r3
   27758:	2301      	movs	r3, #1
   2775a:	4688      	mov	r8, r1
   2775c:	9902      	ldr	r1, [sp, #8]
   2775e:	2400      	movs	r4, #0
   27760:	4019      	ands	r1, r3
   27762:	468c      	mov	ip, r1
   27764:	e5b8      	b.n	272d8 <__aeabi_ddiv+0x19c>
   27766:	4552      	cmp	r2, sl
   27768:	d8be      	bhi.n	276e8 <__aeabi_ddiv+0x5ac>
   2776a:	468b      	mov	fp, r1
   2776c:	2500      	movs	r5, #0
   2776e:	e660      	b.n	27432 <__aeabi_ddiv+0x2f6>
   27770:	9d03      	ldr	r5, [sp, #12]
   27772:	429d      	cmp	r5, r3
   27774:	d3c6      	bcc.n	27704 <__aeabi_ddiv+0x5c8>
   27776:	0011      	movs	r1, r2
   27778:	e762      	b.n	27640 <__aeabi_ddiv+0x504>
   2777a:	2500      	movs	r5, #0
   2777c:	e7d8      	b.n	27730 <__aeabi_ddiv+0x5f4>
   2777e:	2280      	movs	r2, #128	; 0x80
   27780:	465b      	mov	r3, fp
   27782:	0312      	lsls	r2, r2, #12
   27784:	431a      	orrs	r2, r3
   27786:	9b01      	ldr	r3, [sp, #4]
   27788:	0312      	lsls	r2, r2, #12
   2778a:	0b12      	lsrs	r2, r2, #12
   2778c:	469c      	mov	ip, r3
   2778e:	4688      	mov	r8, r1
   27790:	4c03      	ldr	r4, [pc, #12]	; (277a0 <__aeabi_ddiv+0x664>)
   27792:	e5a1      	b.n	272d8 <__aeabi_ddiv+0x19c>
   27794:	000003ff 	.word	0x000003ff
   27798:	feffffff 	.word	0xfeffffff
   2779c:	000007fe 	.word	0x000007fe
   277a0:	000007ff 	.word	0x000007ff

000277a4 <__eqdf2>:
   277a4:	b5f0      	push	{r4, r5, r6, r7, lr}
   277a6:	464f      	mov	r7, r9
   277a8:	4646      	mov	r6, r8
   277aa:	46d6      	mov	lr, sl
   277ac:	005c      	lsls	r4, r3, #1
   277ae:	b5c0      	push	{r6, r7, lr}
   277b0:	031f      	lsls	r7, r3, #12
   277b2:	0fdb      	lsrs	r3, r3, #31
   277b4:	469a      	mov	sl, r3
   277b6:	4b17      	ldr	r3, [pc, #92]	; (27814 <__eqdf2+0x70>)
   277b8:	030e      	lsls	r6, r1, #12
   277ba:	004d      	lsls	r5, r1, #1
   277bc:	4684      	mov	ip, r0
   277be:	4680      	mov	r8, r0
   277c0:	0b36      	lsrs	r6, r6, #12
   277c2:	0d6d      	lsrs	r5, r5, #21
   277c4:	0fc9      	lsrs	r1, r1, #31
   277c6:	4691      	mov	r9, r2
   277c8:	0b3f      	lsrs	r7, r7, #12
   277ca:	0d64      	lsrs	r4, r4, #21
   277cc:	2001      	movs	r0, #1
   277ce:	429d      	cmp	r5, r3
   277d0:	d008      	beq.n	277e4 <__eqdf2+0x40>
   277d2:	429c      	cmp	r4, r3
   277d4:	d001      	beq.n	277da <__eqdf2+0x36>
   277d6:	42a5      	cmp	r5, r4
   277d8:	d00b      	beq.n	277f2 <__eqdf2+0x4e>
   277da:	bc1c      	pop	{r2, r3, r4}
   277dc:	4690      	mov	r8, r2
   277de:	4699      	mov	r9, r3
   277e0:	46a2      	mov	sl, r4
   277e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   277e4:	4663      	mov	r3, ip
   277e6:	4333      	orrs	r3, r6
   277e8:	d1f7      	bne.n	277da <__eqdf2+0x36>
   277ea:	42ac      	cmp	r4, r5
   277ec:	d1f5      	bne.n	277da <__eqdf2+0x36>
   277ee:	433a      	orrs	r2, r7
   277f0:	d1f3      	bne.n	277da <__eqdf2+0x36>
   277f2:	2001      	movs	r0, #1
   277f4:	42be      	cmp	r6, r7
   277f6:	d1f0      	bne.n	277da <__eqdf2+0x36>
   277f8:	45c8      	cmp	r8, r9
   277fa:	d1ee      	bne.n	277da <__eqdf2+0x36>
   277fc:	4551      	cmp	r1, sl
   277fe:	d007      	beq.n	27810 <__eqdf2+0x6c>
   27800:	2d00      	cmp	r5, #0
   27802:	d1ea      	bne.n	277da <__eqdf2+0x36>
   27804:	4663      	mov	r3, ip
   27806:	431e      	orrs	r6, r3
   27808:	0030      	movs	r0, r6
   2780a:	1e46      	subs	r6, r0, #1
   2780c:	41b0      	sbcs	r0, r6
   2780e:	e7e4      	b.n	277da <__eqdf2+0x36>
   27810:	2000      	movs	r0, #0
   27812:	e7e2      	b.n	277da <__eqdf2+0x36>
   27814:	000007ff 	.word	0x000007ff

00027818 <__gedf2>:
   27818:	b5f0      	push	{r4, r5, r6, r7, lr}
   2781a:	4645      	mov	r5, r8
   2781c:	46de      	mov	lr, fp
   2781e:	4657      	mov	r7, sl
   27820:	464e      	mov	r6, r9
   27822:	b5e0      	push	{r5, r6, r7, lr}
   27824:	031f      	lsls	r7, r3, #12
   27826:	0b3d      	lsrs	r5, r7, #12
   27828:	4f2c      	ldr	r7, [pc, #176]	; (278dc <__gedf2+0xc4>)
   2782a:	030e      	lsls	r6, r1, #12
   2782c:	004c      	lsls	r4, r1, #1
   2782e:	46ab      	mov	fp, r5
   27830:	005d      	lsls	r5, r3, #1
   27832:	4684      	mov	ip, r0
   27834:	0b36      	lsrs	r6, r6, #12
   27836:	0d64      	lsrs	r4, r4, #21
   27838:	0fc9      	lsrs	r1, r1, #31
   2783a:	4690      	mov	r8, r2
   2783c:	0d6d      	lsrs	r5, r5, #21
   2783e:	0fdb      	lsrs	r3, r3, #31
   27840:	42bc      	cmp	r4, r7
   27842:	d02a      	beq.n	2789a <__gedf2+0x82>
   27844:	4f25      	ldr	r7, [pc, #148]	; (278dc <__gedf2+0xc4>)
   27846:	42bd      	cmp	r5, r7
   27848:	d02d      	beq.n	278a6 <__gedf2+0x8e>
   2784a:	2c00      	cmp	r4, #0
   2784c:	d10f      	bne.n	2786e <__gedf2+0x56>
   2784e:	4330      	orrs	r0, r6
   27850:	0007      	movs	r7, r0
   27852:	4681      	mov	r9, r0
   27854:	4278      	negs	r0, r7
   27856:	4178      	adcs	r0, r7
   27858:	b2c0      	uxtb	r0, r0
   2785a:	2d00      	cmp	r5, #0
   2785c:	d117      	bne.n	2788e <__gedf2+0x76>
   2785e:	465f      	mov	r7, fp
   27860:	433a      	orrs	r2, r7
   27862:	d114      	bne.n	2788e <__gedf2+0x76>
   27864:	464b      	mov	r3, r9
   27866:	2000      	movs	r0, #0
   27868:	2b00      	cmp	r3, #0
   2786a:	d00a      	beq.n	27882 <__gedf2+0x6a>
   2786c:	e006      	b.n	2787c <__gedf2+0x64>
   2786e:	2d00      	cmp	r5, #0
   27870:	d102      	bne.n	27878 <__gedf2+0x60>
   27872:	4658      	mov	r0, fp
   27874:	4302      	orrs	r2, r0
   27876:	d001      	beq.n	2787c <__gedf2+0x64>
   27878:	4299      	cmp	r1, r3
   2787a:	d018      	beq.n	278ae <__gedf2+0x96>
   2787c:	4248      	negs	r0, r1
   2787e:	2101      	movs	r1, #1
   27880:	4308      	orrs	r0, r1
   27882:	bc3c      	pop	{r2, r3, r4, r5}
   27884:	4690      	mov	r8, r2
   27886:	4699      	mov	r9, r3
   27888:	46a2      	mov	sl, r4
   2788a:	46ab      	mov	fp, r5
   2788c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2788e:	2800      	cmp	r0, #0
   27890:	d0f2      	beq.n	27878 <__gedf2+0x60>
   27892:	2001      	movs	r0, #1
   27894:	3b01      	subs	r3, #1
   27896:	4318      	orrs	r0, r3
   27898:	e7f3      	b.n	27882 <__gedf2+0x6a>
   2789a:	0037      	movs	r7, r6
   2789c:	4307      	orrs	r7, r0
   2789e:	d0d1      	beq.n	27844 <__gedf2+0x2c>
   278a0:	2002      	movs	r0, #2
   278a2:	4240      	negs	r0, r0
   278a4:	e7ed      	b.n	27882 <__gedf2+0x6a>
   278a6:	465f      	mov	r7, fp
   278a8:	4317      	orrs	r7, r2
   278aa:	d0ce      	beq.n	2784a <__gedf2+0x32>
   278ac:	e7f8      	b.n	278a0 <__gedf2+0x88>
   278ae:	42ac      	cmp	r4, r5
   278b0:	dce4      	bgt.n	2787c <__gedf2+0x64>
   278b2:	da03      	bge.n	278bc <__gedf2+0xa4>
   278b4:	1e48      	subs	r0, r1, #1
   278b6:	2101      	movs	r1, #1
   278b8:	4308      	orrs	r0, r1
   278ba:	e7e2      	b.n	27882 <__gedf2+0x6a>
   278bc:	455e      	cmp	r6, fp
   278be:	d8dd      	bhi.n	2787c <__gedf2+0x64>
   278c0:	d006      	beq.n	278d0 <__gedf2+0xb8>
   278c2:	2000      	movs	r0, #0
   278c4:	455e      	cmp	r6, fp
   278c6:	d2dc      	bcs.n	27882 <__gedf2+0x6a>
   278c8:	2301      	movs	r3, #1
   278ca:	1e48      	subs	r0, r1, #1
   278cc:	4318      	orrs	r0, r3
   278ce:	e7d8      	b.n	27882 <__gedf2+0x6a>
   278d0:	45c4      	cmp	ip, r8
   278d2:	d8d3      	bhi.n	2787c <__gedf2+0x64>
   278d4:	2000      	movs	r0, #0
   278d6:	45c4      	cmp	ip, r8
   278d8:	d3f6      	bcc.n	278c8 <__gedf2+0xb0>
   278da:	e7d2      	b.n	27882 <__gedf2+0x6a>
   278dc:	000007ff 	.word	0x000007ff

000278e0 <__ledf2>:
   278e0:	b5f0      	push	{r4, r5, r6, r7, lr}
   278e2:	464e      	mov	r6, r9
   278e4:	4645      	mov	r5, r8
   278e6:	46de      	mov	lr, fp
   278e8:	4657      	mov	r7, sl
   278ea:	005c      	lsls	r4, r3, #1
   278ec:	b5e0      	push	{r5, r6, r7, lr}
   278ee:	031f      	lsls	r7, r3, #12
   278f0:	0fdb      	lsrs	r3, r3, #31
   278f2:	4699      	mov	r9, r3
   278f4:	4b2a      	ldr	r3, [pc, #168]	; (279a0 <__ledf2+0xc0>)
   278f6:	030e      	lsls	r6, r1, #12
   278f8:	004d      	lsls	r5, r1, #1
   278fa:	0fc9      	lsrs	r1, r1, #31
   278fc:	4684      	mov	ip, r0
   278fe:	0b36      	lsrs	r6, r6, #12
   27900:	0d6d      	lsrs	r5, r5, #21
   27902:	468b      	mov	fp, r1
   27904:	4690      	mov	r8, r2
   27906:	0b3f      	lsrs	r7, r7, #12
   27908:	0d64      	lsrs	r4, r4, #21
   2790a:	429d      	cmp	r5, r3
   2790c:	d020      	beq.n	27950 <__ledf2+0x70>
   2790e:	4b24      	ldr	r3, [pc, #144]	; (279a0 <__ledf2+0xc0>)
   27910:	429c      	cmp	r4, r3
   27912:	d022      	beq.n	2795a <__ledf2+0x7a>
   27914:	2d00      	cmp	r5, #0
   27916:	d112      	bne.n	2793e <__ledf2+0x5e>
   27918:	4330      	orrs	r0, r6
   2791a:	4243      	negs	r3, r0
   2791c:	4143      	adcs	r3, r0
   2791e:	b2db      	uxtb	r3, r3
   27920:	2c00      	cmp	r4, #0
   27922:	d01f      	beq.n	27964 <__ledf2+0x84>
   27924:	2b00      	cmp	r3, #0
   27926:	d00c      	beq.n	27942 <__ledf2+0x62>
   27928:	464b      	mov	r3, r9
   2792a:	2001      	movs	r0, #1
   2792c:	3b01      	subs	r3, #1
   2792e:	4303      	orrs	r3, r0
   27930:	0018      	movs	r0, r3
   27932:	bc3c      	pop	{r2, r3, r4, r5}
   27934:	4690      	mov	r8, r2
   27936:	4699      	mov	r9, r3
   27938:	46a2      	mov	sl, r4
   2793a:	46ab      	mov	fp, r5
   2793c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2793e:	2c00      	cmp	r4, #0
   27940:	d016      	beq.n	27970 <__ledf2+0x90>
   27942:	45cb      	cmp	fp, r9
   27944:	d017      	beq.n	27976 <__ledf2+0x96>
   27946:	465b      	mov	r3, fp
   27948:	4259      	negs	r1, r3
   2794a:	2301      	movs	r3, #1
   2794c:	430b      	orrs	r3, r1
   2794e:	e7ef      	b.n	27930 <__ledf2+0x50>
   27950:	0031      	movs	r1, r6
   27952:	2302      	movs	r3, #2
   27954:	4301      	orrs	r1, r0
   27956:	d1eb      	bne.n	27930 <__ledf2+0x50>
   27958:	e7d9      	b.n	2790e <__ledf2+0x2e>
   2795a:	0039      	movs	r1, r7
   2795c:	2302      	movs	r3, #2
   2795e:	4311      	orrs	r1, r2
   27960:	d1e6      	bne.n	27930 <__ledf2+0x50>
   27962:	e7d7      	b.n	27914 <__ledf2+0x34>
   27964:	433a      	orrs	r2, r7
   27966:	d1dd      	bne.n	27924 <__ledf2+0x44>
   27968:	2300      	movs	r3, #0
   2796a:	2800      	cmp	r0, #0
   2796c:	d0e0      	beq.n	27930 <__ledf2+0x50>
   2796e:	e7ea      	b.n	27946 <__ledf2+0x66>
   27970:	433a      	orrs	r2, r7
   27972:	d1e6      	bne.n	27942 <__ledf2+0x62>
   27974:	e7e7      	b.n	27946 <__ledf2+0x66>
   27976:	42a5      	cmp	r5, r4
   27978:	dce5      	bgt.n	27946 <__ledf2+0x66>
   2797a:	db05      	blt.n	27988 <__ledf2+0xa8>
   2797c:	42be      	cmp	r6, r7
   2797e:	d8e2      	bhi.n	27946 <__ledf2+0x66>
   27980:	d007      	beq.n	27992 <__ledf2+0xb2>
   27982:	2300      	movs	r3, #0
   27984:	42be      	cmp	r6, r7
   27986:	d2d3      	bcs.n	27930 <__ledf2+0x50>
   27988:	4659      	mov	r1, fp
   2798a:	2301      	movs	r3, #1
   2798c:	3901      	subs	r1, #1
   2798e:	430b      	orrs	r3, r1
   27990:	e7ce      	b.n	27930 <__ledf2+0x50>
   27992:	45c4      	cmp	ip, r8
   27994:	d8d7      	bhi.n	27946 <__ledf2+0x66>
   27996:	2300      	movs	r3, #0
   27998:	45c4      	cmp	ip, r8
   2799a:	d3f5      	bcc.n	27988 <__ledf2+0xa8>
   2799c:	e7c8      	b.n	27930 <__ledf2+0x50>
   2799e:	46c0      	nop			; (mov r8, r8)
   279a0:	000007ff 	.word	0x000007ff

000279a4 <__aeabi_dmul>:
   279a4:	b5f0      	push	{r4, r5, r6, r7, lr}
   279a6:	4657      	mov	r7, sl
   279a8:	4645      	mov	r5, r8
   279aa:	46de      	mov	lr, fp
   279ac:	464e      	mov	r6, r9
   279ae:	b5e0      	push	{r5, r6, r7, lr}
   279b0:	030c      	lsls	r4, r1, #12
   279b2:	4698      	mov	r8, r3
   279b4:	004e      	lsls	r6, r1, #1
   279b6:	0b23      	lsrs	r3, r4, #12
   279b8:	b087      	sub	sp, #28
   279ba:	0007      	movs	r7, r0
   279bc:	4692      	mov	sl, r2
   279be:	469b      	mov	fp, r3
   279c0:	0d76      	lsrs	r6, r6, #21
   279c2:	0fcd      	lsrs	r5, r1, #31
   279c4:	2e00      	cmp	r6, #0
   279c6:	d06b      	beq.n	27aa0 <__aeabi_dmul+0xfc>
   279c8:	4b6d      	ldr	r3, [pc, #436]	; (27b80 <__aeabi_dmul+0x1dc>)
   279ca:	429e      	cmp	r6, r3
   279cc:	d035      	beq.n	27a3a <__aeabi_dmul+0x96>
   279ce:	2480      	movs	r4, #128	; 0x80
   279d0:	465b      	mov	r3, fp
   279d2:	0f42      	lsrs	r2, r0, #29
   279d4:	0424      	lsls	r4, r4, #16
   279d6:	00db      	lsls	r3, r3, #3
   279d8:	4314      	orrs	r4, r2
   279da:	431c      	orrs	r4, r3
   279dc:	00c3      	lsls	r3, r0, #3
   279de:	4699      	mov	r9, r3
   279e0:	4b68      	ldr	r3, [pc, #416]	; (27b84 <__aeabi_dmul+0x1e0>)
   279e2:	46a3      	mov	fp, r4
   279e4:	469c      	mov	ip, r3
   279e6:	2300      	movs	r3, #0
   279e8:	2700      	movs	r7, #0
   279ea:	4466      	add	r6, ip
   279ec:	9302      	str	r3, [sp, #8]
   279ee:	4643      	mov	r3, r8
   279f0:	031c      	lsls	r4, r3, #12
   279f2:	005a      	lsls	r2, r3, #1
   279f4:	0fdb      	lsrs	r3, r3, #31
   279f6:	4650      	mov	r0, sl
   279f8:	0b24      	lsrs	r4, r4, #12
   279fa:	0d52      	lsrs	r2, r2, #21
   279fc:	4698      	mov	r8, r3
   279fe:	d100      	bne.n	27a02 <__aeabi_dmul+0x5e>
   27a00:	e076      	b.n	27af0 <__aeabi_dmul+0x14c>
   27a02:	4b5f      	ldr	r3, [pc, #380]	; (27b80 <__aeabi_dmul+0x1dc>)
   27a04:	429a      	cmp	r2, r3
   27a06:	d06d      	beq.n	27ae4 <__aeabi_dmul+0x140>
   27a08:	2380      	movs	r3, #128	; 0x80
   27a0a:	0f41      	lsrs	r1, r0, #29
   27a0c:	041b      	lsls	r3, r3, #16
   27a0e:	430b      	orrs	r3, r1
   27a10:	495c      	ldr	r1, [pc, #368]	; (27b84 <__aeabi_dmul+0x1e0>)
   27a12:	00e4      	lsls	r4, r4, #3
   27a14:	468c      	mov	ip, r1
   27a16:	431c      	orrs	r4, r3
   27a18:	00c3      	lsls	r3, r0, #3
   27a1a:	2000      	movs	r0, #0
   27a1c:	4462      	add	r2, ip
   27a1e:	4641      	mov	r1, r8
   27a20:	18b6      	adds	r6, r6, r2
   27a22:	4069      	eors	r1, r5
   27a24:	1c72      	adds	r2, r6, #1
   27a26:	9101      	str	r1, [sp, #4]
   27a28:	4694      	mov	ip, r2
   27a2a:	4307      	orrs	r7, r0
   27a2c:	2f0f      	cmp	r7, #15
   27a2e:	d900      	bls.n	27a32 <__aeabi_dmul+0x8e>
   27a30:	e0b0      	b.n	27b94 <__aeabi_dmul+0x1f0>
   27a32:	4a55      	ldr	r2, [pc, #340]	; (27b88 <__aeabi_dmul+0x1e4>)
   27a34:	00bf      	lsls	r7, r7, #2
   27a36:	59d2      	ldr	r2, [r2, r7]
   27a38:	4697      	mov	pc, r2
   27a3a:	465b      	mov	r3, fp
   27a3c:	4303      	orrs	r3, r0
   27a3e:	4699      	mov	r9, r3
   27a40:	d000      	beq.n	27a44 <__aeabi_dmul+0xa0>
   27a42:	e087      	b.n	27b54 <__aeabi_dmul+0x1b0>
   27a44:	2300      	movs	r3, #0
   27a46:	469b      	mov	fp, r3
   27a48:	3302      	adds	r3, #2
   27a4a:	2708      	movs	r7, #8
   27a4c:	9302      	str	r3, [sp, #8]
   27a4e:	e7ce      	b.n	279ee <__aeabi_dmul+0x4a>
   27a50:	4642      	mov	r2, r8
   27a52:	9201      	str	r2, [sp, #4]
   27a54:	2802      	cmp	r0, #2
   27a56:	d067      	beq.n	27b28 <__aeabi_dmul+0x184>
   27a58:	2803      	cmp	r0, #3
   27a5a:	d100      	bne.n	27a5e <__aeabi_dmul+0xba>
   27a5c:	e20e      	b.n	27e7c <__aeabi_dmul+0x4d8>
   27a5e:	2801      	cmp	r0, #1
   27a60:	d000      	beq.n	27a64 <__aeabi_dmul+0xc0>
   27a62:	e162      	b.n	27d2a <__aeabi_dmul+0x386>
   27a64:	2300      	movs	r3, #0
   27a66:	2400      	movs	r4, #0
   27a68:	2200      	movs	r2, #0
   27a6a:	4699      	mov	r9, r3
   27a6c:	9901      	ldr	r1, [sp, #4]
   27a6e:	4001      	ands	r1, r0
   27a70:	b2cd      	uxtb	r5, r1
   27a72:	2100      	movs	r1, #0
   27a74:	0312      	lsls	r2, r2, #12
   27a76:	0d0b      	lsrs	r3, r1, #20
   27a78:	0b12      	lsrs	r2, r2, #12
   27a7a:	051b      	lsls	r3, r3, #20
   27a7c:	4313      	orrs	r3, r2
   27a7e:	4a43      	ldr	r2, [pc, #268]	; (27b8c <__aeabi_dmul+0x1e8>)
   27a80:	0524      	lsls	r4, r4, #20
   27a82:	4013      	ands	r3, r2
   27a84:	431c      	orrs	r4, r3
   27a86:	0064      	lsls	r4, r4, #1
   27a88:	07ed      	lsls	r5, r5, #31
   27a8a:	0864      	lsrs	r4, r4, #1
   27a8c:	432c      	orrs	r4, r5
   27a8e:	4648      	mov	r0, r9
   27a90:	0021      	movs	r1, r4
   27a92:	b007      	add	sp, #28
   27a94:	bc3c      	pop	{r2, r3, r4, r5}
   27a96:	4690      	mov	r8, r2
   27a98:	4699      	mov	r9, r3
   27a9a:	46a2      	mov	sl, r4
   27a9c:	46ab      	mov	fp, r5
   27a9e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   27aa0:	4303      	orrs	r3, r0
   27aa2:	4699      	mov	r9, r3
   27aa4:	d04f      	beq.n	27b46 <__aeabi_dmul+0x1a2>
   27aa6:	465b      	mov	r3, fp
   27aa8:	2b00      	cmp	r3, #0
   27aaa:	d100      	bne.n	27aae <__aeabi_dmul+0x10a>
   27aac:	e189      	b.n	27dc2 <__aeabi_dmul+0x41e>
   27aae:	4658      	mov	r0, fp
   27ab0:	f000 fe2e 	bl	28710 <__clzsi2>
   27ab4:	0003      	movs	r3, r0
   27ab6:	3b0b      	subs	r3, #11
   27ab8:	2b1c      	cmp	r3, #28
   27aba:	dd00      	ble.n	27abe <__aeabi_dmul+0x11a>
   27abc:	e17a      	b.n	27db4 <__aeabi_dmul+0x410>
   27abe:	221d      	movs	r2, #29
   27ac0:	1ad3      	subs	r3, r2, r3
   27ac2:	003a      	movs	r2, r7
   27ac4:	0001      	movs	r1, r0
   27ac6:	465c      	mov	r4, fp
   27ac8:	40da      	lsrs	r2, r3
   27aca:	3908      	subs	r1, #8
   27acc:	408c      	lsls	r4, r1
   27ace:	0013      	movs	r3, r2
   27ad0:	408f      	lsls	r7, r1
   27ad2:	4323      	orrs	r3, r4
   27ad4:	469b      	mov	fp, r3
   27ad6:	46b9      	mov	r9, r7
   27ad8:	2300      	movs	r3, #0
   27ada:	4e2d      	ldr	r6, [pc, #180]	; (27b90 <__aeabi_dmul+0x1ec>)
   27adc:	2700      	movs	r7, #0
   27ade:	1a36      	subs	r6, r6, r0
   27ae0:	9302      	str	r3, [sp, #8]
   27ae2:	e784      	b.n	279ee <__aeabi_dmul+0x4a>
   27ae4:	4653      	mov	r3, sl
   27ae6:	4323      	orrs	r3, r4
   27ae8:	d12a      	bne.n	27b40 <__aeabi_dmul+0x19c>
   27aea:	2400      	movs	r4, #0
   27aec:	2002      	movs	r0, #2
   27aee:	e796      	b.n	27a1e <__aeabi_dmul+0x7a>
   27af0:	4653      	mov	r3, sl
   27af2:	4323      	orrs	r3, r4
   27af4:	d020      	beq.n	27b38 <__aeabi_dmul+0x194>
   27af6:	2c00      	cmp	r4, #0
   27af8:	d100      	bne.n	27afc <__aeabi_dmul+0x158>
   27afa:	e157      	b.n	27dac <__aeabi_dmul+0x408>
   27afc:	0020      	movs	r0, r4
   27afe:	f000 fe07 	bl	28710 <__clzsi2>
   27b02:	0003      	movs	r3, r0
   27b04:	3b0b      	subs	r3, #11
   27b06:	2b1c      	cmp	r3, #28
   27b08:	dd00      	ble.n	27b0c <__aeabi_dmul+0x168>
   27b0a:	e149      	b.n	27da0 <__aeabi_dmul+0x3fc>
   27b0c:	211d      	movs	r1, #29
   27b0e:	1acb      	subs	r3, r1, r3
   27b10:	4651      	mov	r1, sl
   27b12:	0002      	movs	r2, r0
   27b14:	40d9      	lsrs	r1, r3
   27b16:	4653      	mov	r3, sl
   27b18:	3a08      	subs	r2, #8
   27b1a:	4094      	lsls	r4, r2
   27b1c:	4093      	lsls	r3, r2
   27b1e:	430c      	orrs	r4, r1
   27b20:	4a1b      	ldr	r2, [pc, #108]	; (27b90 <__aeabi_dmul+0x1ec>)
   27b22:	1a12      	subs	r2, r2, r0
   27b24:	2000      	movs	r0, #0
   27b26:	e77a      	b.n	27a1e <__aeabi_dmul+0x7a>
   27b28:	2501      	movs	r5, #1
   27b2a:	9b01      	ldr	r3, [sp, #4]
   27b2c:	4c14      	ldr	r4, [pc, #80]	; (27b80 <__aeabi_dmul+0x1dc>)
   27b2e:	401d      	ands	r5, r3
   27b30:	2300      	movs	r3, #0
   27b32:	2200      	movs	r2, #0
   27b34:	4699      	mov	r9, r3
   27b36:	e79c      	b.n	27a72 <__aeabi_dmul+0xce>
   27b38:	2400      	movs	r4, #0
   27b3a:	2200      	movs	r2, #0
   27b3c:	2001      	movs	r0, #1
   27b3e:	e76e      	b.n	27a1e <__aeabi_dmul+0x7a>
   27b40:	4653      	mov	r3, sl
   27b42:	2003      	movs	r0, #3
   27b44:	e76b      	b.n	27a1e <__aeabi_dmul+0x7a>
   27b46:	2300      	movs	r3, #0
   27b48:	469b      	mov	fp, r3
   27b4a:	3301      	adds	r3, #1
   27b4c:	2704      	movs	r7, #4
   27b4e:	2600      	movs	r6, #0
   27b50:	9302      	str	r3, [sp, #8]
   27b52:	e74c      	b.n	279ee <__aeabi_dmul+0x4a>
   27b54:	2303      	movs	r3, #3
   27b56:	4681      	mov	r9, r0
   27b58:	270c      	movs	r7, #12
   27b5a:	9302      	str	r3, [sp, #8]
   27b5c:	e747      	b.n	279ee <__aeabi_dmul+0x4a>
   27b5e:	2280      	movs	r2, #128	; 0x80
   27b60:	2300      	movs	r3, #0
   27b62:	2500      	movs	r5, #0
   27b64:	0312      	lsls	r2, r2, #12
   27b66:	4699      	mov	r9, r3
   27b68:	4c05      	ldr	r4, [pc, #20]	; (27b80 <__aeabi_dmul+0x1dc>)
   27b6a:	e782      	b.n	27a72 <__aeabi_dmul+0xce>
   27b6c:	465c      	mov	r4, fp
   27b6e:	464b      	mov	r3, r9
   27b70:	9802      	ldr	r0, [sp, #8]
   27b72:	e76f      	b.n	27a54 <__aeabi_dmul+0xb0>
   27b74:	465c      	mov	r4, fp
   27b76:	464b      	mov	r3, r9
   27b78:	9501      	str	r5, [sp, #4]
   27b7a:	9802      	ldr	r0, [sp, #8]
   27b7c:	e76a      	b.n	27a54 <__aeabi_dmul+0xb0>
   27b7e:	46c0      	nop			; (mov r8, r8)
   27b80:	000007ff 	.word	0x000007ff
   27b84:	fffffc01 	.word	0xfffffc01
   27b88:	0002ba28 	.word	0x0002ba28
   27b8c:	800fffff 	.word	0x800fffff
   27b90:	fffffc0d 	.word	0xfffffc0d
   27b94:	464a      	mov	r2, r9
   27b96:	4649      	mov	r1, r9
   27b98:	0c17      	lsrs	r7, r2, #16
   27b9a:	0c1a      	lsrs	r2, r3, #16
   27b9c:	041b      	lsls	r3, r3, #16
   27b9e:	0c1b      	lsrs	r3, r3, #16
   27ba0:	0408      	lsls	r0, r1, #16
   27ba2:	0019      	movs	r1, r3
   27ba4:	0c00      	lsrs	r0, r0, #16
   27ba6:	4341      	muls	r1, r0
   27ba8:	0015      	movs	r5, r2
   27baa:	4688      	mov	r8, r1
   27bac:	0019      	movs	r1, r3
   27bae:	437d      	muls	r5, r7
   27bb0:	4379      	muls	r1, r7
   27bb2:	9503      	str	r5, [sp, #12]
   27bb4:	4689      	mov	r9, r1
   27bb6:	0029      	movs	r1, r5
   27bb8:	0015      	movs	r5, r2
   27bba:	4345      	muls	r5, r0
   27bbc:	444d      	add	r5, r9
   27bbe:	9502      	str	r5, [sp, #8]
   27bc0:	4645      	mov	r5, r8
   27bc2:	0c2d      	lsrs	r5, r5, #16
   27bc4:	46aa      	mov	sl, r5
   27bc6:	9d02      	ldr	r5, [sp, #8]
   27bc8:	4455      	add	r5, sl
   27bca:	45a9      	cmp	r9, r5
   27bcc:	d906      	bls.n	27bdc <__aeabi_dmul+0x238>
   27bce:	468a      	mov	sl, r1
   27bd0:	2180      	movs	r1, #128	; 0x80
   27bd2:	0249      	lsls	r1, r1, #9
   27bd4:	4689      	mov	r9, r1
   27bd6:	44ca      	add	sl, r9
   27bd8:	4651      	mov	r1, sl
   27bda:	9103      	str	r1, [sp, #12]
   27bdc:	0c29      	lsrs	r1, r5, #16
   27bde:	9104      	str	r1, [sp, #16]
   27be0:	4641      	mov	r1, r8
   27be2:	0409      	lsls	r1, r1, #16
   27be4:	042d      	lsls	r5, r5, #16
   27be6:	0c09      	lsrs	r1, r1, #16
   27be8:	4688      	mov	r8, r1
   27bea:	0029      	movs	r1, r5
   27bec:	0c25      	lsrs	r5, r4, #16
   27bee:	0424      	lsls	r4, r4, #16
   27bf0:	4441      	add	r1, r8
   27bf2:	0c24      	lsrs	r4, r4, #16
   27bf4:	9105      	str	r1, [sp, #20]
   27bf6:	0021      	movs	r1, r4
   27bf8:	4341      	muls	r1, r0
   27bfa:	4688      	mov	r8, r1
   27bfc:	0021      	movs	r1, r4
   27bfe:	4379      	muls	r1, r7
   27c00:	468a      	mov	sl, r1
   27c02:	4368      	muls	r0, r5
   27c04:	4641      	mov	r1, r8
   27c06:	4450      	add	r0, sl
   27c08:	4681      	mov	r9, r0
   27c0a:	0c08      	lsrs	r0, r1, #16
   27c0c:	4448      	add	r0, r9
   27c0e:	436f      	muls	r7, r5
   27c10:	4582      	cmp	sl, r0
   27c12:	d903      	bls.n	27c1c <__aeabi_dmul+0x278>
   27c14:	2180      	movs	r1, #128	; 0x80
   27c16:	0249      	lsls	r1, r1, #9
   27c18:	4689      	mov	r9, r1
   27c1a:	444f      	add	r7, r9
   27c1c:	0c01      	lsrs	r1, r0, #16
   27c1e:	4689      	mov	r9, r1
   27c20:	0039      	movs	r1, r7
   27c22:	4449      	add	r1, r9
   27c24:	9102      	str	r1, [sp, #8]
   27c26:	4641      	mov	r1, r8
   27c28:	040f      	lsls	r7, r1, #16
   27c2a:	9904      	ldr	r1, [sp, #16]
   27c2c:	0c3f      	lsrs	r7, r7, #16
   27c2e:	4688      	mov	r8, r1
   27c30:	0400      	lsls	r0, r0, #16
   27c32:	19c0      	adds	r0, r0, r7
   27c34:	4480      	add	r8, r0
   27c36:	4641      	mov	r1, r8
   27c38:	9104      	str	r1, [sp, #16]
   27c3a:	4659      	mov	r1, fp
   27c3c:	0c0f      	lsrs	r7, r1, #16
   27c3e:	0409      	lsls	r1, r1, #16
   27c40:	0c09      	lsrs	r1, r1, #16
   27c42:	4688      	mov	r8, r1
   27c44:	4359      	muls	r1, r3
   27c46:	468a      	mov	sl, r1
   27c48:	0039      	movs	r1, r7
   27c4a:	4351      	muls	r1, r2
   27c4c:	4689      	mov	r9, r1
   27c4e:	4641      	mov	r1, r8
   27c50:	434a      	muls	r2, r1
   27c52:	4651      	mov	r1, sl
   27c54:	0c09      	lsrs	r1, r1, #16
   27c56:	468b      	mov	fp, r1
   27c58:	437b      	muls	r3, r7
   27c5a:	18d2      	adds	r2, r2, r3
   27c5c:	445a      	add	r2, fp
   27c5e:	4293      	cmp	r3, r2
   27c60:	d903      	bls.n	27c6a <__aeabi_dmul+0x2c6>
   27c62:	2380      	movs	r3, #128	; 0x80
   27c64:	025b      	lsls	r3, r3, #9
   27c66:	469b      	mov	fp, r3
   27c68:	44d9      	add	r9, fp
   27c6a:	4651      	mov	r1, sl
   27c6c:	0409      	lsls	r1, r1, #16
   27c6e:	0c09      	lsrs	r1, r1, #16
   27c70:	468a      	mov	sl, r1
   27c72:	4641      	mov	r1, r8
   27c74:	4361      	muls	r1, r4
   27c76:	437c      	muls	r4, r7
   27c78:	0c13      	lsrs	r3, r2, #16
   27c7a:	0412      	lsls	r2, r2, #16
   27c7c:	444b      	add	r3, r9
   27c7e:	4452      	add	r2, sl
   27c80:	46a1      	mov	r9, r4
   27c82:	468a      	mov	sl, r1
   27c84:	003c      	movs	r4, r7
   27c86:	4641      	mov	r1, r8
   27c88:	436c      	muls	r4, r5
   27c8a:	434d      	muls	r5, r1
   27c8c:	4651      	mov	r1, sl
   27c8e:	444d      	add	r5, r9
   27c90:	0c0f      	lsrs	r7, r1, #16
   27c92:	197d      	adds	r5, r7, r5
   27c94:	45a9      	cmp	r9, r5
   27c96:	d903      	bls.n	27ca0 <__aeabi_dmul+0x2fc>
   27c98:	2180      	movs	r1, #128	; 0x80
   27c9a:	0249      	lsls	r1, r1, #9
   27c9c:	4688      	mov	r8, r1
   27c9e:	4444      	add	r4, r8
   27ca0:	9f04      	ldr	r7, [sp, #16]
   27ca2:	9903      	ldr	r1, [sp, #12]
   27ca4:	46b8      	mov	r8, r7
   27ca6:	4441      	add	r1, r8
   27ca8:	468b      	mov	fp, r1
   27caa:	4583      	cmp	fp, r0
   27cac:	4180      	sbcs	r0, r0
   27cae:	4241      	negs	r1, r0
   27cb0:	4688      	mov	r8, r1
   27cb2:	4651      	mov	r1, sl
   27cb4:	0408      	lsls	r0, r1, #16
   27cb6:	042f      	lsls	r7, r5, #16
   27cb8:	0c00      	lsrs	r0, r0, #16
   27cba:	183f      	adds	r7, r7, r0
   27cbc:	4658      	mov	r0, fp
   27cbe:	9902      	ldr	r1, [sp, #8]
   27cc0:	1810      	adds	r0, r2, r0
   27cc2:	4689      	mov	r9, r1
   27cc4:	4290      	cmp	r0, r2
   27cc6:	4192      	sbcs	r2, r2
   27cc8:	444f      	add	r7, r9
   27cca:	46ba      	mov	sl, r7
   27ccc:	4252      	negs	r2, r2
   27cce:	4699      	mov	r9, r3
   27cd0:	4693      	mov	fp, r2
   27cd2:	44c2      	add	sl, r8
   27cd4:	44d1      	add	r9, sl
   27cd6:	44cb      	add	fp, r9
   27cd8:	428f      	cmp	r7, r1
   27cda:	41bf      	sbcs	r7, r7
   27cdc:	45c2      	cmp	sl, r8
   27cde:	4189      	sbcs	r1, r1
   27ce0:	4599      	cmp	r9, r3
   27ce2:	419b      	sbcs	r3, r3
   27ce4:	4593      	cmp	fp, r2
   27ce6:	4192      	sbcs	r2, r2
   27ce8:	427f      	negs	r7, r7
   27cea:	4249      	negs	r1, r1
   27cec:	0c2d      	lsrs	r5, r5, #16
   27cee:	4252      	negs	r2, r2
   27cf0:	430f      	orrs	r7, r1
   27cf2:	425b      	negs	r3, r3
   27cf4:	4313      	orrs	r3, r2
   27cf6:	197f      	adds	r7, r7, r5
   27cf8:	18ff      	adds	r7, r7, r3
   27cfa:	465b      	mov	r3, fp
   27cfc:	193c      	adds	r4, r7, r4
   27cfe:	0ddb      	lsrs	r3, r3, #23
   27d00:	9a05      	ldr	r2, [sp, #20]
   27d02:	0264      	lsls	r4, r4, #9
   27d04:	431c      	orrs	r4, r3
   27d06:	0243      	lsls	r3, r0, #9
   27d08:	4313      	orrs	r3, r2
   27d0a:	1e5d      	subs	r5, r3, #1
   27d0c:	41ab      	sbcs	r3, r5
   27d0e:	465a      	mov	r2, fp
   27d10:	0dc0      	lsrs	r0, r0, #23
   27d12:	4303      	orrs	r3, r0
   27d14:	0252      	lsls	r2, r2, #9
   27d16:	4313      	orrs	r3, r2
   27d18:	01e2      	lsls	r2, r4, #7
   27d1a:	d556      	bpl.n	27dca <__aeabi_dmul+0x426>
   27d1c:	2001      	movs	r0, #1
   27d1e:	085a      	lsrs	r2, r3, #1
   27d20:	4003      	ands	r3, r0
   27d22:	4313      	orrs	r3, r2
   27d24:	07e2      	lsls	r2, r4, #31
   27d26:	4313      	orrs	r3, r2
   27d28:	0864      	lsrs	r4, r4, #1
   27d2a:	485a      	ldr	r0, [pc, #360]	; (27e94 <__aeabi_dmul+0x4f0>)
   27d2c:	4460      	add	r0, ip
   27d2e:	2800      	cmp	r0, #0
   27d30:	dd4d      	ble.n	27dce <__aeabi_dmul+0x42a>
   27d32:	075a      	lsls	r2, r3, #29
   27d34:	d009      	beq.n	27d4a <__aeabi_dmul+0x3a6>
   27d36:	220f      	movs	r2, #15
   27d38:	401a      	ands	r2, r3
   27d3a:	2a04      	cmp	r2, #4
   27d3c:	d005      	beq.n	27d4a <__aeabi_dmul+0x3a6>
   27d3e:	1d1a      	adds	r2, r3, #4
   27d40:	429a      	cmp	r2, r3
   27d42:	419b      	sbcs	r3, r3
   27d44:	425b      	negs	r3, r3
   27d46:	18e4      	adds	r4, r4, r3
   27d48:	0013      	movs	r3, r2
   27d4a:	01e2      	lsls	r2, r4, #7
   27d4c:	d504      	bpl.n	27d58 <__aeabi_dmul+0x3b4>
   27d4e:	2080      	movs	r0, #128	; 0x80
   27d50:	4a51      	ldr	r2, [pc, #324]	; (27e98 <__aeabi_dmul+0x4f4>)
   27d52:	00c0      	lsls	r0, r0, #3
   27d54:	4014      	ands	r4, r2
   27d56:	4460      	add	r0, ip
   27d58:	4a50      	ldr	r2, [pc, #320]	; (27e9c <__aeabi_dmul+0x4f8>)
   27d5a:	4290      	cmp	r0, r2
   27d5c:	dd00      	ble.n	27d60 <__aeabi_dmul+0x3bc>
   27d5e:	e6e3      	b.n	27b28 <__aeabi_dmul+0x184>
   27d60:	2501      	movs	r5, #1
   27d62:	08db      	lsrs	r3, r3, #3
   27d64:	0762      	lsls	r2, r4, #29
   27d66:	431a      	orrs	r2, r3
   27d68:	0264      	lsls	r4, r4, #9
   27d6a:	9b01      	ldr	r3, [sp, #4]
   27d6c:	4691      	mov	r9, r2
   27d6e:	0b22      	lsrs	r2, r4, #12
   27d70:	0544      	lsls	r4, r0, #21
   27d72:	0d64      	lsrs	r4, r4, #21
   27d74:	401d      	ands	r5, r3
   27d76:	e67c      	b.n	27a72 <__aeabi_dmul+0xce>
   27d78:	2280      	movs	r2, #128	; 0x80
   27d7a:	4659      	mov	r1, fp
   27d7c:	0312      	lsls	r2, r2, #12
   27d7e:	4211      	tst	r1, r2
   27d80:	d008      	beq.n	27d94 <__aeabi_dmul+0x3f0>
   27d82:	4214      	tst	r4, r2
   27d84:	d106      	bne.n	27d94 <__aeabi_dmul+0x3f0>
   27d86:	4322      	orrs	r2, r4
   27d88:	0312      	lsls	r2, r2, #12
   27d8a:	0b12      	lsrs	r2, r2, #12
   27d8c:	4645      	mov	r5, r8
   27d8e:	4699      	mov	r9, r3
   27d90:	4c43      	ldr	r4, [pc, #268]	; (27ea0 <__aeabi_dmul+0x4fc>)
   27d92:	e66e      	b.n	27a72 <__aeabi_dmul+0xce>
   27d94:	465b      	mov	r3, fp
   27d96:	431a      	orrs	r2, r3
   27d98:	0312      	lsls	r2, r2, #12
   27d9a:	0b12      	lsrs	r2, r2, #12
   27d9c:	4c40      	ldr	r4, [pc, #256]	; (27ea0 <__aeabi_dmul+0x4fc>)
   27d9e:	e668      	b.n	27a72 <__aeabi_dmul+0xce>
   27da0:	0003      	movs	r3, r0
   27da2:	4654      	mov	r4, sl
   27da4:	3b28      	subs	r3, #40	; 0x28
   27da6:	409c      	lsls	r4, r3
   27da8:	2300      	movs	r3, #0
   27daa:	e6b9      	b.n	27b20 <__aeabi_dmul+0x17c>
   27dac:	f000 fcb0 	bl	28710 <__clzsi2>
   27db0:	3020      	adds	r0, #32
   27db2:	e6a6      	b.n	27b02 <__aeabi_dmul+0x15e>
   27db4:	0003      	movs	r3, r0
   27db6:	3b28      	subs	r3, #40	; 0x28
   27db8:	409f      	lsls	r7, r3
   27dba:	2300      	movs	r3, #0
   27dbc:	46bb      	mov	fp, r7
   27dbe:	4699      	mov	r9, r3
   27dc0:	e68a      	b.n	27ad8 <__aeabi_dmul+0x134>
   27dc2:	f000 fca5 	bl	28710 <__clzsi2>
   27dc6:	3020      	adds	r0, #32
   27dc8:	e674      	b.n	27ab4 <__aeabi_dmul+0x110>
   27dca:	46b4      	mov	ip, r6
   27dcc:	e7ad      	b.n	27d2a <__aeabi_dmul+0x386>
   27dce:	2501      	movs	r5, #1
   27dd0:	1a2a      	subs	r2, r5, r0
   27dd2:	2a38      	cmp	r2, #56	; 0x38
   27dd4:	dd06      	ble.n	27de4 <__aeabi_dmul+0x440>
   27dd6:	9b01      	ldr	r3, [sp, #4]
   27dd8:	2400      	movs	r4, #0
   27dda:	401d      	ands	r5, r3
   27ddc:	2300      	movs	r3, #0
   27dde:	2200      	movs	r2, #0
   27de0:	4699      	mov	r9, r3
   27de2:	e646      	b.n	27a72 <__aeabi_dmul+0xce>
   27de4:	2a1f      	cmp	r2, #31
   27de6:	dc21      	bgt.n	27e2c <__aeabi_dmul+0x488>
   27de8:	2520      	movs	r5, #32
   27dea:	0020      	movs	r0, r4
   27dec:	1aad      	subs	r5, r5, r2
   27dee:	001e      	movs	r6, r3
   27df0:	40ab      	lsls	r3, r5
   27df2:	40a8      	lsls	r0, r5
   27df4:	40d6      	lsrs	r6, r2
   27df6:	1e5d      	subs	r5, r3, #1
   27df8:	41ab      	sbcs	r3, r5
   27dfa:	4330      	orrs	r0, r6
   27dfc:	4318      	orrs	r0, r3
   27dfe:	40d4      	lsrs	r4, r2
   27e00:	0743      	lsls	r3, r0, #29
   27e02:	d009      	beq.n	27e18 <__aeabi_dmul+0x474>
   27e04:	230f      	movs	r3, #15
   27e06:	4003      	ands	r3, r0
   27e08:	2b04      	cmp	r3, #4
   27e0a:	d005      	beq.n	27e18 <__aeabi_dmul+0x474>
   27e0c:	0003      	movs	r3, r0
   27e0e:	1d18      	adds	r0, r3, #4
   27e10:	4298      	cmp	r0, r3
   27e12:	419b      	sbcs	r3, r3
   27e14:	425b      	negs	r3, r3
   27e16:	18e4      	adds	r4, r4, r3
   27e18:	0223      	lsls	r3, r4, #8
   27e1a:	d521      	bpl.n	27e60 <__aeabi_dmul+0x4bc>
   27e1c:	2501      	movs	r5, #1
   27e1e:	9b01      	ldr	r3, [sp, #4]
   27e20:	2401      	movs	r4, #1
   27e22:	401d      	ands	r5, r3
   27e24:	2300      	movs	r3, #0
   27e26:	2200      	movs	r2, #0
   27e28:	4699      	mov	r9, r3
   27e2a:	e622      	b.n	27a72 <__aeabi_dmul+0xce>
   27e2c:	251f      	movs	r5, #31
   27e2e:	0021      	movs	r1, r4
   27e30:	426d      	negs	r5, r5
   27e32:	1a28      	subs	r0, r5, r0
   27e34:	40c1      	lsrs	r1, r0
   27e36:	0008      	movs	r0, r1
   27e38:	2a20      	cmp	r2, #32
   27e3a:	d01d      	beq.n	27e78 <__aeabi_dmul+0x4d4>
   27e3c:	355f      	adds	r5, #95	; 0x5f
   27e3e:	1aaa      	subs	r2, r5, r2
   27e40:	4094      	lsls	r4, r2
   27e42:	4323      	orrs	r3, r4
   27e44:	1e5c      	subs	r4, r3, #1
   27e46:	41a3      	sbcs	r3, r4
   27e48:	2507      	movs	r5, #7
   27e4a:	4303      	orrs	r3, r0
   27e4c:	401d      	ands	r5, r3
   27e4e:	2200      	movs	r2, #0
   27e50:	2d00      	cmp	r5, #0
   27e52:	d009      	beq.n	27e68 <__aeabi_dmul+0x4c4>
   27e54:	220f      	movs	r2, #15
   27e56:	2400      	movs	r4, #0
   27e58:	401a      	ands	r2, r3
   27e5a:	0018      	movs	r0, r3
   27e5c:	2a04      	cmp	r2, #4
   27e5e:	d1d6      	bne.n	27e0e <__aeabi_dmul+0x46a>
   27e60:	0003      	movs	r3, r0
   27e62:	0765      	lsls	r5, r4, #29
   27e64:	0264      	lsls	r4, r4, #9
   27e66:	0b22      	lsrs	r2, r4, #12
   27e68:	08db      	lsrs	r3, r3, #3
   27e6a:	432b      	orrs	r3, r5
   27e6c:	2501      	movs	r5, #1
   27e6e:	4699      	mov	r9, r3
   27e70:	9b01      	ldr	r3, [sp, #4]
   27e72:	2400      	movs	r4, #0
   27e74:	401d      	ands	r5, r3
   27e76:	e5fc      	b.n	27a72 <__aeabi_dmul+0xce>
   27e78:	2400      	movs	r4, #0
   27e7a:	e7e2      	b.n	27e42 <__aeabi_dmul+0x49e>
   27e7c:	2280      	movs	r2, #128	; 0x80
   27e7e:	2501      	movs	r5, #1
   27e80:	0312      	lsls	r2, r2, #12
   27e82:	4322      	orrs	r2, r4
   27e84:	9901      	ldr	r1, [sp, #4]
   27e86:	0312      	lsls	r2, r2, #12
   27e88:	0b12      	lsrs	r2, r2, #12
   27e8a:	400d      	ands	r5, r1
   27e8c:	4699      	mov	r9, r3
   27e8e:	4c04      	ldr	r4, [pc, #16]	; (27ea0 <__aeabi_dmul+0x4fc>)
   27e90:	e5ef      	b.n	27a72 <__aeabi_dmul+0xce>
   27e92:	46c0      	nop			; (mov r8, r8)
   27e94:	000003ff 	.word	0x000003ff
   27e98:	feffffff 	.word	0xfeffffff
   27e9c:	000007fe 	.word	0x000007fe
   27ea0:	000007ff 	.word	0x000007ff

00027ea4 <__aeabi_dsub>:
   27ea4:	b5f0      	push	{r4, r5, r6, r7, lr}
   27ea6:	4646      	mov	r6, r8
   27ea8:	46d6      	mov	lr, sl
   27eaa:	464f      	mov	r7, r9
   27eac:	030c      	lsls	r4, r1, #12
   27eae:	b5c0      	push	{r6, r7, lr}
   27eb0:	0fcd      	lsrs	r5, r1, #31
   27eb2:	004e      	lsls	r6, r1, #1
   27eb4:	0a61      	lsrs	r1, r4, #9
   27eb6:	0f44      	lsrs	r4, r0, #29
   27eb8:	430c      	orrs	r4, r1
   27eba:	00c1      	lsls	r1, r0, #3
   27ebc:	0058      	lsls	r0, r3, #1
   27ebe:	0d40      	lsrs	r0, r0, #21
   27ec0:	4684      	mov	ip, r0
   27ec2:	468a      	mov	sl, r1
   27ec4:	000f      	movs	r7, r1
   27ec6:	0319      	lsls	r1, r3, #12
   27ec8:	0f50      	lsrs	r0, r2, #29
   27eca:	0a49      	lsrs	r1, r1, #9
   27ecc:	4301      	orrs	r1, r0
   27ece:	48c6      	ldr	r0, [pc, #792]	; (281e8 <__aeabi_dsub+0x344>)
   27ed0:	0d76      	lsrs	r6, r6, #21
   27ed2:	46a8      	mov	r8, r5
   27ed4:	0fdb      	lsrs	r3, r3, #31
   27ed6:	00d2      	lsls	r2, r2, #3
   27ed8:	4584      	cmp	ip, r0
   27eda:	d100      	bne.n	27ede <__aeabi_dsub+0x3a>
   27edc:	e0d8      	b.n	28090 <__aeabi_dsub+0x1ec>
   27ede:	2001      	movs	r0, #1
   27ee0:	4043      	eors	r3, r0
   27ee2:	42ab      	cmp	r3, r5
   27ee4:	d100      	bne.n	27ee8 <__aeabi_dsub+0x44>
   27ee6:	e0a6      	b.n	28036 <__aeabi_dsub+0x192>
   27ee8:	4660      	mov	r0, ip
   27eea:	1a35      	subs	r5, r6, r0
   27eec:	2d00      	cmp	r5, #0
   27eee:	dc00      	bgt.n	27ef2 <__aeabi_dsub+0x4e>
   27ef0:	e105      	b.n	280fe <__aeabi_dsub+0x25a>
   27ef2:	2800      	cmp	r0, #0
   27ef4:	d110      	bne.n	27f18 <__aeabi_dsub+0x74>
   27ef6:	000b      	movs	r3, r1
   27ef8:	4313      	orrs	r3, r2
   27efa:	d100      	bne.n	27efe <__aeabi_dsub+0x5a>
   27efc:	e0d7      	b.n	280ae <__aeabi_dsub+0x20a>
   27efe:	1e6b      	subs	r3, r5, #1
   27f00:	2b00      	cmp	r3, #0
   27f02:	d000      	beq.n	27f06 <__aeabi_dsub+0x62>
   27f04:	e14b      	b.n	2819e <__aeabi_dsub+0x2fa>
   27f06:	4653      	mov	r3, sl
   27f08:	1a9f      	subs	r7, r3, r2
   27f0a:	45ba      	cmp	sl, r7
   27f0c:	4180      	sbcs	r0, r0
   27f0e:	1a64      	subs	r4, r4, r1
   27f10:	4240      	negs	r0, r0
   27f12:	1a24      	subs	r4, r4, r0
   27f14:	2601      	movs	r6, #1
   27f16:	e01e      	b.n	27f56 <__aeabi_dsub+0xb2>
   27f18:	4bb3      	ldr	r3, [pc, #716]	; (281e8 <__aeabi_dsub+0x344>)
   27f1a:	429e      	cmp	r6, r3
   27f1c:	d048      	beq.n	27fb0 <__aeabi_dsub+0x10c>
   27f1e:	2380      	movs	r3, #128	; 0x80
   27f20:	041b      	lsls	r3, r3, #16
   27f22:	4319      	orrs	r1, r3
   27f24:	2d38      	cmp	r5, #56	; 0x38
   27f26:	dd00      	ble.n	27f2a <__aeabi_dsub+0x86>
   27f28:	e119      	b.n	2815e <__aeabi_dsub+0x2ba>
   27f2a:	2d1f      	cmp	r5, #31
   27f2c:	dd00      	ble.n	27f30 <__aeabi_dsub+0x8c>
   27f2e:	e14c      	b.n	281ca <__aeabi_dsub+0x326>
   27f30:	2320      	movs	r3, #32
   27f32:	000f      	movs	r7, r1
   27f34:	1b5b      	subs	r3, r3, r5
   27f36:	0010      	movs	r0, r2
   27f38:	409a      	lsls	r2, r3
   27f3a:	409f      	lsls	r7, r3
   27f3c:	40e8      	lsrs	r0, r5
   27f3e:	1e53      	subs	r3, r2, #1
   27f40:	419a      	sbcs	r2, r3
   27f42:	40e9      	lsrs	r1, r5
   27f44:	4307      	orrs	r7, r0
   27f46:	4317      	orrs	r7, r2
   27f48:	4653      	mov	r3, sl
   27f4a:	1bdf      	subs	r7, r3, r7
   27f4c:	1a61      	subs	r1, r4, r1
   27f4e:	45ba      	cmp	sl, r7
   27f50:	41a4      	sbcs	r4, r4
   27f52:	4264      	negs	r4, r4
   27f54:	1b0c      	subs	r4, r1, r4
   27f56:	0223      	lsls	r3, r4, #8
   27f58:	d400      	bmi.n	27f5c <__aeabi_dsub+0xb8>
   27f5a:	e0c5      	b.n	280e8 <__aeabi_dsub+0x244>
   27f5c:	0264      	lsls	r4, r4, #9
   27f5e:	0a65      	lsrs	r5, r4, #9
   27f60:	2d00      	cmp	r5, #0
   27f62:	d100      	bne.n	27f66 <__aeabi_dsub+0xc2>
   27f64:	e0f6      	b.n	28154 <__aeabi_dsub+0x2b0>
   27f66:	0028      	movs	r0, r5
   27f68:	f000 fbd2 	bl	28710 <__clzsi2>
   27f6c:	0003      	movs	r3, r0
   27f6e:	3b08      	subs	r3, #8
   27f70:	2b1f      	cmp	r3, #31
   27f72:	dd00      	ble.n	27f76 <__aeabi_dsub+0xd2>
   27f74:	e0e9      	b.n	2814a <__aeabi_dsub+0x2a6>
   27f76:	2220      	movs	r2, #32
   27f78:	003c      	movs	r4, r7
   27f7a:	1ad2      	subs	r2, r2, r3
   27f7c:	409d      	lsls	r5, r3
   27f7e:	40d4      	lsrs	r4, r2
   27f80:	409f      	lsls	r7, r3
   27f82:	4325      	orrs	r5, r4
   27f84:	429e      	cmp	r6, r3
   27f86:	dd00      	ble.n	27f8a <__aeabi_dsub+0xe6>
   27f88:	e0db      	b.n	28142 <__aeabi_dsub+0x29e>
   27f8a:	1b9e      	subs	r6, r3, r6
   27f8c:	1c73      	adds	r3, r6, #1
   27f8e:	2b1f      	cmp	r3, #31
   27f90:	dd00      	ble.n	27f94 <__aeabi_dsub+0xf0>
   27f92:	e10a      	b.n	281aa <__aeabi_dsub+0x306>
   27f94:	2220      	movs	r2, #32
   27f96:	0038      	movs	r0, r7
   27f98:	1ad2      	subs	r2, r2, r3
   27f9a:	0029      	movs	r1, r5
   27f9c:	4097      	lsls	r7, r2
   27f9e:	002c      	movs	r4, r5
   27fa0:	4091      	lsls	r1, r2
   27fa2:	40d8      	lsrs	r0, r3
   27fa4:	1e7a      	subs	r2, r7, #1
   27fa6:	4197      	sbcs	r7, r2
   27fa8:	40dc      	lsrs	r4, r3
   27faa:	2600      	movs	r6, #0
   27fac:	4301      	orrs	r1, r0
   27fae:	430f      	orrs	r7, r1
   27fb0:	077b      	lsls	r3, r7, #29
   27fb2:	d009      	beq.n	27fc8 <__aeabi_dsub+0x124>
   27fb4:	230f      	movs	r3, #15
   27fb6:	403b      	ands	r3, r7
   27fb8:	2b04      	cmp	r3, #4
   27fba:	d005      	beq.n	27fc8 <__aeabi_dsub+0x124>
   27fbc:	1d3b      	adds	r3, r7, #4
   27fbe:	42bb      	cmp	r3, r7
   27fc0:	41bf      	sbcs	r7, r7
   27fc2:	427f      	negs	r7, r7
   27fc4:	19e4      	adds	r4, r4, r7
   27fc6:	001f      	movs	r7, r3
   27fc8:	0223      	lsls	r3, r4, #8
   27fca:	d525      	bpl.n	28018 <__aeabi_dsub+0x174>
   27fcc:	4b86      	ldr	r3, [pc, #536]	; (281e8 <__aeabi_dsub+0x344>)
   27fce:	3601      	adds	r6, #1
   27fd0:	429e      	cmp	r6, r3
   27fd2:	d100      	bne.n	27fd6 <__aeabi_dsub+0x132>
   27fd4:	e0af      	b.n	28136 <__aeabi_dsub+0x292>
   27fd6:	4b85      	ldr	r3, [pc, #532]	; (281ec <__aeabi_dsub+0x348>)
   27fd8:	2501      	movs	r5, #1
   27fda:	401c      	ands	r4, r3
   27fdc:	4643      	mov	r3, r8
   27fde:	0762      	lsls	r2, r4, #29
   27fe0:	08ff      	lsrs	r7, r7, #3
   27fe2:	0264      	lsls	r4, r4, #9
   27fe4:	0576      	lsls	r6, r6, #21
   27fe6:	4317      	orrs	r7, r2
   27fe8:	0b24      	lsrs	r4, r4, #12
   27fea:	0d76      	lsrs	r6, r6, #21
   27fec:	401d      	ands	r5, r3
   27fee:	2100      	movs	r1, #0
   27ff0:	0324      	lsls	r4, r4, #12
   27ff2:	0b23      	lsrs	r3, r4, #12
   27ff4:	0d0c      	lsrs	r4, r1, #20
   27ff6:	4a7e      	ldr	r2, [pc, #504]	; (281f0 <__aeabi_dsub+0x34c>)
   27ff8:	0524      	lsls	r4, r4, #20
   27ffa:	431c      	orrs	r4, r3
   27ffc:	4014      	ands	r4, r2
   27ffe:	0533      	lsls	r3, r6, #20
   28000:	4323      	orrs	r3, r4
   28002:	005b      	lsls	r3, r3, #1
   28004:	07ed      	lsls	r5, r5, #31
   28006:	085b      	lsrs	r3, r3, #1
   28008:	432b      	orrs	r3, r5
   2800a:	0038      	movs	r0, r7
   2800c:	0019      	movs	r1, r3
   2800e:	bc1c      	pop	{r2, r3, r4}
   28010:	4690      	mov	r8, r2
   28012:	4699      	mov	r9, r3
   28014:	46a2      	mov	sl, r4
   28016:	bdf0      	pop	{r4, r5, r6, r7, pc}
   28018:	2501      	movs	r5, #1
   2801a:	4643      	mov	r3, r8
   2801c:	0762      	lsls	r2, r4, #29
   2801e:	08ff      	lsrs	r7, r7, #3
   28020:	4317      	orrs	r7, r2
   28022:	08e4      	lsrs	r4, r4, #3
   28024:	401d      	ands	r5, r3
   28026:	4b70      	ldr	r3, [pc, #448]	; (281e8 <__aeabi_dsub+0x344>)
   28028:	429e      	cmp	r6, r3
   2802a:	d036      	beq.n	2809a <__aeabi_dsub+0x1f6>
   2802c:	0324      	lsls	r4, r4, #12
   2802e:	0576      	lsls	r6, r6, #21
   28030:	0b24      	lsrs	r4, r4, #12
   28032:	0d76      	lsrs	r6, r6, #21
   28034:	e7db      	b.n	27fee <__aeabi_dsub+0x14a>
   28036:	4663      	mov	r3, ip
   28038:	1af3      	subs	r3, r6, r3
   2803a:	2b00      	cmp	r3, #0
   2803c:	dc00      	bgt.n	28040 <__aeabi_dsub+0x19c>
   2803e:	e094      	b.n	2816a <__aeabi_dsub+0x2c6>
   28040:	4660      	mov	r0, ip
   28042:	2800      	cmp	r0, #0
   28044:	d035      	beq.n	280b2 <__aeabi_dsub+0x20e>
   28046:	4868      	ldr	r0, [pc, #416]	; (281e8 <__aeabi_dsub+0x344>)
   28048:	4286      	cmp	r6, r0
   2804a:	d0b1      	beq.n	27fb0 <__aeabi_dsub+0x10c>
   2804c:	2780      	movs	r7, #128	; 0x80
   2804e:	043f      	lsls	r7, r7, #16
   28050:	4339      	orrs	r1, r7
   28052:	2b38      	cmp	r3, #56	; 0x38
   28054:	dc00      	bgt.n	28058 <__aeabi_dsub+0x1b4>
   28056:	e0fd      	b.n	28254 <__aeabi_dsub+0x3b0>
   28058:	430a      	orrs	r2, r1
   2805a:	0017      	movs	r7, r2
   2805c:	2100      	movs	r1, #0
   2805e:	1e7a      	subs	r2, r7, #1
   28060:	4197      	sbcs	r7, r2
   28062:	4457      	add	r7, sl
   28064:	4557      	cmp	r7, sl
   28066:	4180      	sbcs	r0, r0
   28068:	1909      	adds	r1, r1, r4
   2806a:	4244      	negs	r4, r0
   2806c:	190c      	adds	r4, r1, r4
   2806e:	0223      	lsls	r3, r4, #8
   28070:	d53a      	bpl.n	280e8 <__aeabi_dsub+0x244>
   28072:	4b5d      	ldr	r3, [pc, #372]	; (281e8 <__aeabi_dsub+0x344>)
   28074:	3601      	adds	r6, #1
   28076:	429e      	cmp	r6, r3
   28078:	d100      	bne.n	2807c <__aeabi_dsub+0x1d8>
   2807a:	e14b      	b.n	28314 <__aeabi_dsub+0x470>
   2807c:	2201      	movs	r2, #1
   2807e:	4b5b      	ldr	r3, [pc, #364]	; (281ec <__aeabi_dsub+0x348>)
   28080:	401c      	ands	r4, r3
   28082:	087b      	lsrs	r3, r7, #1
   28084:	4017      	ands	r7, r2
   28086:	431f      	orrs	r7, r3
   28088:	07e2      	lsls	r2, r4, #31
   2808a:	4317      	orrs	r7, r2
   2808c:	0864      	lsrs	r4, r4, #1
   2808e:	e78f      	b.n	27fb0 <__aeabi_dsub+0x10c>
   28090:	0008      	movs	r0, r1
   28092:	4310      	orrs	r0, r2
   28094:	d000      	beq.n	28098 <__aeabi_dsub+0x1f4>
   28096:	e724      	b.n	27ee2 <__aeabi_dsub+0x3e>
   28098:	e721      	b.n	27ede <__aeabi_dsub+0x3a>
   2809a:	0023      	movs	r3, r4
   2809c:	433b      	orrs	r3, r7
   2809e:	d100      	bne.n	280a2 <__aeabi_dsub+0x1fe>
   280a0:	e1b9      	b.n	28416 <__aeabi_dsub+0x572>
   280a2:	2280      	movs	r2, #128	; 0x80
   280a4:	0312      	lsls	r2, r2, #12
   280a6:	4314      	orrs	r4, r2
   280a8:	0324      	lsls	r4, r4, #12
   280aa:	0b24      	lsrs	r4, r4, #12
   280ac:	e79f      	b.n	27fee <__aeabi_dsub+0x14a>
   280ae:	002e      	movs	r6, r5
   280b0:	e77e      	b.n	27fb0 <__aeabi_dsub+0x10c>
   280b2:	0008      	movs	r0, r1
   280b4:	4310      	orrs	r0, r2
   280b6:	d100      	bne.n	280ba <__aeabi_dsub+0x216>
   280b8:	e0ca      	b.n	28250 <__aeabi_dsub+0x3ac>
   280ba:	1e58      	subs	r0, r3, #1
   280bc:	4684      	mov	ip, r0
   280be:	2800      	cmp	r0, #0
   280c0:	d000      	beq.n	280c4 <__aeabi_dsub+0x220>
   280c2:	e0e7      	b.n	28294 <__aeabi_dsub+0x3f0>
   280c4:	4452      	add	r2, sl
   280c6:	4552      	cmp	r2, sl
   280c8:	4180      	sbcs	r0, r0
   280ca:	1864      	adds	r4, r4, r1
   280cc:	4240      	negs	r0, r0
   280ce:	1824      	adds	r4, r4, r0
   280d0:	0017      	movs	r7, r2
   280d2:	2601      	movs	r6, #1
   280d4:	0223      	lsls	r3, r4, #8
   280d6:	d507      	bpl.n	280e8 <__aeabi_dsub+0x244>
   280d8:	2602      	movs	r6, #2
   280da:	e7cf      	b.n	2807c <__aeabi_dsub+0x1d8>
   280dc:	4664      	mov	r4, ip
   280de:	432c      	orrs	r4, r5
   280e0:	d100      	bne.n	280e4 <__aeabi_dsub+0x240>
   280e2:	e1b3      	b.n	2844c <__aeabi_dsub+0x5a8>
   280e4:	002c      	movs	r4, r5
   280e6:	4667      	mov	r7, ip
   280e8:	077b      	lsls	r3, r7, #29
   280ea:	d000      	beq.n	280ee <__aeabi_dsub+0x24a>
   280ec:	e762      	b.n	27fb4 <__aeabi_dsub+0x110>
   280ee:	0763      	lsls	r3, r4, #29
   280f0:	08ff      	lsrs	r7, r7, #3
   280f2:	431f      	orrs	r7, r3
   280f4:	2501      	movs	r5, #1
   280f6:	4643      	mov	r3, r8
   280f8:	08e4      	lsrs	r4, r4, #3
   280fa:	401d      	ands	r5, r3
   280fc:	e793      	b.n	28026 <__aeabi_dsub+0x182>
   280fe:	2d00      	cmp	r5, #0
   28100:	d178      	bne.n	281f4 <__aeabi_dsub+0x350>
   28102:	1c75      	adds	r5, r6, #1
   28104:	056d      	lsls	r5, r5, #21
   28106:	0d6d      	lsrs	r5, r5, #21
   28108:	2d01      	cmp	r5, #1
   2810a:	dc00      	bgt.n	2810e <__aeabi_dsub+0x26a>
   2810c:	e0f2      	b.n	282f4 <__aeabi_dsub+0x450>
   2810e:	4650      	mov	r0, sl
   28110:	1a80      	subs	r0, r0, r2
   28112:	4582      	cmp	sl, r0
   28114:	41bf      	sbcs	r7, r7
   28116:	1a65      	subs	r5, r4, r1
   28118:	427f      	negs	r7, r7
   2811a:	1bed      	subs	r5, r5, r7
   2811c:	4684      	mov	ip, r0
   2811e:	0228      	lsls	r0, r5, #8
   28120:	d400      	bmi.n	28124 <__aeabi_dsub+0x280>
   28122:	e08c      	b.n	2823e <__aeabi_dsub+0x39a>
   28124:	4650      	mov	r0, sl
   28126:	1a17      	subs	r7, r2, r0
   28128:	42ba      	cmp	r2, r7
   2812a:	4192      	sbcs	r2, r2
   2812c:	1b0c      	subs	r4, r1, r4
   2812e:	4255      	negs	r5, r2
   28130:	1b65      	subs	r5, r4, r5
   28132:	4698      	mov	r8, r3
   28134:	e714      	b.n	27f60 <__aeabi_dsub+0xbc>
   28136:	2501      	movs	r5, #1
   28138:	4643      	mov	r3, r8
   2813a:	2400      	movs	r4, #0
   2813c:	401d      	ands	r5, r3
   2813e:	2700      	movs	r7, #0
   28140:	e755      	b.n	27fee <__aeabi_dsub+0x14a>
   28142:	4c2a      	ldr	r4, [pc, #168]	; (281ec <__aeabi_dsub+0x348>)
   28144:	1af6      	subs	r6, r6, r3
   28146:	402c      	ands	r4, r5
   28148:	e732      	b.n	27fb0 <__aeabi_dsub+0x10c>
   2814a:	003d      	movs	r5, r7
   2814c:	3828      	subs	r0, #40	; 0x28
   2814e:	4085      	lsls	r5, r0
   28150:	2700      	movs	r7, #0
   28152:	e717      	b.n	27f84 <__aeabi_dsub+0xe0>
   28154:	0038      	movs	r0, r7
   28156:	f000 fadb 	bl	28710 <__clzsi2>
   2815a:	3020      	adds	r0, #32
   2815c:	e706      	b.n	27f6c <__aeabi_dsub+0xc8>
   2815e:	430a      	orrs	r2, r1
   28160:	0017      	movs	r7, r2
   28162:	2100      	movs	r1, #0
   28164:	1e7a      	subs	r2, r7, #1
   28166:	4197      	sbcs	r7, r2
   28168:	e6ee      	b.n	27f48 <__aeabi_dsub+0xa4>
   2816a:	2b00      	cmp	r3, #0
   2816c:	d000      	beq.n	28170 <__aeabi_dsub+0x2cc>
   2816e:	e0e5      	b.n	2833c <__aeabi_dsub+0x498>
   28170:	1c73      	adds	r3, r6, #1
   28172:	469c      	mov	ip, r3
   28174:	055b      	lsls	r3, r3, #21
   28176:	0d5b      	lsrs	r3, r3, #21
   28178:	2b01      	cmp	r3, #1
   2817a:	dc00      	bgt.n	2817e <__aeabi_dsub+0x2da>
   2817c:	e09f      	b.n	282be <__aeabi_dsub+0x41a>
   2817e:	4b1a      	ldr	r3, [pc, #104]	; (281e8 <__aeabi_dsub+0x344>)
   28180:	459c      	cmp	ip, r3
   28182:	d100      	bne.n	28186 <__aeabi_dsub+0x2e2>
   28184:	e0c5      	b.n	28312 <__aeabi_dsub+0x46e>
   28186:	4452      	add	r2, sl
   28188:	4552      	cmp	r2, sl
   2818a:	4180      	sbcs	r0, r0
   2818c:	1864      	adds	r4, r4, r1
   2818e:	4240      	negs	r0, r0
   28190:	1824      	adds	r4, r4, r0
   28192:	07e7      	lsls	r7, r4, #31
   28194:	0852      	lsrs	r2, r2, #1
   28196:	4317      	orrs	r7, r2
   28198:	0864      	lsrs	r4, r4, #1
   2819a:	4666      	mov	r6, ip
   2819c:	e708      	b.n	27fb0 <__aeabi_dsub+0x10c>
   2819e:	4812      	ldr	r0, [pc, #72]	; (281e8 <__aeabi_dsub+0x344>)
   281a0:	4285      	cmp	r5, r0
   281a2:	d100      	bne.n	281a6 <__aeabi_dsub+0x302>
   281a4:	e085      	b.n	282b2 <__aeabi_dsub+0x40e>
   281a6:	001d      	movs	r5, r3
   281a8:	e6bc      	b.n	27f24 <__aeabi_dsub+0x80>
   281aa:	0029      	movs	r1, r5
   281ac:	3e1f      	subs	r6, #31
   281ae:	40f1      	lsrs	r1, r6
   281b0:	2b20      	cmp	r3, #32
   281b2:	d100      	bne.n	281b6 <__aeabi_dsub+0x312>
   281b4:	e07f      	b.n	282b6 <__aeabi_dsub+0x412>
   281b6:	2240      	movs	r2, #64	; 0x40
   281b8:	1ad3      	subs	r3, r2, r3
   281ba:	409d      	lsls	r5, r3
   281bc:	432f      	orrs	r7, r5
   281be:	1e7d      	subs	r5, r7, #1
   281c0:	41af      	sbcs	r7, r5
   281c2:	2400      	movs	r4, #0
   281c4:	430f      	orrs	r7, r1
   281c6:	2600      	movs	r6, #0
   281c8:	e78e      	b.n	280e8 <__aeabi_dsub+0x244>
   281ca:	002b      	movs	r3, r5
   281cc:	000f      	movs	r7, r1
   281ce:	3b20      	subs	r3, #32
   281d0:	40df      	lsrs	r7, r3
   281d2:	2d20      	cmp	r5, #32
   281d4:	d071      	beq.n	282ba <__aeabi_dsub+0x416>
   281d6:	2340      	movs	r3, #64	; 0x40
   281d8:	1b5d      	subs	r5, r3, r5
   281da:	40a9      	lsls	r1, r5
   281dc:	430a      	orrs	r2, r1
   281de:	1e51      	subs	r1, r2, #1
   281e0:	418a      	sbcs	r2, r1
   281e2:	2100      	movs	r1, #0
   281e4:	4317      	orrs	r7, r2
   281e6:	e6af      	b.n	27f48 <__aeabi_dsub+0xa4>
   281e8:	000007ff 	.word	0x000007ff
   281ec:	ff7fffff 	.word	0xff7fffff
   281f0:	800fffff 	.word	0x800fffff
   281f4:	2e00      	cmp	r6, #0
   281f6:	d03e      	beq.n	28276 <__aeabi_dsub+0x3d2>
   281f8:	4eb3      	ldr	r6, [pc, #716]	; (284c8 <__aeabi_dsub+0x624>)
   281fa:	45b4      	cmp	ip, r6
   281fc:	d045      	beq.n	2828a <__aeabi_dsub+0x3e6>
   281fe:	2680      	movs	r6, #128	; 0x80
   28200:	0436      	lsls	r6, r6, #16
   28202:	426d      	negs	r5, r5
   28204:	4334      	orrs	r4, r6
   28206:	2d38      	cmp	r5, #56	; 0x38
   28208:	dd00      	ble.n	2820c <__aeabi_dsub+0x368>
   2820a:	e0a8      	b.n	2835e <__aeabi_dsub+0x4ba>
   2820c:	2d1f      	cmp	r5, #31
   2820e:	dd00      	ble.n	28212 <__aeabi_dsub+0x36e>
   28210:	e11f      	b.n	28452 <__aeabi_dsub+0x5ae>
   28212:	2620      	movs	r6, #32
   28214:	0027      	movs	r7, r4
   28216:	4650      	mov	r0, sl
   28218:	1b76      	subs	r6, r6, r5
   2821a:	40b7      	lsls	r7, r6
   2821c:	40e8      	lsrs	r0, r5
   2821e:	4307      	orrs	r7, r0
   28220:	4650      	mov	r0, sl
   28222:	40b0      	lsls	r0, r6
   28224:	1e46      	subs	r6, r0, #1
   28226:	41b0      	sbcs	r0, r6
   28228:	40ec      	lsrs	r4, r5
   2822a:	4338      	orrs	r0, r7
   2822c:	1a17      	subs	r7, r2, r0
   2822e:	42ba      	cmp	r2, r7
   28230:	4192      	sbcs	r2, r2
   28232:	1b0c      	subs	r4, r1, r4
   28234:	4252      	negs	r2, r2
   28236:	1aa4      	subs	r4, r4, r2
   28238:	4666      	mov	r6, ip
   2823a:	4698      	mov	r8, r3
   2823c:	e68b      	b.n	27f56 <__aeabi_dsub+0xb2>
   2823e:	4664      	mov	r4, ip
   28240:	4667      	mov	r7, ip
   28242:	432c      	orrs	r4, r5
   28244:	d000      	beq.n	28248 <__aeabi_dsub+0x3a4>
   28246:	e68b      	b.n	27f60 <__aeabi_dsub+0xbc>
   28248:	2500      	movs	r5, #0
   2824a:	2600      	movs	r6, #0
   2824c:	2700      	movs	r7, #0
   2824e:	e6ea      	b.n	28026 <__aeabi_dsub+0x182>
   28250:	001e      	movs	r6, r3
   28252:	e6ad      	b.n	27fb0 <__aeabi_dsub+0x10c>
   28254:	2b1f      	cmp	r3, #31
   28256:	dc60      	bgt.n	2831a <__aeabi_dsub+0x476>
   28258:	2720      	movs	r7, #32
   2825a:	1af8      	subs	r0, r7, r3
   2825c:	000f      	movs	r7, r1
   2825e:	4684      	mov	ip, r0
   28260:	4087      	lsls	r7, r0
   28262:	0010      	movs	r0, r2
   28264:	40d8      	lsrs	r0, r3
   28266:	4307      	orrs	r7, r0
   28268:	4660      	mov	r0, ip
   2826a:	4082      	lsls	r2, r0
   2826c:	1e50      	subs	r0, r2, #1
   2826e:	4182      	sbcs	r2, r0
   28270:	40d9      	lsrs	r1, r3
   28272:	4317      	orrs	r7, r2
   28274:	e6f5      	b.n	28062 <__aeabi_dsub+0x1be>
   28276:	0026      	movs	r6, r4
   28278:	4650      	mov	r0, sl
   2827a:	4306      	orrs	r6, r0
   2827c:	d005      	beq.n	2828a <__aeabi_dsub+0x3e6>
   2827e:	43ed      	mvns	r5, r5
   28280:	2d00      	cmp	r5, #0
   28282:	d0d3      	beq.n	2822c <__aeabi_dsub+0x388>
   28284:	4e90      	ldr	r6, [pc, #576]	; (284c8 <__aeabi_dsub+0x624>)
   28286:	45b4      	cmp	ip, r6
   28288:	d1bd      	bne.n	28206 <__aeabi_dsub+0x362>
   2828a:	000c      	movs	r4, r1
   2828c:	0017      	movs	r7, r2
   2828e:	4666      	mov	r6, ip
   28290:	4698      	mov	r8, r3
   28292:	e68d      	b.n	27fb0 <__aeabi_dsub+0x10c>
   28294:	488c      	ldr	r0, [pc, #560]	; (284c8 <__aeabi_dsub+0x624>)
   28296:	4283      	cmp	r3, r0
   28298:	d00b      	beq.n	282b2 <__aeabi_dsub+0x40e>
   2829a:	4663      	mov	r3, ip
   2829c:	e6d9      	b.n	28052 <__aeabi_dsub+0x1ae>
   2829e:	2d00      	cmp	r5, #0
   282a0:	d000      	beq.n	282a4 <__aeabi_dsub+0x400>
   282a2:	e096      	b.n	283d2 <__aeabi_dsub+0x52e>
   282a4:	0008      	movs	r0, r1
   282a6:	4310      	orrs	r0, r2
   282a8:	d100      	bne.n	282ac <__aeabi_dsub+0x408>
   282aa:	e0e2      	b.n	28472 <__aeabi_dsub+0x5ce>
   282ac:	000c      	movs	r4, r1
   282ae:	0017      	movs	r7, r2
   282b0:	4698      	mov	r8, r3
   282b2:	4e85      	ldr	r6, [pc, #532]	; (284c8 <__aeabi_dsub+0x624>)
   282b4:	e67c      	b.n	27fb0 <__aeabi_dsub+0x10c>
   282b6:	2500      	movs	r5, #0
   282b8:	e780      	b.n	281bc <__aeabi_dsub+0x318>
   282ba:	2100      	movs	r1, #0
   282bc:	e78e      	b.n	281dc <__aeabi_dsub+0x338>
   282be:	0023      	movs	r3, r4
   282c0:	4650      	mov	r0, sl
   282c2:	4303      	orrs	r3, r0
   282c4:	2e00      	cmp	r6, #0
   282c6:	d000      	beq.n	282ca <__aeabi_dsub+0x426>
   282c8:	e0a8      	b.n	2841c <__aeabi_dsub+0x578>
   282ca:	2b00      	cmp	r3, #0
   282cc:	d100      	bne.n	282d0 <__aeabi_dsub+0x42c>
   282ce:	e0de      	b.n	2848e <__aeabi_dsub+0x5ea>
   282d0:	000b      	movs	r3, r1
   282d2:	4313      	orrs	r3, r2
   282d4:	d100      	bne.n	282d8 <__aeabi_dsub+0x434>
   282d6:	e66b      	b.n	27fb0 <__aeabi_dsub+0x10c>
   282d8:	4452      	add	r2, sl
   282da:	4552      	cmp	r2, sl
   282dc:	4180      	sbcs	r0, r0
   282de:	1864      	adds	r4, r4, r1
   282e0:	4240      	negs	r0, r0
   282e2:	1824      	adds	r4, r4, r0
   282e4:	0017      	movs	r7, r2
   282e6:	0223      	lsls	r3, r4, #8
   282e8:	d400      	bmi.n	282ec <__aeabi_dsub+0x448>
   282ea:	e6fd      	b.n	280e8 <__aeabi_dsub+0x244>
   282ec:	4b77      	ldr	r3, [pc, #476]	; (284cc <__aeabi_dsub+0x628>)
   282ee:	4666      	mov	r6, ip
   282f0:	401c      	ands	r4, r3
   282f2:	e65d      	b.n	27fb0 <__aeabi_dsub+0x10c>
   282f4:	0025      	movs	r5, r4
   282f6:	4650      	mov	r0, sl
   282f8:	4305      	orrs	r5, r0
   282fa:	2e00      	cmp	r6, #0
   282fc:	d1cf      	bne.n	2829e <__aeabi_dsub+0x3fa>
   282fe:	2d00      	cmp	r5, #0
   28300:	d14f      	bne.n	283a2 <__aeabi_dsub+0x4fe>
   28302:	000c      	movs	r4, r1
   28304:	4314      	orrs	r4, r2
   28306:	d100      	bne.n	2830a <__aeabi_dsub+0x466>
   28308:	e0a0      	b.n	2844c <__aeabi_dsub+0x5a8>
   2830a:	000c      	movs	r4, r1
   2830c:	0017      	movs	r7, r2
   2830e:	4698      	mov	r8, r3
   28310:	e64e      	b.n	27fb0 <__aeabi_dsub+0x10c>
   28312:	4666      	mov	r6, ip
   28314:	2400      	movs	r4, #0
   28316:	2700      	movs	r7, #0
   28318:	e685      	b.n	28026 <__aeabi_dsub+0x182>
   2831a:	001f      	movs	r7, r3
   2831c:	0008      	movs	r0, r1
   2831e:	3f20      	subs	r7, #32
   28320:	40f8      	lsrs	r0, r7
   28322:	0007      	movs	r7, r0
   28324:	2b20      	cmp	r3, #32
   28326:	d100      	bne.n	2832a <__aeabi_dsub+0x486>
   28328:	e08e      	b.n	28448 <__aeabi_dsub+0x5a4>
   2832a:	2040      	movs	r0, #64	; 0x40
   2832c:	1ac3      	subs	r3, r0, r3
   2832e:	4099      	lsls	r1, r3
   28330:	430a      	orrs	r2, r1
   28332:	1e51      	subs	r1, r2, #1
   28334:	418a      	sbcs	r2, r1
   28336:	2100      	movs	r1, #0
   28338:	4317      	orrs	r7, r2
   2833a:	e692      	b.n	28062 <__aeabi_dsub+0x1be>
   2833c:	2e00      	cmp	r6, #0
   2833e:	d114      	bne.n	2836a <__aeabi_dsub+0x4c6>
   28340:	0026      	movs	r6, r4
   28342:	4650      	mov	r0, sl
   28344:	4306      	orrs	r6, r0
   28346:	d062      	beq.n	2840e <__aeabi_dsub+0x56a>
   28348:	43db      	mvns	r3, r3
   2834a:	2b00      	cmp	r3, #0
   2834c:	d15c      	bne.n	28408 <__aeabi_dsub+0x564>
   2834e:	1887      	adds	r7, r0, r2
   28350:	4297      	cmp	r7, r2
   28352:	4192      	sbcs	r2, r2
   28354:	1864      	adds	r4, r4, r1
   28356:	4252      	negs	r2, r2
   28358:	18a4      	adds	r4, r4, r2
   2835a:	4666      	mov	r6, ip
   2835c:	e687      	b.n	2806e <__aeabi_dsub+0x1ca>
   2835e:	4650      	mov	r0, sl
   28360:	4320      	orrs	r0, r4
   28362:	1e44      	subs	r4, r0, #1
   28364:	41a0      	sbcs	r0, r4
   28366:	2400      	movs	r4, #0
   28368:	e760      	b.n	2822c <__aeabi_dsub+0x388>
   2836a:	4e57      	ldr	r6, [pc, #348]	; (284c8 <__aeabi_dsub+0x624>)
   2836c:	45b4      	cmp	ip, r6
   2836e:	d04e      	beq.n	2840e <__aeabi_dsub+0x56a>
   28370:	2680      	movs	r6, #128	; 0x80
   28372:	0436      	lsls	r6, r6, #16
   28374:	425b      	negs	r3, r3
   28376:	4334      	orrs	r4, r6
   28378:	2b38      	cmp	r3, #56	; 0x38
   2837a:	dd00      	ble.n	2837e <__aeabi_dsub+0x4da>
   2837c:	e07f      	b.n	2847e <__aeabi_dsub+0x5da>
   2837e:	2b1f      	cmp	r3, #31
   28380:	dd00      	ble.n	28384 <__aeabi_dsub+0x4e0>
   28382:	e08b      	b.n	2849c <__aeabi_dsub+0x5f8>
   28384:	2620      	movs	r6, #32
   28386:	0027      	movs	r7, r4
   28388:	4650      	mov	r0, sl
   2838a:	1af6      	subs	r6, r6, r3
   2838c:	40b7      	lsls	r7, r6
   2838e:	40d8      	lsrs	r0, r3
   28390:	4307      	orrs	r7, r0
   28392:	4650      	mov	r0, sl
   28394:	40b0      	lsls	r0, r6
   28396:	1e46      	subs	r6, r0, #1
   28398:	41b0      	sbcs	r0, r6
   2839a:	4307      	orrs	r7, r0
   2839c:	40dc      	lsrs	r4, r3
   2839e:	18bf      	adds	r7, r7, r2
   283a0:	e7d6      	b.n	28350 <__aeabi_dsub+0x4ac>
   283a2:	000d      	movs	r5, r1
   283a4:	4315      	orrs	r5, r2
   283a6:	d100      	bne.n	283aa <__aeabi_dsub+0x506>
   283a8:	e602      	b.n	27fb0 <__aeabi_dsub+0x10c>
   283aa:	4650      	mov	r0, sl
   283ac:	1a80      	subs	r0, r0, r2
   283ae:	4582      	cmp	sl, r0
   283b0:	41bf      	sbcs	r7, r7
   283b2:	1a65      	subs	r5, r4, r1
   283b4:	427f      	negs	r7, r7
   283b6:	1bed      	subs	r5, r5, r7
   283b8:	4684      	mov	ip, r0
   283ba:	0228      	lsls	r0, r5, #8
   283bc:	d400      	bmi.n	283c0 <__aeabi_dsub+0x51c>
   283be:	e68d      	b.n	280dc <__aeabi_dsub+0x238>
   283c0:	4650      	mov	r0, sl
   283c2:	1a17      	subs	r7, r2, r0
   283c4:	42ba      	cmp	r2, r7
   283c6:	4192      	sbcs	r2, r2
   283c8:	1b0c      	subs	r4, r1, r4
   283ca:	4252      	negs	r2, r2
   283cc:	1aa4      	subs	r4, r4, r2
   283ce:	4698      	mov	r8, r3
   283d0:	e5ee      	b.n	27fb0 <__aeabi_dsub+0x10c>
   283d2:	000d      	movs	r5, r1
   283d4:	4315      	orrs	r5, r2
   283d6:	d100      	bne.n	283da <__aeabi_dsub+0x536>
   283d8:	e76b      	b.n	282b2 <__aeabi_dsub+0x40e>
   283da:	4650      	mov	r0, sl
   283dc:	0767      	lsls	r7, r4, #29
   283de:	08c0      	lsrs	r0, r0, #3
   283e0:	4307      	orrs	r7, r0
   283e2:	2080      	movs	r0, #128	; 0x80
   283e4:	08e4      	lsrs	r4, r4, #3
   283e6:	0300      	lsls	r0, r0, #12
   283e8:	4204      	tst	r4, r0
   283ea:	d007      	beq.n	283fc <__aeabi_dsub+0x558>
   283ec:	08cd      	lsrs	r5, r1, #3
   283ee:	4205      	tst	r5, r0
   283f0:	d104      	bne.n	283fc <__aeabi_dsub+0x558>
   283f2:	002c      	movs	r4, r5
   283f4:	4698      	mov	r8, r3
   283f6:	08d7      	lsrs	r7, r2, #3
   283f8:	0749      	lsls	r1, r1, #29
   283fa:	430f      	orrs	r7, r1
   283fc:	0f7b      	lsrs	r3, r7, #29
   283fe:	00e4      	lsls	r4, r4, #3
   28400:	431c      	orrs	r4, r3
   28402:	00ff      	lsls	r7, r7, #3
   28404:	4e30      	ldr	r6, [pc, #192]	; (284c8 <__aeabi_dsub+0x624>)
   28406:	e5d3      	b.n	27fb0 <__aeabi_dsub+0x10c>
   28408:	4e2f      	ldr	r6, [pc, #188]	; (284c8 <__aeabi_dsub+0x624>)
   2840a:	45b4      	cmp	ip, r6
   2840c:	d1b4      	bne.n	28378 <__aeabi_dsub+0x4d4>
   2840e:	000c      	movs	r4, r1
   28410:	0017      	movs	r7, r2
   28412:	4666      	mov	r6, ip
   28414:	e5cc      	b.n	27fb0 <__aeabi_dsub+0x10c>
   28416:	2700      	movs	r7, #0
   28418:	2400      	movs	r4, #0
   2841a:	e5e8      	b.n	27fee <__aeabi_dsub+0x14a>
   2841c:	2b00      	cmp	r3, #0
   2841e:	d039      	beq.n	28494 <__aeabi_dsub+0x5f0>
   28420:	000b      	movs	r3, r1
   28422:	4313      	orrs	r3, r2
   28424:	d100      	bne.n	28428 <__aeabi_dsub+0x584>
   28426:	e744      	b.n	282b2 <__aeabi_dsub+0x40e>
   28428:	08c0      	lsrs	r0, r0, #3
   2842a:	0767      	lsls	r7, r4, #29
   2842c:	4307      	orrs	r7, r0
   2842e:	2080      	movs	r0, #128	; 0x80
   28430:	08e4      	lsrs	r4, r4, #3
   28432:	0300      	lsls	r0, r0, #12
   28434:	4204      	tst	r4, r0
   28436:	d0e1      	beq.n	283fc <__aeabi_dsub+0x558>
   28438:	08cb      	lsrs	r3, r1, #3
   2843a:	4203      	tst	r3, r0
   2843c:	d1de      	bne.n	283fc <__aeabi_dsub+0x558>
   2843e:	08d7      	lsrs	r7, r2, #3
   28440:	0749      	lsls	r1, r1, #29
   28442:	430f      	orrs	r7, r1
   28444:	001c      	movs	r4, r3
   28446:	e7d9      	b.n	283fc <__aeabi_dsub+0x558>
   28448:	2100      	movs	r1, #0
   2844a:	e771      	b.n	28330 <__aeabi_dsub+0x48c>
   2844c:	2500      	movs	r5, #0
   2844e:	2700      	movs	r7, #0
   28450:	e5e9      	b.n	28026 <__aeabi_dsub+0x182>
   28452:	002e      	movs	r6, r5
   28454:	0027      	movs	r7, r4
   28456:	3e20      	subs	r6, #32
   28458:	40f7      	lsrs	r7, r6
   2845a:	2d20      	cmp	r5, #32
   2845c:	d02f      	beq.n	284be <__aeabi_dsub+0x61a>
   2845e:	2640      	movs	r6, #64	; 0x40
   28460:	1b75      	subs	r5, r6, r5
   28462:	40ac      	lsls	r4, r5
   28464:	4650      	mov	r0, sl
   28466:	4320      	orrs	r0, r4
   28468:	1e44      	subs	r4, r0, #1
   2846a:	41a0      	sbcs	r0, r4
   2846c:	2400      	movs	r4, #0
   2846e:	4338      	orrs	r0, r7
   28470:	e6dc      	b.n	2822c <__aeabi_dsub+0x388>
   28472:	2480      	movs	r4, #128	; 0x80
   28474:	2500      	movs	r5, #0
   28476:	0324      	lsls	r4, r4, #12
   28478:	4e13      	ldr	r6, [pc, #76]	; (284c8 <__aeabi_dsub+0x624>)
   2847a:	2700      	movs	r7, #0
   2847c:	e5d3      	b.n	28026 <__aeabi_dsub+0x182>
   2847e:	4650      	mov	r0, sl
   28480:	4320      	orrs	r0, r4
   28482:	0007      	movs	r7, r0
   28484:	1e78      	subs	r0, r7, #1
   28486:	4187      	sbcs	r7, r0
   28488:	2400      	movs	r4, #0
   2848a:	18bf      	adds	r7, r7, r2
   2848c:	e760      	b.n	28350 <__aeabi_dsub+0x4ac>
   2848e:	000c      	movs	r4, r1
   28490:	0017      	movs	r7, r2
   28492:	e58d      	b.n	27fb0 <__aeabi_dsub+0x10c>
   28494:	000c      	movs	r4, r1
   28496:	0017      	movs	r7, r2
   28498:	4e0b      	ldr	r6, [pc, #44]	; (284c8 <__aeabi_dsub+0x624>)
   2849a:	e589      	b.n	27fb0 <__aeabi_dsub+0x10c>
   2849c:	001e      	movs	r6, r3
   2849e:	0027      	movs	r7, r4
   284a0:	3e20      	subs	r6, #32
   284a2:	40f7      	lsrs	r7, r6
   284a4:	2b20      	cmp	r3, #32
   284a6:	d00c      	beq.n	284c2 <__aeabi_dsub+0x61e>
   284a8:	2640      	movs	r6, #64	; 0x40
   284aa:	1af3      	subs	r3, r6, r3
   284ac:	409c      	lsls	r4, r3
   284ae:	4650      	mov	r0, sl
   284b0:	4320      	orrs	r0, r4
   284b2:	1e44      	subs	r4, r0, #1
   284b4:	41a0      	sbcs	r0, r4
   284b6:	4307      	orrs	r7, r0
   284b8:	2400      	movs	r4, #0
   284ba:	18bf      	adds	r7, r7, r2
   284bc:	e748      	b.n	28350 <__aeabi_dsub+0x4ac>
   284be:	2400      	movs	r4, #0
   284c0:	e7d0      	b.n	28464 <__aeabi_dsub+0x5c0>
   284c2:	2400      	movs	r4, #0
   284c4:	e7f3      	b.n	284ae <__aeabi_dsub+0x60a>
   284c6:	46c0      	nop			; (mov r8, r8)
   284c8:	000007ff 	.word	0x000007ff
   284cc:	ff7fffff 	.word	0xff7fffff

000284d0 <__aeabi_dcmpun>:
   284d0:	b570      	push	{r4, r5, r6, lr}
   284d2:	4e0e      	ldr	r6, [pc, #56]	; (2850c <__aeabi_dcmpun+0x3c>)
   284d4:	030d      	lsls	r5, r1, #12
   284d6:	031c      	lsls	r4, r3, #12
   284d8:	0049      	lsls	r1, r1, #1
   284da:	005b      	lsls	r3, r3, #1
   284dc:	0b2d      	lsrs	r5, r5, #12
   284de:	0d49      	lsrs	r1, r1, #21
   284e0:	0b24      	lsrs	r4, r4, #12
   284e2:	0d5b      	lsrs	r3, r3, #21
   284e4:	42b1      	cmp	r1, r6
   284e6:	d004      	beq.n	284f2 <__aeabi_dcmpun+0x22>
   284e8:	4908      	ldr	r1, [pc, #32]	; (2850c <__aeabi_dcmpun+0x3c>)
   284ea:	2000      	movs	r0, #0
   284ec:	428b      	cmp	r3, r1
   284ee:	d008      	beq.n	28502 <__aeabi_dcmpun+0x32>
   284f0:	bd70      	pop	{r4, r5, r6, pc}
   284f2:	4305      	orrs	r5, r0
   284f4:	2001      	movs	r0, #1
   284f6:	2d00      	cmp	r5, #0
   284f8:	d1fa      	bne.n	284f0 <__aeabi_dcmpun+0x20>
   284fa:	4904      	ldr	r1, [pc, #16]	; (2850c <__aeabi_dcmpun+0x3c>)
   284fc:	2000      	movs	r0, #0
   284fe:	428b      	cmp	r3, r1
   28500:	d1f6      	bne.n	284f0 <__aeabi_dcmpun+0x20>
   28502:	4314      	orrs	r4, r2
   28504:	0020      	movs	r0, r4
   28506:	1e44      	subs	r4, r0, #1
   28508:	41a0      	sbcs	r0, r4
   2850a:	e7f1      	b.n	284f0 <__aeabi_dcmpun+0x20>
   2850c:	000007ff 	.word	0x000007ff

00028510 <__aeabi_d2iz>:
   28510:	b530      	push	{r4, r5, lr}
   28512:	4d13      	ldr	r5, [pc, #76]	; (28560 <__aeabi_d2iz+0x50>)
   28514:	030a      	lsls	r2, r1, #12
   28516:	004b      	lsls	r3, r1, #1
   28518:	0b12      	lsrs	r2, r2, #12
   2851a:	0d5b      	lsrs	r3, r3, #21
   2851c:	0fc9      	lsrs	r1, r1, #31
   2851e:	2400      	movs	r4, #0
   28520:	42ab      	cmp	r3, r5
   28522:	dd10      	ble.n	28546 <__aeabi_d2iz+0x36>
   28524:	4c0f      	ldr	r4, [pc, #60]	; (28564 <__aeabi_d2iz+0x54>)
   28526:	42a3      	cmp	r3, r4
   28528:	dc0f      	bgt.n	2854a <__aeabi_d2iz+0x3a>
   2852a:	2480      	movs	r4, #128	; 0x80
   2852c:	4d0e      	ldr	r5, [pc, #56]	; (28568 <__aeabi_d2iz+0x58>)
   2852e:	0364      	lsls	r4, r4, #13
   28530:	4322      	orrs	r2, r4
   28532:	1aed      	subs	r5, r5, r3
   28534:	2d1f      	cmp	r5, #31
   28536:	dd0b      	ble.n	28550 <__aeabi_d2iz+0x40>
   28538:	480c      	ldr	r0, [pc, #48]	; (2856c <__aeabi_d2iz+0x5c>)
   2853a:	1ac3      	subs	r3, r0, r3
   2853c:	40da      	lsrs	r2, r3
   2853e:	4254      	negs	r4, r2
   28540:	2900      	cmp	r1, #0
   28542:	d100      	bne.n	28546 <__aeabi_d2iz+0x36>
   28544:	0014      	movs	r4, r2
   28546:	0020      	movs	r0, r4
   28548:	bd30      	pop	{r4, r5, pc}
   2854a:	4b09      	ldr	r3, [pc, #36]	; (28570 <__aeabi_d2iz+0x60>)
   2854c:	18cc      	adds	r4, r1, r3
   2854e:	e7fa      	b.n	28546 <__aeabi_d2iz+0x36>
   28550:	4c08      	ldr	r4, [pc, #32]	; (28574 <__aeabi_d2iz+0x64>)
   28552:	40e8      	lsrs	r0, r5
   28554:	46a4      	mov	ip, r4
   28556:	4463      	add	r3, ip
   28558:	409a      	lsls	r2, r3
   2855a:	4302      	orrs	r2, r0
   2855c:	e7ef      	b.n	2853e <__aeabi_d2iz+0x2e>
   2855e:	46c0      	nop			; (mov r8, r8)
   28560:	000003fe 	.word	0x000003fe
   28564:	0000041d 	.word	0x0000041d
   28568:	00000433 	.word	0x00000433
   2856c:	00000413 	.word	0x00000413
   28570:	7fffffff 	.word	0x7fffffff
   28574:	fffffbed 	.word	0xfffffbed

00028578 <__aeabi_i2d>:
   28578:	b570      	push	{r4, r5, r6, lr}
   2857a:	2800      	cmp	r0, #0
   2857c:	d030      	beq.n	285e0 <__aeabi_i2d+0x68>
   2857e:	17c3      	asrs	r3, r0, #31
   28580:	18c4      	adds	r4, r0, r3
   28582:	405c      	eors	r4, r3
   28584:	0fc5      	lsrs	r5, r0, #31
   28586:	0020      	movs	r0, r4
   28588:	f000 f8c2 	bl	28710 <__clzsi2>
   2858c:	4b17      	ldr	r3, [pc, #92]	; (285ec <__aeabi_i2d+0x74>)
   2858e:	4a18      	ldr	r2, [pc, #96]	; (285f0 <__aeabi_i2d+0x78>)
   28590:	1a1b      	subs	r3, r3, r0
   28592:	1ad2      	subs	r2, r2, r3
   28594:	2a1f      	cmp	r2, #31
   28596:	dd18      	ble.n	285ca <__aeabi_i2d+0x52>
   28598:	4a16      	ldr	r2, [pc, #88]	; (285f4 <__aeabi_i2d+0x7c>)
   2859a:	1ad2      	subs	r2, r2, r3
   2859c:	4094      	lsls	r4, r2
   2859e:	2200      	movs	r2, #0
   285a0:	0324      	lsls	r4, r4, #12
   285a2:	055b      	lsls	r3, r3, #21
   285a4:	0b24      	lsrs	r4, r4, #12
   285a6:	0d5b      	lsrs	r3, r3, #21
   285a8:	2100      	movs	r1, #0
   285aa:	0010      	movs	r0, r2
   285ac:	0324      	lsls	r4, r4, #12
   285ae:	0d0a      	lsrs	r2, r1, #20
   285b0:	0b24      	lsrs	r4, r4, #12
   285b2:	0512      	lsls	r2, r2, #20
   285b4:	4322      	orrs	r2, r4
   285b6:	4c10      	ldr	r4, [pc, #64]	; (285f8 <__aeabi_i2d+0x80>)
   285b8:	051b      	lsls	r3, r3, #20
   285ba:	4022      	ands	r2, r4
   285bc:	4313      	orrs	r3, r2
   285be:	005b      	lsls	r3, r3, #1
   285c0:	07ed      	lsls	r5, r5, #31
   285c2:	085b      	lsrs	r3, r3, #1
   285c4:	432b      	orrs	r3, r5
   285c6:	0019      	movs	r1, r3
   285c8:	bd70      	pop	{r4, r5, r6, pc}
   285ca:	0021      	movs	r1, r4
   285cc:	4091      	lsls	r1, r2
   285ce:	000a      	movs	r2, r1
   285d0:	210b      	movs	r1, #11
   285d2:	1a08      	subs	r0, r1, r0
   285d4:	40c4      	lsrs	r4, r0
   285d6:	055b      	lsls	r3, r3, #21
   285d8:	0324      	lsls	r4, r4, #12
   285da:	0b24      	lsrs	r4, r4, #12
   285dc:	0d5b      	lsrs	r3, r3, #21
   285de:	e7e3      	b.n	285a8 <__aeabi_i2d+0x30>
   285e0:	2500      	movs	r5, #0
   285e2:	2300      	movs	r3, #0
   285e4:	2400      	movs	r4, #0
   285e6:	2200      	movs	r2, #0
   285e8:	e7de      	b.n	285a8 <__aeabi_i2d+0x30>
   285ea:	46c0      	nop			; (mov r8, r8)
   285ec:	0000041e 	.word	0x0000041e
   285f0:	00000433 	.word	0x00000433
   285f4:	00000413 	.word	0x00000413
   285f8:	800fffff 	.word	0x800fffff

000285fc <__aeabi_ui2d>:
   285fc:	b510      	push	{r4, lr}
   285fe:	1e04      	subs	r4, r0, #0
   28600:	d028      	beq.n	28654 <__aeabi_ui2d+0x58>
   28602:	f000 f885 	bl	28710 <__clzsi2>
   28606:	4b15      	ldr	r3, [pc, #84]	; (2865c <__aeabi_ui2d+0x60>)
   28608:	4a15      	ldr	r2, [pc, #84]	; (28660 <__aeabi_ui2d+0x64>)
   2860a:	1a1b      	subs	r3, r3, r0
   2860c:	1ad2      	subs	r2, r2, r3
   2860e:	2a1f      	cmp	r2, #31
   28610:	dd15      	ble.n	2863e <__aeabi_ui2d+0x42>
   28612:	4a14      	ldr	r2, [pc, #80]	; (28664 <__aeabi_ui2d+0x68>)
   28614:	1ad2      	subs	r2, r2, r3
   28616:	4094      	lsls	r4, r2
   28618:	2200      	movs	r2, #0
   2861a:	0324      	lsls	r4, r4, #12
   2861c:	055b      	lsls	r3, r3, #21
   2861e:	0b24      	lsrs	r4, r4, #12
   28620:	0d5b      	lsrs	r3, r3, #21
   28622:	2100      	movs	r1, #0
   28624:	0010      	movs	r0, r2
   28626:	0324      	lsls	r4, r4, #12
   28628:	0d0a      	lsrs	r2, r1, #20
   2862a:	0b24      	lsrs	r4, r4, #12
   2862c:	0512      	lsls	r2, r2, #20
   2862e:	4322      	orrs	r2, r4
   28630:	4c0d      	ldr	r4, [pc, #52]	; (28668 <__aeabi_ui2d+0x6c>)
   28632:	051b      	lsls	r3, r3, #20
   28634:	4022      	ands	r2, r4
   28636:	4313      	orrs	r3, r2
   28638:	005b      	lsls	r3, r3, #1
   2863a:	0859      	lsrs	r1, r3, #1
   2863c:	bd10      	pop	{r4, pc}
   2863e:	0021      	movs	r1, r4
   28640:	4091      	lsls	r1, r2
   28642:	000a      	movs	r2, r1
   28644:	210b      	movs	r1, #11
   28646:	1a08      	subs	r0, r1, r0
   28648:	40c4      	lsrs	r4, r0
   2864a:	055b      	lsls	r3, r3, #21
   2864c:	0324      	lsls	r4, r4, #12
   2864e:	0b24      	lsrs	r4, r4, #12
   28650:	0d5b      	lsrs	r3, r3, #21
   28652:	e7e6      	b.n	28622 <__aeabi_ui2d+0x26>
   28654:	2300      	movs	r3, #0
   28656:	2400      	movs	r4, #0
   28658:	2200      	movs	r2, #0
   2865a:	e7e2      	b.n	28622 <__aeabi_ui2d+0x26>
   2865c:	0000041e 	.word	0x0000041e
   28660:	00000433 	.word	0x00000433
   28664:	00000413 	.word	0x00000413
   28668:	800fffff 	.word	0x800fffff

0002866c <__aeabi_f2d>:
   2866c:	0041      	lsls	r1, r0, #1
   2866e:	0e09      	lsrs	r1, r1, #24
   28670:	1c4b      	adds	r3, r1, #1
   28672:	b570      	push	{r4, r5, r6, lr}
   28674:	b2db      	uxtb	r3, r3
   28676:	0246      	lsls	r6, r0, #9
   28678:	0a75      	lsrs	r5, r6, #9
   2867a:	0fc4      	lsrs	r4, r0, #31
   2867c:	2b01      	cmp	r3, #1
   2867e:	dd14      	ble.n	286aa <__aeabi_f2d+0x3e>
   28680:	23e0      	movs	r3, #224	; 0xe0
   28682:	009b      	lsls	r3, r3, #2
   28684:	076d      	lsls	r5, r5, #29
   28686:	0b36      	lsrs	r6, r6, #12
   28688:	18cb      	adds	r3, r1, r3
   2868a:	2100      	movs	r1, #0
   2868c:	0d0a      	lsrs	r2, r1, #20
   2868e:	0028      	movs	r0, r5
   28690:	0512      	lsls	r2, r2, #20
   28692:	4d1c      	ldr	r5, [pc, #112]	; (28704 <__aeabi_f2d+0x98>)
   28694:	4332      	orrs	r2, r6
   28696:	055b      	lsls	r3, r3, #21
   28698:	402a      	ands	r2, r5
   2869a:	085b      	lsrs	r3, r3, #1
   2869c:	4313      	orrs	r3, r2
   2869e:	005b      	lsls	r3, r3, #1
   286a0:	07e4      	lsls	r4, r4, #31
   286a2:	085b      	lsrs	r3, r3, #1
   286a4:	4323      	orrs	r3, r4
   286a6:	0019      	movs	r1, r3
   286a8:	bd70      	pop	{r4, r5, r6, pc}
   286aa:	2900      	cmp	r1, #0
   286ac:	d114      	bne.n	286d8 <__aeabi_f2d+0x6c>
   286ae:	2d00      	cmp	r5, #0
   286b0:	d01e      	beq.n	286f0 <__aeabi_f2d+0x84>
   286b2:	0028      	movs	r0, r5
   286b4:	f000 f82c 	bl	28710 <__clzsi2>
   286b8:	280a      	cmp	r0, #10
   286ba:	dc1c      	bgt.n	286f6 <__aeabi_f2d+0x8a>
   286bc:	230b      	movs	r3, #11
   286be:	002a      	movs	r2, r5
   286c0:	1a1b      	subs	r3, r3, r0
   286c2:	40da      	lsrs	r2, r3
   286c4:	0003      	movs	r3, r0
   286c6:	3315      	adds	r3, #21
   286c8:	409d      	lsls	r5, r3
   286ca:	4b0f      	ldr	r3, [pc, #60]	; (28708 <__aeabi_f2d+0x9c>)
   286cc:	0312      	lsls	r2, r2, #12
   286ce:	1a1b      	subs	r3, r3, r0
   286d0:	055b      	lsls	r3, r3, #21
   286d2:	0b16      	lsrs	r6, r2, #12
   286d4:	0d5b      	lsrs	r3, r3, #21
   286d6:	e7d8      	b.n	2868a <__aeabi_f2d+0x1e>
   286d8:	2d00      	cmp	r5, #0
   286da:	d006      	beq.n	286ea <__aeabi_f2d+0x7e>
   286dc:	0b32      	lsrs	r2, r6, #12
   286de:	2680      	movs	r6, #128	; 0x80
   286e0:	0336      	lsls	r6, r6, #12
   286e2:	076d      	lsls	r5, r5, #29
   286e4:	4316      	orrs	r6, r2
   286e6:	4b09      	ldr	r3, [pc, #36]	; (2870c <__aeabi_f2d+0xa0>)
   286e8:	e7cf      	b.n	2868a <__aeabi_f2d+0x1e>
   286ea:	4b08      	ldr	r3, [pc, #32]	; (2870c <__aeabi_f2d+0xa0>)
   286ec:	2600      	movs	r6, #0
   286ee:	e7cc      	b.n	2868a <__aeabi_f2d+0x1e>
   286f0:	2300      	movs	r3, #0
   286f2:	2600      	movs	r6, #0
   286f4:	e7c9      	b.n	2868a <__aeabi_f2d+0x1e>
   286f6:	0003      	movs	r3, r0
   286f8:	002a      	movs	r2, r5
   286fa:	3b0b      	subs	r3, #11
   286fc:	409a      	lsls	r2, r3
   286fe:	2500      	movs	r5, #0
   28700:	e7e3      	b.n	286ca <__aeabi_f2d+0x5e>
   28702:	46c0      	nop			; (mov r8, r8)
   28704:	800fffff 	.word	0x800fffff
   28708:	00000389 	.word	0x00000389
   2870c:	000007ff 	.word	0x000007ff

00028710 <__clzsi2>:
   28710:	211c      	movs	r1, #28
   28712:	2301      	movs	r3, #1
   28714:	041b      	lsls	r3, r3, #16
   28716:	4298      	cmp	r0, r3
   28718:	d301      	bcc.n	2871e <__clzsi2+0xe>
   2871a:	0c00      	lsrs	r0, r0, #16
   2871c:	3910      	subs	r1, #16
   2871e:	0a1b      	lsrs	r3, r3, #8
   28720:	4298      	cmp	r0, r3
   28722:	d301      	bcc.n	28728 <__clzsi2+0x18>
   28724:	0a00      	lsrs	r0, r0, #8
   28726:	3908      	subs	r1, #8
   28728:	091b      	lsrs	r3, r3, #4
   2872a:	4298      	cmp	r0, r3
   2872c:	d301      	bcc.n	28732 <__clzsi2+0x22>
   2872e:	0900      	lsrs	r0, r0, #4
   28730:	3904      	subs	r1, #4
   28732:	a202      	add	r2, pc, #8	; (adr r2, 2873c <__clzsi2+0x2c>)
   28734:	5c10      	ldrb	r0, [r2, r0]
   28736:	1840      	adds	r0, r0, r1
   28738:	4770      	bx	lr
   2873a:	46c0      	nop			; (mov r8, r8)
   2873c:	02020304 	.word	0x02020304
   28740:	01010101 	.word	0x01010101
	...
   28760:	bf800000 	.word	0xbf800000
   28764:	00000000 	.word	0x00000000
   28768:	bf4ccccd 	.word	0xbf4ccccd
	...
   28774:	be4ccccd 	.word	0xbe4ccccd
   28778:	bf000000 	.word	0xbf000000
   2877c:	00000000 	.word	0x00000000
   28780:	bf800000 	.word	0xbf800000
	...
   2879c:	3dcccccd 	.word	0x3dcccccd
   287a0:	3f333333 	.word	0x3f333333
   287a4:	00000000 	.word	0x00000000
   287a8:	bf4ccccd 	.word	0xbf4ccccd
   287ac:	bdcccccd 	.word	0xbdcccccd
	...
   287cc:	74737271 	.word	0x74737271
   287d0:	7075      	.short	0x7075
   287d2:	71          	.byte	0x71
   287d3:	08          	.byte	0x08
   287d4:	0820      	.short	0x0820
   287d6:	00          	.byte	0x00
   287d7:	41          	.byte	0x41
   287d8:	6c467269 	.word	0x6c467269
   287dc:	203a776f 	.word	0x203a776f
   287e0:	322e3025 	.word	0x322e3025
   287e4:	2f6d2066 	.word	0x2f6d2066
   287e8:	0a0d2073 	.word	0x0a0d2073
   287ec:	00          	.byte	0x00
   287ed:	54          	.byte	0x54
   287ee:	203a      	.short	0x203a
   287f0:	322e3025 	.word	0x322e3025
   287f4:	3a482066 	.word	0x3a482066
   287f8:	2e302520 	.word	0x2e302520
   287fc:	50206632 	.word	0x50206632
   28800:	3025203a 	.word	0x3025203a
   28804:	2066322e 	.word	0x2066322e
   28808:	0a0d      	.short	0x0a0d
   2880a:	00          	.byte	0x00
   2880b:	41          	.byte	0x41
   2880c:	5b206363 	.word	0x5b206363
   28810:	3a5d676d 	.word	0x3a5d676d
   28814:	2e302520 	.word	0x2e302520
   28818:	25206632 	.word	0x25206632
   2881c:	66322e30 	.word	0x66322e30
   28820:	2e302520 	.word	0x2e302520
   28824:	0a0d6632 	.word	0x0a0d6632
   28828:	00          	.byte	0x00
   28829:	5b          	.byte	0x5b
   2882a:	4146      	.short	0x4146
   2882c:	205d4c49 	.word	0x205d4c49
   28830:	20736572 	.word	0x20736572
   28834:	0a0d6425 	.word	0x0a0d6425
   28838:	6f6f6200 	.word	0x6f6f6200
   2883c:	6c665f74 	.word	0x6c665f74
   28840:	742e6761 	.word	0x742e6761
   28844:	61207478 	.word	0x61207478
   28848:	64656464 	.word	0x64656464
   2884c:	000a0d21 	.word	0x000a0d21
   28850:	65736552 	.word	0x65736552
   28854:	676e6974 	.word	0x676e6974
   28858:	726f6620 	.word	0x726f6620
   2885c:	21574620 	.word	0x21574620
   28860:	0a0d      	.short	0x0a0d
	...

00028863 <pcWelcomeMessage>:
   28863:	7246 6565 5452 534f 4320 494c 0d2e 540a     FreeRTOS CLI...T
   28873:	7079 2065 6548 706c 7420 206f 6976 7765     ype Help to view
   28883:	6120 6c20 7369 2074 666f 7220 6765 7369      a list of regis
   28893:	6574 6572 2064 6f63 6d6d 6e61 7364 0d2e     tered commands..
   288a3:	000a 6c63 0073 6c63 3a73 4320 656c 7261     ..cls.cls: Clear
   288b3:	2073 6874 2065 6574 6d72 6e69 6c61 7320     s the terminal s
   288c3:	7263 6565 0d6e 000a 6e65 0076 6e65 3a76     creen...env.env:
   288d3:	5220 7465 7275 736e 6120 7620 6c61 6575      Returns a value
   288e3:	6620 6f72 206d 6874 2065 6e65 6976 6f72      from the enviro
   288f3:	6d6e 6e65 6174 206c 6573 736e 726f 0a0d     nmental sensor..
   28903:	6100 7269 6100 7269 203a 6552 7574 6e72     .air.air: Return
   28913:	2073 2061 6176 756c 2065 7266 6d6f 4620     s a value from F
   28923:	2d53 3033 3030 6120 7269 6c66 776f 7320     S-3000 airflow s
   28933:	6e65 6f73 0d72 000a 7766 6600 3a77 4420     ensor...fw.fw: D
   28943:	776f 6c6e 616f 2064 2061 6966 656c 6120     ownload a file a
   28953:	646e 7020 7265 6f66 6d72 6120 206e 5746     nd perform an FW
   28963:	7520 6470 7461 0d65 000a 6d69 0075 6d69      update...imu.im
   28973:	3a75 5220 7465 7275 736e 6120 7620 6c61     u: Returns a val
   28983:	6575 6620 6f72 206d 6874 2065 4d49 0d55     ue from the IMU.
   28993:	000a 6f43 6c75 2064 6f6e 2074 6c61 6f6c     ..Could not allo
   289a3:	6163 6574 7320 6d65 7061 6f68 6572 0a0d     cate semaphore..
   289b3:	6f00 0061 6325 325b 0d4b 003e 0400               .oa.%c[2K.>..

000289c0 <xAirFlow>:
   289c0:	8904 0002 8908 0002 3b15 0001 0000 0000     .........;......

000289d0 <xClearScreen>:
   289d0:	88a5 0002 88a9 0002 3a71 0001 0000 0000     ........q:......
   289e0:	6325 325b 004a 0000                         %c[2J...

000289e8 <xEnvGetCommand>:
   289e8:	88cb 0002 88cf 0002 3a0d 0001 0000 0000     .........:......

000289f8 <xImuGetCommand>:
   289f8:	896d 0002 8971 0002 3b55 0001 0000 0000     m...q...U;......

00028a08 <xOTAUCommand>:
   28a08:	893b 0002 893e 0002 3a9d 0001 0000 0000     ;...>....:......
   28a18:	2e25 732a 0a0d 5300 6174 7472 6e69 2067     %.*s...Starting 
   28a28:	6957 646e 5220 756f 6974 656e 0a0d 4d00     Wind Routine...M
   28a38:	5451 2054 6e69 7469 6169 696c 617a 6974     QTT initializati
   28a48:	6e6f 6620 6961 656c 2e64 4520 7272 726f     on failed. Error
   28a58:	6320 646f 2065 7369 2820 6425 0d29 000a      code is (%d)...
   28a68:	514d 5454 7220 6765 7369 6574 2072 6163     MQTT register ca
   28a78:	6c6c 6162 6b63 6620 6961 656c 2e64 4520     llback failed. E
   28a88:	7272 726f 6320 646f 2065 7369 2820 6425     rror code is (%d
   28a98:	0d29 000a 7468 7074 635f 696c 6e65 5f74     )...http_client_
   28aa8:	6163 6c6c 6162 6b63 203a 5448 5054 6320     callback: HTTP c
   28ab8:	696c 6e65 2074 6f73 6b63 7465 6320 6e6f     lient socket con
   28ac8:	656e 7463 6465 0d2e 000a 7468 7074 635f     nected....http_c
   28ad8:	696c 6e65 5f74 6163 6c6c 6162 6b63 203a     lient_callback: 
   28ae8:	6572 7571 7365 2074 6f63 706d 656c 6574     request complete
   28af8:	2e64 0a0d 6800 7474 5f70 6c63 6569 746e     d....http_client
   28b08:	635f 6c61 626c 6361 3a6b 7220 6365 6965     _callback: recei
   28b18:	6576 2064 6572 7073 6e6f 6573 2520 2075     ved response %u 
   28b28:	6164 6174 7320 7a69 2065 7525 0a0d 6800     data size %u...h
   28b38:	7474 5f70 6c63 6569 746e 635f 6c61 626c     ttp_client_callb
   28b48:	6361 3a6b 6420 7369 6f63 6e6e 6365 6974     ack: disconnecti
   28b58:	6e6f 7220 6165 6f73 3a6e 6425 0a0d 6900     on reason:%d...i
   28b68:	696e 5f74 7473 726f 6761 3a65 7020 656c     nit_storage: ple
   28b78:	7361 2065 6c70 6775 6120 206e 4453 4d2f     ase plug an SD/M
   28b88:	434d 6320 7261 2064 6e69 7320 6f6c 2e74     MC card in slot.
   28b98:	2e2e 0a0d 6900 696e 5f74 7473 726f 6761     .....init_storag
   28ba8:	3a65 5320 2044 6143 6472 6920 736e 6174     e: SD Card insta
   28bb8:	6c6c 6620 6961 656c 2e64 0a0d 6900 696e     ll failed....ini
   28bc8:	5f74 7473 726f 6761 3a65 7420 7972 7520     t_storage: try u
   28bd8:	706e 756c 2067 6e61 2064 6572 702d 756c     nplug and re-plu
   28be8:	2067 6874 2065 6163 6472 0d2e 000a 6e69     g the card....in
   28bf8:	7469 735f 6f74 6172 6567 203a 6f6d 6e75     it_storage: moun
   28c08:	6974 676e 5320 2044 6163 6472 2e2e 0d2e     ting SD card....
   28c18:	000a 6e69 7469 735f 6f74 6172 6567 203a     ..init_storage: 
   28c28:	4453 6320 7261 2064 6f6d 6e75 2074 6166     SD card mount fa
   28c38:	6c69 6465 2021 7228 7365 2520 2964 0a0d     iled! (res %d)..
   28c48:	6900 696e 5f74 7473 726f 6761 3a65 5320     .init_storage: S
   28c58:	2044 6163 6472 6d20 756f 746e 4f20 2e4b     D card mount OK.
   28c68:	0a0d 6200                                        ...

00028c6b <main_mqtt_broker>:
   28c6b:	7262 6b6f 7265 682e 7669 6d65 2e71 6f63     broker.hivemq.co
   28c7b:	006d 0a0d 6f43 6e6e 6365 6974 676e 7420     m...Connecting t
   28c8b:	206f 7242 6b6f 7265 2e2e 002e 6957 646e     o Broker....Wind
   28c9b:	435f 6568 7461 7265 0073 514d 5454 2020     _Cheaters.MQTT  
   28cab:	7245 6f72 2072 202d 4f4e 2054 6f43 6e6e     Error - NOT Conn
   28cbb:	6365 6574 2064 6f74 6220 6f72 656b 0d72     ected to broker.
   28ccb:	000a 514d 5454 4320 6e6f 656e 7463 6465     ..MQTT Connected
   28cdb:	7420 206f 7262 6b6f 7265 0a0d 4300 6e6f      to broker...Con
   28ceb:	656e 7463 6620 6961 206c 6f74 7320 7265     nect fail to ser
   28cfb:	6576 2872 7325 2129 7220 7465 7972 6920     ver(%s)! retry i
   28d0b:	2074 7561 6f74 616d 6974 6163 6c6c 2e79     t automatically.
   28d1b:	0a0d 4100 7475 6d6f 7461 0065 514d 5454     ...Automate.MQTT
   28d2b:	4320 6e6f 656e 7463 6465 0a0d 4d00 5451      Connected...MQT
   28d3b:	2054 7262 6b6f 7265 6420 6365 696c 656e     T broker decline
   28d4b:	7920 756f 2072 6361 6563 7373 2021 7265      your access! er
   28d5b:	6f72 2072 6f63 6564 2520 0d64 000a 514d     ror code %d...MQ
   28d6b:	5454 6420 7369 6f63 6e6e 6365 6574 0d64     TT disconnected.
   28d7b:	000a 3025 6433 7200 7365 6c6f 6576 635f     ..%03d.resolve_c
   28d8b:	3a62 2520 2073 5049 6120 6464 6572 7373     b: %s IP address
   28d9b:	6920 2073 6425 252e 2e64 6425 252e 0d64      is %d.%d.%d.%d.
   28dab:	0d0a 000a 7473 7261 5f74 6f64 6e77 6f6c     ....start_downlo
   28dbb:	6461 203a 4d4d 2043 7473 726f 6761 2065     ad: MMC storage 
   28dcb:	6f6e 2074 6572 6461 2e79 0a0d 7300 6174     not ready....sta
   28ddb:	7472 645f 776f 6c6e 616f 3a64 5720 2d69     rt_download: Wi-
   28deb:	6946 6920 2073 6f6e 2074 6f63 6e6e 6365     Fi is not connec
   28dfb:	6574 2e64 0a0d 7300 6174 7472 645f 776f     ted....start_dow
   28e0b:	6c6e 616f 3a64 7220 7165 6575 7473 6920     nload: request i
   28e1b:	2073 6573 746e 6120 726c 6165 7964 0d2e     s sent already..
   28e2b:	000a 7473 7261 5f74 6f64 6e77 6f6c 6461     ..start_download
   28e3b:	203a 7572 6e6e 6e69 2067 6f64 6e77 6f6c     : running downlo
   28e4b:	6461 6120 726c 6165 7964 0d2e 000a 7473     ad already....st
   28e5b:	7261 5f74 6f64 6e77 6f6c 6461 203a 6573     art_download: se
   28e6b:	646e 6e69 2067 5448 5054 7220 7165 6575     nding HTTP reque
   28e7b:	7473 2e2e 0d2e 000a 7468 7074 2f3a 312f     st......http://1
   28e8b:	3237 312e 3837 342e 2e35 3431 412f 7070     72.178.45.14/App
   28e9b:	696c 6163 6974 6e6f 622e 6e69 7300 6f74     lication.bin.sto
   28eab:	6572 665f 6c69 5f65 6170 6b63 7465 203a     re_file_packet: 
   28ebb:	6d65 7470 2079 6164 6174 0d2e 000a 7473     empty data....st
   28ecb:	726f 5f65 6966 656c 705f 6361 656b 3a74     ore_file_packet:
   28edb:	6320 6572 7461 6e69 2067 6966 656c 5b20      creating file [
   28eeb:	7325 0d5d 000a 7473 726f 5f65 6966 656c     %s]...store_file
   28efb:	705f 6361 656b 3a74 6620 6c69 2065 616e     _packet: file na
   28f0b:	656d 6920 2073 6e69 6176 696c 2e64 4420     me is invalid. D
   28f1b:	776f 6c6e 616f 2064 6163 636e 6c65 6465     ownload canceled
   28f2b:	0d2e 000a 7473 726f 5f65 6966 656c 705f     ....store_file_p
   28f3b:	6361 656b 3a74 6620 6c69 2065 7263 6165     acket: file crea
   28f4b:	6974 6e6f 6520 7272 726f 2021 6572 3a74     tion error! ret:
   28f5b:	6425 0a0d 7300 6f74 6572 665f 6c69 5f65     %d...store_file_
   28f6b:	6170 6b63 7465 203a 6966 656c 7720 6972     packet: file wri
   28f7b:	6574 6520 7272 726f 202c 6f64 6e77 6f6c     te error, downlo
   28f8b:	6461 6320 6e61 6563 656c 2e64 0a0d 7300     ad canceled....s
   28f9b:	6f74 6572 665f 6c69 5f65 6170 6b63 7465     tore_file_packet
   28fab:	203a 6572 6563 7669 6465 255b 756c 2c5d     : received[%lu],
   28fbb:	6620 6c69 2065 6973 657a 255b 756c 0d5d      file size[%lu].
   28fcb:	000a 7473 726f 5f65 6966 656c 705f 6361     ..store_file_pac
   28fdb:	656b 3a74 6620 6c69 2065 6f64 6e77 6f6c     ket: file downlo
   28feb:	6461 6465 7320 6375 6563 7373 7566 6c6c     aded successfull
   28ffb:	2e79 0a0d 4500 5252 524f 4920 696e 6974     y....ERROR Initi
   2900b:	6c61 7a69 6e69 2067 6957 6966 4420 7461     alizing Wifi Dat
   2901b:	2061 7571 7565 7365 0d21 000a 5345 3545     a queues!...ESE5
   2902b:	3631 2d20 5720 6669 2069 6e49 7469 4320     16 - Wifi Init C
   2903b:	646f 0d65 000a 6f63 666e 6769 7275 5f65     ode...configure_
   2904b:	7468 7074 635f 696c 6e65 3a74 4820 5454     http_client: HTT
   2905b:	2050 6c63 6569 746e 6920 696e 6974 6c61     P client initial
   2906b:	7a69 7461 6f69 206e 6166 6c69 6465 2021     ization failed! 
   2907b:	7228 7365 2520 2964 0a0d 6d00 6961 3a6e     (res %d)...main:
   2908b:	6d20 6d32 775f 6669 5f69 6e69 7469 6320      m2m_wifi_init c
   2909b:	6c61 206c 7265 6f72 2172 2820 6572 2073     all error! (res 
   290ab:	6425 0d29 000a 616d 6e69 203a 6f63 6e6e     %d)...main: conn
   290bb:	6365 6974 676e 7420 206f 6957 6946 4120     ecting to WiFi A
   290cb:	2050 7325 2e2e 0d2e 000a 6f43 6e6e 6365     P %s......Connec
   290db:	6574 2064 6f74 4d20 5451 2054 7242 6b6f     ted to MQTT Brok
   290eb:	7265 0d21 000a 227b 2254 253a 2e30 6632     er!...{"T":%0.2f
   290fb:	202c 4822 3a22 3025 322e 2c66 2220 2250     , "H":%0.2f, "P"
   2910b:	253a 2e30 6632 007d 6e45 6976 6f72 6d6e     :%0.2f}.Environm
   2911b:	6e65 6174 5f6c 6144 6174 7b00 5822 3a22     ental_Data.{"X":
   2912b:	6625 202c 5922 3a22 6625 202c 5a22 3a22     %f, "Y":%f, "Z":
   2913b:	2520 7d66 4900 554d 445f 7461 0061 3025      %f}.IMU_Data.%0
   2914b:	322e 0066 6941 5f72 6556 6f6c 6963 7974     .2f.Air_Velocity
   2915b:	445f 7461 0061 6c46 6761 2e41 7874 2074     _Data.FlagA.txt 
   2916b:	6461 6564 2164 0a0d 3000 463a 616c 4167     added!...0:FlagA
   2917b:	742e 7478 7700 6669 5f69 6263 203a 324d     .txt.wifi_cb: M2
   2918b:	5f4d 4957 4946 435f 4e4f 454e 5443 4445     M_WIFI_CONNECTED
   2919b:	0a0d 7700 6669 5f69 6263 203a 324d 5f4d     ...wifi_cb: M2M_
   291ab:	4957 4946 445f 5349 4f43 4e4e 4345 4554     WIFI_DISCONNECTE
   291bb:	0d44 000a 306e 7472 4368 7530 746e 7972     D...n0rthC0untry
   291cb:	4400 7465 696b 206e 4f49 2054 6f4e 7472     .Detkin IOT Nort
   291db:	0068 6977 6966 635f 3a62 4920 2050 6461     h.wifi_cb: IP ad
   291eb:	7264 7365 2073 7369 2520 2e75 7525 252e     dress is %u.%u.%
   291fb:	2e75 7525 0a0d 4500 7272 726f 6320 6e6f     u.%u...Error con
   2920b:	656e 7463 6e69 2067 6f74 4d20 5451 2054     necting to MQTT 
   2921b:	7242 6b6f 7265 0d21 000a 6e49 6f63 7272     Broker!...Incorr
   2922b:	6365 2074 6f63 6d6d 6e61 2064 6170 6172     ect command para
   2923b:	656d 6574 2872 2973 202e 4520 746e 7265     meter(s).  Enter
   2924b:	2220 6568 706c 2022 6f74 7620 6569 2077      "help" to view 
   2925b:	2061 696c 7473 6f20 2066 7661 6961 616c     a list of availa
   2926b:	6c62 2065 6f63 6d6d 6e61 7364 0d2e 0d0a     ble commands....
   2927b:	000a 6f43 6d6d 6e61 2064 6f6e 2074 6572     ..Command not re
   2928b:	6f63 6e67 7369 6465 202e 4520 746e 7265     cognised.  Enter
   2929b:	2720 6568 706c 2027 6f74 7620 6569 2077      'help' to view 
   292ab:	2061 696c 7473 6f20 2066 7661 6961 616c     a list of availa
   292bb:	6c62 2065 6f63 6d6d 6e61 7364 0d2e 0d0a     ble commands....
   292cb:	000a 6568 706c 0d00 680a 6c65 3a70 0a0d     ..help...help:..
   292db:	4c20 7369 7374 6120 6c6c 7420 6568 7220      Lists all the r
   292eb:	6765 7369 6574 6572 2064 6f63 6d6d 6e61     egistered comman
   292fb:	7364 0a0d 0a0d 0000 cd00                         ds.......

00029304 <xHelpCommand>:
   29304:	92cd 0002 92d2 0002 5aa9 0001 0000 0000     .........Z......

00029314 <CSWTCH.27>:
   29314:	9366 0002 93b0 0002 9402 0002 944c 0002     f...........L...
   29324:	9494 0002 94da 0002 9524 0002 9578 0002     ........$...x...
   29334:	95d0 0002 7370 547a 6172 6563 6547 4574     ....pszTraceGetE
   29344:	7272 726f 6148 646e 656c 3a73 4920 766e     rrorHandles: Inv
   29354:	6c61 6469 6f20 6a62 6365 6374 616c 7373     alid objectclass
   29364:	0021 6f4e 2074 6e65 756f 6867 5120 4555     !.Not enough QUE
   29374:	4555 6820 6e61 6c64 7365 2d20 6920 636e     UE handles - inc
   29384:	6572 7361 2065 5254 5f43 4643 5f47 514e     rease TRC_CFG_NQ
   29394:	4555 4555 6920 206e 7274 5363 616e 7370     UEUE in trcSnaps
   293a4:	6f68 4374 6e6f 6966 2e67 0068 6f4e 2074     hotConfig.h.Not 
   293b4:	6e65 756f 6867 5320 4d45 5041 4f48 4552     enough SEMAPHORE
   293c4:	6820 6e61 6c64 7365 2d20 6920 636e 6572      handles - incre
   293d4:	7361 2065 5254 5f43 4643 5f47 534e 4d45     ase TRC_CFG_NSEM
   293e4:	5041 4f48 4552 6920 206e 7274 5363 616e     APHORE in trcSna
   293f4:	7370 6f68 4374 6e6f 6966 2e67 0068 6f4e     pshotConfig.h.No
   29404:	2074 6e65 756f 6867 4d20 5455 5845 6820     t enough MUTEX h
   29414:	6e61 6c64 7365 2d20 6920 636e 6572 7361     andles - increas
   29424:	2065 5254 5f43 4643 5f47 4d4e 5455 5845     e TRC_CFG_NMUTEX
   29434:	6920 206e 7274 5363 616e 7370 6f68 4374      in trcSnapshotC
   29444:	6e6f 6966 2e67 0068 6f4e 2074 6e65 756f     onfig.h.Not enou
   29454:	6867 5420 5341 204b 6168 646e 656c 2073     gh TASK handles 
   29464:	202d 6e69 7263 6165 6573 5420 4352 435f     - increase TRC_C
   29474:	4746 4e5f 4154 4b53 6920 206e 7274 5363     FG_NTASK in trcS
   29484:	616e 7370 6f68 4374 6e6f 6966 2e67 0068     napshotConfig.h.
   29494:	6f4e 2074 6e65 756f 6867 4920 5253 6820     Not enough ISR h
   294a4:	6e61 6c64 7365 2d20 6920 636e 6572 7361     andles - increas
   294b4:	2065 5254 5f43 4643 5f47 494e 5253 6920     e TRC_CFG_NISR i
   294c4:	206e 7274 5363 616e 7370 6f68 4374 6e6f     n trcSnapshotCon
   294d4:	6966 2e67 0068 6f4e 2074 6e65 756f 6867     fig.h.Not enough
   294e4:	5420 4d49 5245 6820 6e61 6c64 7365 2d20      TIMER handles -
   294f4:	6920 636e 6572 7361 2065 5254 5f43 4643      increase TRC_CF
   29504:	5f47 544e 4d49 5245 6920 206e 7274 5363     G_NTIMER in trcS
   29514:	616e 7370 6f68 4374 6e6f 6966 2e67 0068     napshotConfig.h.
   29524:	6f4e 2074 6e65 756f 6867 4520 4556 544e     Not enough EVENT
   29534:	5247 554f 2050 6168 646e 656c 2073 202d     GROUP handles - 
   29544:	6e69 7263 6165 6573 5420 4352 435f 4746     increase TRC_CFG
   29554:	4e5f 5645 4e45 4754 4f52 5055 6920 206e     _NEVENTGROUP in 
   29564:	7274 5363 616e 7370 6f68 4374 6e6f 6966     trcSnapshotConfi
   29574:	2e67 0068 6f4e 2074 6e65 756f 6867 5320     g.h.Not enough S
   29584:	5254 4145 424d 4655 4546 2052 6168 646e     TREAMBUFFER hand
   29594:	656c 2073 202d 6e69 7263 6165 6573 5420     les - increase T
   295a4:	4352 435f 4746 4e5f 5453 4552 4d41 5542     RC_CFG_NSTREAMBU
   295b4:	4646 5245 6920 206e 7274 5363 616e 7370     FFER in trcSnaps
   295c4:	6f68 4374 6e6f 6966 2e67 0068 6f4e 2074     hotConfig.h.Not 
   295d4:	6e65 756f 6867 4d20 5345 4153 4547 5542     enough MESSAGEBU
   295e4:	4646 5245 6820 6e61 6c64 7365 2d20 6920     FFER handles - i
   295f4:	636e 6572 7361 2065 5254 5f43 4643 5f47     ncrease TRC_CFG_
   29604:	4d4e 5345 4153 4547 5542 4646 5245 6920     NMESSAGEBUFFER i
   29614:	206e 7274 5363 616e 7370 6f68 4374 6e6f     n trcSnapshotCon
   29624:	6966 2e67 0068 5476 6172 6563 6e45 6261     fig.h.vTraceEnab
   29634:	656c 5428 4352 535f 4154 5452 415f 4157     le(TRC_START_AWA
   29644:	5449 485f 534f 2954 6e20 746f 6120 6c6c     IT_HOST) not all
   29654:	776f 6465 6920 206e 6e53 7061 6873 746f     owed in Snapshot
   29664:	6d20 646f 0065 6e55 7865 6570 7463 6465      mode.Unexpected
   29674:	6120 6772 6d75 6e65 2074 6f74 7620 7254      argument to vTr
   29684:	6361 4565 616e 6c62 2065 7328 616e 7370     aceEnable (snaps
   29694:	6f68 2074 6f6d 6564 0029 7a54 7443 6c72     hot mode).TzCtrl
   296a4:	5400 4152 4543 415f 5353 5245 3a54 7020     .TRACE_ASSERT: p
   296b4:	7672 6843 6365 446b 7461 5461 426f 4f65     rvCheckDataToBeO
   296c4:	6576 7772 6972 7474 6e65 6f46 4d72 6c75     verwrittenForMul
   296d4:	6974 6e45 7274 4579 6576 746e 3a73 6e20     tiEntryEvents: n
   296e4:	666f 6e45 7274 6569 5473 436f 6568 6b63     ofEntriesToCheck
   296f4:	3d20 203d 0030 5254 4341 5f45 5341 4553      == 0.TRACE_ASSE
   29704:	5452 203a 7270 5476 6172 6563 6547 4474     RT: prvTraceGetD
   29714:	5354 203a 6e49 6176 696c 2064 6176 756c     TS: Invalid valu
   29724:	2065 6f66 2072 6170 6172 5f6d 616d 4478     e for param_maxD
   29734:	5354 4200 6461 7020 7261 6d61 6d5f 7861     TS.Bad param_max
   29744:	5444 2053 6e69 7020 7672 7254 6361 4765     DTS in prvTraceG
   29754:	7465 5444 0053 5254 4341 5f45 5341 4553     etDTS.TRACE_ASSE
   29764:	5452 203a 7270 5476 6172 6563 6547 4f74     RT: prvTraceGetO
   29774:	6a62 6365 4874 6e61 6c64 3a65 4920 766e     bjectHandle: Inv
   29784:	6c61 6469 7620 6c61 6575 6620 726f 6f20     alid value for o
   29794:	6a62 6365 6374 616c 7373 5400 4152 4543     bjectclass.TRACE
   297a4:	415f 5353 5245 3a54 7020 7672 7254 6361     _ASSERT: prvTrac
   297b4:	4765 7465 7250 6f69 6972 7974 7250 706f     eGetPriorityProp
   297c4:	7265 7974 203a 626f 656a 7463 6c63 7361     erty: objectclas
   297d4:	2073 3d3e 5420 4152 4543 4e5f 4c43 5341     s >= TRACE_NCLAS
   297e4:	4553 0053 5254 4341 5f45 5341 4553 5452     SES.TRACE_ASSERT
   297f4:	203a 7270 5476 6172 6563 6547 5074 6972     : prvTraceGetPri
   29804:	726f 7469 5079 6f72 6570 7472 3a79 4920     orityProperty: I
   29814:	766e 6c61 6469 7620 6c61 6575 6620 726f     nvalid value for
   29824:	6920 0064 7254 6361 2065 6552 6f63 6472      id.Trace Record
   29834:	7265 4420 6d65 006f 7441 6574 706d 2074     er Demo.Attempt 
   29844:	6f74 6920 646e 7865 6f20 7475 6973 6564     to index outside
   29854:	6520 6576 746e 6220 6675 6566 2172 5400      event buffer!.T
   29864:	4152 4543 415f 5353 5245 3a54 7020 7672     RACE_ASSERT: prv
   29874:	7254 6361 5365 7465 624f 656a 7463 614e     TraceSetObjectNa
   29884:	656d 203a 616e 656d 3d20 203d 554e 4c4c     me: name == NULL
   29894:	4900 6c6c 6765 6c61 6f20 6a62 6365 2074     .Illegal object 
   298a4:	6c63 7361 2073 6e69 7020 7672 7254 6361     class in prvTrac
   298b4:	5365 7465 624f 656a 7463 614e 656d 4900     eSetObjectName.I
   298c4:	6c6c 6765 6c61 6820 6e61 6c64 2065 3028     llegal handle (0
   298d4:	2029 6e69 7020 7672 7254 6361 5365 7465     ) in prvTraceSet
   298e4:	624f 656a 7463 614e 656d 002e 5254 4341     ObjectName..TRAC
   298f4:	5f45 5341 4553 5452 203a 7270 5476 6172     E_ASSERT: prvTra
   29904:	6563 6553 4f74 6a62 6365 5374 6174 6574     ceSetObjectState
   29914:	203a 626f 656a 7463 6c63 7361 2073 3d3e     : objectclass >=
   29924:	5420 4152 4543 4e5f 4c43 5341 4553 0053      TRACE_NCLASSES.
   29934:	5254 4341 5f45 5341 4553 5452 203a 7270     TRACE_ASSERT: pr
   29944:	5476 6172 6563 6553 4f74 6a62 6365 5374     vTraceSetObjectS
   29954:	6174 6574 203a 6e49 6176 696c 2064 6176     tate: Invalid va
   29964:	756c 2065 6f66 2072 6469 5400 4152 4543     lue for id.TRACE
   29974:	415f 5353 5245 3a54 7020 7672 7254 6361     _ASSERT: prvTrac
   29984:	5365 7465 7250 6f69 6972 7974 7250 706f     eSetPriorityProp
   29994:	7265 7974 203a 626f 656a 7463 6c63 7361     erty: objectclas
   299a4:	2073 3d3e 5420 4152 4543 4e5f 4c43 5341     s >= TRACE_NCLAS
   299b4:	4553 0053 5254 4341 5f45 5341 4553 5452     SES.TRACE_ASSERT
   299c4:	203a 7270 5476 6172 6563 6553 5074 6972     : prvTraceSetPri
   299d4:	726f 7469 5079 6f72 6570 7472 3a79 4920     orityProperty: I
   299e4:	766e 6c61 6469 7620 6c61 6575 6620 726f     nvalid value for
   299f4:	6920 0064 5254 4341 5f45 5341 4553 5452      id.TRACE_ASSERT
   29a04:	203a 7270 5476 6172 6563 6553 5474 7361     : prvTraceSetTas
   29a14:	496b 736e 6174 636e 4665 6e69 7369 6568     kInstanceFinishe
   29a24:	3a64 4920 766e 6c61 6469 7620 6c61 6575     d: Invalid value
   29a34:	6620 726f 6820 6e61 6c64 0065 5254 4341      for handle.TRAC
   29a44:	5f45 5341 4553 5452 203a 7270 5476 6172     E_ASSERT: prvTra
   29a54:	6563 7453 726f 4b65 7265 656e 436c 6c61     ceStoreKernelCal
   29a64:	3a6c 6520 6f63 6564 3e20 203d 7830 4646     l: ecode >= 0xFF
   29a74:	5400 4152 4543 415f 5353 5245 3a54 7020     .TRACE_ASSERT: p
   29a84:	7672 7254 6361 5365 6f74 6572 654b 6e72     rvTraceStoreKern
   29a94:	6c65 6143 6c6c 203a 626f 656a 7463 6c43     elCall: objectCl
   29aa4:	7361 2073 3d3e 5420 4152 4543 4e5f 4c43     ass >= TRACE_NCL
   29ab4:	5341 4553 0053 5254 4341 5f45 5341 4553     ASSES.TRACE_ASSE
   29ac4:	5452 203a 7270 5476 6172 6563 7453 726f     RT: prvTraceStor
   29ad4:	4b65 7265 656e 436c 6c61 3a6c 4920 766e     eKernelCall: Inv
   29ae4:	6c61 6469 7620 6c61 6575 6620 726f 6f20     alid value for o
   29af4:	6a62 6365 4e74 6d75 6562 0072 6552 6f63     bjectNumber.Reco
   29b04:	6472 7265 6220 7375 2079 202d 6968 6867     rder busy - high
   29b14:	7020 6972 726f 7469 2079 5349 2052 7375      priority ISR us
   29b24:	6e69 2067 7973 6373 6c61 3f6c 2820 2932     ing syscall? (2)
   29b34:	5400 4152 4543 415f 5353 5245 3a54 7020     .TRACE_ASSERT: p
   29b44:	7672 7254 6361 5365 6f74 6572 654b 6e72     rvTraceStoreKern
   29b54:	6c65 6143 6c6c 6957 6874 754e 656d 6972     elCallWithNumeri
   29b64:	5063 7261 6d61 6e4f 796c 203a 6e49 6176     cParamOnly: Inva
   29b74:	696c 2064 6176 756c 2065 6f66 2072 7665     lid value for ev
   29b84:	6374 646f 0065 6552 6f63 6472 7265 6220     tcode.Recorder b
   29b94:	7375 2079 202d 6968 6867 7020 6972 726f     usy - high prior
   29ba4:	7469 2079 5349 2052 7375 6e69 2067 7973     ity ISR using sy
   29bb4:	6373 6c61 3f6c 2820 2934 5400 4152 4543     scall? (4).TRACE
   29bc4:	415f 5353 5245 3a54 7020 7672 7254 6361     _ASSERT: prvTrac
   29bd4:	5365 6f74 6572 654b 6e72 6c65 6143 6c6c     eStoreKernelCall
   29be4:	6957 6874 6150 6172 3a6d 6520 7476 6f63     WithParam: evtco
   29bf4:	6564 3e20 203d 7830 4646 5400 4152 4543     de >= 0xFF.TRACE
   29c04:	415f 5353 5245 3a54 7020 7672 7254 6361     _ASSERT: prvTrac
   29c14:	5365 6f74 6572 654b 6e72 6c65 6143 6c6c     eStoreKernelCall
   29c24:	6957 6874 6150 6172 3a6d 6f20 6a62 6365     WithParam: objec
   29c34:	4374 616c 7373 3e20 203d 5254 4341 5f45     tClass >= TRACE_
   29c44:	434e 414c 5353 5345 5400 4152 4543 415f     NCLASSES.TRACE_A
   29c54:	5353 5245 3a54 7020 7672 7254 6361 5365     SSERT: prvTraceS
   29c64:	6f74 6572 654b 6e72 6c65 6143 6c6c 6957     toreKernelCallWi
   29c74:	6874 6150 6172 3a6d 4920 766e 6c61 6469     thParam: Invalid
   29c84:	7620 6c61 6575 6620 726f 6f20 6a62 6365      value for objec
   29c94:	4e74 6d75 6562 0072 6552 6f63 6472 7265     tNumber.Recorder
   29ca4:	6220 7375 2079 202d 6968 6867 7020 6972      busy - high pri
   29cb4:	726f 7469 2079 5349 2052 7375 6e69 2067     ority ISR using 
   29cc4:	7973 6373 6c61 3f6c 2820 2933 5400 4152     syscall? (3).TRA
   29cd4:	4543 415f 5353 5245 3a54 7020 7672 7254     CE_ASSERT: prvTr
   29ce4:	6361 5365 6f74 6572 6154 6b73 6552 6461     aceStoreTaskRead
   29cf4:	3a79 4920 766e 6c61 6469 7620 6c61 6575     y: Invalid value
   29d04:	6620 726f 6820 6e61 6c64 0065 6552 6f63      for handle.Reco
   29d14:	6472 7265 6220 7375 2079 202d 6968 6867     rder busy - high
   29d24:	7020 6972 726f 7469 2079 5349 2052 7375      priority ISR us
   29d34:	6e69 2067 7973 6373 6c61 3f6c 2820 2931     ing syscall? (1)
   29d44:	5400 4152 4543 415f 5353 5245 3a54 7020     .TRACE_ASSERT: p
   29d54:	7672 7254 6361 5365 6f74 6572 6154 6b73     rvTraceStoreTask
   29d64:	7773 7469 6863 203a 6e49 6176 696c 2064     switch: Invalid 
   29d74:	6176 756c 2065 6f66 2072 6174 6b73 685f     value for task_h
   29d84:	6e61 6c64 0065 5254 4341 5f45 5341 4553     andle.TRACE_ASSE
   29d94:	5452 203a 7270 5476 6172 6563 6547 4f74     RT: prvTraceGetO
   29da4:	6a62 6365 5374 6174 6574 203a 6e49 6176     bjectState: Inva
   29db4:	696c 2064 6176 756c 2065 6f66 2072 6469     lid value for id
   29dc4:	5400 4152 4543 415f 5353 5245 3a54 7520     .TRACE_ASSERT: u
   29dd4:	4969 646e 7865 664f 624f 656a 7463 203a     iIndexOfObject: 
   29de4:	6e49 6176 696c 2064 6176 756c 2065 6f66     Invalid value fo
   29df4:	2072 626f 656a 7463 6c63 7361 0073 5254     r objectclass.TR
   29e04:	4341 5f45 5341 4553 5452 203a 6975 6e49     ACE_ASSERT: uiIn
   29e14:	6564 4f78 4f66 6a62 6365 3a74 4920 766e     dexOfObject: Inv
   29e24:	6c61 6469 7620 6c61 6575 6620 726f 6f20     alid value for o
   29e34:	6a62 6365 6874 6e61 6c64 0065 5254 4341     bjecthandle.TRAC
   29e44:	5f45 5341 4553 5452 203a 6552 6f63 6472     E_ASSERT: Record
   29e54:	7265 6e20 746f 6920 696e 6974 6c61 7a69     er not initializ
   29e64:	6465 202e 7355 2065 5476 6172 6563 6e45     ed. Use vTraceEn
   29e74:	6261 656c 2928 6920 736e 6574 6461 0021     able() instead!.
   29e84:	7328 6174 7472 7075 0029 5254 4341 5f45     (startup).TRACE_
   29e94:	5341 4553 5452 203a 5478 6172 6563 6552     ASSERT: xTraceRe
   29ea4:	6967 7473 7265 7453 6972 676e 203a 616c     gisterString: la
   29eb4:	6562 206c 3d3d 4e20 4c55 004c 5254 4341     bel == NULL.TRAC
   29ec4:	5f45 5341 4553 5452 203a 6552 6f63 6472     E_ASSERT: Record
   29ed4:	7265 6e20 746f 6920 696e 6974 6c61 7a69     er not initializ
   29ee4:	6465 202c 6163 6c6c 7620 7254 6361 4565     ed, call vTraceE
   29ef4:	616e 6c62 2865 2029 6966 7372 2174 4900     nable() first!.I
   29f04:	4c44 0045 6d54 2072 7653 0063               DLE.Tmr Svc.

00029f10 <mmc_trans_multipliers>:
   29f10:	0000 0000 000a 0000 000c 0000 000d 0000     ................
   29f20:	000f 0000 0014 0000 001a 0000 001e 0000     ................
   29f30:	0023 0000 0028 0000 002d 0000 0034 0000     #...(...-...4...
   29f40:	0037 0000 003c 0000 0046 0000 0050 0000     7...<...F...P...

00029f50 <sd_mmc_trans_units>:
   29f50:	000a 0000 0064 0000 03e8 0000 2710 0000     ....d........'..
	...

00029f6c <sd_trans_multipliers>:
   29f6c:	0000 0000 000a 0000 000c 0000 000d 0000     ................
   29f7c:	000f 0000 0014 0000 0019 0000 001e 0000     ................
   29f8c:	0023 0000 0028 0000 002d 0000 0032 0000     #...(...-...2...
   29f9c:	0037 0000 003c 0000 0046 0000 0050 0000     7...<...F...P...

00029fac <__FUNCTION__.16429>:
   29fac:	6d6e 625f 7375 695f 636f 6c74 2800 5041     nm_bus_ioctl.(AP
   29fbc:	2950 4528 5252 5b29 7325 5b5d 6425 005d     P)(ERR)[%s][%d].
   29fcc:	6e69 6176 696c 6564 6920 636f 746c 6320     invalide ioclt c
   29fdc:	646d 000a                                   md..

00029fe0 <__FUNCTION__.17297>:
   29fe0:	6968 5f66 6573 646e 6800                         hif_send.

00029fe9 <__FUNCTION__.17307>:
   29fe9:	6968 5f66 7369 0072                         hif_isr.

00029ff1 <__FUNCTION__.17316>:
   29ff1:	6968 5f66 6168 646e 656c 695f 7273 6800          hif_handle_isr.

0002a000 <__FUNCTION__.17328>:
   2a000:	6968 5f66 6572 6563 7669 0065               hif_receive.

0002a00c <__FUNCTION__.17344>:
   2a00c:	6968 5f66 6572 6967 7473 7265 635f 0062     hif_register_cb.
   2a01c:	6828 6669 2029 4957 4946 485f 534f 5f54     (hif) WIFI_HOST_
   2a02c:	4352 5f56 5443 4c52 315f 6220 7375 6620     RCV_CTRL_1 bus f
   2a03c:	6961 0a6c 2800 6968 2966 6120 6464 6572     ail..(hif) addre
   2a04c:	7373 6220 7375 6620 6961 0a6c 2800 6968     ss bus fail..(hi
   2a05c:	2966 4320 726f 7572 7470 6465 7020 6361     f) Corrupted pac
   2a06c:	656b 2074 6953 657a 3d20 2520 2075 4c3c     ket Size = %u <L
   2a07c:	3d20 2520 2c75 4720 3d20 2520 2c75 4f20      = %u, G = %u, O
   2a08c:	2050 203d 3025 5832 0a3e 5700 4649 2049     P = %02X>..WIFI 
   2a09c:	6163 6c6c 6162 6b63 6920 2073 6f6e 2074     callback is not 
   2a0ac:	6572 6967 7473 7265 6465 000a 6353 6b6f     registered..Scok
   2a0bc:	7465 6320 6c61 626c 6361 206b 7369 6e20     et callback is n
   2a0cc:	746f 7220 6765 7369 6574 6572 0a64 4f00     ot registered..O
   2a0dc:	6174 6320 6c61 626c 6361 206b 7369 6e20     ta callback is n
   2a0ec:	746f 7220 6765 7369 6574 6572 0a64 4300     ot registered..C
   2a0fc:	7972 7470 206f 6163 6c6c 6162 6b63 6920     rypto callback i
   2a10c:	2073 6f6e 2074 6572 6967 7473 7265 6465     s not registered
   2a11c:	000a 6953 6d67 2061 6163 6c6c 6162 6b63     ..Sigma callback
   2a12c:	6920 2073 6f6e 2074 6572 6967 7473 7265      is not register
   2a13c:	6465 000a 6828 6669 2029 6e69 6176 696c     ed..(hif) invali
   2a14c:	2064 7267 756f 2070 4449 000a 6828 6669     d group ID..(hif
   2a15c:	2029 6f68 7473 6120 7070 6420 6469 276e     ) host app didn'
   2a16c:	2074 6573 2074 5852 4420 6e6f 2065 253c     t set RX Done <%
   2a17c:	3e75 253c 3e58 000a 6828 6669 2029 7257     u><%X>..(hif) Wr
   2a18c:	6e6f 2067 6953 657a 000a 6828 6669 2029     ong Size..(hif) 
   2a19c:	6146 736c 2065 6e69 6574 7272 7075 2074     False interrupt 
   2a1ac:	6c25 0078 6828 6669 2029 6146 6c69 7420     %lx.(hif) Fail t
   2a1bc:	206f 6552 6461 6920 746e 7265 7572 7470     o Read interrupt
   2a1cc:	7220 6765 000a 4828 4649 2029 6146 6c69      reg..(HIF) Fail
   2a1dc:	7420 206f 6168 646e 656c 6920 746e 7265      to handle inter
   2a1ec:	7572 7470 2520 2064 7274 2079 6741 6961     rupt %d try Agai
   2a1fc:	2e6e 0a2e 2000 6968 5f66 6572 6563 7669     n.... hif_receiv
   2a20c:	3a65 4920 766e 6c61 6469 6120 6772 6d75     e: Invalid argum
   2a21c:	6e65 0a74 4100 5050 5220 7165 6575 7473     ent..APP Request
   2a22c:	6465 5320 7a69 2065 7369 6c20 7261 6567     ed Size is large
   2a23c:	2072 6874 6e61 7420 6568 7220 6365 7669     r than the reciv
   2a24c:	6465 6220 6675 6566 2072 6973 657a 3c20     ed buffer size <
   2a25c:	7525 3c3e 6c25 3e75 000a 5041 2050 6552     %u><%lu>..APP Re
   2a26c:	7571 7365 6574 2064 6441 7264 7365 2073     quested Address 
   2a27c:	6562 6f79 646e 7420 6568 7220 6365 7669     beyond the reciv
   2a28c:	6465 6220 6675 6566 2072 6461 7264 7365     ed buffer addres
   2a29c:	2073 6e61 2064 656c 676e 6874 000a 5247     s and length..GR
   2a2ac:	2070 203f 6425 000a 4128 5050 2829 4e49     p ? %d..(APP)(IN
   2a2bc:	4f46 0029 6c53 776f 6e69 2067 6f64 6e77     FO).Slowing down
   2a2cc:	2e2e 0a2e 2800 4948 2946 6146 6c69 7420     .....(HIF)Fail t
   2a2dc:	206f 6177 756b 2070 6874 2065 6863 7069     o wakup the chip
   2a2ec:	000a                                        ..

0002a2ee <__FUNCTION__.17279>:
   2a2ee:	326d 5f6d 6977 6966 635f 0062               m2m_wifi_cb.

0002a2fa <__FUNCTION__.17308>:
   2a2fa:	326d 5f6d 6977 6966 695f 696e 0074          m2m_wifi_init.

0002a308 <__FUNCTION__.17339>:
   2a308:	326d 5f6d 6977 6966 635f 6e6f 656e 7463     m2m_wifi_connect
   2a318:	735f 0063 6f43 666e 696c 7463 6465 4920     _sc.Conflicted I
   2a328:	2050 2022 7525 252e 2e75 7525 252e 2075     P " %u.%u.%u.%u 
   2a338:	2022 000a 4552 2051 6f4e 2074 6564 6966     " ..REQ Not defi
   2a348:	656e 2064 6425 000a 654b 2079 7369 6e20     ned %d..Key is n
   2a358:	746f 7620 6c61 6469 000a 6e49 6176 696c     ot valid..Invali
   2a368:	2064 654b 0a79 5300 4953 2044 454c 204e     d Key..SSID LEN 
   2a378:	4e49 4156 494c 0a44 4300 2048 4e49 4156     INVALID..CH INVA
   2a388:	494c 0a44 4900 766e 6c61 6469 5720 7065     LID..Invalid Wep
   2a398:	6b20 7965 6920 646e 7865 2520 0a64 4900      key index %d..I
   2a3a8:	766e 6c61 6469 5720 7065 6b20 7965 6c20     nvalid Wep key l
   2a3b8:	6e65 7467 2068 6425 000a 6e49 6f63 7272     ength %d..Incorr
   2a3c8:	6365 2074 5350 204b 656b 2079 656c 676e     ect PSK key leng
   2a3d8:	6874 000a 6e75 6564 6966 656e 2064 6573     th..undefined se
   2a3e8:	2063 7974 6570 000a 6946 6d72 6177 6572     c type..Firmware
   2a3f8:	7620 7265 2020 3a20 2520 2e75 7525 252e      ver   : %u.%u.%
   2a408:	2075 7653 726e 7665 2520 0a75 4600 7269     u Svnrev %u..Fir
   2a418:	776d 7261 2065 7542 6c69 2064 7325 5420     mware Build %s T
   2a428:	6d69 2065 7325 000a 6946 6d72 6177 6572     ime %s..Firmware
   2a438:	4d20 6e69 6420 6972 6576 2072 6576 2072      Min driver ver 
   2a448:	203a 7525 252e 2e75 7525 000a 7244 7669     : %u.%u.%u..Driv
   2a458:	7265 7620 7265 203a 7525 252e 2e75 7525     er ver: %u.%u.%u
   2a468:	000a 3431 343a 3a31 3031 4400 6365 3120     ..14:41:10.Dec 1
   2a478:	2037 3032 3332 4400 6972 6576 2072 7562     7 2023.Driver bu
   2a488:	6c69 2074 7461 2520 0973 7325 000a 694d     ilt at %s.%s..Mi
   2a498:	6d73 7461 6863 4620 7269 616d 7277 2065     smatch Firmawre 
   2a4a8:	6556 7372 6f69 0a6e 6300                         Version..

0002a4b1 <__FUNCTION__.17136>:
   2a4b1:	6863 7069 775f 6b61 0065                    chip_wake.

0002a4bb <__FUNCTION__.17185>:
   2a4bb:	6863 7069 645f 6965 696e 0074 6166 6c69     chip_deinit.fail
   2a4cb:	6465 7420 206f 6564 692d 696e 6974 6c61     ed to de-initial
   2a4db:	7a69 0a65 4200 7375 6520 7272 726f 2820     ize..Bus error (
   2a4eb:	2935 252e 2064 6c25 0a78 4600 6961 656c     5).%d %lx..Faile
   2a4fb:	2064 6f74 7720 6b61 7075 7420 6568 6320     d to wakup the c
   2a50b:	6968 0a70 4400 6972 6576 5672 7265 6e49     hip..DriverVerIn
   2a51b:	6f66 203a 7830 3025 6c38 0a78 6e00               fo: 0x%08lx..

0002a528 <__FUNCTION__.17183>:
   2a528:	6d6e 645f 7672 695f 696e 0074               nm_drv_init.

0002a534 <__FUNCTION__.17190>:
   2a534:	6d6e 645f 7672 645f 6965 696e 0074 6e5b     nm_drv_deinit.[n
   2a544:	696d 7320 6f74 5d70 203a 6863 7069 645f     mi stop]: chip_d
   2a554:	6965 696e 2074 6166 6c69 000a 6e5b 696d     einit fail..[nmi
   2a564:	7320 6f74 5d70 203a 5053 2049 6c66 7361      stop]: SPI flas
   2a574:	2068 6964 6173 6c62 2065 6166 6c69 000a     h disable fail..
   2a584:	6e5b 696d 7320 6f74 5d70 203a 6166 6c69     [nmi stop]: fail
   2a594:	6920 696e 2074 7562 0a73 6600 6961 656c      init bus..faile
   2a5a4:	2064 6f74 6520 616e 6c62 2065 6e69 6574     d to enable inte
   2a5b4:	7272 7075 7374 2e2e 000a 6e5b 696d 7320     rrupts....[nmi s
   2a5c4:	6174 7472 3a5d 6620 6961 206c 6e69 7469     tart]: fail init
   2a5d4:	6220 7375 000a 6843 7069 4920 2044 6c25      bus..Chip ID %l
   2a5e4:	0a78 c400 c3ca 00c9 2000                    x........ 

0002a5ee <__FUNCTION__.16458>:
   2a5ee:	7073 5f69 6d63 0064                         spi_cmd.

0002a5f6 <__FUNCTION__.16465>:
   2a5f6:	7073 5f69 6164 6174 725f 7073 7300               spi_data_rsp.

0002a603 <__FUNCTION__.16474>:
   2a603:	7073 5f69 6d63 5f64 7372 0070               spi_cmd_rsp.

0002a60f <__FUNCTION__.16507>:
   2a60f:	7073 5f69 6d63 5f64 6f63 706d 656c 6574     spi_cmd_complete
	...

0002a620 <__FUNCTION__.16553>:
   2a620:	7073 5f69 6164 6174 775f 6972 6574 7300          spi_data_write.

0002a62f <__FUNCTION__.16565>:
   2a62f:	7073 5f69 7277 7469 5f65 6572 0067          spi_write_reg.

0002a63d <__FUNCTION__.16576>:
   2a63d:	6d6e 735f 6970 775f 6972 6574 7300               nm_spi_write.

0002a64a <__FUNCTION__.16588>:
   2a64a:	7073 5f69 6572 6461 725f 6765 6e00               spi_read_reg.

0002a657 <__FUNCTION__.16599>:
   2a657:	6d6e 735f 6970 725f 6165 0064               nm_spi_read.

0002a663 <__FUNCTION__.16620>:
   2a663:	6d6e 735f 6970 695f 696e 0074               nm_spi_init.

0002a66f <crc7_syndrome_table>:
   2a66f:	0900 1b12 2d24 3f36 4148 535a 656c 777e     ....$-6?HAZSle~w
   2a67f:	1019 020b 343d 262f 5851 4a43 7c75 6e67     ....=4/&QXCJu|gn
   2a68f:	3b32 2920 1f16 0d04 737a 6168 575e 454c     2; )....zsha^WLE
   2a69f:	222b 3039 060f 141d 6a63 7871 4e47 5c55     +"90....cjqxGNU\
   2a6af:	6d64 7f76 4940 5b52 252c 373e 0108 131a     dmv.@IR[,%>7....
   2a6bf:	747d 666f 5059 424b 3c35 2e27 1811 0a03     }tofYPKB5<'.....
   2a6cf:	5f56 4d44 7b72 6960 171e 050c 333a 2128     V_DMr{`i....:3(!
   2a6df:	464f 545d 626b 7079 0e07 1c15 2a23 3831     OF]Tkbyp....#*18
   2a6ef:	4841 5a53 6c65 7e77 0009 121b 242d 363f     AHSZelw~....-$?6
   2a6ff:	5158 434a 757c 676e 1910 0b02 3d34 2f26     XQJC|ung....4=&/
   2a70f:	7a73 6861 5e57 4c45 323b 2029 161f 040d     szahW^EL;2) ....
   2a71f:	636a 7178 474e 555c 2b22 3930 0f06 1d14     jcxqNG\U"+09....
   2a72f:	2c25 3e37 0801 1a13 646d 767f 4049 525b     %,7>....md.vI@[R
   2a73f:	353c 272e 1118 030a 7d74 6f66 5950 4b42     <5.'....t}foPYBK
   2a74f:	1e17 0c05 3a33 2821 565f 444d 727b 6069     ....3:!(_VMD{ri`
   2a75f:	070e 151c 232a 3138 4f46 5d54 6b62 7970     ....*#81FOT]bkpy
   2a76f:	6e5b 696d 7320 6970 3a5d 4620 6961 656c     [nmi spi]: Faile
   2a77f:	2064 6e69 6574 6e72 6c61 7220 6165 2064     d internal read 
   2a78f:	7270 746f 636f 6c6f 7720 7469 2068 5243     protocol with CR
   2a79f:	2043 6e6f 202c 6572 7974 6972 676e 7720     C on, retyring w
   2a7af:	7469 2068 5243 2043 666f 2e66 2e2e 000a     ith CRC off.....
   2a7bf:	6e5b 696d 7320 6970 3a5d 4620 6961 656c     [nmi spi]: Faile
   2a7cf:	2064 6e69 6574 6e72 6c61 7220 6165 2064     d internal read 
   2a7df:	7270 746f 636f 6c6f 2e2e 0a2e 5b00 6d6e     protocol.....[nm
   2a7ef:	2069 7073 5d69 203a 6146 6c69 6465 6920     i spi]: Failed i
   2a7ff:	746e 7265 616e 206c 7277 7469 2065 7270     nternal write pr
   2a80f:	746f 636f 6c6f 7220 6765 2e2e 0a2e 5b00     otocol reg.....[
   2a81f:	6d6e 2069 7073 5d69 203a 6146 6c69 6320     nmi spi]: Fail c
   2a82f:	646d 7220 6165 2064 6863 7069 6920 2e64     md read chip id.
   2a83f:	2e2e 000a 6e5b 696d 7320 6970 3a5d 4620     ....[nmi spi]: F
   2a84f:	6961 656c 2064 6d63 2c64 7220 6165 2064     ailed cmd, read 
   2a85f:	6c62 636f 206b 2528 3830 2978 2e2e 0a2e     block (%08x)....
   2a86f:	5200 7365 7465 6120 646e 7220 7465 7972     .Reset and retry
   2a87f:	2520 2064 6c25 2078 6425 000a 6e5b 696d      %d %lx %d..[nmi
   2a88f:	7320 6970 3a5d 4620 6961 656c 2064 6d63      spi]: Failed cm
   2a89f:	2c64 7720 6972 6574 6220 6f6c 6b63 2820     d, write block (
   2a8af:	3025 7838 2e29 2e2e 000a 6e5b 696d 7320     %08x).....[nmi s
   2a8bf:	6970 3a5d 4620 6961 656c 2064 6164 6174     pi]: Failed data
   2a8cf:	6220 6f6c 6b63 6320 646d 7720 6972 6574      block cmd write
   2a8df:	202c 7562 2073 7265 6f72 2e72 2e2e 000a     , bus error.....
   2a8ef:	6e5b 696d 7320 6970 3a5d 4620 6961 656c     [nmi spi]: Faile
   2a8ff:	2064 6164 6174 6220 6f6c 6b63 7720 6972     d data block wri
   2a90f:	6574 202c 7562 2073 7265 6f72 2e72 2e2e     te, bus error...
   2a91f:	000a 6e5b 696d 7320 6970 3a5d 4620 6961     ..[nmi spi]: Fai
   2a92f:	656c 2064 6164 6174 6220 6f6c 6b63 6320     led data block c
   2a93f:	6372 7720 6972 6574 202c 7562 2073 7265     rc write, bus er
   2a94f:	6f72 2e72 2e2e 000a 6e5b 696d 7320 6970     ror.....[nmi spi
   2a95f:	3a5d 4620 6961 656c 2064 7562 2073 7265     ]: Failed bus er
   2a96f:	6f72 2e72 2e2e 000a 6e5b 696d 7320 6970     ror.....[nmi spi
   2a97f:	3a5d 4620 6961 656c 2064 6164 6174 7220     ]: Failed data r
   2a98f:	7365 6f70 736e 2065 6572 6461 202c 7825     esponse read, %x
   2a99f:	2520 2078 7825 000a 6e5b 696d 7320 6970      %x %x..[nmi spi
   2a9af:	3a5d 4620 6961 656c 2064 6c62 636f 206b     ]: Failed block 
   2a9bf:	6164 6174 7720 6972 6574 2e2e 0a2e 5b00     data write.....[
   2a9cf:	6d6e 2069 7073 5d69 203a 6146 6c69 6465     nmi spi]: Failed
   2a9df:	6320 646d 7720 6972 6574 202c 7562 2073      cmd write, bus 
   2a9ef:	7265 6f72 2e72 2e2e 000a 6e5b 696d 7320     error.....[nmi s
   2a9ff:	6970 3a5d 4620 6961 656c 2064 6d63 2064     pi]: Failed cmd 
   2aa0f:	6572 7073 6e6f 6573 202c 6d63 2064 2528     response, cmd (%
   2aa1f:	3230 2978 202c 6572 7073 2820 3025 7832     02x), resp (%02x
   2aa2f:	0a29 5b00 6d6e 2069 7073 5d69 203a 6146     )..[nmi spi]: Fa
   2aa3f:	6c69 6465 6320 646d 7320 6174 6574 7220     iled cmd state r
   2aa4f:	7365 6f70 736e 2065 7473 7461 2065 2528     esponse state (%
   2aa5f:	3230 2978 000a 6e5b 696d 7320 6970 3a5d     02x)..[nmi spi]:
   2aa6f:	4520 7272 726f 202c 6164 6174 7220 6165      Error, data rea
   2aa7f:	2064 6572 7073 6e6f 6573 2820 3025 7832     d response (%02x
   2aa8f:	0a29 5b00 6d6e 2069 7073 5d69 203a 7562     )..[nmi spi]: bu
   2aa9f:	6666 7265 6f20 6576 7272 6e75 7720 6568     ffer overrun whe
   2aaaf:	206e 6572 6461 6e69 2067 6164 6174 0a2e     n reading data..
   2aabf:	5b00 6d6e 2069 7073 5d69 203a 7562 6666     .[nmi spi]: buff
   2aacf:	7265 6f20 6576 7272 6e75 7720 6568 206e     er overrun when 
   2aadf:	6572 6461 6e69 2067 7263 2e63 000a 6e5b     reading crc...[n
   2aaef:	696d 7320 6970 3a5d 4620 6961 656c 2064     mi spi]: Failed 
   2aaff:	6164 6174 6220 6f6c 6b63 7220 6165 2c64     data block read,
   2ab0f:	6220 7375 6520 7272 726f 2e2e 0a2e 5b00      bus error.....[
   2ab1f:	6d6e 2069 7073 5d69 203a 6146 6c69 6465     nmi spi]: Failed
   2ab2f:	6420 7461 2061 6c62 636f 206b 7263 2063      data block crc 
   2ab3f:	6572 6461 202c 7562 2073 7265 6f72 2e72     read, bus error.
   2ab4f:	2e2e 000a 6e5b 696d 7320 6970 3a5d 4620     ....[nmi spi]: F
   2ab5f:	6961 656c 2064 6164 6174 7220 7365 6f70     ailed data respo
   2ab6f:	736e 2065 6572 6461 202c 7562 2073 7265     nse read, bus er
   2ab7f:	6f72 2e72 2e2e 000a 6e5b 696d 7320 6970     ror.....[nmi spi
   2ab8f:	3a5d 4620 6961 656c 2064 6d63 2064 6572     ]: Failed cmd re
   2ab9f:	7073 6e6f 6573 7220 6165 2c64 6220 7375     sponse read, bus
   2abaf:	6520 7272 726f 2e2e 0a2e 5b00 6d6e 2069      error.....[nmi 
   2abbf:	7073 5d69 203a 6146 6c69 6465 6320 646d     spi]: Failed cmd
   2abcf:	202c 6572 6461 7220 6765 2820 3025 7838     , read reg (%08x
   2abdf:	2e29 2e2e 000a 6552 6573 2074 6e61 2064     ).....Reset and 
   2abef:	6572 7274 2079 6425 2520 786c 000a 6e5b     retry %d %lx..[n
   2abff:	696d 7320 6970 3a5d 4620 6961 656c 2064     mi spi]: Failed 
   2ac0f:	6d63 2c64 7720 6972 6574 7220 6765 2820     cmd, write reg (
   2ac1f:	3025 7838 2e29 2e2e 000a 6552 6573 2074     %08x).....Reset 
   2ac2f:	6e61 2064 6572 7274 2079 6425 2520 786c     and retry %d %lx
   2ac3f:	2520 786c 000a 4528 5252 2952 7543 7272      %lx..(ERRR)Curr
   2ac4f:	6e65 2074 253c 3e64 000a 6f53 6b63 7420     ent <%d>..Sock t
   2ac5f:	206f 6564 656c 6574 3c20 6425 0a3e 5300     o delete <%d>..S
   2ac6f:	636f 656b 2074 6425 7320 7365 6973 6e6f     ocket %d session
   2ac7f:	4920 2044 203d 6425 0a0d 0000 0000 0008      ID = %d........
   2ac8f:	0042 000c 0042 0010 0042 0014 0042 0018     B...B...B...B...
   2ac9f:	0042 001c 0042                                   B...B

0002aca4 <_tcc_apbcmasks>:
   2aca4:	0100 0000 0200 0000 0400 0000               ............

0002acb0 <_tcc_cc_nums>:
   2acb0:	0204 1a02                                        ...

0002acb3 <_tcc_gclk_ids>:
   2acb3:	1a1a 001b ff00                                   .....

0002acb8 <_tcc_maxs>:
   2acb8:	ffff 00ff ffff 00ff ffff 0000               ............

0002acc4 <_tcc_ow_nums>:
   2acc4:	0408 0002                                   ....

0002acc8 <_tcc_intflag>:
   2acc8:	0001 0000 0002 0000 0004 0000 0008 0000     ................
   2acd8:	1000 0000 2000 0000 4000 0000 8000 0000     ..... ...@......
   2ace8:	0000 0001 0000 0002 0000 0004 0000 0008     ................

0002acf8 <tcc_interrupt_vectors.12458>:
   2acf8:	100f 0111                                        ...

0002acfb <LfnOfs>:
   2acfb:	0301 0705 0e09 1210 1614 1c18 801e               .............

0002ad08 <excvt.4558>:
   2ad08:	9a80 b690 b78e 808f d3d2 d8d4 ded7 8f8e     ................
   2ad18:	9290 e292 e399 ebea 9959 9d9a 9d9c 9f9e     ........Y.......
   2ad28:	d6b5 e9e0 a5a5 a7a6 a9a8 abaa 21ac afae     .............!..
   2ad38:	b1b0 b3b2 b5b4 b7b6 b9b8 bbba bdbc bfbe     ................
   2ad48:	c1c0 c3c2 c5c4 c7c7 c9c8 cbca cdcc cfce     ................
   2ad58:	d1d0 d3d2 d5d4 d7d6 d9d8 dbda dddc dfde     ................
   2ad68:	e1e0 e3e2 e5e5 e7e6 e9e7 ebea eded efee     ................
   2ad78:	f1f0 f3f2 f5f4 f7f6 f9f8 fbfa fdfc fffe     ................
   2ad88:	2a22 3c3a 3f3e 7f7c 2b00 3b2c 5b3d 005d     "*:<>?|..+,;=[].

0002ad98 <Tbl>:
   2ad98:	00c7 00fc 00e9 00e2 00e4 00e0 00e5 00e7     ................
   2ada8:	00ea 00eb 00e8 00ef 00ee 00ec 00c4 00c5     ................
   2adb8:	00c9 00e6 00c6 00f4 00f6 00f2 00fb 00f9     ................
   2adc8:	00ff 00d6 00dc 00f8 00a3 00d8 00d7 0192     ................
   2add8:	00e1 00ed 00f3 00fa 00f1 00d1 00aa 00ba     ................
   2ade8:	00bf 00ae 00ac 00bd 00bc 00a1 00ab 00bb     ................
   2adf8:	2591 2592 2593 2502 2524 00c1 00c2 00c0     .%.%.%.%$%......
   2ae08:	00a9 2563 2551 2557 255d 00a2 00a5 2510     ..c%Q%W%]%.....%
   2ae18:	2514 2534 252c 251c 2500 253c 00e3 00c3     .%4%,%.%.%<%....
   2ae28:	255a 2554 2569 2566 2560 2550 256c 00a4     Z%T%i%f%`%P%l%..
   2ae38:	00f0 00d0 00ca 00cb 00c8 0131 00cd 00ce     ..........1.....
   2ae48:	00cf 2518 250c 2588 2584 00a6 00cc 2580     ...%.%.%.%.....%
   2ae58:	00d3 00df 00d4 00d2 00f5 00d5 00b5 00fe     ................
   2ae68:	00de 00da 00db 00d9 00fd 00dd 00af 00b4     ................
   2ae78:	00ad 00b1 2017 00be 00b6 00a7 00f7 00b8     ..... ..........
   2ae88:	00b0 00a8 00b7 00b9 00b3 00b2 25a0 00a0     .............%..

0002ae98 <tbl_lower.4308>:
   2ae98:	0061 0062 0063 0064 0065 0066 0067 0068     a.b.c.d.e.f.g.h.
   2aea8:	0069 006a 006b 006c 006d 006e 006f 0070     i.j.k.l.m.n.o.p.
   2aeb8:	0071 0072 0073 0074 0075 0076 0077 0078     q.r.s.t.u.v.w.x.
   2aec8:	0079 007a 00a1 00a2 00a3 00a5 00ac 00af     y.z.............
   2aed8:	00e0 00e1 00e2 00e3 00e4 00e5 00e6 00e7     ................
   2aee8:	00e8 00e9 00ea 00eb 00ec 00ed 00ee 00ef     ................
   2aef8:	00f0 00f1 00f2 00f3 00f4 00f5 00f6 00f8     ................
   2af08:	00f9 00fa 00fb 00fc 00fd 00fe 00ff 0101     ................
   2af18:	0103 0105 0107 0109 010b 010d 010f 0111     ................
   2af28:	0113 0115 0117 0119 011b 011d 011f 0121     ..............!.
   2af38:	0123 0125 0127 0129 012b 012d 012f 0131     #.%.'.).+.-./.1.
   2af48:	0133 0135 0137 013a 013c 013e 0140 0142     3.5.7.:.<.>.@.B.
   2af58:	0144 0146 0148 014b 014d 014f 0151 0153     D.F.H.K.M.O.Q.S.
   2af68:	0155 0157 0159 015b 015d 015f 0161 0163     U.W.Y.[.]._.a.c.
   2af78:	0165 0167 0169 016b 016d 016f 0171 0173     e.g.i.k.m.o.q.s.
   2af88:	0175 0177 017a 017c 017e 0192 03b1 03b2     u.w.z.|.~.......
   2af98:	03b3 03b4 03b5 03b6 03b7 03b8 03b9 03ba     ................
   2afa8:	03bb 03bc 03bd 03be 03bf 03c0 03c1 03c3     ................
   2afb8:	03c4 03c5 03c6 03c7 03c8 03c9 03ca 0430     ..............0.
   2afc8:	0431 0432 0433 0434 0435 0436 0437 0438     1.2.3.4.5.6.7.8.
   2afd8:	0439 043a 043b 043c 043d 043e 043f 0440     9.:.;.<.=.>.?.@.
   2afe8:	0441 0442 0443 0444 0445 0446 0447 0448     A.B.C.D.E.F.G.H.
   2aff8:	0449 044a 044b 044c 044d 044e 044f 0451     I.J.K.L.M.N.O.Q.
   2b008:	0452 0453 0454 0455 0456 0457 0458 0459     R.S.T.U.V.W.X.Y.
   2b018:	045a 045b 045c 045e 045f 2170 2171 2172     Z.[.\.^._.p!q!r!
   2b028:	2173 2174 2175 2176 2177 2178 2179 217a     s!t!u!v!w!x!y!z!
   2b038:	217b 217c 217d 217e 217f ff41 ff42 ff43     {!|!}!~!.!A.B.C.
   2b048:	ff44 ff45 ff46 ff47 ff48 ff49 ff4a ff4b     D.E.F.G.H.I.J.K.
   2b058:	ff4c ff4d ff4e ff4f ff50 ff51 ff52 ff53     L.M.N.O.P.Q.R.S.
   2b068:	ff54 ff55 ff56 ff57 ff58 ff59 ff5a 0000     T.U.V.W.X.Y.Z...

0002b078 <tbl_upper.4309>:
   2b078:	0041 0042 0043 0044 0045 0046 0047 0048     A.B.C.D.E.F.G.H.
   2b088:	0049 004a 004b 004c 004d 004e 004f 0050     I.J.K.L.M.N.O.P.
   2b098:	0051 0052 0053 0054 0055 0056 0057 0058     Q.R.S.T.U.V.W.X.
   2b0a8:	0059 005a 0021 ffe0 ffe1 ffe5 ffe2 ffe3     Y.Z.!...........
   2b0b8:	00c0 00c1 00c2 00c3 00c4 00c5 00c6 00c7     ................
   2b0c8:	00c8 00c9 00ca 00cb 00cc 00cd 00ce 00cf     ................
   2b0d8:	00d0 00d1 00d2 00d3 00d4 00d5 00d6 00d8     ................
   2b0e8:	00d9 00da 00db 00dc 00dd 00de 0178 0100     ............x...
   2b0f8:	0102 0104 0106 0108 010a 010c 010e 0110     ................
   2b108:	0112 0114 0116 0118 011a 011c 011e 0120     .............. .
   2b118:	0122 0124 0126 0128 012a 012c 012e 0130     ".$.&.(.*.,...0.
   2b128:	0132 0134 0136 0139 013b 013d 013f 0141     2.4.6.9.;.=.?.A.
   2b138:	0143 0145 0147 014a 014c 014e 0150 0152     C.E.G.J.L.N.P.R.
   2b148:	0154 0156 0158 015a 015c 015e 0160 0162     T.V.X.Z.\.^.`.b.
   2b158:	0164 0166 0168 016a 016c 016e 0170 0172     d.f.h.j.l.n.p.r.
   2b168:	0174 0176 0179 017b 017d 0191 0391 0392     t.v.y.{.}.......
   2b178:	0393 0394 0395 0396 0397 0398 0399 039a     ................
   2b188:	039b 039c 039d 039e 039f 03a0 03a1 03a3     ................
   2b198:	03a4 03a5 03a6 03a7 03a8 03a9 03aa 0410     ................
   2b1a8:	0411 0412 0413 0414 0415 0416 0417 0418     ................
   2b1b8:	0419 041a 041b 041c 041d 041e 041f 0420     .............. .
   2b1c8:	0421 0422 0423 0424 0425 0426 0427 0428     !.".#.$.%.&.'.(.
   2b1d8:	0429 042a 042b 042c 042d 042e 042f 0401     ).*.+.,.-.../...
   2b1e8:	0402 0403 0404 0405 0406 0407 0408 0409     ................
   2b1f8:	040a 040b 040c 040e 040f 2160 2161 2162     ..........`!a!b!
   2b208:	2163 2164 2165 2166 2167 2168 2169 216a     c!d!e!f!g!h!i!j!
   2b218:	216b 216c 216d 216e 216f ff21 ff22 ff23     k!l!m!n!o!!.".#.
   2b228:	ff24 ff25 ff26 ff27 ff28 ff29 ff2a ff2b     $.%.&.'.(.).*.+.
   2b238:	ff2c ff2d ff2e ff2f ff30 ff31 ff32 ff33     ,.-.../.0.1.2.3.
   2b248:	ff34 ff35 ff36 ff37 ff38 ff39 ff3a 0000     4.5.6.7.8.9.:...
   2b258:	514d 4354 0000 0000 0004 0000 0000 0000     MQTC............
	...
   2b270:	003c 0001 514d 5754 0000 0000 0000 0000     <...MQTW........
	...
   2b2b0:	514d 4354 0000 0000 0004 0000 0000 0000     MQTC............
	...
   2b2c8:	003c 0001 514d 5754 0000 0000 0000 0000     <...MQTW........
	...
   2b308:	514d 5454 4d00 4951 6473 0070 3130 3332     MQTT.MQIsdp.0123
   2b318:	3534 3736 3938 6261 6463 6665 0d31 5400     456789abcdef1..T
   2b328:	6172 736e 6566 2d72 6e45 6f63 6964 676e     ransfer-Encoding
   2b338:	203a 4300 6e6f 656e 7463 6f69 3a6e 0020     : .Connection: .
   2b348:	5448 5054 002f 4547 2054 5000 534f 2054     HTTP/.GET .POST 
   2b358:	4400 4c45 5445 2045 5000 5455 0020 504f     .DELETE .PUT .OP
   2b368:	4954 4e4f 2053 4800 4145 2044 2000 5448     TIONS .HEAD . HT
   2b378:	5054 312f 312e 0a0d 5500 6573 2d72 6741     TP/1.1...User-Ag
   2b388:	6e65 3a74 0020 6f48 7473 203a 4300 6e6f     ent: .Host: .Con
   2b398:	656e 7463 6f69 3a6e 4b20 6565 2d70 6c41     nection: Keep-Al
   2b3a8:	7669 0d65 000a 6341 6563 7470 452d 636e     ive...Accept-Enc
   2b3b8:	646f 6e69 3a67 0d20 000a 6341 6563 7470     oding: ...Accept
   2b3c8:	432d 6168 7372 7465 203a 7475 2d66 0d38     -Charset: utf-8.
   2b3d8:	000a 7254 6e61 6673 7265 452d 636e 646f     ..Transfer-Encod
   2b3e8:	6e69 3a67 6320 7568 6b6e 6465 0a0d 2500     ing: chunked...%
   2b3f8:	0075 6f43 746e 6e65 2d74 654c 676e 6874     u.Content-Length
   2b408:	203a 6100 6d74 6c65 312f 302e 322e 6800     : .atmel/1.0.2.h
   2b418:	7474 3a70 2f2f 6800 7474 7370 2f3a 002f     ttp://.https://.
   2b428:	2000 4200 2400 4200 2800 4200 0a0d 0a0d     . .B.$.B.(.B....
   2b438:	2d2d 2d2d 202d 6957 646e 4320 6568 7461     ----- Wind Cheat
   2b448:	7265 3a73 5620 2031 2d2d 2d2d 0d2d 000a     ers: V1 -----...
   2b458:	0a0d 0a0d 6e49 7469 6169 696c 657a 4820     ....Initialize H
   2b468:	2e57 2e2e 0a0d 4500 7272 726f 6920 696e     W......Error ini
   2b478:	6974 6c61 7a69 6e69 2067 3249 2043 7244     tializing I2C Dr
   2b488:	7669 7265 0d21 000a 6e49 7469 6169 696c     iver!...Initiali
   2b498:	657a 2064 3249 2043 7244 7669 7265 0d21     zed I2C Driver!.
   2b4a8:	000a 4d42 3645 3038 4920 696e 6974 6c61     ..BME680 Initial
   2b4b8:	6620 6961 656c 2164 0a0d 4200 454d 3836      failed!...BME68
   2b4c8:	2030 6e49 7469 6169 656c 2064 7553 6363     0 Initialed Succ
   2b4d8:	7365 2173 0a0d 4900 554d 6920 696e 6974     ess!...IMU initi
   2b4e8:	6c61 7a69 6465 0d21 000a 6f43 6c75 2064     alized!...Could 
   2b4f8:	6f6e 2074 6e69 7469 6169 696c 657a 4920     not initialize I
   2b508:	554d 0a0d 4800 6165 2070 6562 6f66 6572     MU...Heap before
   2b518:	7320 6174 7472 6e69 2067 6174 6b73 3a73      starting tasks:
   2b528:	2520 0d64 000a 4c43 5f49 4154 4b53 4500      %d...CLI_TASK.E
   2b538:	5252 203a 4c43 2049 6174 6b73 6320 756f     RR: CLI task cou
   2b548:	646c 6e20 746f 6220 2065 6e69 7469 6169     ld not be initia
   2b558:	696c 657a 2164 0a0d 5700 4649 5f49 4154     lized!...WIFI_TA
   2b568:	4b53 4500 5252 203a 4957 4946 7420 7361     SK.ERR: WIFI tas
   2b578:	206b 6f63 6c75 2064 6f6e 2074 6562 6920     k could not be i
   2b588:	696e 6974 6c61 7a69 6465 0d21 000a 4341     nitialized!...AC
   2b598:	4543 5f4c 4154 4b53 4500 5252 203a 4d49     CEL_TASK.ERR: IM
   2b5a8:	2055 6174 6b73 6320 756f 646c 6e20 746f     U task could not
   2b5b8:	6220 2065 6e69 7469 6169 696c 657a 2164      be initialized!
   2b5c8:	0a0d 4200 454d 545f 5341 004b 5245 3a52     ...BME_TASK.ERR:
   2b5d8:	4220 454d 7420 7361 206b 6f63 6c75 2064      BME task could 
   2b5e8:	6f6e 2074 6562 6920 696e 6974 6c61 7a69     not be initializ
   2b5f8:	6465 0d21 000a 6548 7061 6120 7466 7265     ed!...Heap after
   2b608:	6120 6c6c 7420 7361 736b 2520 0d64 000a      all tasks %d...
   2b618:	7245 6f72 2072 6e6f 6d20 6d65 726f 2079     Error on memory 
   2b628:	6c61 6f6c 6163 6974 6e6f 6f20 206e 5246     allocation on FR
   2b638:	4545 5452 534f 0d21 000a 7245 6f72 2072     EERTOS!...Error 
   2b648:	6e6f 7320 6174 6b63 6f20 6576 6672 6f6c     on stack overflo
   2b658:	2077 6e6f 4620 4552 5245 4f54 2153 0a0d     w on FREERTOS!..
   2b668:	0000 0000                                   ....

0002b66c <_global_impure_ptr>:
   2b66c:	0210 2000 4e49 0046 6e69 0066 414e 004e     ... INF.inf.NAN.
   2b67c:	616e 006e 3130 3332 3534 3736 3938 4241     nan.0123456789AB
   2b68c:	4443 4645 3000 3231 3433 3635 3837 6139     CDEF.0123456789a
   2b69c:	6362 6564 0066 6e49 6966 696e 7974 4e00     bcdef.Infinity.N
   2b6ac:	4e61 0000                                   aN..

0002b6b0 <__sf_fake_stderr>:
	...

0002b6d0 <__sf_fake_stdin>:
	...

0002b6f0 <__sf_fake_stdout>:
	...
   2b710:	0043 4f50 4953 0058                         C.POSIX.

0002b718 <__mprec_bigtens>:
   2b718:	8000 37e0 c379 4341 6e17 b505 b8b5 4693     ...7y.AC.n.....F
   2b728:	f9f5 e93f 4f03 4d38 1d32 f930 7748 5a82     ..?..O8M2.0.Hw.Z
   2b738:	bf3c 7f73 4fdd 7515                         <.s..O.u

0002b740 <__mprec_tens>:
   2b740:	0000 0000 0000 3ff0 0000 0000 0000 4024     .......?......$@
   2b750:	0000 0000 0000 4059 0000 0000 4000 408f     ......Y@.....@.@
   2b760:	0000 0000 8800 40c3 0000 0000 6a00 40f8     .......@.....j.@
   2b770:	0000 0000 8480 412e 0000 0000 12d0 4163     .......A......cA
   2b780:	0000 0000 d784 4197 0000 0000 cd65 41cd     .......A....e..A
   2b790:	0000 2000 a05f 4202 0000 e800 4876 4237     ... _..B....vH7B
   2b7a0:	0000 a200 1a94 426d 0000 e540 309c 42a2     ......mB..@..0.B
   2b7b0:	0000 1e90 bcc4 42d6 0000 2634 6bf5 430c     .......B..4&.k.C
   2b7c0:	8000 37e0 c379 4341 a000 85d8 3457 4376     ...7y.AC....W4vC
   2b7d0:	c800 674e c16d 43ab 3d00 6091 58e4 43e1     ..Ngm..C.=.`.X.C
   2b7e0:	8c40 78b5 af1d 4415 ef50 d6e2 1ae4 444b     @..x...DP.....KD
   2b7f0:	d592 064d f0cf 4480 4af6 c7e1 2d02 44b5     ..M....D.J...-.D
   2b800:	9db4 79d9 7843 44ea                         ...yCx.D

0002b808 <p05.6047>:
   2b808:	0005 0000 0019 0000 007d 0000 2d23 2b30     ........}...#-0+
   2b818:	0020 6c68 004c 6665 4567 4746 0000                .hlL.efgEFG.

0002b825 <_ctype_>:
   2b825:	2000 2020 2020 2020 2020 2828 2828 2028     .         ((((( 
   2b835:	2020 2020 2020 2020 2020 2020 2020 2020                     
   2b845:	8820 1010 1010 1010 1010 1010 1010 1010      ...............
   2b855:	0410 0404 0404 0404 0404 1004 1010 1010     ................
   2b865:	1010 4141 4141 4141 0101 0101 0101 0101     ..AAAAAA........
   2b875:	0101 0101 0101 0101 0101 0101 1010 1010     ................
   2b885:	1010 4242 4242 4242 0202 0202 0202 0202     ..BBBBBB........
   2b895:	0202 0202 0202 0202 0202 0202 1010 1010     ................
   2b8a5:	0020 0000 0000 0000 0000 0000 0000 0000      ...............
	...
   2b925:	0000 e400 0261 b400 0261 c600 0261 0800     ....a...a...a...
   2b935:	0261 c600 0261 aa00 0261 c600 0261 0800     a...a...a...a...
   2b945:	0261 b400 0261 b400 0261 aa00 0261 0800     a...a...a...a...
   2b955:	0261 1000 0261 1000 0261 1000 0261 cc00     a...a...a...a...
   2b965:	0261 b400 0261 b400 0261 8800 0261 6c00     a...a...a...a..l
   2b975:	0262 8800 0261 aa00 0261 8800 0261 6c00     b...a...a...a..l
   2b985:	0262 b400 0261 b400 0261 aa00 0261 6c00     b...a...a...a..l
   2b995:	0262 1000 0261 1000 0261 1000 0261 7600     b...a...a...a..v
   2b9a5:	0262 6400 0265 b400 0264 b400 0264 b200     b..de...d...d...
   2b9b5:	0264 5600 0265 5600 0265 4c00 0265 b200     d..Ve..Ve..Le...
   2b9c5:	0264 5600 0265 4c00 0265 5600 0265 b200     d..Ve..Le..Ve...
   2b9d5:	0264 5c00 0265 5c00 0265 5c00 0265 ec00     d..\e..\e..\e...
   2b9e5:	0265 3400 0273 1600 0273 d000 0272 ee00     e..4s...s...r...
   2b9f5:	0271 d000 0272 0800 0273 d000 0272 ee00     q...r...s...r...
   2ba05:	0271 1600 0273 1600 0273 0800 0273 ee00     q...s...s...s...
   2ba15:	0271 e600 0271 e600 0271 e600 0271 4c00     q...q...q...q..L
   2ba25:	0275 9400 027b 5400 027a 5400 027a 5000     u...{..Tz..Tz..P
   2ba35:	027a 6c00 027b 6c00 027b 5e00 027b 5000     z..l{..l{..^{..P
   2ba45:	027a 6c00 027b 5e00 027b 6c00 027b 5000     z..l{..^{..l{..P
   2ba55:	027a 7400 027b 7400 027b 7400 027b 7800     z..t{..t{..t{..x
   2ba65:	027d f800                                        }..

0002ba68 <_init>:
   2ba68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2ba6a:	46c0      	nop			; (mov r8, r8)
   2ba6c:	bcf8      	pop	{r3, r4, r5, r6, r7}
   2ba6e:	bc08      	pop	{r3}
   2ba70:	469e      	mov	lr, r3
   2ba72:	4770      	bx	lr

0002ba74 <__init_array_start>:
   2ba74:	000120dd 	.word	0x000120dd

0002ba78 <_fini>:
   2ba78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2ba7a:	46c0      	nop			; (mov r8, r8)
   2ba7c:	bcf8      	pop	{r3, r4, r5, r6, r7}
   2ba7e:	bc08      	pop	{r3}
   2ba80:	469e      	mov	lr, r3
   2ba82:	4770      	bx	lr

0002ba84 <__fini_array_start>:
   2ba84:	000120b5 	.word	0x000120b5
